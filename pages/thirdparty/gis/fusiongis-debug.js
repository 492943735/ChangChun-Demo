var fusiongis =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "./build";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!******************************!*\
  !*** ./src/gis/gisCovery.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	
	var utils = __webpack_require__(/*! utils/util */ 1);
	var layersLegend = __webpack_require__(/*! layers/legend */ 3);
	var businessLayersLenged = __webpack_require__(/*! businessLayers/legend */ 64);
	var legend = utils.extend({}, layersLegend, businessLayersLenged);

	var oBaseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var setVectorLayerData = __webpack_require__(/*! layers/setVectorLayerData */ 65);
	var baseLayer = utils.extend({}, oBaseLayer, setVectorLayerData);

	module.exports = {
	    Constant: __webpack_require__(/*! framework/constant */ 2),
	    Algorithm: __webpack_require__(/*! framework/algorithm */ 48),

	    AdminRegion: __webpack_require__(/*! layers/adminRegion */ 66),
	    BaseLayer: baseLayer,

	    BLayerManager: __webpack_require__(/*! layers/bLayerManager */ 39),
	    BubbleCircle: __webpack_require__(/*! layers/bubbleCircle */ 67),
	    Bubble: __webpack_require__(/*! layers/bubble */ 68),
	    GradientCircle: __webpack_require__(/*! layers/gradientCircle */ 69),
	    Cell: __webpack_require__(/*! layers/cell */ 47),
	    Chart:__webpack_require__(/*! layers/echartsLayer/addChartsOnMap */ 70),
	    
	    Curve: __webpack_require__(/*! layers/bezierCurveLine */ 74),
	    FigTense: __webpack_require__(/*! layers/figTense */ 75),
	    GridDensity: __webpack_require__(/*! layers/gridDensity */ 76),
	    HeatMap: __webpack_require__(/*! layers/heatMap */ 77),
	    Highlight: __webpack_require__(/*! layers/highlight */ 43),
	    Icon: __webpack_require__(/*! layers/icon */ 78),
	    Icon2Label: __webpack_require__(/*! layers/icon2Label */ 79),
	    InfoPop: __webpack_require__(/*! layers/infoPop */ 80),
	    ImageFilter: __webpack_require__(/*! layers/imageFilter */ 81),
	    Line: __webpack_require__(/*! layers/line */ 82),
	    LayerManager: __webpack_require__(/*! layers/layerManager */ 84),
	    LegendRange: __webpack_require__(/*! layers/legendRange */ 85),
	    LegendSlider: __webpack_require__(/*! layers/legendSlider */ 86),
	    PointCluster: __webpack_require__(/*! layers/pointCluster */ 87),
	    Radar: __webpack_require__(/*! layers/radar */ 88),
	    RenderShadowArea: __webpack_require__(/*! layers/renderShadowArea */ 89),
	    SetVectorLayerData: __webpack_require__(/*! layers/setVectorLayerData */ 65),
	    TrackShow: __webpack_require__(/*! layers/trackShow */ 90),
	    ConvergeCell: __webpack_require__(/*! layers/convergeCell */ 91),
	    ConvergeGrid: __webpack_require__(/*! layers/convergeGrid */ 92),
	    BubbleCircleLabel : __webpack_require__(/*! layers/bubbleCircleLabel */ 59),
	    FontStyle : __webpack_require__(/*! layers/fontStyle */ 60),

	    Legend: legend,
	    Grid: __webpack_require__(/*! businessLayers/grid */ 50),
	    BCell: __webpack_require__(/*! businessLayers/cell */ 46),
	    BsiteAndCell: __webpack_require__(/*! businessLayers/siteAndCell */ 93),
	    BSite: __webpack_require__(/*! businessLayers/site */ 49),
	    BLine: __webpack_require__(/*! businessLayers/line */ 54),
	    CirclePoint: __webpack_require__(/*! businessLayers/circlePoint */ 44),
	    Point: __webpack_require__(/*! businessLayers/point */ 42),
	    Polygon: __webpack_require__(/*! businessLayers/polygon */ 45),
	    ServicePoint: __webpack_require__(/*! businessLayers/servicePoint */ 52),
	    ServiceLine: __webpack_require__(/*! businessLayers/serviceLine */ 53),
	    ServicePolygon: __webpack_require__(/*! businessLayers/servicePolygon */ 51),
	    VectorPolygon: __webpack_require__(/*! businessLayers/vectorPolygon */ 94),

	    DGrid: __webpack_require__(/*! businessLayers/dcGrid */ 95),
	    DBCell: __webpack_require__(/*! businessLayers/dcCell */ 96),
	    DBSite: __webpack_require__(/*! businessLayers/dcSite */ 97),
	    DServicePoint: __webpack_require__(/*! businessLayers/dcServicePoint */ 57),
	    DServiceLine: __webpack_require__(/*! businessLayers/dcServiceLine */ 58),
	    DServicePolygon: __webpack_require__(/*! businessLayers/dcServicePolygon */ 56),
	    Render: __webpack_require__(/*! businessLayers/render */ 98),
	    RenderToken: __webpack_require__(/*! businessLayers/renderToken */ 99),

	    Events: __webpack_require__(/*! maps/event */ 11),
	    Map: __webpack_require__(/*! maps/map */ 8),
	    AcrossLine:__webpack_require__(/*! maps/acrossLine */ 21),
	    GStreetView: __webpack_require__(/*! maps/gStreetView */ 100),

	    Overlay: __webpack_require__(/*! tools/popup */ 12),
	    Popup: __webpack_require__(/*! framework/popup */ 9),
	    Measure: __webpack_require__(/*! tools/measure */ 101),
	    MeasureAngle: __webpack_require__(/*! tools/measureAngle */ 104),
	    Geometry: __webpack_require__(/*! tools/drawGeometry */ 105),
	    Search: __webpack_require__(/*! tools/searchLocate */ 106),
	    SearchObject: __webpack_require__(/*! tools/searchObject */ 107),
	    Graticule: __webpack_require__(/*! tools/mapGraticule */ 108),
	    SelectMode: __webpack_require__(/*! tools/select */ 109),
	    Migration: __webpack_require__(/*! tools/migrationMap */ 110),
	    BubbleLine: __webpack_require__(/*! tools/wave */ 111),
	    PolygonQuery: __webpack_require__(/*! tools/polygonQuery */ 112),
	    InterSectPolygons:__webpack_require__(/*! tools/polygonsInterSect */ 113),
	    ShowPolygonCenterIcon: __webpack_require__(/*! tools/showPolygonCenterIcon */ 114),
	//  ThiessenPolygon: require('layers/thiessenPolygon'),
	    ContributionPlotOnLine: __webpack_require__(/*! layers/contributionPlotOnLine */ 115),
	    LineStraight: __webpack_require__(/*! layers/straightLine */ 55),
	    LineAdd: __webpack_require__(/*! layers/addLine */ 116),
	    PolygonBezier: __webpack_require__(/*! layers/polygonBezier */ 117),
	    UnChangePolygon: __webpack_require__(/*! layers/unchangedPolygon */ 118),

	    Util: utils,
	    DomUtil: __webpack_require__(/*! utils/domUtil */ 10),
	    OlUtil: __webpack_require__(/*! utils/olUtil */ 16),
	    I18n: __webpack_require__(/*! utils/i18n */ 13),
	    ImageUtil: __webpack_require__(/*! utils/export/imageUtil */ 119),
	    OriginalAjax: __webpack_require__(/*! utils/ajax */ 14),
	    ExportUI: __webpack_require__(/*! utils/exportUI */ 120),
	    DragZoomInteraction: __webpack_require__(/*! tools/dragZoomInteraction */ 124),
	    GPSNavigation: __webpack_require__(/*! tools/gps-navigation */ 125),
	    HashMap: __webpack_require__(/*! framework/hashmap */ 5),
	    RenderGeometry: __webpack_require__(/*! layers/renderGeometry */ 126),
	    CustomQuery: __webpack_require__(/*! tools/customQuery */ 127),
	    Transform: __webpack_require__(/*! framework/transform */ 128),
	    SearchUI: __webpack_require__(/*! utils/searchUI */ 129),
	    ServiceHeatMap: __webpack_require__(/*! businessLayers/serviceHeatMap */ 130),


	    Union: __webpack_require__(/*! transformation/union */ 131),
	    Intersect: __webpack_require__(/*! transformation/intersect */ 132),
	    Difference: __webpack_require__(/*! transformation/difference */ 133),
	    SecondaryMesh: __webpack_require__(/*! tools/secondaryMesh */ 134),
	    IntersectSelf:__webpack_require__(/*! tools/intersectSelf */ 135),
	    AnalysisGeoJson: __webpack_require__(/*! utils/analysisGeoJson */ 136),
	    Buffer: __webpack_require__(/*! transformation/buffer */ 137),
	    Drag: __webpack_require__(/*! tools/drag */ 138),
	    XYZLayer: __webpack_require__(/*! businessLayers/xyzLayer */ 139),
	    PreLoad: __webpack_require__(/*! framework/preLoad */ 140),
	    TrackPlay: __webpack_require__(/*! layers/trackPlay */ 141),
	    TrackPlayer: __webpack_require__(/*! layers/trackPlayer */ 142),
	    RoadMain: __webpack_require__(/*! businessLayers/roadMain */ 143),
	    IconCluster: __webpack_require__(/*! layers/iconCluster */ 144),
	    Wms: __webpack_require__(/*! layers/wmsLayer */ 145),
	    ArcgisTileLayer:__webpack_require__(/*! layers/arcgisTileLayer */ 36),
	    ServiceLayer: __webpack_require__(/*! layers/servicelayer */ 146),
	    FilterFeature: __webpack_require__(/*! utils/filterFeatureUI */ 147),
	    layerFilterHighLight:__webpack_require__(/*! tools/layerFilteringHighlighted */ 148),
	    CircleLabel: __webpack_require__(/*! layers/circleLabel */ 149),
	    MuliPoint: __webpack_require__(/*! businessLayers/multiPoint */ 61)
	};

/***/ },
/* 1 */
/*!*******************************!*\
  !*** ./src/gis/utils/util.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	var constant = __webpack_require__(/*! framework/constant */ 2);
	//替换方法
	String.prototype.replaceAll = function (str, str1) {
	    return this.replace(new RegExp(str, "g"), str1);
	};

	//去除点
	String.prototype.removeDot = function () {
	    var _str = this;
	    while (_str.indexOf(".") > -1) {
	        _str = _str.replace(".", "");
	    }
	    return _str;
	};

	// 获取浏览器类型
	var getBrowserType = function () {
	    var browser = {};
	    browser.mozilla = /firefox/.test(navigator.userAgent.toLowerCase());
	    browser.webkit = /webkit/.test(navigator.userAgent.toLowerCase());
	    browser.opera = /opera/.test(navigator.userAgent.toLowerCase());
	    browser.msie = /msie/.test(navigator.userAgent.toLowerCase()) || !!navigator.userAgent.match(/Trident.*rv\:11\./);
	    return browser;
	};
	//数据类型判断
	var isValid = function (val) {
	    // void 0 always evaluates to undefined and hence we do not need to depend on
	    // the definition of the global variable named 'undefined'.
	    if (undefined !== val && null !== val) {
	        return true;
	    }
	    else {
	        return false;
	    }
	};

	//生成唯一标识
	var getUUID = function () {
	    var s = [];
	    var hexDigits = "0123456789abcdef";
	    for (var i = 0; i < 36; i++) {
	        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
	    }
	    s[14] = "4"; // bits 12-15 of the time_hi_and_version field to 0010
	    s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01
	    s[8] = s[13] = s[18] = s[23] = "-";

	    var uuid = s.join("");
	    return uuid;
	};

	/**
	 * 对象克隆
	 * @param sourceObj
	 */
	var cloneObj = function (sourceObj) {
	    return Object.assign({}, sourceObj);
	};

	/**
	 * 对象合并
	 * @param targetObj {Object}
	 * @param sourceObjs {Array{Object}}
	 */
	var mergeObj = function (targetObj, sourceObjs) {
	    for (var i in sourceObjs) {
	        Object.assign(targetObj, sourceObjs[i]);
	    }
	    return targetObj;
	};
	/**
	 * 对象合并
	 * @param target {Object}
	 * @param source {Array{Object}}
	 */
	var mixin = function (target, source) {
	    for (var x in source) {
	        target[x] = source[x];
	    }
	}
	/**
	 * 判断数组是是否包含指定元素
	 * @param targetE
	 */
	var isInArray = function (array, targetE) {
	    return array.find(function (item, index, array) {
	        return (item === targetE);
	    }) === undefined ? false : true;
	};

	/**
	 * 获取元素在数组的索引
	 * @param array
	 * @param targetE
	 * @returns {number}
	 */
	var getIndexInArray = function (array, targetE) {
	    return array.findIndex(function (item, index, array) {
	        return (item === targetE);
	    });

	};

	var getDom = function (attr) {
	    if (attr.substring(0, 1) === '.') {
	        return document.getElementsByClassName(attr.substring(1));
	    }
	    return document.getElementById(attr);
	};

	/**
	 * 判断对象是否含有某属性
	 * @param obj 对象
	 * @param attribute 属性
	 * @returns {boolean}
	 */
	var isPropertyInObj = function (obj, attribute) {
	    return obj.hasOwnProperty(attribute);
	};

	/**
	 * 在当前数据范围内
	 * @param extent
	 * @returns {Array}
	 * @param multiple {number} 扩展到当前屏幕范围的几倍
	 */
	var extentTimes = function (extent, multiple) {
	    var _newExtent = [];
	    var _minLon = extent[0];
	    var _minLat = extent[1];
	    var _maxLon = extent[2];
	    var _maxLat = extent[3];
	    var _multiple = multiple - 1;

	    var x_span = ((_maxLon - _minLon) / 2);
	    var y_span = ((_maxLat - _minLat) / 2);

	    var _newMinLon = _minLon - x_span * _multiple;
	    var _newMinLat = _minLat - y_span * _multiple;
	    var _newMaxLon = _maxLon + x_span * _multiple;
	    var _newMaxLat = _maxLat + y_span * _multiple;

	    _newExtent[0] = _newMinLon;
	    _newExtent[1] = _newMinLat;
	    _newExtent[2] = _newMaxLon;
	    _newExtent[3] = _newMaxLat;

	    return _newExtent;
	};

	var _isArray = Array.isArray || function (obj) {
	    return Object.prototype.toString.call(obj) === '[object Array]';
	};

	var _isFinite = function (obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	};

	var _isObject = function (obj) {
	    return obj === Object(obj);
	};

	var _find = function (arr, func) {
	    if (!_isArray(arr) && !arr.length) {
	        return;
	    }
	    if (arr.find) {
	        return arr.find(func);
	    }
	    var l = arr.length, findItem;
	    for (var i = 0; i < l; i++) {
	        if (func(arr[i])) {
	            findItem = arr[i];
	            break;
	        }
	    }
	    return findItem;
	};

	function sortBy(list) {
	    if (!list || !_isArray(list)) {
	        return;
	    }
	    var result = [];
	    if (typeof arguments[1] === 'function') {
	        var callback = arguments[1];
	        var len = list.length, sortMap = [];
	        for (var i = 0; i < len; i++) {
	            var v = callback(list[i], i);
	            sortMap.push({
	                source_pos: i,
	                value: v
	            });
	        }
	        for (var j = 0; j < len; j++) {
	            for (var k = j; k < len; k++) {
	                if (sortMap[j].value > sortMap[k].value) {
	                    var temp = sortMap[j];
	                    sortMap[j] = sortMap[k];
	                    sortMap[k] = temp;
	                }
	            }
	        }

	        for (var m = 0; m < len; m++) {
	            result.push(list[sortMap[m].source_pos]);
	        }
	        return result;
	    }
	    if (_isArray(arguments[1]) && arguments[1].length === list.length) {
	        var arr = arguments[1];
	        result.length = arr.length;
	        arr.forEach(function (i, index) {
	            result[i] = list[index];
	        });
	        return result;
	    }
	}

	function sortedIndex(list, callback) {
	    if (!list || !_isArray(list)) {
	        return;
	    }
	    var len = list.length, sortMap = [];
	    for (var i = 0; i < len; i++) {
	        var v = callback(list[i], i);
	        sortMap.push({
	            source_pos: i,
	            value: v
	        });
	    }
	    for (var j = 0; j < len; j++) {
	        for (var k = j; k < len; k++) {
	            if (sortMap[j].value > sortMap[k].value) {
	                var temp = sortMap[j];
	                sortMap[j] = sortMap[k];
	                sortMap[k] = temp;
	            }
	        }
	    }
	    var result = new Array(len);
	    for (var m = 0; m < len; m++) {
	        result[sortMap[m].source_pos] = m;
	    }
	    return result;

	}

	function flatten(list) {
	    if (!list || !_isArray(list)) {
	        return [];
	    }

	    var len = list.length, merged = [];
	    for (var i = 0; i < len; i++) {
	        merged = merged.concat(list[i]);
	    }
	    return merged;
	}

	function getParameterString(params) {
	    var paramsArray = [];
	    for (var key in params) {
	        if (!params.hasOwnProperty(key)) {
	            continue;
	        }
	        var value = params[key];
	        if ((value !== null) && (typeof value !== 'function')) {
	            var encodedValue;
	            if (typeof value === 'object' && value.constructor === Array) {
	                /* value is an array; encode items and separate with "," */
	                var encodedItemArray = [];
	                var item;
	                for (var itemIndex = 0, len = value.length; itemIndex < len; itemIndex++) {
	                    item = value[itemIndex];
	                    encodedItemArray.push(encodeURIComponent(
	                        (item === null || item === undefined) ? '' : item)
	                    );
	                }
	                encodedValue = encodedItemArray.join(',');
	            }
	            else {
	                /* value is a string; simply encode */
	                encodedValue = encodeURIComponent(value);
	            }
	            paramsArray.push(encodeURIComponent(key) + '=' + encodedValue);
	        }
	    }

	    return paramsArray.join('&');
	}

	function extend() {
	    var args = arguments;
	    var origin = args[0];
	    for (var i = 1, l = args.length; i < l; i++) {
	        var cur = args[i];
	        var keys = Object.keys(cur);
	        for (var j = 0, s = keys.length; j < s; j++) {
	            var key = keys[j];
	            if (cur[key] !== 'undefined' && cur[key] !== null) {
	                origin[key] = cur[key];
	            }
	        }
	    }
	    return origin;
	}

	function compact(arr) {
	    if (!_isArray(arr)) {
	        return;
	    }
	    var nArr = [];
	    for (var i = 0, l = arr.length; i < l; i++) {
	        if (arr[i] !== undefined && arr[i] !== null) {
	            nArr.push(arr[i]);
	        }
	    }
	    return nArr;
	}

	function last(arr) {
	    if (_isArray(arr)) {
	        return arr[arr.length - 1];
	    }
	}

	function groupBy(list, callback) {
	    if (!list || !_isArray(list)) {
	        return;
	    }
	    var tags = {};
	    for (var i = 0, l = list.length; i < l; i++) {
	        var tag = callback(list[i]);
	        if (!tags[tag]) {
	            tags[tag] = [];
	        }
	        tags[tag].push(list[i]);
	    }
	    return tags;
	}

	function sortGroupBy(list, callback) {
	    if (!list || !_isArray(list)) {
	        return;
	    }
	    list = sortBy(list, callback);
	    var result = [], tempTag = null;
	    for (var i = 0, l = list.length; i < l; i++) {
	        var tag = callback(list[i]);
	        if (tempTag !== tag) {
	            tempTag = tag;
	            result.push([]);
	        }
	        last(result).push(list[i]);
	    }
	    return result;
	}

	function sortAsc(nums) {
	    nums.sort(function (num1, num2) {
	        if (num1 > num2) {
	            return 1;
	        }
	        else if (num1 < num2) {
	            return -1;
	        }
	        else {
	            return 0;
	        }
	    });
	}

	function sortDes(nums) {
	    nums.sort(function (num1, num2) {
	        if (num1 > num2) {
	            return -1;
	        }
	        else if (num1 < num2) {
	            return 1;
	        }
	        else {
	            return 0;
	        }
	    });
	}

	function toArray(arr) {
	    if (!arr || typeof (arr.length) !== 'number') {
	        return;
	    }
	    var list = [];
	    for (var x = 0, l = arr.length; x < l; x++) {
	        list.push(arr[x]);
	    }
	    return list;
	}

	function endsWith(string, subString) {
	    if (string.indexOf(subString) === (string.length - subString.length)) {
	        return true;
	    }
	    return false;
	}

	// 速度最快， 占空间最多（空间换时间）
	function unique(array) {
	    var n = {}, r = [], len = array.length, val, type;
	    for (var i = 0; i < array.length; i++) {
	        val = array[i];
	        type = typeof val;
	        if (!n[val]) {
	            n[val] = [type];
	            r.push(val);
	        }
	        else if (n[val].indexOf(type) < 0) {
	            n[val].push(type);
	            r.push(val);
	        }
	    }
	    return r;
	}

	var htmlDecode = function (text) {
	    var temp = document.createElement('div');
	    temp.innerHTML = text;
	    var output = temp.innerText || temp.textContent;
	    temp = null;
	    return output;
	};

	var objectDecode = function (obj) {
	    if (obj) {
	        return JSON.parse(this.htmlDecode(JSON.stringify(obj)));
	    }
	    else {
	        return obj;
	    }
	};

	var getWKTFromText = function (text) {
	    var _wkt = new ol.format.WKT();
	    if (!!text) {
	        var _feature = _wkt.readFeature(text);

	        if (!!!_feature.getGeometry()) {
	            return false;
	        }

	        return {
	            geoType: _feature.getGeometry().getType(),
	            coordinates: _feature.getGeometry().getCoordinates()
	        };
	    }
	};
	var coordinateTypeCheck = function (coordinate) {
	    var type;
	    if (coordinate instanceof Array) {
	        coordinate.forEach(function (item) {
	            if (item instanceof Array) {
	                item.forEach(function (itemC) {
	                    if (itemC instanceof Array) {
	                        type = 'Polygon';
	                    } else {
	                        type = 'LineString';
	                    }
	                })
	            } else {
	                type = 'Point';
	            }
	        })
	    }
	    return type;
	}
	var strFormat = function (WKTTextFormatBefore) {
	    var str = '', i = 0;
	    var tmpStr = WKTTextFormatBefore.replace(/\),\(/g, '&').replace(/\s/g, ',');
	    var tmpArray = tmpStr.split(',');
	    tmpArray.forEach(function (item, index) {
	        if (item.indexOf('&') > 0) {
	            i = 0;
	            str = str + item + ' ';
	        } else {
	            if (i % 2 === 0 && index < tmpArray.length - 1) {
	                str = str + item + ' ';
	            } else if (index < tmpArray.length - 1) {
	                str = str + item + ','
	            } else {
	                str = str + item;
	            }
	        }
	        i++;
	    })
	    str = str.replace(/\&/g, '),(');
	    return str;
	}
	var translateVertexToWKT = function (coordinate) {
	    var _wkt = new ol.format.WKT;
	    var _feature;
	    var type = coordinateTypeCheck(coordinate);
	    if (type === 'Polygon') {
	        _feature = new ol.Feature({
	            geometry: new ol.geom.Polygon(coordinate)
	        });
	    } else if (type === 'LineString') {
	        _feature = new ol.Feature({
	            geometry: new ol.geom.LineString(coordinate)
	        });
	    } else {
	        return false;
	    }
	    var _format = _wkt.writeFeature(_feature);
	    return strFormat(_format);
	}

	/*融合gis工具类*/
	//判断多边形是否相交
	var isPolygonIntersect = function (polygon1, polygon2) {
	    var interPoly = [];
	    var isIntersect = true;
	    var points1 = polygon1, points2 = polygon2;

	    var poly1 = [], poly2 = [];
	    points1 = points1.split(";");
	    points2 = points2.split(";");
	    for (var i = 0; i < points1.length; i++) {
	        var lon = parseFloat(points1[i].split(",")[0]);
	        var lat = parseFloat(points1[i].split(",")[1]);
	        poly1.push([lon, lat]);
	    }
	    for (var i = 0; i < points2.length; i++) {
	        var lon = parseFloat(points2[i].split(",")[0]);
	        var lat = parseFloat(points2[i].split(",")[1]);
	        poly2.push([lon, lat]);
	    }

	    //计算多边形的交点
	    for (var j = 0; j < poly1.length; j++) {
	        var poly1_next_idx = (j + 1) % poly1.length;
	        for (var k = 0; k < poly2.length; k++) {
	            var poly2_next_idx = (k + 1) % poly2.length;
	            var point = this.getCrossPoint_(poly1[j], poly1[poly1_next_idx],
	                poly2[k], poly2[poly2_next_idx]);
	            if (point) {
	                interPoly.push(point);
	            }
	        }
	    }

	    //计算多边形的内部点
	    for (var m = 0; m < poly1.length; m++) {
	        if (this.isPointInPolygon_(poly2, poly1[m])) {
	            interPoly.push(poly1[m]);
	        }
	    }
	    for (var n = 0; n < poly2.length; n++) {
	        if (this.isPointInPolygon_(poly1, poly2[n])) {
	            interPoly.push(poly2[n]);
	        }
	    }

	    if (interPoly.length <= 0) {
	        isIntersect = false;
	    }
	    return isIntersect;
	};


	/**
	 * 判断polygonA是否在polygonB内
	 * @param polygonA
	 * @param polygonB
	 * @returns {*}
	 */
	var isPolygonAInPolygonB = function (polygonA, polygonB) {
	    var interPoly = [];
	    var isInsidePoly = false;
	    var points1 = polygonA, points2 = polygonB;

	    var poly1 = [], poly2 = [];
	    points1 = points1.split(";");
	    points2 = points2.split(";");
	    for (var i = 0; i < points1.length; i++) {
	        var lon = parseFloat(points1[i].split(",")[0]);
	        var lat = parseFloat(points1[i].split(",")[1]);
	        poly1.push([lon, lat]);
	    }
	    for (var i = 0; i < points2.length; i++) {
	        var lon = parseFloat(points2[i].split(",")[0]);
	        var lat = parseFloat(points2[i].split(",")[1]);
	        poly2.push([lon, lat]);
	    }

	    //计算多边形的内部点
	    for (var m = 0; m < poly1.length; m++) {
	        if (this.isPointInPolygon_(poly2, poly1[m])) {
	            interPoly.push(poly1[m]);
	        }
	    }
	    if (interPoly.length == poly1.length) {
	        isInsidePoly = true;
	    }
	    return isInsidePoly;
	};

	/**
	 * 叉乘判断点与线的位置关系（内部方法）
	 * @param p1
	 * @param p2
	 * @param p3
	 * @returns {number}
	 */
	var multi = function (p1, p2, p3) {
	    return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1]);
	};


	/**
	 * 判断线段ab与线段cd是否相交，两线段重叠或交点为顶点视为不相交
	 */
	var isIntersection = function (a, b, c, d) {
	    var flag = false;
	    if (a == c && b == d
	        || b == c
	        || b == d
	        || a == d
	        || (b[1] - a[1]) * (c[0] - d[0]) - (c[1] - d[1]) * (b[0] - a[0]) == 0) {
	        return flag;
	    }
	    var point = [];
	    point.push(0);
	    point.push(0);
	    var intersection = new ol.geom.Point(point);
	    intersection[0] = ((b[0] - a[0]) * (c[0] - d[0]) * (c[1] - a[1]) - c[0]
	        * (b[0] - a[0]) * (c[1] - d[1]) + a[0] * (b[1] - a[1]) * (c[0] - d[0]))
	        / ((b[1] - a[1]) * (c[0] - d[0]) - (b[0] - a[0]) * (c[1] - d[1]));

	    intersection[1] = ((b[1] - a[1]) * (c[1] - d[1]) * (c[0] - a[0]) - c[1]
	        * (b[1] - a[1]) * (c[0] - d[0]) + a[1] * (b[0] - a[0]) * (c[1] - d[1]))
	        / ((b[0] - a[0]) * (c[1] - d[1]) - (b[1] - a[1]) * (c[0] - d[0]));

	    intersection[0] = intersection[0].toFixed(11);
	    intersection[1] = intersection[1].toFixed(12);

	    if ((intersection[0] - a[0]) * (intersection[0] - b[0]) <= 0
	        && (intersection[0] - c[0]) * (intersection[0] - d[0]) <= 0
	        && (intersection[1] - a[1]) * (intersection[1] - b[1]) <= 0
	        && (intersection[1] - c[1]) * (intersection[1] - d[1]) <= 0) {
	        flag = true; // '相交 否则'相交但不在线段上
	    } else if (c[0] == d[0] && c[1] != d[1] && a[1] == b[1] && a[0] != b[0]) { // 直角由内向外
	        flag = true;
	    } else if (a[0] == d[0] && a[1] != d[1] && b[1] == c[1] && b[0] != c[0]) { // 直角由外向内
	        flag = true;
	    } else if (a[0] == b[0] && a[1] != b[1] || a[1] == b.y && a[0] != b.x) { // 锐角外边平信个，且有一边两端点某坐标在同一坐标
	        flag = true;
	    }
	    point = null;
	    return flag;


	};


	/**
	 * 相交点算法，更精细
	 * @param line1StartX
	 * @param line1StartY
	 * @param line1EndX
	 * @param line1EndY
	 * @param line2StartX
	 * @param line2StartY
	 * @param line2EndX
	 * @param line2EndY
	 * @returns {*}
	 */
	var lineIntersects = function (line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
	    // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
	    var denominator, a, b, numerator1, numerator2,
	        result = {
	            x: null,
	            y: null,
	            onLine1: false,
	            onLine2: false
	        };
	    denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));
	    if (denominator === 0) {
	        if (result.x !== null && result.y !== null) {
	            return result;
	        } else {
	            return false;
	        }
	    }
	    a = line1StartY - line2StartY;
	    b = line1StartX - line2StartX;
	    numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);
	    numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);
	    a = numerator1 / denominator;
	    b = numerator2 / denominator;

	    // if we cast these lines infinitely in both directions, they intersect here:
	    result.x = line1StartX + (a * (line1EndX - line1StartX));
	    result.y = line1StartY + (a * (line1EndY - line1StartY));

	    // if line1 is a segment and line2 is infinite, they intersect if:
	    if (a >= 0 && a <= 1) {
	        result.onLine1 = true;
	    }
	    // if line2 is a segment and line1 is infinite, they intersect if:
	    if (b >= 0 && b <= 1) {
	        result.onLine2 = true;
	    }
	    // if line1 and line2 are segments, they intersect if both of the above are true
	    if (result.onLine1 && result.onLine2) {
	        return [result.x, result.y];
	    } else {
	        return false;
	    }
	};

	/**
	 * 相交点个数
	 * @param points [[[]]] 三维数组
	 * @returns {boolean}
	 */
	var polygonIntersectCount = function (points) {
	    var results = [];
	    points.forEach(function (ring1) {
	        points.forEach(function (ring2) {
	            for (var i = 0; i < ring1.length - 1; i++) {
	                for (var k = 0; k < ring2.length - 1; k++) {
	                    // don't check adjacent sides of a given ring, since of course they intersect in a vertex.
	                    if (ring1 === ring2 && (Math.abs(i - k) === 1 || Math.abs(i - k) === ring1.length - 2)) {
	                        continue;
	                    }

	                    var intersection = lineIntersects(ring1[i][0], ring1[i][1], ring1[i + 1][0], ring1[i + 1][1],
	                        ring2[k][0], ring2[k][1], ring2[k + 1][0], ring2[k + 1][1]);
	                    if (intersection) {
	                        results.push(intersection);
	                    }
	                }
	            }
	        });
	    });
	    return results;
	};


	/**
	 * calculate distance between LonLat in earth.
	 * 计算两点之间的距离 和ol自带的测距一致
	 * @param srcLonLat
	 * @param descLonLat
	 * @returns {number}米
	 */
	var calcDistanceBetweenLonLat = function (startLonLat, endLonLat) {
	    var length = 0;
	    if ($.isArray(startLonLat) && $.isArray(endLonLat)) {
	        var wgs84 = new ol.Sphere(GisUtil.DEF_R);
	        length = wgs84.haversineDistance(startLonLat, endLonLat);
	    }
	    return length;
	};

	/**
	 * 判断点p是否在多边形内（包括边界线）
	 * @param polygonVerVertexsStr string
	 * @param location float arr
	 * @returns {boolean}
	 */
	var isInsidePolygon = function (polygonVerVertexsStr, location) {
	    var localLon = location[0];
	    var localLat = location[1];
	    var polygon = null;
	    if (typeof polygonVerVertexsStr === 'string') {
	        polygon = parsePointStrToLocationArray(polygonVerVertexsStr);
	    } else {
	        polygon = polygonVerVertexsStr;
	    }
	    var sum = 0;
	    var n = polygon.length;
	    for (var i = n - 1, j = 0; j < n; i = j++) {
	        if (GisUtil.EPSILON > Math.abs(polygon[i][0] - (localLon)) && GisUtil.EPSILON > Math
	            .abs(polygon[i][1] - (localLat))) { // 是否在顶点上
	            return true;
	        } else if (isPointInLine(location, polygon[i], polygon[j])) { // 是否在边界线上
	            return true;
	        }
	        var x1 = polygon[i][0] - localLon;
	        var y1 = polygon[i][1] - localLat;
	        var x2 = polygon[j][0] - localLon;
	        var y2 = polygon[j][1] - localLat;
	        var radian = Math.atan2(y2, x2) - Math.atan2(y1, x1);
	        var crossProduct = x1 * y2 - x2 * y1; // 向量积
	        radian = modifyAngle(radian, crossProduct);
	        sum += radian;
	    }
	    if (Math.abs(2 * Math.PI - sum) < GisUtil.EPSILON || Math.abs(sum + (2 * Math.PI)) < GisUtil.EPSILON) {
	        return true;
	    }
	    return false;
	};

	var parsePointStrToLocationArray = function (pointStr) {
	    var points = pointStr.split(";");
	    var polygons = [];
	    for (var i = 0, validLenth = points.length - 1; i < validLenth; i++) {
	        var point = points[i];
	        if (goog.isDefAndNotNull(point)) {
	            var lonLat = point.split(",");
	            polygons.push(lonLat);
	        }
	    }
	    return polygons;
	};

	/**
	 * 判断点P是否在线段ab上
	 * @param p 当前点
	 * @param a 线段ab的端点
	 * @param b 线段ab的端点
	 */
	var isPointInLine = function (p, a, b) {
	    var plon = p[0];
	    var plat = p[1];
	    var alon = a[0];
	    var alat = a[1];
	    var blon = b[0];
	    var blat = b[1];
	    var maxLat = Math.max(alat, blat);
	    var minLat = Math.min(alat, blat);
	    var maxLon = Math.max(alon, blon);
	    var minLon = Math.min(alon, blon);
	    // 判断点p的经纬度是否在最大最小经纬度范围内
	    if (plat >= minLat && plat <= maxLat && plon >= minLon && plon <= maxLon) {
	        // 根据向量ap与向量bp是否共线来确定p是否在线段ab上
	        var product = (alon - plon) * (blat - plat) - (blon - plon)
	            * (alat - plat);
	        return Math.abs(product) < GisUtil.EPSILON;
	    }
	    return false;
	};


	/**
	 * 对所求内角弧度进行修正
	 *
	 * @param radian
	 *            初始弧度值
	 * @param product
	 *            向量积
	 * @return 修正后的弧度值
	 */
	var modifyAngle = function (radian, product) {
	    radian = Math.abs(radian);
	    // 内角弧度不大于PI即角度不大于180度
	    if (radian > Math.PI) {
	        radian = 2 * Math.PI - radian;
	    }
	    // 如果向量积大于0，说明当前内角是逆时针方向获得，即为弧度为负
	    if (product > 0) {
	        radian = 0.0 - radian;
	    }
	    return radian;
	};


	/**
	 * 计算曲线所有点
	 */
	var curvePoint = function (path) {
	    var curve = [];
	    var f = bezierCurve(path);
	    var coor = path[0];// 起点
	    curve.push(coor);
	    var tempLnglat;
	    for (var i = 0.01; i <= 1; i += 0.01) {
	        tempLnglat = f(i);
	        curve.push(tempLnglat);
	    }
	    tempLnglat = f(1);// 终点
	    if (coor[0] != tempLnglat[0] || coor[1] != tempLnglat[1]) {
	        curve.push(tempLnglat);
	    }
	    // delete f;
	    return curve;
	};
	/**
	 * 阶贝赛尔曲线函数
	 */
	var bezierCurve = function (p) {
	    function getPolynomial(N) { // 展开Cn_k的多项式
	        var result = [1, N];
	        for (var i = 2, j = Math.floor(N / 2); i <= j; i++) {
	            result[i] = result[i - 1] * (N - i + 1) / i;
	        }
	        while (i <= N) {
	            result[i] = result[N - i++];
	        }
	        return result;
	    }

	    var len = p.length - 1;
	    var Cn = getPolynomial(len);

	    return function (t) {
	        var n = len;
	        if (t == 1) {
	            return p[len];
	        }
	        var lt = 1 - t;
	        var s = Math.pow(lt, n), lt_t = t / lt;
	        var p1 = p[0];
	        var x = p1[0] * s, y = p1[1] * s;
	        for (var i = 1; i <= n; i++) {
	            s = s / Cn[i - 1] * lt_t * Cn[i];
	            var pp = p[i];
	            x += pp[0] * s;
	            y += pp[1] * s;
	        }
	        return ([x, y]);
	    };
	};
	/**
	 * 绘制带箭头的直线
	 *
	 * @param start_x
	 *            开始坐标x
	 * @param start_y
	 *            开始坐标y
	 * @param end_x
	 *            结束坐标x
	 * @param end_y
	 *            结束坐标y
	 * @param arrowRadius
	 *            箭头的长度(乘以地图基础半径后的值)
	 * @param arrowPosition
	 *            箭头在箭身的位置比例，取值[0,1]：0表示在start点绘制箭头，1表示在end点绘制箭头，0.75表示在离start点3/4处绘制箭头
	 * @returns {OpenLayers.Feature.Vector} 包含当前图形点集的Feature
	 */
	var curveLineArr = function (start_x, start_y, end_x, end_y, arrowRadius, arrowPosition) {
	    var arrowAngle = Math.atan(0.1) / Math.PI * 180; // 默认箭头与线的夹角为Math.atan(0.1)
	    // 箭头所在坐标
	    var arrowCenter_x = start_x + (end_x - start_x) * arrowPosition;
	    var arrowCenter_y = start_y + (end_y - start_y) * arrowPosition;
	    // 上箭头
	    var arrUp_End = rotateVecForArrowLine(arrowCenter_x - start_x,
	        arrowCenter_y - start_y, -arrowAngle, arrowRadius);
	    var x_up_Start = arrowCenter_x;// 上箭头的开始端点
	    var y_up_Start = arrowCenter_y;
	    var x_up_End = arrowCenter_x - arrUp_End[0]; // 上箭头的结束端点
	    var y_up_End = arrowCenter_y - arrUp_End[1];
	    // 下箭头
	    var arrDown_End = rotateVecForArrowLine(arrowCenter_x - start_x,
	        arrowCenter_y - start_y, arrowAngle, arrowRadius);
	    var x_down_Start = arrowCenter_x;// 下箭头的开始端点
	    var y_down_Start = arrowCenter_y;
	    var x_down_End = arrowCenter_x - arrDown_End[0]; // 下箭头的结束端点
	    var y_down_End = arrowCenter_y - arrDown_End[1];
	    // 线
	    var startPoint = [start_x, start_y]; // 箭头文字显示位置
	    var endPoint = [end_x, end_y];
	    var points = [];
	    points.push(startPoint);
	    points.push(endPoint);
	    // 上箭头线
	    var upStartPoint = [x_up_Start, y_up_Start];
	    var upEndPoint = [x_up_End, y_up_End];
	    points.push(upStartPoint);
	    points.push(upEndPoint);
	    // 下箭头线
	    var downStartPoint = [x_down_Start, y_down_Start];
	    var downEndPoint = [x_down_End, y_down_End];
	    points.push(downStartPoint);
	    points.push(downEndPoint);

	    return points;
	};

	var rotateVecForArrowLine = function (px, py, angle, arrowRadius) {
	    var vPoint = []; // 箭头坐标点的x,y分量
	    // 矢量旋转函数，参数含义分别是x分量、y分量、旋转角、箭头长度
	    var vx = px * Math.cos(angle) - py * Math.sin(angle);
	    var vy = px * Math.sin(angle) + py * Math.cos(angle);
	    var d = Math.sqrt(vx * vx + vy * vy);
	    vx = vx / d * arrowRadius;
	    vy = vy / d * arrowRadius;
	    vPoint[0] = vx;
	    vPoint[1] = vy;
	    return vPoint;
	};

	/**
	 * 计算角度象限
	 */
	var getAngleQuadrant = function (angle) {
	    if (0 <= angle && angle < 90) {
	        return 1;
	    } else if (90 <= angle && angle < 180) {
	        return 4;
	    } else if (180 <= angle && angle < 270) {
	        return 3;
	    } else if (270 <= angle && angle < 360) {
	        return 2;
	    }
	};
	// 建立http请求对象
	var createXMLHttpRequest = function () {
	    var xmlHttp = null;
	    if (window.XMLHttpRequest) {
	        xmlHttp = new XMLHttpRequest();
	        if (xmlHttp.overrideMimeType)
	            xmlHttp.overrideMimeType('text/xml');
	    } else if (window.ActiveXObject) {
	        try {
	            xmlHttp = new ActiveXObject("Msxml2.XMLHTTP");
	        } catch (e) {
	            try {
	                xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");
	            } catch (e) {
	            }
	        }
	    }
	    return xmlHttp;
	};
	/**
	 * 字符串转码
	 */
	var strToBase64 = function (sDOMStr) {
	    var aBytes, nChr, nStrLen = sDOMStr.length, nArrLen = 0;
	    var nMod3 = 2, sB64Enc = "";
	    for (var nMapIdx = 0; nMapIdx < nStrLen; nMapIdx++) {
	        nChr = sDOMStr.charCodeAt(nMapIdx);
	        nArrLen += nChr < 0x80 ? 1 : nChr < 0x800 ? 2 : nChr < 0x10000 ? 3 : nChr < 0x200000 ? 4 : nChr < 0x4000000 ? 5 : 6;
	    }
	    aBytes = new Uint8Array(nArrLen);
	    for (var nIdx = 0, nChrIdx = 0; nIdx < nArrLen; nChrIdx++) {
	        nChr = sDOMStr.charCodeAt(nChrIdx);
	        if (nChr < 128) {
	            /* one byte */
	            aBytes[nIdx++] = nChr;
	        } else if (nChr < 0x800) {
	            /* two bytes */
	            aBytes[nIdx++] = 192 + (nChr >>> 6);
	            aBytes[nIdx++] = 128 + (nChr & 63);
	        } else if (nChr < 0x10000) {
	            /* three bytes */
	            aBytes[nIdx++] = 224 + (nChr >>> 12);
	            aBytes[nIdx++] = 128 + (nChr >>> 6 & 63);
	            aBytes[nIdx++] = 128 + (nChr & 63);
	        } else if (nChr < 0x200000) {
	            /* four bytes */
	            aBytes[nIdx++] = 240 + (nChr >>> 18);
	            aBytes[nIdx++] = 128 + (nChr >>> 12 & 63);
	            aBytes[nIdx++] = 128 + (nChr >>> 6 & 63);
	            aBytes[nIdx++] = 128 + (nChr & 63);
	        } else if (nChr < 0x4000000) {
	            /* five bytes */
	            aBytes[nIdx++] = 248 + (nChr >>> 24);
	            aBytes[nIdx++] = 128 + (nChr >>> 18 & 63);
	            aBytes[nIdx++] = 128 + (nChr >>> 12 & 63);
	            aBytes[nIdx++] = 128 + (nChr >>> 6 & 63);
	            aBytes[nIdx++] = 128 + (nChr & 63);
	        } else /* if (nChr <= 0x7fffffff) */ {
	            /* six bytes */
	            aBytes[nIdx++] = 252 + /* (nChr >>> 32) is not possible in ECMAScript! So...: */ (nChr / 1073741824);
	            aBytes[nIdx++] = 128 + (nChr >>> 24 & 63);
	            aBytes[nIdx++] = 128 + (nChr >>> 18 & 63);
	            aBytes[nIdx++] = 128 + (nChr >>> 12 & 63);
	            aBytes[nIdx++] = 128 + (nChr >>> 6 & 63);
	            aBytes[nIdx++] = 128 + (nChr & 63);
	        }
	    }
	    for (var nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {
	        nMod3 = nIdx % 3;
	        if (nIdx > 0 && (nIdx * 4 / 3) % 76 === 0) { sB64Enc += "\r\n"; }
	        nUint24 |= aBytes[nIdx] << (16 >>> nMod3 & 24);
	        if (nMod3 === 2 || aBytes.length - nIdx === 1) {
	            sB64Enc += String.fromCharCode(uint6ToB64(nUint24 >>> 18 & 63), uint6ToB64(nUint24 >>> 12 & 63), uint6ToB64(nUint24 >>> 6 & 63), uint6ToB64(nUint24 & 63));
	            nUint24 = 0;
	        }
	    }
	    return sB64Enc.substr(0, sB64Enc.length - 2 + nMod3) + (nMod3 === 2 ? '' : nMod3 === 1 ? '=' : '==');
	};
	var uint6ToB64 = function (nUint6) {
	    return nUint6 < 26 ?
	        nUint6 + 65
	        : nUint6 < 52 ?
	            nUint6 + 71
	            : nUint6 < 62 ?
	                nUint6 - 4
	                : nUint6 === 62 ?
	                    43
	                    : nUint6 === 63 ?
	                        47
	                        :
	                        65;
	}
	/**
	 * 计算邻区点象线
	 * basePoint
	 * basePoint 原点
	 * neiPoint 该点在原点的第几象限的点坐标
	 */
	var getPointQuadrant = function (basePoint, neiPoint) {
	    var a = basePoint[0], b = basePoint[1], c = neiPoint[0], d = neiPoint[1];
	    if (d >= b && c >= a) {// 1
	        return 1;
	    } else if (d >= b && c < a) {// 2
	        return 2;
	    } else if (d < b && c <= a) {// 3
	        return 3;
	    } else if (d < b && c >= a) {// 4
	        return 4;
	    }
	};

	var parsePointStrToLocationArray = function (pointStr) {
	    var points = pointStr.split(";");
	    var polygons = [];
	    for (var i = 0, validLenth = points.length - 1; i < validLenth; i++) {
	        var point = points[i];
	        if (goog.isDefAndNotNull(point)) {
	            var lonLat = point.split(",");
	            polygons.push(lonLat);
	        }
	    }
	    return polygons;
	};
	/**
	 * 对所求内角弧度进行修正
	 *
	 * @param radian
	 *            初始弧度值
	 * @param product
	 *            向量积
	 * @return 修正后的弧度值
	 */
	var modifyAngle = function (radian, product) {
	    radian = Math.abs(radian);
	    // 内角弧度不大于PI即角度不大于180度
	    if (radian > Math.PI) {
	        radian = 2 * Math.PI - radian;
	    }
	    // 如果向量积大于0，说明当前内角是逆时针方向获得，即为弧度为负
	    if (product > 0) {
	        radian = 0.0 - radian;
	    }
	    return radian;
	};
	/**
	 * 构造扇形点集合
	 * @param originx
	 * @param originy
	 * @param finalRadius
	 * @param azimuth
	 * @param angleRange
	 * @returns {Array}
	 */
	var getSectorArr = function (transformInd, originx, originy, finalRadius, azimuth, angleRange) {
	    var anglePerPoint = 10;
	    var sides = angleRange / anglePerPoint;
	    var angleParm = anglePerPoint * Math.PI / 180;
	    var rotatedAngle = Math.PI / 2 - (azimuth + angleRange / 2) / 180 * Math.PI;
	    var x = 0, y = 0, points = [];
	    points.push([originx, originy]);
	    for (var i = 0; i <= sides; ++i) {
	        x = originx + finalRadius * Math.cos(rotatedAngle);
	        // 空白地图y不需要转换，有地图时不同纬度下地球切面半径不用，需要对y进行转换
	        if (transformInd) {
	            y = originy + finalRadius * Math.sin(rotatedAngle) * Math.cos(originy * Math.PI / 180);
	        } else {
	            y = originy + finalRadius * Math.sin(rotatedAngle);
	        }
	        points.push([x, y]);
	        rotatedAngle += angleParm;
	    }
	    points.push([originx, originy]);
	    return points;
	};
	/**
	 * 曲线算法
	 * @param transformInd
	 * @param x1 起始点经度
	 * @param y1 起始点纬度
	 * @param x2 终止点经度
	 * @param y2 终止点纬度
	 * @param angleRange 角度
	 * @returns {Array}
	 */

	var getCurve = function (transformInd, x1, y1, x2, y2, angleRange) {
	    var distance = Math.sqrt(Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2));
	    var radius = distance / (2 * Math.sin(angleRange / 2 / 180 * Math.PI));
	    var azimuth = Math.atan((y2 - y1) / (x1 - x2));
	    var anglePerPoint = 5;
	    var x = 0, y = 0, points = [], newPoints = [];
	    var flag = false;
	    if (angleRange == 0) {
	        points.push([x1, y1]);
	        points.push([x2, y2]);
	        return points;
	    } else {
	        if (angleRange > 180) {
	            angleRange = 360 - angleRange;
	            flag = true;
	        }
	        var sides = angleRange / anglePerPoint;
	        var angleParm = anglePerPoint * Math.PI / 180;
	        var rotatedAngle = Math.PI / 2 - (azimuth + angleRange / 2 / 180 * Math.PI);
	        var maxX = Math.max(x1, x2);
	        var Y;
	        maxX == x1 ? Y = y1 : Y = y2;
	        var originx = maxX - radius * Math.cos(rotatedAngle);
	        var originy = Y - radius * Math.sin(rotatedAngle);
	        for (var i = 0; i <= sides; ++i) {
	            x = originx + radius * Math.cos(rotatedAngle);
	            // 空白地图y不需要转换，有地图时不同纬度下地球切面半径不用，需要对y进行转换
	            //            if (transformInd) {
	            //                y = originy + radius * Math.sin(rotatedAngle) * Math.cos(originy * Math.PI / 180);
	            //            } else {
	            y = originy + radius * Math.sin(rotatedAngle);
	            //            }
	            if (flag) {
	                var A = y2 - y1, B = -(x2 - x1), C = y1 * x2 - y2 * x1;
	                var molecule = A * x + B * y + C;
	                var mirrorX = x - 2 * A * molecule / (A * A + B * B);
	                var mirrorY = y - 2 * B * molecule / (A * A + B * B);
	                points.push([mirrorX, mirrorY]);
	                rotatedAngle += angleParm;
	                if (rotatedAngle > ((angleRange / 180 * Math.PI) + Math.PI / 2 - (azimuth + angleRange / 2 / 180 * Math.PI))) {
	                    break;
	                }
	            } else {
	                points.push([x, y]);
	                rotatedAngle += angleParm;
	                if (rotatedAngle > ((angleRange / 180 * Math.PI) + Math.PI / 2 - (azimuth + angleRange / 2 / 180 * Math.PI))) {
	                    break;
	                }
	            }
	        }
	        if (x1 < x2) {
	            points[0] = [x2, y2];
	            points[points.length - 1] = [x1, y1];
	            for (var j = points.length - 1; j >= 0; j--) {
	                newPoints.push(points[j]);
	            }
	            return newPoints;
	        } else {
	            points[0] = [x1, y1];
	            points[points.length - 1] = [x2, y2];
	            return points;
	        }
	    }
	};
	/**
	 * 折线算法
	 * @param start
	 * @param end
	 * @param index
	 * @returns pointArr
	 */
	var brokenLine = function (start, end, index, separation) {
	    var pointArr = [], startArr = [], endArr = [];

	    //计算起点与终点的相对位置
	    var position = null;
	    var dx = start[0] - end[0];
	    var dy = start[1] - end[1];
	    if (Math.abs(dx) > Math.abs(dy)) {
	        if (dx < 0) {
	            position = 8;
	        } else {
	            position = 16;
	        }
	    }
	    if (dy < 0) {
	        position = 1;
	    } else {
	        position = 4;
	    }

	    pointArr.push(start);
	    if (index > 0) {
	        //计算斜率
	        var ray = [];
	        if (position == 4 || position == 16) {
	            ray.push(end[0] - start[0]);
	            ray.push(end[1] - start[1]);
	        } else {
	            ray.push(end[0] - start[0]);
	            ray.push(end[1] - start[1]);
	        }
	        var length = Math.sqrt((ray[0] * ray[0]) + (ray[1] * ray[1]));
	        if (length <= 0.1) {
	            separation = 0.001;
	        }

	        var raito = 0.05;
	        var width = end[0] - start[0];
	        var height = end[1] - start[1];
	        var midx1 = start[0] + width * raito;
	        var midy1 = start[1] + height * raito;
	        var midx2 = start[0] + width * (1 - raito);
	        var midy2 = start[1] + height * (1 - raito);
	        var xSeparation = separation * ray[0] / length;
	        var ySeparation = separation * ray[1] / length;
	        if (index % 2 == 0) {
	            startArr.push(midx1 + (index / 2) * (-1 * ySeparation));
	            startArr.push(midy1 + (index / 2) * xSeparation);
	            endArr.push(midx2 + (index / 2) * (-1 * ySeparation));
	            endArr.push(midy2 + (index / 2) * xSeparation);
	        }
	        else {
	            startArr.push(midx1 + (index / 2) * ySeparation);
	            startArr.push(midy1 + (index / 2) * (-1 * xSeparation));
	            endArr.push(midx2 + (index / 2) * ySeparation);
	            endArr.push(midy2 + (index / 2) * (-1 * xSeparation));
	        }
	        pointArr.push(startArr);
	        pointArr.push(endArr);
	    }
	    pointArr.push(end);
	    return pointArr;
	};
	/**
	 * 计算扇形的顶点
	 * @param transformInd
	 * @param originx
	 * @param originy
	 * @param finalRadius
	 * @param azimuth
	 * @returns {{lon: number, lat: number}}
	 */
	var getSectorVertex = function (transformInd, originx, originy, finalRadius, azimuth) {
	    var rotatedAngle = Math.PI / 2 - azimuth / 180 * Math.PI;
	    var currentX = 0, currentY = 0;
	    currentX = originx + finalRadius * Math.cos(rotatedAngle);
	    if (transformInd) {
	        currentY = originy + finalRadius * Math.sin(rotatedAngle) * Math.sin(originy * Math.PI / 180);
	    } else {
	        currentY = originy + finalRadius * Math.sin(rotatedAngle);
	    }
	    return { lon: currentX, lat: currentY };
	};
	/**
	 * 绘制菱形 originx经度 originy纬度 finalRadius边长半径 rhombusCount菱形个数 rotation方位角 angleRange菱形角度
	 * @param originx
	 * @param originy
	 * @param finalRadius
	 * @param rhombusCount
	 * @param rotation
	 * @param angleRange
	 * @returns {Array}
	 */
	var getRhombusArr = function (originx, originy, finalRadius, rhombusCount, rotation, angleRange) {
	    var coordinates = [];
	    var side = finalRadius;// 菱形边长
	    var moveLength = finalRadius;// 移动边长
	    var rhombusRadian = angleRange * Math.PI / 180 / 2;// 菱形角度的弧度
	    var point = {
	        px: originx,
	        py: originy
	    };
	    coordinates.push({
	        px: point.px,
	        py: point.py
	    });

	    for (var i = 0; i < 2 * rhombusCount - 1; i++) {
	        if (i % 2 === 0) {
	            point.px = originx + (i + 1) * side * Math.cos(rhombusRadian) - moveLength / 2 * i;
	            point.py = originy - side * Math.sin(rhombusRadian);
	            coordinates.push({
	                px: point.px,
	                py: point.py
	            });
	        } else {
	            point.px = originx + (i + 1) * side * Math.cos(rhombusRadian) - i / 2 * moveLength;
	            point.py = originy - 0.5 * moveLength * Math.tan(rhombusRadian);
	            coordinates.push({
	                px: point.px,
	                py: point.py
	            });
	        }
	    }

	    point.px = originx + 2 * rhombusCount * side * Math.cos(rhombusRadian) - (rhombusCount - 1) * moveLength;
	    point.py = originy;
	    coordinates.push({
	        px: point.px,
	        py: point.py
	    });
	    for (var j = (2 * rhombusCount - 2); j >= 0; j--) {
	        if (j % 2 === 0) {
	            point.px = originx + (j + 1) * side * Math.cos(rhombusRadian) - moveLength / 2 * j;
	            point.py = originy + side * Math.sin(rhombusRadian);
	            coordinates.push({
	                px: point.px,
	                py: point.py
	            });
	        } else {
	            point.px = originx + (j + 1) * side * Math.cos(rhombusRadian) - j / 2 * moveLength;
	            point.py = originy + 0.5 * moveLength * Math.tan(rhombusRadian);
	            coordinates.push({
	                px: point.px,
	                py: point.py
	            });
	        }
	    }
	    var angleRadian = Math.PI * (0.5 - rotation / 180);// 方位角的弧度
	    var points = [], px, py;
	    for (var k = 0; k < coordinates.length; k++) {
	        px = originx + (coordinates[k].px - originx) * Math.cos(angleRadian) - (coordinates[k].py - originy) * Math.sin(angleRadian);
	        py = originy + (coordinates[k].py - originy) * Math.cos(angleRadian) + (coordinates[k].px - originx) * Math.sin(angleRadian);
	        points.push([px, py]);
	    }
	    return points;
	};
	/**
	 * 绘制菱形 originx经度 originy纬度 finalRadius边长半径 rhombusCount菱形个数 rotation方位角 angleRange菱形角度
	 * @param originx
	 * @param originy
	 * @param finalRadius
	 * @param rhombusCount
	 * @param rotation
	 * @param angleRange
	 * @returns {{lon: number, lat: number}}
	 */
	var getRhombusVertex = function (originx, originy, finalRadius, rhombusCount, rotation, angleRange) {
	    var side = finalRadius;// 菱形边长
	    var moveLength = finalRadius;// 移动边长
	    var rhombusRadian = angleRange * Math.PI / 180 / 2;// 菱形角度的弧度
	    var angleRadian = Math.PI * (0.5 - rotation / 180);// 方位角的弧度
	    var currentX = originx + (2 * rhombusCount * side * Math.cos(rhombusRadian) - (rhombusCount - 1) * moveLength) * Math.cos(angleRadian);
	    var currentY = originy + (2 * rhombusCount * side * Math.cos(rhombusRadian) - (rhombusCount - 1) * moveLength) * Math.sin(angleRadian);
	    return { lon: currentX, lat: currentY };
	};
	/**
	 * 构造正六边形点的集合
	 * @param transformInd
	 * @param originx
	 * @param originy
	 * @param azimuth
	 * @param radius
	 */
	var getHexagonArr = function (transformInd, originx, originy, radius, azimuth) {
	    var pointsArr = [];
	    var tmpAngle = 0;
	    var angle = azimuth / 180 * Math.PI;
	    var x = originx;
	    var y = originy;
	    pointsArr.push([x, y]);
	    //计算重心
	    var centerLon = 0, centerLat = 0;
	    if (azimuth >= 90) {
	        tmpAngle = angle - 90 / 180 * Math.PI;
	        centerLon = radius * Math.cos(tmpAngle) + x;
	        if (transformInd) {
	            centerLat = y - radius * Math.sin(tmpAngle) * Math.cos(y * Math.PI / 180);
	        } else {
	            centerLat = y - radius * Math.sin(tmpAngle);
	        }
	    } else {
	        centerLon = radius * Math.sin(angle) + x;
	        if (transformInd) {
	            centerLat = radius * Math.cos(angle) * Math.cos(y * Math.PI / 180) + y;
	        } else {
	            centerLat = radius * Math.cos(angle) + y;
	        }
	    }

	    //第二个点
	    var secondLon = 0, secondLat = 0;
	    if (azimuth >= 90) {
	        tmpAngle = 210 / 180 * Math.PI - angle;
	        secondLon = x - radius * Math.cos(tmpAngle);
	        if (transformInd) {
	            secondLat = y - radius * Math.sin(tmpAngle) * Math.cos(y * Math.PI / 180);
	        } else {
	            secondLat = y - radius * Math.sin(tmpAngle);
	        }
	    } else {
	        tmpAngle = angle - 30 / 180 * Math.PI;
	        secondLon = radius * Math.cos(tmpAngle) + x;
	        if (transformInd) {
	            secondLat = y - radius * Math.sin(tmpAngle) * Math.cos(y * Math.PI / 180);
	        } else {
	            secondLat = y - radius * Math.sin(tmpAngle);
	        }
	    }
	    pointsArr.push([secondLon, secondLat]);

	    //第三个点
	    var thirdLon = 0, thirdLat = 0;
	    if (azimuth >= 90) {
	        tmpAngle = 210 / 180 * Math.PI - angle;
	        thirdLon = centerLon - radius * Math.cos(tmpAngle);
	        if (transformInd) {
	            thirdLat = centerLat - radius * Math.sin(tmpAngle) * Math.cos(y * Math.PI / 180);
	        } else {
	            thirdLat = centerLat - radius * Math.sin(tmpAngle);
	        }
	    } else {
	        tmpAngle = 120 / 180 * Math.PI - angle;
	        thirdLon = centerLon + radius * Math.sin(tmpAngle);
	        if (transformInd) {
	            thirdLat = centerLat - radius * Math.cos(tmpAngle) * Math.cos(y * Math.PI / 180);
	        } else {
	            thirdLat = centerLat - radius * Math.cos(tmpAngle);
	        }
	    }
	    pointsArr.push([thirdLon, thirdLat]);

	    //第四个点
	    var forthLon = 0, forthLat = 0;
	    if (azimuth >= 90) {
	        tmpAngle = angle - 90 / 180 * Math.PI;
	        forthLon = x + 2 * radius * Math.cos(tmpAngle);
	        if (transformInd) {
	            forthLat = y - 2 * radius * Math.sin(tmpAngle) * Math.cos(y * Math.PI / 180);
	        } else {
	            forthLat = y - 2 * radius * Math.sin(tmpAngle);
	        }
	    } else {
	        tmpAngle = angle;
	        forthLon = 2 * radius * Math.sin(tmpAngle) + x;
	        if (transformInd) {
	            forthLat = 2 * radius * Math.cos(tmpAngle) * Math.cos(y * Math.PI / 180) + y;
	        } else {
	            forthLat = 2 * radius * Math.cos(tmpAngle) + y;
	        }
	    }
	    pointsArr.push([forthLon, forthLat]);

	    //第五个点
	    var fifthLon = 0, fifthLat = 0;
	    if (azimuth >= 90) {
	        tmpAngle = angle - 60 / 180 * Math.PI;
	        fifthLon = centerLon + radius * Math.sin(tmpAngle);
	        fifthLat = centerLat + radius * Math.cos(tmpAngle);
	        if (transformInd) {
	            fifthLat = centerLat + radius * Math.cos(tmpAngle) * Math.cos(y * Math.PI / 180);
	        } else {
	            fifthLat = centerLat + radius * Math.cos(tmpAngle);
	        }
	    } else {
	        fifthLon = centerLon - radius * Math.cos(30 / 180 * Math.PI + angle);
	        if (transformInd) {
	            fifthLat = centerLat + radius * Math.sin(30 / 180 * Math.PI + angle) * Math.cos(y * Math.PI / 180);
	        } else {
	            fifthLat = centerLat + radius * Math.sin(30 / 180 * Math.PI + angle);
	        }
	    }
	    pointsArr.push([fifthLon, fifthLat]);

	    //第六个点
	    var sixthLon = 0, sixthLat = 0;
	    if (azimuth >= 90) {
	        tmpAngle = 150 / 180 * Math.PI - angle;
	        sixthLon = x + radius * Math.cos(tmpAngle);
	        if (transformInd) {
	            sixthLat = y + radius * Math.sin(tmpAngle) * Math.cos(y * Math.PI / 180);
	        } else {
	            sixthLat = y + radius * Math.sin(tmpAngle);
	        }
	    } else {
	        sixthLon = centerLon - radius * Math.cos(angle - 30 / 180 * Math.PI);
	        if (transformInd) {
	            sixthLat = centerLat + radius * Math.sin(angle - 30 / 180 * Math.PI) * Math.cos(y * Math.PI / 180);
	        } else {
	            sixthLat = centerLat + radius * Math.sin(angle - 30 / 180 * Math.PI);
	        }
	    }
	    pointsArr.push([sixthLon, sixthLat]);
	    pointsArr.push([x, y]);
	    return pointsArr;
	};
	/**
	 * 构造三角形点的集合
	 * @param transformInd
	 * @param originx
	 * @param originy
	 * @param finalRadius
	 * @param azimuth
	 * @param angleRange
	 * @returns {Array}
	 */
	var getTriangleArr = function (transformInd, originx, originy, finalRadius, azimuth, angleRange) {
	    var angleParm = angleRange * Math.PI / 180;
	    var rotatedAngle = Math.PI / 2 - (azimuth + angleRange / 2) / 180 * Math.PI;
	    var x = 0, y = 0, points = [];
	    for (var i = 0; i < 2; ++i) {
	        x = originx + finalRadius * Math.cos(rotatedAngle);
	        // 空白地图y不需要转换，有地图时不同纬度下地球切面半径不用，需要对y进行转换
	        if (transformInd) {
	            y = originy + finalRadius * Math.sin(rotatedAngle) * Math.cos(originy * Math.PI / 180);
	        } else {
	            y = originy + finalRadius * Math.sin(rotatedAngle);
	        }
	        points.push([x, y]);
	        rotatedAngle += angleParm;
	    }
	    points.push([originx, originy]);
	    return points;
	};
	/**
	 * 返回三角形的顶点坐标
	 * @param transformInd
	 * @param originx
	 * @param originy
	 * @param finalRadius
	 * @param azimuth
	 * @param angleRange
	 * @returns {{lon: number, lat: number}}
	 */
	var getTriangleVertex = function (transformInd, originx, originy, finalRadius, azimuth, angleRange) {
	    var rotatedAngle = Math.PI / 2 - azimuth / 180 * Math.PI;
	    var centerLine = Math.cos(angleRange / 2) * finalRadius;
	    var currentX = 0, currentY = 0;

	    currentX = originx + centerLine * Math.cos(rotatedAngle);
	    if (transformInd) {
	        currentY = originy + centerLine * Math.sin(rotatedAngle) * Math.sin(originy * Math.PI / 180);
	    } else {
	        currentY = originy + centerLine * Math.sin(rotatedAngle);
	    }
	    return { lon: currentX, lat: currentY };
	};
	/**
	 * 计算多段线的箭头的坐标
	 * @param lineCoords 线的两个顶点
	 * @param optArrowLen 箭头的长度 0.5 1 2 3 默认0.5
	 * @param optArrowPos 箭头在线的什么位置 默认为1（1为终点,0<x<=1）
	 * @returns {*[]}
	 */
	var getArrowCoords = function (lineCoords, optArrowLen, optArrowPos) {
	    var xStart = lineCoords[0][0];
	    var yStart = lineCoords[0][1];
	    var xEnd = lineCoords[1][0];
	    var yEnd = lineCoords[1][1];
	    var arrowLen = goog.isDefAndNotNull(optArrowLen) ? optArrowLen : 0.2;
	    var arrowPos = goog.isDefAndNotNull(optArrowPos) ? optArrowPos : 1;
	    var param = (xEnd - xStart >= 0) ? 1 : -1;
	    //箭头与线的夹角
	    var angleOffset = Math.PI / 6;
	    //箭头顶点坐标
	    var xVertex = xStart + (xEnd - xStart) * arrowPos;
	    var yVertex = yStart + (yEnd - yStart) * arrowPos;
	    //直线、上箭头、下箭头的角度
	    var angleLine = Math.atan((yEnd - yStart) / (xEnd - xStart));
	    var angleUp = angleLine + Math.PI - angleOffset;
	    var angleDown = angleLine + Math.PI + angleOffset;
	    //上箭头
	    var xUp = xVertex + param * Math.cos(angleUp) * arrowLen;
	    var yUp = yVertex + param * Math.sin(angleUp) * arrowLen;
	    //下箭头
	    var xDown = xVertex + param * Math.cos(angleDown) * arrowLen;
	    var yDown = yVertex + param * Math.sin(angleDown) * arrowLen;
	    //返回箭头的三个顶点
	    return [
	        [xUp, yUp],
	        [xVertex, yVertex],
	        [xDown, yDown]
	    ];
	};
	//通过两个坐标点计算方位角
	var calAzimuthVal = function (start, end) {
	    var deltaX = end[0] - start[0];
	    var deltaY = end[1] - start[1];
	    var azimuth = 0;
	    if (deltaX > 0 && deltaY > 0) {
	        //第一象限
	        azimuth = Math.PI / 2 - Math.atan(deltaY / deltaX);
	    } else if (deltaX > 0 && deltaY === 0) {
	        //X正轴
	        azimuth = Math.PI / 2;
	    } else if (deltaX > 0 && deltaY < 0) {
	        //第四象限
	        azimuth = Math.PI / 2 + Math.atan(Math.abs(deltaY) / deltaX);
	    } else if (deltaX === 0 && deltaY < 0) {
	        //Y负轴
	        azimuth = Math.PI;
	    } else if (deltaX < 0 && deltaY < 0) {
	        //第三象限
	        azimuth = Math.PI * 3 / 2 - Math.atan(deltaY / deltaX);
	    } else if (deltaX < 0 && deltaY === 0) {
	        //X负轴
	        azimuth = Math.PI * 3 / 2;
	    } else if (deltaX < 0 && deltaY > 0) {
	        //第四象限
	        azimuth = Math.PI * 3 / 2 + Math.atan(deltaY / Math.abs(deltaX));
	    } else if (deltaX === 0 && deltaY > 0) {
	        //Y正轴
	        azimuth = Math.PI * 2;
	    }
	    return azimuth;
	};

	/**
	 * 通过一个顶点、一个方位角、一个半径可以画出一条线段，求出这条线段终点的坐标
	 * @param origin
	 * @param radius
	 * @param azimuth
	 * @returns {*[]}
	 */
	var calEndPointCoords = function (origin, radius, azimuth) {
	    var x, y;
	    if (azimuth > 0 && azimuth < Math.PI / 2) {
	        //第一象限
	        x = origin[0] + Math.sin(azimuth) * radius;
	        y = origin[1] + Math.cos(azimuth) * radius;
	    } else if (azimuth === Math.PI / 2) {
	        //X正轴
	        x = origin[0] + radius;
	        y = origin[1];
	    } else if (azimuth > Math.PI / 2 && azimuth < Math.PI) {
	        //第四象限
	        x = origin[0] + Math.cos(azimuth - Math.PI / 2) * radius;
	        y = origin[1] - Math.sin(azimuth - Math.PI / 2) * radius;
	    } else if (azimuth === Math.PI) {
	        //Y负轴
	        x = origin[0];
	        y = origin[1] - radius;
	    } else if (azimuth > Math.PI && azimuth < Math.PI * 3 / 2) {
	        //第三象限
	        x = origin[0] - Math.cos(Math.PI * 3 / 2 - azimuth) * radius;
	        y = origin[1] - Math.sin(Math.PI * 3 / 2 - azimuth) * radius;
	    } else if (azimuth === Math.PI * 3 / 2) {
	        //X负轴
	        x = origin[0] - radius;
	        y = origin[1];
	    } else if (azimuth > Math.PI * 3 / 2 && azimuth < Math.PI * 2) {
	        //第四象限
	        x = origin[0] - Math.cos(azimuth - Math.PI * 3 / 2) * radius;
	        y = origin[1] + Math.sin(azimuth - Math.PI * 3 / 2) * radius;
	    } else if (azimuth === 0 || azimuth === Math.PI * 2) {
	        //Y正轴
	        x = origin[0];
	        y = origin[1] + radius;
	    }
	    return [x, y];
	};
	var dragBox = function (obj, container) {
	    var _obj = obj;
	    var _container = container;
	    _obj.forEach(function (objItem, index) {
	        if (typeof objItem == 'string') {
	            var obj = document.getElementById(objItem);
	            if (!obj) {
	                return;
	            }
	            var containerObj;
	            if (!_container || _container.length === 0) {
	                containerObj = document.body;
	            } else {
	                containerObj = document.getElementById(_container[index]);
	            }
	            obj.objContainer = containerObj;
	            obj.orig_index = obj.style.zIndex;
	            //设置当前对象永远显示在最上层
	        }
	        obj.onmousedown = function (a) {
	            if (!!a && (a.target.tagName === 'INPUT' || a.target.tagName === 'SELECT')) {
	                return;
	            }
	            //鼠标按下
	            this.style.cursor = 'move';
	            //设置鼠标样式
	            this.style.zIndex = 1000;
	            var d = document;
	            if (!a) a = window.event;
	            //按下时创建一个事件
	            var x = a.clientX - document.body.scrollLeft - obj.offsetLeft;
	            //x=鼠标相对于网页的x坐标-网页被卷去的宽-待移动对象的左外边距
	            var y = a.clientY - document.body.scrollTop - obj.offsetTop;
	            //y=鼠标相对于网页的y左边-网页被卷去的高-待移动对象的左上边距
	            d.onmousemove = function (a) {//鼠标移动
	                if (!a) a = window.event;//移动时创建一个事件
	                var l = a.clientX - document.body.scrollLeft - x;
	                var t = a.clientY - document.body.scrollTop - y;
	                if (l < 0) {
	                    l = 0;
	                } else if (l > obj.objContainer.offsetWidth - obj.offsetWidth) {
	                    l = obj.objContainer.offsetWidth - obj.offsetWidth
	                }
	                if (t < 0) {
	                    t = 0;
	                } else if (t > obj.objContainer.offsetHeight - obj.offsetHeight) {
	                    t = obj.objContainer.offsetHeight - obj.offsetHeight
	                }

	                obj.style.left = l + 'px';
	                obj.style.top = t + 'px';
	            }
	            d.onmouseup = function () {//鼠标放开
	                document.onmousemove = null;
	                document.onmouseup = null;
	                obj.style.cursor = '';//设置放开的样式
	                obj.style.zIndex = obj.orig_index;
	            }
	        }
	        obj.onmouseup = function () {
	            document.onmousemove = null;
	            document.onmouseup = null;
	            obj.style.cursor = '';//设置放开的样式
	            obj.style.zIndex = obj.orig_index;
	        }
	    });
	}
	/**
	 * 已知一个弧段的中心点、半径、起始方位角、结束方位角，计算弧段的坐标
	 * @param origin
	 * @param radius
	 * @param startAzimuth
	 * @param endAzimuth
	 * @returns {Array}
	 */
	var calArcCoords = function (origin, radius, startAzimuth, endAzimuth) {
	    //构成一个圆的线段数，数值越大，画的弧段越平滑
	    var sides = 720;
	    var precision = Math.PI * 2 / 720;
	    var radian = 0;
	    var coords = [];

	    //如果起始边方位角小于结束边方位角
	    if (startAzimuth < endAzimuth) {
	        for (var i = 0; i < sides; i++) {
	            radian = i * precision;
	            if (radian >= startAzimuth && radian <= endAzimuth) {
	                coords.push(webgis.GisUtil.calEndPointCoords(origin, radius, radian));
	            }
	        }
	    }

	    //如果起始边方位角大于结束边方位角
	    if (startAzimuth > endAzimuth) {
	        var startCoords = [];
	        var endCoords = [];
	        for (var j = 0; j < sides; j++) {
	            radian = j * precision;
	            if (radian >= startAzimuth && radian <= Math.PI * 2) {
	                startCoords.push(webgis.GisUtil.calEndPointCoords(origin, radius, radian));
	            }
	            if (radian >= 0 && radian <= endAzimuth) {
	                endCoords.push(webgis.GisUtil.calEndPointCoords(origin, radius, radian));
	            }
	        }
	        coords = startCoords.concat(endCoords);
	    }
	    return coords;
	};
	/**
	 * 求线段交点（内部方法）
	 * @param p1
	 * @param p2
	 * @param q1
	 * @param q2
	 * @returns {*[]}
	 * @private
	 */
	var getCrossPoint_ = function (p1, p2, q1, q2, isJudge) {
	    var x = null, y = null;
	    if (isJudge || this.IsRectCross_(p1, p2, q1, q2)) {
	        //求交点
	        var tmpLeft, tmpRight;
	        tmpLeft = (q2[0] - q1[0]) * (p1[1] - p2[1]) - (p2[0] - p1[0]) * (q1[1] - q2[1]);
	        tmpRight = (p1[1] - q1[1]) * (p2[0] - p1[0]) * (q2[0] - q1[0]) + q1[0] * (q2[1] - q1[1]) * (p2[0] - p1[0]) - p1[0] * (p2[1] - p1[1]) * (q2[0] - q1[0]);

	        x = tmpRight / tmpLeft;

	        tmpLeft = (p1[0] - p2[0]) * (q2[1] - q1[1]) - (p2[1] - p1[1]) * (q1[0] - q2[0]);
	        tmpRight = p2[1] * (p1[0] - p2[0]) * (q2[1] - q1[1]) + (q2[0] - p2[0]) * (q2[1] - q1[1]) * (p1[1] - p2[1]) - q2[1] * (q1[0] - q2[0]) * (p2[1] - p1[1]);
	        y = tmpRight / tmpLeft;
	        return [x, y];
	    }
	};
	var createInputElement = function (type, value, id) {
	    var input = document.createElement("input");
	    input.setAttribute("type", type);
	    input.setAttribute("value", value);
	    input.setAttribute("id", id);
	    return input;
	};

	/**
	 * 普通坐标和火星坐标的转换
	 * @type {{PI: number, x_pi: number, delta: delta, gcj_encrypt: gcj_encrypt, gcj_decrypt: gcj_decrypt, gcj_decrypt_exact: gcj_decrypt_exact, bd_encrypt: bd_encrypt, bd_decrypt: bd_decrypt, mercator_encrypt: mercator_encrypt, mercator_decrypt: mercator_decrypt, distance: distance, outOfChina: outOfChina, transformLat: transformLat, transformLon: transformLon}}
	 */
	var transformGPS = {
	    PI: 3.14159265358979324,
	    x_pi: 3.14159265358979324 * 3000.0 / 180.0,
	    delta: function (lat, lon) {
	        var a = 6378245.0; //  a: 卫星椭球坐标投影到平面地图坐标系的投影因子。
	        var ee = 0.00669342162296594323; //  ee: 椭球的偏心率。
	        var dLat = this.transformLat(lon - 105.0, lat - 35.0);
	        var dLon = this.transformLon(lon - 105.0, lat - 35.0);
	        var radLat = lat / 180.0 * this.PI;
	        var magic = Math.sin(radLat);
	        magic = 1 - ee * magic * magic;
	        var sqrtMagic = Math.sqrt(magic);
	        dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * this.PI);
	        dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * this.PI);
	        return { 'lat': dLat, 'lon': dLon };
	    },

	    gcj_encrypt: function (wgsLat, wgsLon) {
	        if (this.outOfChina(wgsLat, wgsLon))
	            return { 'lat': wgsLat, 'lon': wgsLon };

	        var d = this.delta(wgsLat, wgsLon);
	        return { 'lat': wgsLat + d.lat, 'lon': wgsLon + d.lon };
	    },
	    gcj_decrypt: function (gcjLat, gcjLon) {
	        if (this.outOfChina(gcjLat, gcjLon))
	            return { 'lat': gcjLat, 'lon': gcjLon };

	        var d = this.delta(gcjLat, gcjLon);
	        return { 'lat': gcjLat - d.lat, 'lon': gcjLon - d.lon };
	    },
	    gcj_decrypt_exact: function (gcjLat, gcjLon) {
	        var initDelta = 0.01;
	        var threshold = 0.000000001;
	        var dLat = initDelta, dLon = initDelta;
	        var mLat = gcjLat - dLat, mLon = gcjLon - dLon;
	        var pLat = gcjLat + dLat, pLon = gcjLon + dLon;
	        var wgsLat, wgsLon, i = 0;
	        while (1) {
	            wgsLat = (mLat + pLat) / 2;
	            wgsLon = (mLon + pLon) / 2;
	            var tmp = this.gcj_encrypt(wgsLat, wgsLon);
	            dLat = tmp.lat - gcjLat;
	            dLon = tmp.lon - gcjLon;
	            if ((Math.abs(dLat) < threshold) && (Math.abs(dLon) < threshold))
	                break;

	            if (dLat > 0) pLat = wgsLat; else mLat = wgsLat;
	            if (dLon > 0) pLon = wgsLon; else mLon = wgsLon;

	            if (++i > 10000) break;
	        }
	        return { 'lat': wgsLat, 'lon': wgsLon };
	    },
	    bd_encrypt: function (gcjLat, gcjLon) {
	        var x = gcjLon, y = gcjLat;
	        var z = Math.sqrt(x * x + y * y) + 0.00002 * Math.sin(y * this.x_pi);
	        var theta = Math.atan2(y, x) + 0.000003 * Math.cos(x * this.x_pi);
	        bdLon = z * Math.cos(theta) + 0.0065;
	        bdLat = z * Math.sin(theta) + 0.006;
	        return { 'lat': bdLat, 'lon': bdLon };
	    },
	    bd_decrypt: function (bdLat, bdLon) {
	        var x = bdLon - 0.0065, y = bdLat - 0.006;
	        var z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * this.x_pi);
	        var theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * this.x_pi);
	        var gcjLon = z * Math.cos(theta);
	        var gcjLat = z * Math.sin(theta);
	        return { 'lat': gcjLat, 'lon': gcjLon };
	    },
	    mercator_encrypt: function (wgsLat, wgsLon) {
	        var x = wgsLon * 20037508.34 / 180.;
	        var y = Math.log(Math.tan((90. + wgsLat) * this.PI / 360.)) / (this.PI / 180.);
	        y = y * 20037508.34 / 180.;
	        return { 'lat': y, 'lon': x };
	    },
	    mercator_decrypt: function (mercatorLat, mercatorLon) {
	        var x = mercatorLon / 20037508.34 * 180.;
	        var y = mercatorLat / 20037508.34 * 180.;
	        y = 180 / this.PI * (2 * Math.atan(Math.exp(y * this.PI / 180.)) - this.PI / 2);
	        return { 'lat': y, 'lon': x };
	    },
	    distance: function (latA, lonA, latB, lonB) {
	        var earthR = 6371000.;
	        var x = Math.cos(latA * this.PI / 180.) * Math.cos(latB * this.PI / 180.) * Math.cos((lonA - lonB) * this.PI / 180);
	        var y = Math.sin(latA * this.PI / 180.) * Math.sin(latB * this.PI / 180.);
	        var s = x + y;
	        if (s > 1) s = 1;
	        if (s < -1) s = -1;
	        var alpha = Math.acos(s);
	        var distance = alpha * earthR;
	        return distance;
	    },
	    outOfChina: function (lat, lon) {
	        if (lon < 72.004 || lon > 137.8347)
	            return true;
	        if (lat < 0.8293 || lat > 55.8271)
	            return true;
	        return false;
	    },
	    transformLat: function (x, y) {
	        var ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));
	        ret += (20.0 * Math.sin(6.0 * x * this.PI) + 20.0 * Math.sin(2.0 * x * this.PI)) * 2.0 / 3.0;
	        ret += (20.0 * Math.sin(y * this.PI) + 40.0 * Math.sin(y / 3.0 * this.PI)) * 2.0 / 3.0;
	        ret += (160.0 * Math.sin(y / 12.0 * this.PI) + 320 * Math.sin(y * this.PI / 30.0)) * 2.0 / 3.0;
	        return ret;
	    },
	    transformLon: function (x, y) {
	        var ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));
	        ret += (20.0 * Math.sin(6.0 * x * this.PI) + 20.0 * Math.sin(2.0 * x * this.PI)) * 2.0 / 3.0;
	        ret += (20.0 * Math.sin(x * this.PI) + 40.0 * Math.sin(x / 3.0 * this.PI)) * 2.0 / 3.0;
	        ret += (150.0 * Math.sin(x / 12.0 * this.PI) + 300.0 * Math.sin(x / 30.0 * this.PI)) * 2.0 / 3.0;
	        return ret;
	    }
	};

	var sessionStorageObj = function () {
	    if (typeof (Storage) !== "undefined") {
	        this.sessionStorage = sessionStorage;
	    } else {
	        console.warn('抱歉！您的浏览器不支持 Web Storage ...');
	    }
	};

	sessionStorageObj.prototype.set = function (key, val) {
	    this.sessionStorage.setItem(key, val);
	}

	sessionStorageObj.prototype.get = function (key) {
	    return this.sessionStorage.getItem(key);
	}


	var _arrayDimension = function (arry, n) {
	    if (!(arry instanceof Array)) {
	        return n;
	    }
	    return _arrayDimension(arry[0], n + 1);
	}
	//判断数组维数
	var arrayDimensionCheck = function (array) {
	    if (array instanceof Array) {
	        return _arrayDimension(array[0], 1);
	    }
	    return false;
	}
	var getCurTolerance = function (mapObj, layerObj) {
	    var _view = mapObj.getView();
	    var currentZoom = _view.getZoom();
	    var targetTolerance = {};
	    (function () {
	        var arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]; tempArr = constant.Tolerance.POINT;
	        if (!!layerObj && layerObj.get('businessType') === constant.BUSINESSTYPE.SERVICEPOINT) {
	            tempArr = constant.Tolerance.POINT;
	        } else if (!!layerObj && layerObj.get('businessType') === constant.BUSINESSTYPE.SERVICELINE) {
	            tempArr = constant.Tolerance.LINE;
	        }
	        arr.forEach(function (item, index) {
	            targetTolerance[item] = tempArr[index];
	        });
	    })();
	    if (!!targetTolerance[currentZoom]) {
	        return targetTolerance[currentZoom]
	    } else {
	        return 2;
	    }
	}
	var gcjTransform = function (point) {
	    var tempPoint = point;
	    if (window.sessionStorage && sessionStorage.getItem('mapType') === constant.MAPTYPE.GAODE_MAP) {
	        tempPoint = transformGPS.gcj_encrypt(tempPoint[1], tempPoint[0]);
	        tempPoint = [tempPoint.lon, tempPoint.lat]
	    }
	    return tempPoint;
	}
	//反偏移
	var gcj_decTransform = function(point) {
		var tempPoint = point;
		if(window.sessionStorage && sessionStorage.getItem('mapType') === constant.MAPTYPE.GAODE_MAP) {
			tempPoint = transformGPS.gcj_decrypt(tempPoint[1], tempPoint[0]);
			tempPoint = [tempPoint.lon, tempPoint.lat]
		}
		return tempPoint;

	};
	/*
	* 3857-GCJ-3857
	*/
	var gcjTransform3857 = function (point) {
	    var tempPoint = ol.proj.toLonLat(point);
	    if (window.sessionStorage && sessionStorage.getItem('mapType') === constant.MAPTYPE.GAODE_MAP) {
	        tempPoint = transformGPS.gcj_decrypt_exact(tempPoint[1], tempPoint[0]);
	        tempPoint = [tempPoint.lon, tempPoint.lat]
	    }
	    return ol.proj.fromLonLat(tempPoint);
	}
	var multigcjTransform = function (pointArr,is3857) {
	    var tempPointArr = pointArr;
	    if (window.sessionStorage && sessionStorage.getItem('mapType') === constant.MAPTYPE.GAODE_MAP) {
	        if(is3857) {
	        	tempPointArr = tempPointArr.map(function (tempPoint) {
	        		tempPoint = ol.proj.toLonLat(tempPoint);
		            tempPoint = transformGPS.gcj_encrypt(tempPoint[1], tempPoint[0]);
		            tempPoint = [tempPoint.lon, tempPoint.lat];
		            return ol.proj.fromLonLat(tempPoint);
		        });
	        }else {
		        tempPointArr = tempPointArr.map(function (tempPoint) {
		            tempPoint = transformGPS.gcj_encrypt(tempPoint[1], tempPoint[0]);
		            tempPoint = [tempPoint.lon, tempPoint.lat];
		            return tempPoint;
		        });
	        }
	    }
	    return tempPointArr;
	}
	var transformMultArray = function (arr) {
	    if (window.sessionStorage && sessionStorage.getItem('mapType') === constant.MAPTYPE.GAODE_MAP) {
	        if (arr === null) {
	            return null;
	        } else if (arr instanceof Array) {
	            var o = [];
	            if (!(arr[0] instanceof Array)) {
	                var tempPoint = transformGPS.gcj_encrypt(arr[1], arr[0]);
	                return [tempPoint.lon, tempPoint.lat];
	            }
	            for (var i in arr) {
	                if (arr.hasOwnProperty(i)) {
	                    o[i] = transformMultArray(arr[i]);
	                }
	            }
	            return o;
	        } else {
	            return arr;
	        }
	    } else {
	        return arr
	    }
	}
	var transformMultArrayFrom3857 = function (arr) {
	    if (window.sessionStorage && sessionStorage.getItem('mapType') === constant.MAPTYPE.GAODE_MAP) {
	        if (arr === null) {
	            return null;
	        } else if (arr instanceof Array) {
	            var o = [];
	            if (!(arr[0] instanceof Array)) {
	            	var points = ol.proj.toLonLat(arr);
	                var tempPoint = transformGPS.gcj_encrypt(points[1], points[0]);
	                var _3857Coords =ol.proj.fromLonLat([tempPoint.lon, tempPoint.lat]);
	                return _3857Coords;
	            }
	            for (var i in arr) {
	                if (arr.hasOwnProperty(i)) {
	                    o[i] = transformMultArrayFrom3857(arr[i]);
	                }
	            }
	            return o;
	        } else {
	            return arr;
	        }
	    } else {
	        return arr
	    }
	}
	/**
	 * 用于适配自定义地图时，layer data中coordinate转换成国测局规定的坐标系
	 */
	var changeCoordinateForGcj = function (data, mapType) {
	    var _data = extend({},data);
	    //高德地图时，需要将普通4326坐标转换成火星坐标系
	    if(mapType === constant.MAPTYPE.GAODE_MAP) {
	            var changeCoordinate = function (obj) {
	                var tempObj = {}, coordinate;
	                for (var p in obj) {
	                    tempObj[p] = obj[p];
	                    if (p.indexOf('coordinate') !== -1) {
	                        coordinate = obj[p];
	                        //如果是coordinate属性，则转换 其他属性直接返回
	                        if (coordinate && coordinate instanceof Array && coordinate.length > 0) {
	                            coordinate = transformMultArray(coordinate);
	                        }
	                        tempObj[p] = coordinate;
	                    }
	                }
	                return tempObj;
	            };
	            if(_data && _data instanceof Array) {
	                _data = _data.map(changeCoordinate);
	            }
	            else {
	                _data = changeCoordinate(_data);
	            }
	    }
	    return _data;
	};





	module.exports = {
	    getBrowserType: getBrowserType,
	    isValid: isValid,
	    getUUID: getUUID,
	    cloneObj: cloneObj,
	    mergeObj: mergeObj,
	    mixin: mixin,
	    isInArray: isInArray,
	    getIndexInArray: getIndexInArray,
	    getDom: getDom,
	    isPropertyInObj: isPropertyInObj,
	    extentTimes: extentTimes,
	    isArray: _isArray,
	    isFinite: _isFinite,
	    isObject: _isObject,
	    find: _find,
	    getParameterString: getParameterString,
	    sortBy: sortBy,
	    sortedIndex: sortedIndex,
	    flatten: flatten,
	    extend: extend,
	    compact: compact,
	    last: last,
	    groupBy: groupBy,
	    sortGroupBy: sortGroupBy,
	    sortAsc: sortAsc,
	    sortDesc: sortDes,
	    toArray: toArray,
	    endsWith: endsWith,
	    unique: unique,
	    htmlDecode: htmlDecode,
	    objectDecode: objectDecode,
	    getWKTFromText: getWKTFromText,
	    isPolygonIntersect: isPolygonIntersect,//判断多边形是否相交
	    isPolygonAInPolygonB: isPolygonAInPolygonB,
	    multi: multi,
	    isIntersection: isIntersection,
	    lineIntersects: lineIntersects,
	    polygonIntersectCount: polygonIntersectCount,
	    calcDistanceBetweenLonLat: calcDistanceBetweenLonLat,
	    isInsidePolygon: isInsidePolygon,
	    isPointInLine: isPointInLine,
	    curvePoint: curvePoint,
	    bezierCurve: bezierCurve,
	    curveLineArr: curveLineArr,
	    isPolygonAInPolygonB: isPolygonAInPolygonB,
	    getAngleQuadrant: getAngleQuadrant,
	    createXMLHttpRequest: createXMLHttpRequest,
	    strToBase64: strToBase64,
	    uint6ToB64: uint6ToB64,
	    getPointQuadrant: getPointQuadrant,
	    parsePointStrToLocationArray: parsePointStrToLocationArray,
	    modifyAngle: modifyAngle,
	    getSectorArr: getSectorArr,
	    getCurve: getCurve,
	    brokenLine: brokenLine,
	    getSectorVertex: getSectorVertex,
	    getRhombusArr: getRhombusArr,
	    getRhombusVertex: getRhombusVertex,
	    getHexagonArr: getHexagonArr,
	    getTriangleArr: getTriangleArr,
	    getTriangleVertex: getTriangleVertex,
	    getArrowCoords: getArrowCoords,
	    calAzimuthVal: calAzimuthVal,
	    calEndPointCoords: calEndPointCoords,
	    calArcCoords: calArcCoords,
	    getCrossPoint_: getCrossPoint_,
	    createInputElement: createInputElement,
	    translateVertexToWKT: translateVertexToWKT,
	    transformGPS: transformGPS,
	    dragBox: dragBox,
	    sessionStorageObj: sessionStorageObj,
	    arrayDimensionCheck: arrayDimensionCheck,
	    getCurTolerance: getCurTolerance,
	    gcjTransform: gcjTransform,
	    gcj_decTransform:gcj_decTransform,
	    gcjTransform3857:gcjTransform3857,
	    multigcjTransform: multigcjTransform,
	    transformMultArray: transformMultArray,
	    transformMultArrayFrom3857:transformMultArrayFrom3857,
	    changeCoordinateForGcj: changeCoordinateForGcj
	};

/***/ },
/* 2 */
/*!***************************************!*\
  !*** ./src/gis/framework/constant.js ***!
  \***************************************/
/***/ function(module, exports) {

	var MapType = {
	    OSM_MAP: 'OSM_MAP',
	    HUAWEI_MAP: 'HUAWEI_MAP',
	    BING_MAP: 'BING_MAP',
	    GOOGLE_MAP: 'GOOGLE_MAP',
	    WMS_MAP: 'WMS_MAP',
	    ARCGISTILE_LAYER: 'ARCGISTILE_LAYER',
	    NAVER_MAP: 'NAVER_MAP',
	    TIANDI_MAP: 'TIANDI_MAP',
	    BAIDU_MAP: 'BAIDU_MAP',
	    GOOGLE_ROAD_MAP: 'GOOGLE_ROAD_MAP',
	    GAODE_MAP: 'GAODE_MAP',
	    YAHOO_MAP: 'YAHOO_MAP',
	    OFFLINE_MAP: 'OFFLINE_MAP'
	};

	var Proj = {
	    EPSG_4326: 'EPSG:4326',
	    EPSG_3857: 'EPSG:3857'
	};

	var ControlType = {
	    SCALELINE: 'scaleLine',
	    MOUSEPOSITION: 'mousePosition',
	    ZOOMCONTENT: 'zoomContent',
	    OVERVIEWMAP: 'overviewMap'
	};

	var MapProperty = {
	    DEFAULT_PROJECTION: 'EPSG:3857',
	    DEFAULT_UNITS: 'metric',
	    DEFAULT_ZOOM: 10,
	    DEFAULT_MIN_ZOOM: 0,
	    DEFAULT_MAX_ZOOM: 17,
	    DEFAULT_CENTER: [116.38229370117188, 39.90868283513285],
	    BASE_LAYER_ID: 'base_layer'
	};

	var LastClickFeature = 'lastClickFeature';

	var BusinessType = {
	    BUBBLE: 'BUBBLE',
	    BUBBLE_CIRCLE: 'BUBBLE_CIRCLE',
	    BUBBLE_CIRCLE_LABEL: 'BUBBLE_CIRCLE_LABEL',
	    POINTER_CLUSTER: 'POINTER_CLUSTER',
	    TRACK_SHOW: 'TRACK_SHOW',
	    TRACK_SHOW_LINE: 'TRACK_SHOW_LINE',
	    ICON: 'ICON',///异常事件 | 网元
	    ICONWITH2LABEL: 'ICONWITH2LABEL',///异常事件 | 网元
	    ICON2LABEL: 'ICON2LABEL',///异常事件 | 网元
	    VECTOR_CELL: 'VECTOR_CELL', ///矢量小区
	    LEGEND: 'LEGEND', ///单点指标
	    LEGEND_RANGE: 'LEGEND_RANGE', ///值域指标
	    LEGEND_SLIDER: 'LEGEND_SLIDER', ///组合指标
	    ADMIN_REGION: 'ADMIN_REGION', //行政区域
	    CELLSITE: 'CELLSITE', //工参
	    CELL: 'CELL', //小区
	    GRID: 'GRID',//栅格
	    CIRCLEPOINT: 'CIRCLEPOINT',//离散点
	    MARKPOINT: 'MARKPOINT',//marker点
	    LINE: 'LINE',//连线
	    POLYGON: 'POLYGON',//多边形,
	    DPOLYGON: 'DPOLYGON',//适配disCovery的系统polygon在UI设计器中的编排
	    SITE: 'SITE',
	    POINT: 'POINT',
	    SERVICEPOLYGON: 'SERVICEPOLYGON',
	    SERVICEPOINT: 'SERVICEPOINT',
	    SERVICELINE: 'SERVICELINE',
	    HEAT_MAP: 'HEAT_MAP',
	    STRAIGHTLINE: 'STRAIGHTLINE',
	    BEZIERLINE: 'BEZIERLINE',
	    ICON_FONT_STYLE: 'ICON_FONT_STYLE',
	    BUBBLE_CIRCLE_LABEL: 'BUBBLE_CIRCLE_LABEL',
	    DLINE: 'DLINE',
	    DPOINT: 'DPOINT',
	    DCELL: 'DCELL',
	    MULTIPOINT: 'MULTIPOINT'
	};

	var CustomType = {
	    MAPTYPE: 'ol.Map',
	    LAYERTYPE: 'ol.layer.Vector',
	    LAYERTILETYPE: 'ol.layer.Tile',
	    LAYERIMGTYPE: 'ol.layer.Image',
	    LAYERHEATTYPE: 'ol.layer.Heatmap',
	    SOURCETYPE: 'ol.source.Vector'
	};

	var I18n = {
	    EN: 'en',
	    ZH: 'zh',
	    ES: 'es'
	};

	var LayerType = {
	    POINT: 'POINT',
	    LINE: 'LINE',
	    POLYGON: 'POLYGON'
	};

	var SearchEngine = {
	    OSM: 'OSM',
	    GOOGLE: 'GOOGLE'
	};

	//图层垂直高度
	var Z_Index = {
	    BASELAYER: 0,
	    GRID: 100,
	    POLYGON: 300,
	    CELL: 400,
	    SITE: 450,
	    RADAR: 500,
	    TEMPPOLYGON: 600,
	    LINE: 800,
	    LANDMARKER: 850,
	    ROUTEPOINT: 900,
	    MARKER: 1000,
	    ROADMAIN_1:530,
	    ROADMAIN_2:520,
	    ROADMAIN_3:510,
	    INFOPOP:1999,
	    VECTORLINE:2000
	};

	var GisRootUrl = '/fusiongisaccess';

	var Url = {
	    IMGTOKENURL: GisRootUrl + '/gridManager/getImgToken',
	    EXPORTURL: GisRootUrl + '/gridManager/export',
	    GET_GRIDINFO: GisRootUrl + '/gridManager/getGridInfo',
	    QUERY_GRIDINFO: GisRootUrl + '/gridManager/queryGridInfo',
	    MAPRENDER_EXPORT: GisRootUrl + '/mapRender/export'
	};

	//GIS支持自定义图层按照名称搜索，并将查询结果在地图上显示；
	var CustomQuery = {
	    GET_FEATURE_INFO: GisRootUrl + '/custommap/v1/getfeatureinfo',
	    GET_LAYER_INFO: GisRootUrl + '/custommap/v1/getlayerinfo',//自定义图层
	    GET_ATTR_INFO: GisRootUrl + '/customMap.do', //图层上的属性
	    GET_COMMON_LAYER_INFO: GisRootUrl + '/resource/v1/getspatialdatalist',
	    GET_ATTR_IN_COMMON_LAYER: GisRootUrl + '/spatialdata/v1/queryFieldsInfo',
	    GET_FEATURE_IN_COMMON_LAYER: GisRootUrl + '/spatialdata/v1/Query'
	};
	//多边形查询
	var PolygonQuery = {
	    GET_THIESSEN_POLYGONLAYER_INFO: GisRootUrl + '/spatialdata/v1/Query'
	};

	var HighlightType = {
	    CLICK: 'click',
	    SINGLE: 'single',
	    MULlTI: 'multi',
	    VECTOR: 'vector',
	    SERVICE: 'service'
	};

	var LayerGroup = {
	    NE: ['CELL', 'SITE']
	};

	var Joiner = {
	    UNDERLINE: '_',
	    SHORT_TERM: '-'
	};

	var DefaultLayerVisibleLevel = {
	    CELL: 0,
	    SITE: 0,
	    POLYGON: 0,
	    GRID: 0,
	    HEAT_MAP: 0
	};

	var GoogleMapTypes = {
	    HYBRID: 'hybrid',
	    ROADMAP: 'roadmap',
	    SATELLITE: 'satellite',
	    TERRAIN: 'terrain'
	};

	var BingMapTypes = {
	    ROAD: 'Road',
	    AERIAL: 'Aerial',
	    AERIALWITHLABELS: 'AerialWithLabels',
	    BIRDSEYE: 'Birdseye',
	    BIRDSEYEWITHLABELS: 'BirdseyeWithLabels',
	    COLLINSBART: 'CollinsBart',
	    ORDNANCESURVEY: 'OrdnanceSurvey'
	};

	//处理浏览器兼容性，如果不处理：fixfox19版本下会报错
	window.requestAnimationFrame =
	    window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
	window.cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame;
	//点线面容差
	var Tolerance = {
	    POINT: [15000, 8000, 3000, 2000, 1000, 600, 300, 150, 70, 40, 20, 15, 10, 8, 4, 2, 1, 0.6],
	    LINE: [15000, 8000, 3000, 2000, 1000, 600, 300, 150, 70, 40, 18, 10, 4, 2, 1, 0.5, 0.3, 0.2]
	};
	module.exports = {
	    MAPTYPE: MapType,
	    PROJ: Proj,
	    CONTROL_TYPE: ControlType,
	    MAPPROPERTY: MapProperty,
	    LAST_CLICK_FEATURE: LastClickFeature,
	    BUSINESSTYPE: BusinessType,
	    CUSTOMTYPE: CustomType,
	    I18N: I18n,
	    LAYERTYPE: LayerType,
	    Search_Engine: SearchEngine,
	    Z_INDEX: Z_Index,
	    URL: Url,
	    HTYPE: HighlightType,
	    GisRootUrl: GisRootUrl,
	    layerGroup: LayerGroup,
	    Joiner: Joiner,
	    DefaultLayerVisibleLevel: DefaultLayerVisibleLevel,
	    CustomQuery: CustomQuery,
	    PolygonQuery: PolygonQuery,

	    GoogleMapTypes: GoogleMapTypes,
	    BingMapTypes: BingMapTypes,
	    GisResourceURL: (function () {
	        var htmlDecode = function (text) {
	            var temp = document.createElement('div');
	            temp.innerHTML = text;
	            var output = temp.innerText || temp.textContent;
	            temp = null;
	            return output;
	        };

	        var js = document.scripts;
	        js = js[js.length - 1].src.substring(0, js[js.length - 1].src.lastIndexOf("/") + 1);
	        return htmlDecode(js + 'resources/imgs/');
	    }()),
	    GlobalVariable: {},
	    Tolerance: Tolerance
	};

/***/ },
/* 3 */
/*!**********************************!*\
  !*** ./src/gis/layers/legend.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var maps = __webpack_require__(/*! maps/map */ 8);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var domUtil = __webpack_require__(/*! utils/domUtil */ 10);

	var _globalSource = null;
	var _globalFeatures = [];

	var addFeature = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId;
	    var _layer = null;

	    if (hashMap.containsKey(_layerId)) {
	        _layer = hashMap.get(_layerId);
	    }
	    else {
	        baseLayer.createLayer(paramObj);
	        _layer = hashMap.get(_layerId);
	    }
	    _globalSource = _layer.getSource();

	    setLayerData(paramObj);
	};

	var setLayerData = function (paramObj) {
	    var _features = [];
	    var _datas = paramObj.datas;
	    var _currentExtent = maps.getExtent(paramObj.mapId);

	    if (utils.isValid(_datas) || _datas.length > 0) {
	        _datas.forEach(function (data) {
	            var _coordinate = ol.proj.fromLonLat(utils.gcjTransform(data.coordinate));

	//          if (!ol.extent.containsCoordinate(_currentExtent, _coordinate)) {
	//              return;
	//          }

	            var _point = new ol.geom.Point(_coordinate);
	            var _feature = new ol.Feature({
	                geometry: _point,
	                businessType: constant.BUSINESSTYPE.LEGEND,
	                data: data
	            });
	            _feature.setId(data.id);
	            _feature.set('legendVal', data.legendVal);

	            var _style = new ol.style.Style({
	                image: new ol.style.Circle({
	                    radius: data.radius ? data.radius : 5,
	                    fill: new ol.style.Fill({
	                        color: data.fillColor ? data.fillColor : 'red'
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color: data.strokeColor ? data.strokeColor : '#319FD3',
	                        width: data.strokeWidth ? data.strokeWidth : 1
	                    })
	                })
	            });
	            _feature.setStyle(_style);
	            _feature.set('foreverStyle', _style);
	            _feature.set('radius', data.radius ? data.radius : 5);
	            _feature.set('strokeWidth', data.strokeWidth ? data.strokeWidth : 1);

	            _features.push(_feature);

	        });
	        _globalSource.addFeatures(_features);
	        _globalFeatures = _features;
	    }

	    createLegend(paramObj);
	};

	/**
	 * 构造图例
	 * @param paramObj
	 *
	 * paramObj = [{
	             *   color: ##
	             *   text: ##
	             *   val: ##
	             * }]
	 */
	var createLegend = function (paramObj) {
	    var _legendData = paramObj.legendData;
	    var _mapId = paramObj.mapId;
	    var util = domUtil;

	    ///图例顶层box
	    var _legendBox = null;
	    var _legendContainer = util.getDom(_mapId).getElementsByClassName('layer_legend_container_for_one_map');
	    if (_legendContainer && _legendContainer.length > 0) {
	        _legendBox = _legendContainer[0];
	    }
	    else {
	        _legendBox = util.createDom({
	            tagName: 'div',
	            attributes: {
	                class: 'layer_legend_container_for_one_map'
	            }
	        });
	        util.getDom(_mapId).appendChild(_legendBox);
	    }

	    ///create one legend box
	    var _oneLegendBox = util.createDom({
	        tagName: 'div',
	        attributes: {
	            class: 'one_legend_box_one_layer'
	        }
	    });

	    if (!document.querySelector('.layer_legend_container_for_one_map').hasChildNodes('measure-close-legend')) {
	        var _closeButton = util.createDom({
	            tagName: 'div',
	            attributes: {
	                id: 'closeEvent',
	                class: 'measure-close-legend'
	            }
	        });
	        _legendBox.insertBefore(_closeButton, _legendBox.childNodes[0]);
	        //为_closeButton注册关闭事件
	        _closeButton.onclick = function () {
	            _legendBox.style.display = 'none';
	            util.getDom(_mapId).removeChild(_legendBox);
	        };
	    }
	    if (_legendBox.querySelector('.one_legend_box_one_layer')) {
	        _legendBox.removeChild(_legendBox.querySelector('.one_legend_box_one_layer'));
	    }
	    _legendBox.appendChild(_oneLegendBox);

	    _legendData.forEach(function (legend) {
	        var _oneLegendLine = util.createDom({
	            tagName: 'div',
	            attributes: {
	                class: 'one_legend_line'
	            }
	        });
	        _oneLegendLine.style.cursor = 'pointer';
	        _oneLegendLine.id = legend.val;
	        _oneLegendBox.appendChild(_oneLegendLine);

	        _oneLegendLine.onclick = function () {
	            var _legend = _oneLegendLine.getAttribute('id');
	            _globalFeatures.forEach(function (feature) {
	                if (feature.get('legendVal') === parseFloat(_legend)) {
	                    if (feature.get('opacity') === 0) {
	                        feature.set('opacity', 1);
	                        feature.setStyle(feature.get('foreverStyle'));

	                        _oneLegendLine.style.borderLeftWidth = 0 + 'px';

	                        _oneLegendLine.childNodes[0].style.backgroundColor = _oneLegendLine.childNodes[0].id;
	                    }
	                    else {
	                        feature.set('opacity', 0);

	                        var _style = new ol.style.Style({
	                            image: new ol.style.Circle({
	                                radius: feature.get('radius'),
	                                fill: new ol.style.Fill({
	                                    color: 'gray'
	                                }),
	                                stroke: new ol.style.Stroke({
	                                    color: 'gray',
	                                    width: feature.get('strokeWidth')
	                                })
	                            })
	                        });
	                        feature.setStyle(_style);

	                        _oneLegendLine.style.borderLeftWidth = 2 + 'px';
	                        _oneLegendLine.style.borderLeftStyle = 'solid';
	                        _oneLegendLine.style.borderLeftColor = '#00BFFF';

	                        _oneLegendLine.childNodes[0].style.backgroundColor = 'gray';
	                    }
	                }
	            });
	        };

	        var _colorNode = util.createDom({
	            tagName: 'div'
	        });
	        _colorNode.style.width = 8 + 'px';
	        _colorNode.style.height = 8 + 'px';
	        _colorNode.style.marginTop = 9 + 'px';
	        _colorNode.style.marginLeft = 10 + 'px';
	        _colorNode.style.marginRight = 10 + 'px';
	        _colorNode.style.backgroundColor = legend.color;
	        _colorNode.style.borderRadius = 100 + 'px';
	        _colorNode.style.webkitBorderRadius = 100 + 'px';
	        _colorNode.style.mozBorderRadius = 100 + 'px';
	        _colorNode.id = legend.color;
	        _oneLegendLine.appendChild(_colorNode);

	        var _titleNode = util.createDom({
	            tagName: 'div'
	        });
	        _titleNode.innerHTML = legend.title ? legend.title : legend.text;
	        _oneLegendLine.appendChild(_titleNode);
	    });
	};

	module.exports = {
	    addFeature: addFeature,
	    setLayerData: setLayerData
	};

/***/ },
/* 4 */
/*!*********************!*\
  !*** external "ol" ***!
  \*********************/
/***/ function(module, exports) {

	module.exports = ol;

/***/ },
/* 5 */
/*!**************************************!*\
  !*** ./src/gis/framework/hashmap.js ***!
  \**************************************/
/***/ function(module, exports) {

	var _keys = new Array();
	var _vals = new Array();

	// 添加指定KEY的元素到Map,如果存在则修改
	var put = function (_key, _value) {
	    var bln = false;
	    var idx = this.getIndex(_key);
	    if (idx == -1) {
	        _keys.push(_key);
	        _vals.push(_value);
	        bln = true;
	    }
	    else {
	        _vals[idx] = _value;
	    }
	    return bln;
	};

	/**
	 *
	 * @param _key
	 * @returns {boolean}
	 */
	var remove = function (_key) {
	    var bln = false;
	    try {
	        for (var i = 0; i < _keys.length; i++) {
	            if (_keys[i] == _key) {
	                _keys.splice(i, 1);
	                _vals.splice(i, 1);
	                break;
	            }
	        }
	        bln = true;
	    }
	    catch (e) {
	        bln = false;
	    }
	    return bln;
	};

	/**
	 * 判断MAP中指定KEY的元素索引,没有返回-1
	 * @param _key
	 * @returns {number}
	 */
	var getIndex = function (_key) {
	    var result = -1;
	    try {
	        for (var i = 0; i < _keys.length; i++) {
	            if (_keys[i] == _key) {
	                result = i;
	                break;
	            }
	        }
	    }
	    catch (e) {
	        result = -1;
	    }
	    return result;
	};

	// 判断MAP中是否含有指定KEY的元素
	var containsKey = function (_key) {
	    var bln = false;
	    try {
	        for (var i = 0; i < _keys.length; i++) {
	            if (_keys[i] == _key) {
	                bln = true;
	            }
	        }
	    }
	    catch (e) {
	        bln = false;
	    }
	    return bln;
	};

	/**
	 *  获取指定KEY的元素值VALUE，失败返回NULL
	 * @param _key
	 * @returns {*}
	 */
	var get = function (_key) {
	    try {
	        for (var i = 0; i < _keys.length; i++) {
	            if (_keys[i] == _key) {
	                return _vals[i];
	            }
	        }
	    }
	    catch (e) {
	        return null;
	    }
	};
	// 获取Map的size
	var size = function () {
	    return _keys.length;
	};
	// 判断Map是否为空
	var isEmpty = function () {
	    return (_keys.length == 0);
	};

	// 删除所有的元素，成功返回True，失败返回False
	var clear = function () {
	    var bln = true;
	    try {
	        _keys = [];
	        _vals = [];
	    }
	    catch (e) {
	        bln = false;
	    }
	    return bln;
	};

	module.exports = {
	    put: put,
	    remove: remove,
	    getIndex: getIndex,
	    containsKey: containsKey,
	    clear: clear,
	    get: get,
	    size: size,
	    isEmpty: isEmpty,
	    keys: _keys,
	    vals: _vals
	};

/***/ },
/* 6 */
/*!*************************************!*\
  !*** ./src/gis/layers/baseLayer.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var maps = __webpack_require__(/*! maps/map */ 8);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var event = __webpack_require__(/*! maps/event */ 11);

	//存放闪烁效果
	var _flickerMap = new Map();

	var _defaultStyle = {
	    'Point': [
	        new ol.style.Style({
	            image: new ol.style.Circle({
	                fill: new ol.style.Fill({
	                    color: '#319FD3'
	                }),
	                radius: 5,
	                stroke: new ol.style.Stroke({
	                    color: '#ff0',
	                    width: 1
	                })
	            })
	        })
	    ],
	    'Circle': [
	        new ol.style.Style({
	            fill: new ol.style.Fill({
	                color: '#319FD3'
	            }),
	            stroke: new ol.style.Stroke({
	                color: '#ff0',
	                width: 1
	            })
	        })
	    ],
	    'Polygon': [
	        new ol.style.Style({
	            fill: new ol.style.Fill({
	                color: '#319FD3'
	            }),
	            stroke: new ol.style.Stroke({
	                color: '#ff0',
	                width: 1
	            })
	        })
	    ],
	    'LineString': [
	        new ol.style.Style({
	            stroke: new ol.style.Stroke({
	                color: '#2C89E8',
	                width: 3
	            })
	        })
	    ],
	    'MultiPolygon': [
	        new ol.style.Style({
	            stroke: new ol.style.Stroke({
	                color: '#2C89E8',
	                width: 3
	            })
	        })
	    ]
	};

	var _styleFunction = function (feature, resolution) {
	    var featureStyleFunction = feature.getStyleFunction();
	    if (featureStyleFunction) {
	        return featureStyleFunction.call(feature, resolution);
	    }
	    else {
	        return _defaultStyle[feature.getGeometry().getType()];
	    }
	};

	var _clusterLayerStyle = function (pro) {
	    var strokeColor = pro.strokeColor;
	    var fillColor = pro.fillColor;
	    var strokeWidth = pro.strokeWidth;
	    return [
	        new ol.style.Style({
	            image: new ol.style.Circle({
	                radius: pro.radius,
	                fill: new ol.style.Fill({
	                    color: fillColor
	                }),
	                stroke: new ol.style.Stroke({
	                    color: strokeColor,
	                    width: strokeWidth
	                })
	            }),
	            text: new ol.style.Text({
	                text: pro.label,
	                fill: new ol.style.Fill({
	                    color: 'white'
	                })
	            })
	        })
	    ];
	};

	var _clusterStyleFunc = function (feature, resolution) {
	    var _features = feature.get('features');
	    var _size = _features.length;
	    var pro = {};
	    if (_size > 1) {
	        pro.radius = 10 * _size * 0.4;
	        pro.label = _size.toString();
	        pro.strokeColor = 'white';
	        pro.strokeWidht = 1 * _size * 0.4;
	        pro.fillColor = 'rgba(250,139,46, 0.9)';
	    }
	    else {
	        pro = _features[0].get('property');

	    }
	    return _clusterLayerStyle(pro);
	};

	var _clusterStyleFunc_noResize = function (feature, resolution) {
	    var _features = feature.get('features');
	    var _size = _features.length;
	    var pro = {};
	    if (_size > 1) {
	        pro.radius = 15;
	        pro.label = _size.toString();
	        pro.strokeColor = 'white';
	        pro.strokeWidht = 1 * _size * 0.4;
	        pro.fillColor = 'rgba(250,139,46, 0.9)';
	    }
	    else {
	        pro = _features[0].get('property');

	    }
	    return _clusterLayerStyle(pro);
	};

	/**
	 * 创建图层
	 * @param paramObj
	 * @private
	 */
	var createLayer = function (paramObj) {
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId + '_' + _mapId;
	    var _isCluster = paramObj.isCluster;
	    var _mapObj = mapBox.getMapObj(_mapId);
	    var isShow = paramObj.isShow != undefined ? paramObj.isShow : true;
	    var _label = paramObj.label?paramObj.label:paramObj.layerId;
	    if (!utils.isValid(hashMap.get(_layerId))) {
	        var _layer = null;
	        if (_isCluster) {
	            var _cluster = new ol.source.Cluster({
	                distance: paramObj.distance ? paramObj.distance : 20,
	                source: new ol.source.Vector({
	                    wrapX: false
	                }),
	                wrapX:false
	            });

	            /// isCLusterVariableSize 用来判断，汇聚后点的半径是否会随地图缩放改变
	            if (paramObj.isClusterVariableSize) {
	                _layer = new ol.layer.Vector({
	                    source: _cluster,
	                    style: _clusterStyleFunc
	                });
	            }
	            else {
	                _layer = new ol.layer.Vector({
	                    source: _cluster,
	                    style: _clusterStyleFunc_noResize
	                });
	            }

	        }
	        else {
	            _layer = new ol.layer.Vector({
	                source: new ol.source.Vector({
	                    wrapX: false
	                }),
	                style: _styleFunction
	            });
	        }

	        ///自定义属性，方便后面通过类型判断对象
	        _layer.set('type', constant.CUSTOMTYPE.LAYERTYPE);
	        _layer.set('map', _mapObj);
	        _layer.set('layerId', _layerId);
	        _layer.set('params.label', _label);
	        _layer.set('layer_id', paramObj.layerId);
	        _layer.set('isShow', isShow);
	        _mapObj.addLayer(_layer);

	        // 图层管理使用，所有的图层使用都从这里入口
	        hashMap.put(_layerId, _layer);
	    }

	};

	/**
	 * 删除图层
	 * @param paramObj
	 * @private
	 */
	var removeLayer = function (paramObj) {
	    var _mapId = paramObj.mapId;
	    var _olMap = mapBox.getMapObj(_mapId);
	    var _layerIds = paramObj.layerIds;
	    if (!!_olMap && !!_layerIds && _layerIds.length > 0) {
	        for (var i=0; i < _layerIds.length; i++) {
	            var _layerId = _layerIds[i] + '_' + _mapId;
	            var _layer = hashMap.get(_layerId);

	            if (!!_layer) {
	                //remove legend for layer
	                if (!!_layer.get('mineLegendID')) {
	                    var _legendId = _layer.get('mineLegendID');
	                    var _targetNode = _olMap.getTargetElement().querySelector('.' + _legendId);
	                    if (_targetNode && _targetNode.parentNode) {
	                        _targetNode.parentNode.removeChild(_targetNode);
	                    }
	                }

	                if (_layer.get('isCustomMap')) {
	                    maps.destroyCustomMap(_mapId);
	                }
	                
	                //remove the event was bind on layer
	                var _clickId = _layer.get('clickId');
	                if (_clickId != undefined) {
	                	event.removeClickCallback(_mapId, _clickId);
	                }
	                
	                var _UIclickId = _layer.get('UIclickId');
	                if (_UIclickId != undefined) {
	                	event.removeClickCallback(_mapId, _UIclickId);
	                }
	                
	                
	                layers.removeEffectLayer({
	                    mapId: _mapId,
	                    layer: _layer
	                });
	                _olMap.removeLayer(_layer);
	                hashMap.remove(_layerId);
	            }
	        }
	    }
	};

	/**
	 * 设置图层是否可见
	 * @param paramObj
	 * @private
	 */
	var setVisible = function (paramObj) {//paramObj
		var _olMap = mapBox.getMapObj(paramObj.mapId);
		var _ui = _olMap.get('paramObj').UI;
		if (!_olMap) {
			return;
		}
	    var _layerIds = paramObj.layerIds;
	    if (utils.isValid(_layerIds) && _layerIds.length > 0) {

	        _layerIds.forEach(function (layerId) {
	            var _layer = hashMap.get(layerId + '_' + paramObj.mapId);
	            if (utils.isValid(_layer)) {
	                
	                if (_ui == true) {
	                	_layer.set('ui_isShow', paramObj.isShow);
	                }
	                else if (_ui == 'discovery') {
	                	_layer.setVisible(paramObj.isShow);
	                	layers.setEffectLayerVisible(_layer, paramObj.isShow);
	                	_layer.set('discovery', paramObj.isShow);
	                }
	                else {
	                	_layer.setVisible(paramObj.isShow);
	                	layers.setEffectLayerVisible(_layer, paramObj.isShow);
	                }
	            }
	        });
	    }
	};

	/**
	 *  设置图层垂直高度
	 * @param paramObj
	 */
	var setLayerZIndex = function (paramObj) {
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId;
	    var _zIndex = paramObj.zIndex;

	    var _layerObj = layers.getLayer({
	        mapId: _mapId,
	        layerId: _layerId
	    });

	    _layerObj.setZIndex(_zIndex);
	};

	var getLayerZIndex = function (paramObj) {
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId;

	    var _layerObj = layers.getLayer({
	        mapId: _mapId,
	        layerId: _layerId
	    });

	    return !!_layerObj && _layerObj.getZIndex();
	};

	/**
	 * 判断layerId的图层是否存在
	 * @param paramObj
	 * paramObj = {
	 *  mapId: ##
	 *  layerId: ###
	 *
	 * }
	 */
	var isLayerExist = function (paramObj) {
	    var mapId = paramObj.mapId;
	    var layerId = paramObj.layerId;
	    var isTrue = false;

	    var mapObj = mapBox.getMapObj(mapId);
	    var layers = mapObj.getLayers();

	    layers.forEach(function (layer, index, layers) {
	        if (layer.get('layerId') === layerId) {
	            isTrue = true;
	        }
	    });

	    return isTrue;

	};

	/**
	 * 删除指定图层上的元素
	 * @param paramObj
	 *  paramObj = {
	 *     mapId: ##
	 *     layerId: ##
	 *     featureId: ##
	 * }
	 * @returns {*|ol.Feature}
	 */
	var removeFeatureById = function (paramObj) {
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId + '_' + _mapId;
	    var _featureId = paramObj.featureId;

	    var _layerSource = hashMap.get(_layerId).getSource();
	    var _feature = _layerSource.getFeatureById(_featureId);
	    if (!!_feature) {
	        _layerSource.removeFeature(_feature);
	    }
	};

	/**
	 * 获取图层上指定ID的元素
	 * @param paramObj
	 * paramObj = {
	 *     mapId: ##
	 *     layerId: ##
	 *     featureId: ##
	 *
	 * }
	 * @returns {*|ol.Feature}
	 */
	var getFeatureById = function (paramObj) {
	    var _layerId = paramObj.layerId + constant.Joiner.UNDERLINE + paramObj.mapId;
	    return paramObj.featureId &&
	        hashMap.get(_layerId).getSource().getFeatureById(paramObj.featureId);
	};

	/**
	 * 给图层注册单击事件
	 * @param paramObj
	 * paramObj = {
	 *  mapId: ##
	 *  layerId: ##
	 *  callback: ##
	 * }
	 */
	var registerClick = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId;
	    var _clickCallback = paramObj.callbackfunc;
	    var _layerObj = _layerId && hashMap.get(_layerId);

	    if (_layerObj && _clickCallback) {
	    	_layerObj.set('UIclickId', 'event_from_user_custom_' + _layerId);
	        event.addClickCallback(paramObj.mapId, 'event_from_user_custom_' + _layerId, _clickCallback, paramObj.layerId);
	    }

	};

	/**
	 * 给图层注册缩放事件
	 * @param paramObj
	 * paramObj = {
	 *  mapId: ##
	 *  layerId: ##
	 *  callback: ##
	 * }
	 */
	var registerZoom = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId;
	    var _zoomCallback = paramObj.callbackfunc;
	    var _layerObj = _layerId && hashMap.get(_layerId);

	    if (_layerObj && _zoomCallback) {
	        _layerObj.zoomCallback = _zoomCallback;
	    }
	};

	/**
	 * 给图层注册鼠标悬浮事件
	 * @param paramObj
	 */
	var registerMouseHover = function (paramObj) {
	    var _layerIdentify = paramObj.layerId + constant.Joiner.UNDERLINE + paramObj.mapId;
	    var _layer = hashMap.get(_layerIdentify);
	    if (paramObj.hasOwnProperty('callbackfunc')
	        && _layer) {
	        _layer.mouseoverCallback = paramObj.callbackfunc;
	    }
	};

	/**
	 * 给地图注册右键菜单
	 * @param paramObj
	 */
	var registerRightClick = function (paramObj) {
	    var _layerIdentify = paramObj.layerId + constant.Joiner.UNDERLINE + paramObj.mapId;
	    var _layer = hashMap.get(_layerIdentify);
	    if (paramObj.hasOwnProperty('callbackfunc')
	        && _layer) {
	        _layer.rightClickCallback = paramObj.callbackfunc;
	    }
	};

	/**
	 * 高亮元素
	 * @param paramObj
	 * paramObj = {
	 *  mapId: ##
	 *  layerId: ''
	 *  featureId: ##
	 * }
	 */
	var highLight = function (paramObj) {
	    var _lastClkFeature = constant.LAST_CLICK_FEATURE;
	    if (undefined === hashMap.get(_lastClkFeature)) {
	        hashMap.put(_lastClkFeature, []);
	    }
	    var _feature = getFeatureById(paramObj);
	    _feature && _feature.getStyle() && hashMap.get(_lastClkFeature).push({
	        'feature': _feature,
	        'style': _feature.getStyle()
	    });

	    var _cellClcStyle = new ol.style.Style({
	        fill: new ol.style.Fill({
	            color: paramObj.fillColor || 'red'
	        }),
	        stroke: new ol.style.Stroke({
	            color: paramObj.strokeColor || 'yellow',
	            width: 2
	        })
	    });
	    _feature.setStyle(_cellClcStyle);
	};

	/**
	 * 设置元素透明度。
	 * @param paramObj
	 * paramObj  = {
	 *      mapId: String 地图唯一标识
	 *      layerId: String 图层唯一标识
	 *      geomId: String 元素唯一标识
	 *      opacity: number透明度 values range from 0 to 1
	 * }
	 */
	var setGeometryOpacity = function (paramObj) {
	    var layerId = paramObj.layerId + '_' + paramObj.mapId;
	    var featureId = paramObj.featureId;
	    var opacity = paramObj.opacity;

	    var feature = hashMap.get(layerId).getSource().getFeatureById(featureId);
	    var oldStyle = feature.getStyle();
	    var oldColorString = oldStyle.getFill().a;///"rgba(166, 206, 227, .7)"
	    var oldColorArray = oldColorString.split(',');///["rgba(166", "206", "227", " .7)"]
	    oldColorArray.pop();
	    oldColorArray.push(opacity);
	    var newColorString = oldColorArray.toLocaleString() + ')';

	    var style = new ol.style.Style({
	        fill: new ol.style.Fill({
	            color: newColorString
	        })
	    });
	    feature.setStyle(style);
	};

	/**
	 * 设置图层透明度
	 * @param params
	 */
	function setLayerOpacity(params) {
	    if (!params.layerId || !params.mapId) {
	        return;
	    }
	    var layer = layers.getLayer(params);
	    layer.setOpacity(params.opacity);
	    layers.setEffectLayerOpacity(layer, params.opacity);
	}

	/**
	 * 给图层注册刷新数据事件
	 * @param paramObj
	 */
	var registerMove = function (paramObj) {
	    var _layerObj = hashMap.get(paramObj.layerId + '_' + paramObj.mapId);
	    if (!!_layerObj) {
	        _layerObj.refreshDataCallback = paramObj.refreshDataCallback;
	    }
	};

	/**
	 * 获取当前地图上的所有图层
	 * @param mapId
	 * @returns {Array}
	 */
	var getLayers = function (mapId) {
	    var _subffix = '_' + mapId;
	    var _targetLayers = [];
	    hashMap.keys.forEach(function (layerId) {
	        if (layerId && utils.endsWith(layerId, _subffix)) {
	            _targetLayers.push(hashMap.get(layerId));
	        }
	    });
	    return _targetLayers;
	};

	/**
	 * 清除图层上的图层
	 * @param mapId
	 *
	 * notes: openlayers's collection 提供的forEach方法有问题，在删除图层是，循环没有执行完成就退出循环体，需要自己重写for处理
	 */
	var clearLayers = function (mapId) {
	    var _mapObj = mapBox.getMapObj(mapId);
	    var _layers = _mapObj.getLayers();
	    var _arrays = _layers.getArray();
	    for (var len = _arrays.length, i = len - 1; i >= 0; i--) {
	        var _layer = _arrays[i];
	        if (!!_layer) {
	            _mapObj.removeLayer(_layer);
	        }

	        //从地图上删除图层同时，将图层管理器里面的图层也要删除
	        hashMap.remove(_layer.get('layerId'));
	    }
	};

	var _filterFeatureStyle = function (feature, style) {
	    var _geometryType = feature.getGeometry().getType();
	    var _starStyle = null;
	    var _nowStyle = null;
	    var _endStyle = null;

	    switch (_geometryType) {
	        case 'Point':
	            if (style && style.star) {
	                _starStyle = new ol.style.Style({
	                    image: new ol.style.Circle({
	                        fill: new ol.style.Fill({
	                            color: style.starFillColor
	                        }),
	                        radius: style.radius,
	                        stroke: new ol.style.Stroke({
	                            color: style.starStrokeColor,
	                            width: style.width
	                        })
	                    })
	                });
	            }

	            if (style && style.now) {
	                _nowStyle = new ol.style.Style({
	                    image: new ol.style.Circle({
	                        fill: new ol.style.Fill({
	                            color: style.nowFillColor
	                        }),
	                        radius: style.radius,
	                        stroke: new ol.style.Stroke({
	                            color: style.nowStrokeColor,
	                            width: style.width
	                        })
	                    })
	                });
	            }

	            if (style && style.end) {
	                _endStyle = new ol.style.Style({
	                    image: new ol.style.Circle({
	                        fill: new ol.style.Fill({
	                            color: style.endFillColor
	                        }),
	                        radius: style.radius,
	                        stroke: new ol.style.Stroke({
	                            color: style.endStrokeColor,
	                            width: style.width
	                        })
	                    })
	                });
	            }
	            break;

	        case 'Polygon':
	            if (style && style.star) {
	                _starStyle = new ol.style.Style({
	                    fill: new ol.style.Fill({
	                        color: style.starFillColor
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color: style.starStrokeColor,
	                        width: style.width
	                    })
	                });
	            }

	            if (style && style.now) {
	                _nowStyle = new ol.style.Style({
	                    fill: new ol.style.Fill({
	                        color: style.nowFillColor
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color: style.nowStrokeColor,
	                        width: style.width
	                    })
	                });
	            }

	            if (style && style.end) {
	                _endStyle = new ol.style.Style({
	                    fill: new ol.style.Fill({
	                        color: style.endFillColor
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color: style.endStrokeColor,
	                        width: style.width
	                    })
	                });
	            }
	            break;

	        case 'LineString':
	            if (style && style.star) {
	                _starStyle = new ol.style.Style({
	                    fill: new ol.style.Fill({
	                        color: style.starFillColor
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color: style.starStrokeColor,
	                        width: style.width
	                    })
	                });
	            }

	            if (style && style.now) {
	                _nowStyle = new ol.style.Style({
	                    fill: new ol.style.Fill({
	                        color: style.nowFillColor
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color: style.nowStrokeColor,
	                        width: style.width
	                    })
	                });
	            }

	            if (style && style.end) {
	                _endStyle = new ol.style.Style({
	                    fill: new ol.style.Fill({
	                        color: style.endFillColor
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color: style.endStrokeColor,
	                        width: style.width
	                    })
	                });
	            }
	            break;

	        default:
	            break;
	    }

	    return {
	        starStyle: _starStyle,
	        nowStyle: _nowStyle,
	        endStyle: _endStyle
	    }
	};

	/**
	 *  给指定元素添加闪烁效果。
	 * @param paramObj
	 */
	var flickerFeature = function (paramObj) {
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId;

	    var _targetFeature = getFeatureById({
	        mapId: _mapId,
	        layerId: _layerId,
	        featureId: paramObj.featureId
	    });

	    if (_targetFeature) {
	        var _timestamp = paramObj.timestamp || 800;
	        var _radius = _targetFeature.get('data').radius;
	        var _starFillColor = paramObj.starFillColor || 'blue';
	        var _nowFillColor = paramObj.nowFillColor || 'red';
	        var _endFillColor = paramObj.endFillColor || 'yellow';

	        var _starStrokeColor = paramObj.starStrokeColor || 'red';
	        var _nowStrokeColor = paramObj.nowStrokeColor || 'blue';
	        var _endStrokeColor = paramObj.endStrokeColor || 'green';

	        var _flickerKey = 'flickerFeature_' + _layerId + constant.Joiner.UNDERLINE + _mapId;
	        var _unFlickerKey = 'feature_' + _layerId + constant.Joiner.UNDERLINE + _mapId;

	        if (!_flickerMap.has(_flickerKey)) {
	            _flickerMap.set(_flickerKey, []);
	        }

	        if (!_flickerMap.has(_unFlickerKey)) {
	            _flickerMap.set(_unFlickerKey, new Map());
	        }

	        var _interval = setInterval(function () {

	            var _starStyle = _filterFeatureStyle(
	                _targetFeature,
	                {
	                    starFillColor: _starFillColor,
	                    starStrokeColor: _starStrokeColor,
	                    radius: _radius,
	                    width: 2,
	                    star: 'star'
	                }
	            ).starStyle;

	            var _nowStyle = _filterFeatureStyle(
	                _targetFeature,
	                {
	                    nowFillColor: _nowFillColor,
	                    nowStrokeColor: _nowStrokeColor,
	                    radius: _radius,
	                    width: 2,
	                    now: 'now'
	                }
	            ).nowStyle;

	            var _endStyle = _filterFeatureStyle(
	                _targetFeature,
	                {
	                    endFillColor: _endFillColor,
	                    endStrokeColor: _endStrokeColor,
	                    radius: _radius,
	                    width: 2,
	                    end: 'end'
	                }
	            ).endStyle;

	            var _mineStyle = 'customStyle';
	            var _customStyle = _targetFeature.get(_mineStyle);
	            if (_customStyle === _endFillColor) {
	                _targetFeature.setStyle(_nowStyle);
	                _targetFeature.set(_mineStyle, _nowFillColor);
	            }
	            else if (_customStyle === _nowFillColor) {
	                _targetFeature.setStyle(_starStyle);
	                _targetFeature.set(_mineStyle, _starFillColor);
	            }
	            else {
	                _targetFeature.setStyle(_endStyle);
	                _targetFeature.set(_mineStyle, _endFillColor);
	            }

	        }, _timestamp);

	        _flickerMap.get(_flickerKey).push(_interval);
	        _flickerMap.get(_unFlickerKey).set(_interval, _targetFeature);

	        return _interval;
	    }
	};

	/**
	 * 清除元素闪烁效果。
	 */
	var clearFeatureFlicker = function (paramObj) {
	    var _layerId = paramObj.layerId;
	    var _mapId = paramObj.mapId;
	    var _flickerKey = 'flickerFeature_' + _layerId + '_' + _mapId;
	    var _unFlickerKey = 'feature_' + _layerId + '_' + _mapId;

	    //恢复元素默认样式
	    var _restoreFeature = function (interval) {
	        var _feature = _flickerMap.get(_unFlickerKey).get(interval);
	        var _defaultStyle = _feature.get('defaultStyle');

	        _feature.setStyle(_defaultStyle);
	    };

	    if (!!_flickerMap.get(_flickerKey).length) {

	        if (paramObj.intervals && paramObj.intervals.length > 0) {
	            _flickerMap.get(_flickerKey).forEach(function (interval) {
	                paramObj.intervals.forEach(function (_interval) {
	                    if (_interval === interval) {
	                        clearInterval(interval);

	                        _restoreFeature(interval);
	                    }
	                });
	            });
	        }
	        else {

	            _flickerMap.get(_flickerKey).forEach(function (interval) {
	                clearInterval(interval);

	                _restoreFeature(interval);
	            });
	        }
	    }
	};

	function removeGeometry(params) {
	    var layer = layers.getLayer(params);
	    if (!layer) {
	        return;
	    }
	    var f = layer.getSource().getFeatureById(params.geoId);
	    if (!f) {
	        return;
	    }
	    if (!!layer.getSource()) {
	        layer.getSource().removeFeature(f);
	    }
	    var highlightLayer = olUtil.getLayer({
	        mapId: params.mapId,
	        layerId: params.layerId + '&&&highlight'
	    });

	    if (!highlightLayer) {
	        return;
	    }

	    if (!!highlightLayer.getSource()) {
	        var highlightFeature = highlightLayer.getSource().getFeatureById(params.geoId);
	        if (!!highlightFeature) {
	            highlightLayer.getSource().removeFeature(highlightFeature);
	        }
	    }

	}

	/**
	 * 获取地图图层信息
	 * @param params
	 * {
	 *      mapId  :{string} 地图Id,
	 *      isBusiness：{boolean} 是否是业务图层
	 * }
	 * @returns {*}
	 */
	function getLayersInfo(params) {
	    var mapobj = mapBox.getMapObj(params.mapId);
	    if (mapobj) {
	        return;
	    }
	    var mapLayers = getLayers(params);
	    var olLayers;
	    if (params.isBusiness) {
	        olLayers = mapLayers.filter(function (l) {
	            return l.get('businessType');
	        });
	    }
	    else {
	        olLayers = mapLayers;
	    }
	    return olLayers.map(function (l) {
	        return {
	            layerId: l.get('layerId'),
	            visible: l.getVisible(),
	            zIndex: l.getZIndex(),
	            dataType: l.get('dataType'),
	            layerType: l.get('businessType'),
	            layerData: l.get('layerData')
	        };
	    });
	}
	/**
	 * 鼠标在线上的移入移出事件
	 * @param params
	 * {
	 *      mapId  :{string} 地图Id,
	 * }
	 */
	function registerMouseEvent(params, callbackFunc) {
	    var mapObj = mapBox.getMapObj(params.mapId);
	    if (!!!mapObj) {
	        return;
	    }
	    if (!!mapObj.get('pointermoveKey')) {
	        mapObj.unByKey(mapObj.get('pointermoveKey'));
	    }
	    var pointermoveKey = mapObj.on('pointermove', function (evt) {
	        var pixel = mapObj.getEventPixel(evt.originalEvent);
	        var _hasFeatureAtPixel = mapObj.hasFeatureAtPixel(pixel);
	        var feature = mapObj.forEachFeatureAtPixel(evt.pixel, function (feature) {
	            if (_hasFeatureAtPixel) {
	                return feature
	            }
	        });

	        if (!!feature) {
	            if (!!callbackFunc && typeof callbackFunc === 'function') {
	                callbackFunc(feature)
	            }
	        }
	        else {
	            if (!!callbackFunc && typeof callbackFunc === 'function') {
	                callbackFunc(null)
	            }
	        }
	    });
	    mapObj.set('pointermoveKey', pointermoveKey);
	}

	function registerLayerChange(paramObj) {
	    if (!!paramObj.mapId) {
	        var _mapObj = mapBox.getMapObj(paramObj.mapId);
	        if (!!_mapObj) {
	            _mapObj.getLayers().on('change:length', function (event) {
	                if (!!paramObj.lengthChangeCallback && typeof paramObj.lengthChangeCallback === 'function') {
	                    paramObj.lengthChangeCallback({
	                        layerCount: event.target.getLength(),
	                        layerIds: (function () {
	                            var layerIds = [];
	                            if (!!event.target.getArray() && event.target.getArray().length > 0) {
	                                event.target.getArray().forEach(function (layer) {
	                                    layerIds.push(layer.get('layer_id') ? layer.get('layer_id') : undefined);

	                                    if (!!layer) {
	                                        layer.on('change:visible', function() {
	                                            if (!!paramObj.visibleChangeCallback && typeof paramObj.visibleChangeCallback == 'function') {
	                                                paramObj.visibleChangeCallback(layer.get('layer_id') ? layer.get('layer_id') : undefined);
	                                            }
	                                        });


	                                        layer.on('change:opacity', function() {
	                                            if (!!paramObj.opacityChangeCallback && typeof paramObj.opacityChangeCallback == 'function') {
	                                                paramObj.opacityChangeCallback(layer.get('layer_id') ? layer.get('layer_id') : undefined);
	                                            }
	                                        });
	                                    }
	                                });
	                            }
	                            return layerIds;
	                        }())
	                    });
	                }
	            });

	        }
	    }
	}

	var clear = function (olLayer) {
	    if (!!olLayer) {
	        if (!!olLayer.getSource()) {
	            olLayer.getSource().clear();
	        }
	    }
	};

	var setLayerVisibleLevel = function(paramObj) {
		var mapId = paramObj.mapId;
		var layerId = paramObj.layerId;
		var minShowLevel = paramObj.minShowLevel;
		var maxShowLevel = paramObj.maxShowLevel;
		var layer = layers.getLayer(paramObj);
		if (layer != undefined) {
			if (minShowLevel != undefined) {
		        layer.set('minShowLevel', parseInt(minShowLevel));
		    }
		
		    if (maxShowLevel != undefined) {
		        layer.set('maxShowLevel', parseInt(maxShowLevel));    
		    }
		}
		
	}

	module.exports = {
	    //图层
	    createLayer: createLayer,
	    removeLayer: removeLayer,
	    getLayer: layers.getLayer,
	    setVisible: setVisible,
	    setLayerOpacity: setLayerOpacity,
	    setLayerZIndex: setLayerZIndex,
	    getLayerZIndex: getLayerZIndex,
	    isLayerExist: isLayerExist,
	    getLayers: getLayers,
	    getLayersInfo: getLayersInfo,
	    clearLayers: clearLayers,
	    removeGeometry: removeGeometry,
	    setLayerVisibleLevel: setLayerVisibleLevel,

	    //元素
	    removeFeatureById: removeFeatureById,
	    clearFeatureOnLayer: clear,
	    clearFeatureFlicker: clearFeatureFlicker,
	    getFeatureById: getFeatureById,
	    setGeometryOpacity: setGeometryOpacity,
	    highLight: highLight,
	    flickerFeature: flickerFeature,

	    //事件
	    registerClick: registerClick,
	    registerMove: registerMove,
	    registerZoom: registerZoom,
	    registerMouseHover: registerMouseHover,
	    registerRightClick: registerRightClick,
	    registerMouseEvent: registerMouseEvent,
	    registerLayerChange: registerLayerChange
	};


/***/ },
/* 7 */
/*!********************************!*\
  !*** ./src/gis/maps/mapBox.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var ol = __webpack_require__(/*! ol */ 4);

	/**
	 * @param mapId {String}
	 * @returns {*}
	 */
	var getMapObj = function (mapId) {
	    var _olMap = hashMap.get(mapId);
	    if (!!_olMap && _olMap instanceof ol.Map) {
	        return _olMap;
	    }
	    else {
	        return undefined;
	    }
	};

	/**
	 *
	 * @param _target
	 * @param isTransform
	 * @returns {ol.Extent}
	 */
	var getExtent = function (_target, isTransform) {
	    var _mapObj = hashMap.get(_target);
	    var _currentExtent = _mapObj.getView().calculateExtent(_mapObj.getSize());
	    if (!isTransform) {
	        return _currentExtent;
	    }
	    else {
	        return ol.proj.transformExtent(_currentExtent, constant.PROJ.EPSG_3857, constant.PROJ.EPSG_4326);
	    }
	};

	module.exports = {
	    getMapObj: getMapObj,
	    getExtent: getExtent
	};

/***/ },
/* 8 */
/*!*****************************!*\
  !*** ./src/gis/maps/map.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);

	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var popup = __webpack_require__(/*! framework/popup */ 9);

	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var event = __webpack_require__(/*! maps/event */ 11);
	var Control = __webpack_require__(/*! maps/control */ 19);
	var multiMap = __webpack_require__(/*! maps/multimap */ 20);
	var views = __webpack_require__(/*! maps/views */ 22);
	var mapType = __webpack_require__(/*! maps/maptype */ 23);

	var googleMap = __webpack_require__(/*! maps/googleMap */ 24);
	var gaodeMap = __webpack_require__(/*! maps/gaode */ 26);
	var osmMap = __webpack_require__(/*! maps/osmMap */ 27);
	var bingMap = __webpack_require__(/*! maps/bingMap */ 28);
	var vMap = __webpack_require__(/*! maps/vMap */ 29);
	var wmsMap = __webpack_require__(/*! maps/wmsMap */ 30);
	var naverMap = __webpack_require__(/*! maps/naverMap */ 31);
	var tiandiMap = __webpack_require__(/*! maps/tiandiMap */ 32);
	var bDuMap = __webpack_require__(/*! maps/bDu */ 33);
	var xyzGoogleRoad = __webpack_require__(/*! maps/xyzGoogleRoad */ 34);
	var yahooMapLayer = __webpack_require__(/*! maps/yahoo */ 35);
	var arcgisTileLayer =__webpack_require__(/*! layers/arcgisTileLayer */ 36);
	var overMap = __webpack_require__(/*! maps/overMap */ 37);

	var bLayerManager = __webpack_require__(/*! layers/bLayerManager */ 39);

	var domUtil = __webpack_require__(/*! utils/domUtil */ 10);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var ajax = __webpack_require__(/*! utils/ajax */ 14);

	//鼠标悬浮事件
	var mouseHover = __webpack_require__(/*! utils/mouseHover */ 63);


	var lastMouseOverFeature = new Map();

	var _queryMapType = function (paramObj) {
	    var _mapType = constant.MAPTYPE.OSM_MAP;
	        var result = {"data":
	                    {"saveMapType":null,
					     "mapFormat":20,
					     "mapService":"&#x2F;gisserver&#x2F;rest&#x2F;maps&#x2F;germany&#x2F;ows",
					     "centerPoint":{"zoom":8,"longitude":47.975811,"latitude":29.288874},
					     "mapLayer":"admin1,boundary2,boundary3,road10,road11,road20,road22,road31,trunk,place2",
					     "mapName":"kuwait_map",
					     "tileStatus":null,
					     "mapType":1,"dataName":null
	                    },
	                  "status":{"code":1,"message":""}
	        };
	        
	        
	        if (!!result) {
	                var _result = result;
	                if (!!_result && _result.status.code === 1 && !!_result.data) {
	                    var _data = _result.data;
	                    var format_ = _data.mapFormat;
	                    var _key = utils.htmlDecode(_data && _data.mapService);
	                    var _url = utils.htmlDecode(_data && _data.mapService);
	                    var _layers = _data && _data.mapLayer;
	                    var _mapName = utils.htmlDecode(_data && _data.mapName);
	                    var _isMapCutting = false;
	                    if (format_ === 3 || format_ === 4
	                        || format_ === 5 || format_ === 9 || format_ === 20) {
	                        _mapType = constant.MAPTYPE.WMS_MAP;
	                        if(!!_data.tileStatus&&_data.tileStatus===1){
	                            _isMapCutting =true ;
	                        }
	                    } else if (_data.mapFormat === 101) {
	                        _mapType = constant.MAPTYPE.OSM_MAP;
	                    } else if (_data.mapFormat === 102) {
	                        _mapType = constant.MAPTYPE.GOOGLE_MAP;
	                    } else if (_data.mapFormat === 103) {
	                        _mapType = constant.MAPTYPE.BING_MAP;
	                    } else if (_data.mapFormat === 105) {
	                        _mapType = constant.MAPTYPE.HUAWEI_MAP;
	                    }else if(_data.mapFormat === 106){
	                        _mapType = constant.MAPTYPE.TIANDI_MAP;
	                    }else if(_data.mapFormat === 107){//Wmts map
	                    	_mapType = constant.MAPTYPE.ARCGISTILE_LAYER;

	                    } else if(_data.mapFormat === 108){
	                        _mapType = constant.MAPTYPE.GAODE_MAP;
	                    }else {
	                        _mapType = constant.MAPTYPE.OSM_MAP;
	                    }

	                    if (_data.mapFormat === 20) {
	                        //自定义地图导入使用
	                        //_url = 'http://localhost:1335/{z}/{x}/{y}.png?MAPNAME=' + _mapName + '&LAYERS=' + _layers;
							_url = 'http://localhost:1335/{z}/{x}/{y}.png';
	                        /*if(_isMapCutting){
	                            _url = '/fusiongisaccess/offlineMap/service/tms/1.0.0/'+_data.mapName+'/@900913/{z}/{x}/{-y}.png?mapName='+_data.mapName;
	                        }*/
	                    } else if (_data.mapFormat === 3) {
	                        //planetServer使用
	                        _url = fusiongis.Constant.GisRootUrl + '/offlineMap/planetServer';
	                        _mapName = undefined;
	                    } else if (_data.mapFormat === 4) {
	                        //shapeServer使用
	                        _url = fusiongis.Constant.GisRootUrl + '/offlineMap/shapeServer';
	                        _mapName = undefined;
	                    } else if (_data.mapFormat === 5) {
	                        //高铁使用
	                        _url = fusiongis.Constant.GisRootUrl + '/offlineMap/RailwayServer';
	                        _mapName = undefined;
	                    } else if (_data.mapFormat === 9) {
	                        //DC融合使用
	                        _url = fusiongis.Constant.GisRootUrl + '/offlineMap/customMap?MAPNAME=' + _mapName + '&LAYERS=' + _layers;
	                    }

	                    var _defaultZoom = paramObj.defaultZoom;
	                    if (_data != undefined) {
	                    	if (_data.centerPoint != undefined) {
	                    		if (_data.centerPoint.zoom != undefined) {
	                    			_defaultZoom = _data.centerPoint.zoom;
	                    		}
	                    		else {
	                    			_defaultZoom = undefined;
	                    		}
	                    	}
	                    }

	                    _createMap({
	                        mapId: paramObj.mapId,
	                        layerId: paramObj.layerId,
	                        center: _data != undefined ? (_data.centerPoint != undefined ? [_data.centerPoint.longitude, _data.centerPoint.latitude] : paramObj.center) : undefined,
	                        defaultZoom: _defaultZoom,
	                        minZoom:paramObj.minZoom,
	                        maxZoom:paramObj.maxZoom,
	                        mapType: _mapType,
	                        url: paramObj.url != undefined ? paramObj.url : 'http://localhost:1335/{z}/{x}/{y}.png',
	                        key: paramObj.key != undefined ? paramObj.key : _key,
	                        layers: paramObj.layers != undefined ? paramObj.layers : _layers,
	                        mapName: paramObj.mapName != undefined ? paramObj.mapName : (!!_mapName ? _mapName : undefined),
	                        version: !!paramObj.version ? paramObj.version : '1.1.1',
	                        language: !!paramObj.language ? paramObj.language : 'zh-CH',
	                        linkage: !!paramObj.linkage ? paramObj.linkage : false,
	                        controls: !!paramObj.controls ? paramObj.controls : undefined,
	                        controlStyles: !!paramObj.controlStyles ? paramObj.controlStyles : undefined,
	                        initCallback: !!paramObj.initCallback ? paramObj.initCallback : undefined,
	                        rightClickCallback: !!paramObj.rightClickCallback ? paramObj.rightClickCallback : undefined,
	                        isMapCutting: _isMapCutting,
	                        productType: paramObj.productType
	                    });
	                }
	                else {

	                	 var _defaultZoom = paramObj.defaultZoom;
	                    if (_result.data != undefined) {
	                    	var _data = _result.data;
	                    	if (_data.centerPoint != undefined) {
	                    		if (_data.centerPoint.zoom != undefined) {
	                    			_defaultZoom = _data.centerPoint.zoom;
	                    		}
	                    		else {
	                    			_defaultZoom = undefined;
	                    		}
	                    	}


	                    	_createMap({
		                        mapId: paramObj.mapId,
		                        layerId: paramObj.layerId,
		                        center: _data != undefined ? (_data.centerPoint != undefined ? [_data.centerPoint.longitude, _data.centerPoint.latitude] : paramObj.center) : undefined,
		                        defaultZoom: _defaultZoom,
		                        minZoom:paramObj.minZoom,
	                            maxZoom:paramObj.maxZoom,
		                        mapType: paramObj.mapType ? paramObj.mapType : constant.MAPTYPE.OSM_MAP,
		                        url: paramObj.url ? paramObj.url : undefined,
		                        key: paramObj.key ? paramObj.key : undefined,
		                        layers: paramObj.layers ? paramObj.layers : [],
		                        mapName: paramObj.mapName != undefined ? paramObj.mapName : (!!_mapName ? _mapName : undefined),
		                        version: !!paramObj.version ? paramObj.version : '1.1.1',
		                        language: !!paramObj.language ? paramObj.language : 'zh-CH',
		                        linkage: !!paramObj.linkage ? paramObj.linkage : false,
		                        controls: !!paramObj.controls ? paramObj.controls : undefined,
		                        controlStyles: !!paramObj.controlStyles ? paramObj.controlStyles : undefined,
		                        initCallback: !!paramObj.initCallback ? paramObj.initCallback : undefined,
		                        rightClickCallback: !!paramObj.rightClickCallback ? paramObj.rightClickCallback : undefined,
		                        productType: paramObj.productType
		                    });
	                    }

	                }

	            }
	};

	var getOffLineMapUrls = function (callback) {
	    ajax.postJSON({
	        url: fusiongis.Constant.GisRootUrl + '/mapCfgView.do',
	        data: JSON.stringify({
	            subject: {
	                param: {},
	                formatter: {
	                    date: ''
	                }
	            },
	            services: [
	                { name: 'mapSourceList', param: {}}
	            ]
	        }),
	        success: function (result) {
	            if (!!result) {
	                var _result = JSON.parse(result);
	                var mapInfoList = [];
	                var _mapType = null;
	                if (!!_result && _result.status.code === 1 && !!_result.data) {
	                    var _mapSourceList = _result.data.mapSourceList;
	                    for (var i = 0; i < _mapSourceList.length; i++) {
	                        var data__ = _mapSourceList[i];
	                        var format_ = data__.mapFormat;
	                        var _key = utils.htmlDecode(data__ && data__.mapService);
	                        var _url = utils.htmlDecode(data__ && data__.mapService);
	                        var _layers = data__ && data__.mapLayer;
	                        var _mapName = utils.htmlDecode(data__ && data__.mapName);
	                        if (format_ === 3 || format_ === 4 || format_ === 5 || format_ === 9 || format_ === 20) {
	                            _mapType = constant.MAPTYPE.WMS_MAP;
	                        } else if (data__.mapFormat === 101) {
	                            _mapType = constant.MAPTYPE.OSM_MAP;
	                        } else if (data__.mapFormat === 102) {
	                            _mapType = constant.MAPTYPE.GOOGLE_MAP;
	                        } else if (data__.mapFormat === 103) {
	                            _mapType = constant.MAPTYPE.BING_MAP;
	                        } else if (data__.mapFormat === 105) {
	                            _mapType = constant.MAPTYPE.HUAWEI_MAP;
	                        }else if(data__.mapFormat === 107){
	                        	_mapType = constant.MAPTYPE.ARCGISTILE_LAYER;
	                        }
	                        else {
	                            _mapType = constant.MAPTYPE.OSM_MAP;
	                        }

	                        if (data__.mapFormat === 20) {
	                            //自定义地图导入使用
	                            _url = fusiongis.Constant.GisRootUrl + '/offlineMap/customServer?MAPNAME=' + _mapName + '&LAYERS=' + _layers;
	                        } else if (data__.mapFormat === 3) {
	                            //planetServer使用
	                            _url = fusiongis.Constant.GisRootUrl + '/offlineMap/planetServer';
	                            _mapName = undefined;
	                        } else if (data__.mapFormat === 4) {
	                            //shapeServer使用
	                            _url = fusiongis.Constant.GisRootUrl + '/offlineMap/shapeServer';
	                            _mapName = undefined;
	                        } else if (data__.mapFormat === 5) {
	                            //高铁使用
	                            _url = fusiongis.Constant.GisRootUrl + '/offlineMap/RailwayServer';
	                            _mapName = undefined;
	                        } else if (data__.mapFormat === 9) {
	                            //DC融合使用
	                            _url = fusiongis.Constant.GisRootUrl + '/offlineMap/customMap?MAPNAME=' + _mapName + '&LAYERS=' + _layers;
	                        }

	                        mapInfoList.push({
	                            mapFormat: data__.mapFormat,
	                            mapName: _mapName,
	                            mapLayer: _layers,
	                            url: _url,
	                            mapType: _mapType,
	                            key: _key,
	                            timeMaker: data__.timeMaker
	                        });
	                    }

	                    if (callback && typeof callback === 'function') {
	                        callback(mapInfoList);
	                    }

	                }
	            }
	        },
	        failure: function(result) {
	        	callback([]);
	        	console.log('离线地图信息获取失败,返回' + result);

	        }
	    })
	};

	var createMap = function (paramObj) {
	    if (!!!paramObj.UI) {
	        _queryMapType(paramObj);
	    }
	    else {
	        _createMap(paramObj);
	    }
	};

	function _createMap(paramObj) {
	    var _mapObj = null;
	    var _target = paramObj.mapId;
	    var _layerId = constant.MAPPROPERTY.BASE_LAYER_ID;
	    var _mapType = paramObj.mapType;
	    var _url = paramObj.url;
	    var _mapKey = paramObj.key;
	    var _mapName = paramObj.mapName;
	    var _layers = paramObj.layers;
	    var _version = paramObj.version;
	    var _language = paramObj.language;
	    var _controls = paramObj.controls;
	    var _controlStyles = paramObj.controlStyles || {
	        scaleLine: 'vGisWeb_scale-line-gis',
	        mousePosition: 'vGisWeb_mouse-position-gis'
	    };
	    var _isMapCutting = paramObj.isMapCutting;
	    var initCallback = paramObj.initCallback;

	    var _finalControls = (function (controls) {
	        var _tempControls = [];
	        for (var index in controls) {
	            var _controlStyle = _controlStyles[index];
	            if (index == 'overviewMap') {
	            	continue;
	            }
	            var _control = Control[index](_controlStyle, paramObj.overViewMapTipLabel, paramObj);
	            _tempControls.push(_control);
	        }

	        return _tempControls;
	    }(_controls));
	    
	    if (paramObj.layerId === undefined || paramObj.layerId === '' || paramObj.layerId === null) {
	    	paramObj.layerId = _layerId;
	    }


	    if (!hashMap.containsKey(_target)) {
	        var _view = views.createView(paramObj);
	        _mapObj = new ol.Map({
	            renderer: 'canvas',
	            target: _target,
	            view: _view,
	            controls: ol.control.defaults({
	                zoomOptions: {
	                    className: 'vGisWeb_olZoom_custom',
	                    zoomInTipLabel: fusiongis.I18n.prop('map.zoomIn'),
	                    zoomOutTipLabel: fusiongis.I18n.prop('map.zoomOut')
	                },
	                attributionOptions: ({
	                    collapsible: true
	                })
	            }).extend(_finalControls),
	            loadTilesWhileInteracting: false,
	            loadTilesWhileAnimating: false
	        });

	        //设置地图背景色为白色，规避图片到处时，瓦片没有加载出来是，导出黑色背景
	        if (!!_mapObj) {
	            _mapObj.set('mineView', _view);
	            _mapObj.set('type', constant.CUSTOMTYPE.MAPTYPE);
	            _mapObj.set('currentMapType', _mapType);
	            _mapObj.set('paramObj', paramObj);
	            new utils.sessionStorageObj().set('currentMapType', _mapType);
	            hashMap.put(_target, _mapObj);

	            var targetElement = _mapObj.getTargetElement();
	            if (!!targetElement) {
	                targetElement.setAttribute('class', targetElement.className + ' map_background');
	            }

	            if (!!initCallback && typeof(initCallback) === 'function') {
	                initCallback();
	            }

	            //添加地图级别自定义控件
	            _resolutionChange(_target, paramObj);
	            
	            //监控高亮图层的显隐
	            _mapObj.getLayers().on('change:length', function (event) {
	                if (!!event.target.getArray() && event.target.getArray().length > 0) {
	                    event.target.getArray().forEach(function (layer) {
	                        if (!!layer) {
	                            layer.on('change:visible', function() {
	                                var _mainLayerVisible = layer.getVisible();
	                                var layerId = layer.get('layer_id');
								    var hLayerId = layerId + '&&&highlight';
								    var hLayer = olUtil.getLayer({
								        mapId: _mapObj.getTarget(),
								        layerId: hLayerId
								    });
								    if (hLayer != undefined && hLayer != null) {
								    	hLayer.setVisible(_mainLayerVisible);
								    }
	                            });
	                        }
	                    });
	                }
	            });
	        }


	    }
	    else {
	        return;
	    }


	    _mapObj = hashMap.get(_target);
	    if (!!_mapObj) {

	        switch (_mapType) {
	            case constant.MAPTYPE.OSM_MAP:
	                mapType.mapTypeToolbar({
	                    mapObj: _mapObj
	                });
	                _mapObj.getLayers().insertAt(0, osmMap.createLayer({
	                    mapId: _target,
	                    layerId: _layerId,
	                    layer_id: _layerId
	                }));
	                break;
	            case constant.MAPTYPE.HUAWEI_MAP:
	                mapType.mapTypeToolbar({
	                    mapObj: _mapObj
	                });
	                _mapObj.getLayers().insertAt(0, vMap.createLayer({
	                    mapId: _target,
	                    url: _url,
	                    key: _mapKey,
	                    layerId: _layerId,
	                    layer_id: _layerId
	                }));
	                break;
	            case constant.MAPTYPE.WMS_MAP:
	                mapType.mapTypeToolbar({
	                    mapObj: _mapObj
	                });
	                _mapObj.getLayers().insertAt(0, wmsMap.createLayer({
	                    mapId: _target,
	                    url: _url,
	                    layers: _layers,
	                    version: _version,
	                    layerId: _layerId,
	                    layer_id: _layerId,
	                    mapName: _mapName,
	                    title: paramObj.title || '',
	                    isMapCutting:_isMapCutting
	                }));
	                break;
	            case constant.MAPTYPE.BING_MAP:
	                _mapObj.getLayers().insertAt(0, bingMap.createLayer({
	                    mapId: _target,
	                    key: _mapKey,
	                    layerId: _layerId,
	                    layer_id: _layerId,
	                    layers: _layers
	                }));

	                mapType.mapTypeToolbar({
	                    mapObj: _mapObj,
	                    mapType: constant.MAPTYPE.BING_MAP,
	                    bingMapKey: _mapKey
	                });
	                break;
	            case constant.MAPTYPE.GOOGLE_MAP:
	                if (!!_mapKey) {
	                    googleMap.loadGoogleAPI(_mapKey, _language, function (isTrue) {
	                        if (isTrue) {
	                            if (window.sessionStorage) {
	                                sessionStorage.setItem("key", _mapKey);
	                            }
	                            googleMap.createCustomMap(paramObj);
	                            mapType.mapTypeToolbar({
	                                mapObj: _mapObj,
	                                mapType: constant.MAPTYPE.GOOGLE_MAP,
	                                bingMapKey: undefined
	                            });
	                        }
	                    });
	                }
	                else {
	                    console.error('load google api failed...');
	                }
	                break;
	            case constant.MAPTYPE.NAVER_MAP:
	                _mapObj.getLayers().insertAt(0, naverMap.createLayer({
	                    mapId: _target,
	                    layerId: _layerId,
	                    layer_id: _layerId
	                }));
	                break;
	            case constant.MAPTYPE.TIANDI_MAP:
	              	var tdMarkerLayer = fusiongis.BaseLayer.getLayer({
				        mapId: _target,
				        layerId: layer_id + '_marker'
				    });
				    if (!!tdMarkerLayer && tdMarkerLayer instanceof ol.layer.Tile) {
				        _mapObj.removeLayer(tdMarkerLayer);
				    }

	                _mapObj.getLayers().insertAt(0, tiandiMap.createRoadLayer({
	                    mapId: _target,
	                    layerId: _layerId,
	                    layer_id: _layerId
	                }));
	                _mapObj.getLayers().insertAt(1, tiandiMap.createMarkerLayer({
	                    mapId: _target,
	                    layerId: _layerId + '_marker',
	                    layer_id: _layerId + '_marker'
	                }));

	                mapType.mapTypeToolbar({
	                    mapObj: _mapObj,
	                    mapType: constant.MAPTYPE.TIANDI_MAP
	                });
	                break;
	            case constant.MAPTYPE.BAIDU_MAP:
	                mapType.mapTypeToolbar({
	                    mapObj: _mapObj,
	                    mapType: constant.MAPTYPE.BAIDU_MAP
	                });
	                _mapObj.getLayers().insertAt(0, bDuMap.createLayer({
	                    mapId: _target,
	                    layerId: _layerId,
	                    layer_id: _layerId
	                }));
	                break;
	            case constant.MAPTYPE.GOOGLE_ROAD_MAP:
	                mapType.mapTypeToolbar({
	                    mapObj: _mapObj,
	                    mapType: constant.MAPTYPE.GOOGLE_ROAD_MAP
	                });
	                _mapObj.getLayers().insertAt(0, xyzGoogleRoad.createLayer({
	                    mapId: _target,
	                    layerId: _layerId,
	                    layer_id: _layerId
	                }));
	                break;
	            case constant.MAPTYPE.GAODE_MAP:
					if (!!_mapKey) {
	                    gaodeMap.loadGaodeAPI(_mapKey, _language, function (isTrue) {
	                        if (isTrue) {
	                            if (window.sessionStorage) {
	                                sessionStorage.setItem("key", _mapKey);
	                            }
	                            gaodeMap.createCustomMap(paramObj);
	                            mapType.mapTypeToolbar({
	                                mapObj: _mapObj,
	                                mapType: constant.MAPTYPE.GAODE_MAP,
	                                gaodeMapKey: _mapKey
	                            });
	                        }
	                    });
	                }
	                else {
	                    console.error('load gaode api failed...');
	                }
	                break;
	            case constant.MAPTYPE.YAHOO_MAP:
	                mapType.mapTypeToolbar({
	                    mapObj: _mapObj,
	                    mapType: constant.MAPTYPE.YAHOO_MAP
	                });
	                _mapObj.getLayers().insertAt(0, yahooMapLayer.createLayer({
	                    mapId: _target,
	                    layerId: _layerId,
	                    layer_id: _layerId
	                }));
	                break;
			             //增加arcgisTileLayer
	            case constant.MAPTYPE.ARCGISTILE_LAYER:
	            	_mapObj.getLayers().insertAt(0, arcgisTileLayer.createArcgisTileLayer({
	            		mapId: _target,
	            		layerId: _layerId,
	            		layer_id: _layerId,
	            		url: _url
	            	}));
	            	mapType.mapTypeToolbar({
	            		mapObj: _mapObj
	            	});
	            	break;
	            default :
	                mapType.mapTypeToolbar({
	                    mapObj: _mapObj,
	                    mapType: constant.MAPTYPE.OSM_MAP
	                });
	                _mapObj.getLayers().insertAt(0, osmMap.createLayer({
	                    mapId: _target,
	                    layer_id: _layerId,
	                    layerId: _layerId
	                }));
	        }
	        if (window.sessionStorage) {
	            sessionStorage.setItem("mapType", _mapType);
	        }
	        //创建自定义地图
	        _createCustomMap(paramObj);

	        ///鼠标悬浮事件
	        _pointerMove(_target);

	        ///地图点击事件
	        event.mapClick(_target, paramObj);

	        //trigger when resolution or zoom changed
	        _resolutionChange(_target, paramObj);

	        moveEnd(_target);

	        //地图缩放事件
	        event.zoomChangeEvent(_mapObj);

	        //地力中心变化事件
	        event.centerChangeEvent(_mapObj);

			//鹰眼时，不对图层管理器进行监测,disCovery不使用平台的图层管理器
			if (paramObj.eventDC === undefined) {
				bLayerManager.monitorLayers(paramObj);
			}

	        //用于存储地图统计数据，例如statistic.popupZIndex存储弹出窗zIndex
	        _mapObj.set('statistics', {});

	        _contextMenu(paramObj, _mapObj);

	        _pointerdrag(_target);
	        _pointerup(_target);
	        _mapObj.addLayer(new ol.layer.Vector({
	            source: new ol.source.Vector({wrapX:false})
	        }));

	        if (_mapObj) {
	        	if (_controls != undefined &&  _controls.hasOwnProperty('overviewMap')) {
	        		setTimeout(function() {
	        			overMap.addMinMap(paramObj);
	        		}, 3000);
	        	}
	        }
	    }

	};

	/**
	 * 鼠标右键菜单
	 * @param mapObj
	 * @private
	 */
	var _contextMenu = function (paramObj, mapObj) {
	    if (!!mapObj && !!mapObj.getViewport()) {

	        mapObj.getViewport().oncontextmenu = function (event) {
	            var _mapId = mapObj.getTarget();
	            event.preventDefault();

	            var pixel = mapObj.getEventPixel(event);
	            var _hasFeatureAtPixel = mapObj.hasFeatureAtPixel(pixel);
	            document.getElementById(_mapId).style.cursor = _hasFeatureAtPixel ? 'pointer' : '';

	            var feature = mapObj.forEachFeatureAtPixel(mapObj.getEventPixel(event), function(feature) {
	            	if(_hasFeatureAtPixel) {
	            		return feature;
	            	}
	            });


	            if (!!feature) {
	                hashMap.keys.filter(function (key) {
	                    return key.indexOf(_mapId) === (key.length - _mapId.length);
	                }).forEach(function (key) {
	                    var _value = hashMap.get(key);
	                    if (!!_value && _value instanceof ol.layer.Layer) {
	                        var _layer = _value;

	                        if (_layer.hasOwnProperty('rightClickCallback')
	                            && typeof _layer.rightClickCallback === 'function') {
	                            var _layerId = key.substring(0, key.indexOf(_mapId) - 1);
	                            if (!!_hasFeatureAtPixel) {
	                            	if(_layerId === feature.get('layerId')) {
	                            		_layer.rightClickCallback({
	                            			mapId: paramObj.mapId,
	                            			layerId: _layerId,
	                            			layerType: _layer.get('businessType'),
	                            			popupPosition: ol.proj.toLonLat(mapObj.getEventCoordinate(event)),
	                            			lonLat: ol.proj.toLonLat(ol.extent.getCenter(feature.getGeometry().getExtent())),
	                            			geoId: feature.getId(),
	                            			points: !!feature.getProperties() && !!feature.getProperties().data &&
	                            				feature.getProperties().data.coordinates
	                            		})
	                            	}

	                            }
	                        }
	                    }
	                });
	            }
	            else {
	                //点击地图执行，是否有业务图层无所谓
	                if (paramObj.rightClickCallback && typeof paramObj.rightClickCallback === 'function') {
	                    fusiongis.Popup.removeContextMenu();
	                    paramObj.rightClickCallback({
	                        mapId: paramObj.mapId,
	                        popupPosition: ol.proj.toLonLat(mapObj.getEventCoordinate(event))
	                    })
	                }
	            }

	        };
	    }
	};

	/**
	 * 创建自定义地图
	 * @param paramObj
	 * @private
	 */
	var _createCustomMap = function (paramObj) {
	    var olMap = mapBox.getMapObj(paramObj.mapId);
	    if (!olMap) {
	        return;
	    }
	    if (paramObj.mapType && paramObj.mapType === constant.MAPTYPE.GOOGLE_MAP) {
	        var gmap = googleMap.createCustomMap(paramObj);
	        olMap.set('customMap', gmap);
	    }
	};

	/**
	 * 销毁自定义地图
	 * @param params
	 */
	function destroyCustomMap(params) {
	    var mapId = params.mapId;
	    var olMap = mapBox.getMapObj(mapId);
	    if (olMap.get('customMap')) {
	        olMap.unset('customMap');
	        var cckey = olMap.get('customCenterKey');
	        var crkey = olMap.get('customResolutionKey');
	        if (cckey) {
	            olMap.unByKey(cckey);
	        }
	        if (crkey) {
	            olMap.unByKey(crkey);
	        }
	    }
	    var gMap = document.getElementById('$$customMap_' + mapId);
	    if (gMap && gMap.parentNode) {
	        gMap.parentNode.removeChild(gMap);
	    }
	}



	function _pointerMove(_target) {
		var _mapObj = hashMap.get(_target);
		var mouseHoverHeartBeatObj = new mouseHover.mouseHoverHeartBeat();
		var sessionStore = new utils.sessionStorageObj();
		_mapObj.on('pointermove', function(e) {

			var pixel = _mapObj.getEventPixel(e.originalEvent);
			var eCoordinates = e.coordinate;
	        var _hasFeatureAtPixel = _mapObj.hasFeatureAtPixel(pixel);
			if(mouseHover.isServiceLayer(_mapObj)) { //如果是服务图层，就直接返回
				popup.removeSuspensionPopup(_target);
				mouseHoverHeartBeatObj.beat(_mapObj, pixel, _target);
				return;
			}
			
			var _feature = _mapObj.forEachFeatureAtPixel(pixel, function(feature, layer) {
				if(_hasFeatureAtPixel) {
					return feature;
				}
			});
	        var isHasEvents=function(_feature,_mapObj){
	            var _callbackList = _mapObj.get('callbackList');
	            var feaLayer=_feature.get('layer');
	            if(!!!feaLayer){
	                return false;
	            }
	            if(!!_callbackList[_feature.get('layer').get('UIclickId')]){
	                return true;
	            }else if((feaLayer.hasOwnProperty('mouseoverCallback') &&
	                typeof feaLayer.mouseoverCallback === 'function')||
	                (feaLayer.hasOwnProperty('zoomCallback') &&
	                typeof feaLayer.zoomCallback === 'function')||
	                (feaLayer.hasOwnProperty('rightClickCallback') &&
	                typeof feaLayer.rightClickCallback === 'function')||
	                (feaLayer.hasOwnProperty('refreshDataCallback') &&
	                typeof feaLayer.refreshDataCallback === 'function')){
	                    return true;
	            }else{
	                return false;
	            }
	        }
	        if(_mapObj.get('paramObj').eventDC!=undefined){
	            if(_hasFeatureAtPixel&&!!_feature){
	                var isHasEvent=isHasEvents(_feature,_mapObj);
	                document.getElementById(_target).style.cursor = isHasEvent ? 'pointer' : '';
	            }else{
	                document.getElementById(_target).style.cursor = '';
	            }
	        }else{
			    document.getElementById(_target).style.cursor = _hasFeatureAtPixel ? 'pointer' : '';
	        }
			
			if(!!_feature) {
				if (sessionStore.get(_target + 'vectorFeature') === undefined) {
					sessionStore.set(_target + 'vectorFeature', _feature);
				}
				else if (sessionStore.get(_target + 'vectorFeature') !== undefined) {
					if (sessionStore.get(_target + 'vectorFeature') !== _feature) {
						sessionStore.set(_target + 'vectorFeature', _feature);
					}
					else {
						return;
					}
				}
				
				
				var fLayer;
				var clusterFeature = _feature.get('features');
				if(!!clusterFeature && clusterFeature instanceof Array && clusterFeature.length === 1) {
					fLayer = clusterFeature[0].get('layer');
				} else {
					fLayer = _feature.get('layer');
				}
				if(fLayer && fLayer.hasOwnProperty('mouseoverCallback') &&
					typeof fLayer.mouseoverCallback === 'function') {
					
					var _geomExtent = _feature.getGeometry().getExtent();
					var _geomCenter = ol.extent.getCenter(_geomExtent);
	                var _wcjFrom4326 =ol.proj.toLonLat(_geomCenter);
					var _data = null;
					var _isCluster = false;
					_feature.set('eCoordinates', ol.proj.toLonLat(eCoordinates));
					if(_feature.get('data')) {
						_data = _feature.get('data');
					} else {
						///汇聚情况
						var _features = _feature.get('features');
						if(_features) {
							if(_features.lenght > 1) {
								_isCluster = true;
							}
							_data = _features[0].get('data');
						}
					}
					if(fLayer.get('layerId') && fLayer.get('layerId').indexOf('&&&highlight') > -1) {
						fLayer.mouseoverCallback({
	                        centerCoordinate: utils.gcjTransform3857(_geomCenter),
	                        lonLat: utils.gcj_decTransform(_wcjFrom4326),
							mapId: _target,
							layerId: fLayer.get('layerId').replace(/&&&highlight/g, ''),
							eCooordinate: _feature.get('eCoordinates'),
							tipCoordinates: _feature.get('tipCoordinates'),
							infor: _data,
	                        position: utils.gcj_decTransform(_wcjFrom4326)
						});
						lastMouseOverFeature.set('lastMouseOverFeature', _feature.getId());
					} else {
						popup.removeSuspensionPopup(_target);
						lastMouseOverFeature.set('lastMouseOverFeature', null);
					}
					hashMap.keys.filter(function(key) {
						return !!key && key.indexOf(_mapObj.getTarget()) ===
							(key.length - _mapObj.getTarget().length);
					}).forEach(function(key) {
						var _value = hashMap.get(key);
						if(!!_value && _value instanceof ol.layer.Layer) {
							var _layer = _value;
							if(_layer.hasOwnProperty('mouseoverCallback') &&
								typeof _layer.mouseoverCallback === 'function') {
								var registerLayerId = _layer.get('layerId'); //注册悬浮事件的layerId
								var _layerId = key.substr(0, key.length - (_target.length + 1));
								if(_layer.getSource() && (_layer.getSource().getFeatures())) {
									var _layerFeatures = _layer.getSource().getFeatures();
									if(_layerFeatures.length > 0) {
										for(var i = 0; i < _layerFeatures.length; i++) {
											var _callBackData = {
	                                            centerCoordinate: utils.gcjTransform3857(_geomCenter),
	                                            lonLat: utils.gcj_decTransform(_wcjFrom4326),
												mapId: _target,
												layerId: _layerId,
												eCooordinate: _feature.get('eCoordinates'),
												tipCoordinates: _feature.get('tipCoordinates'),
												infor: _data,
												isCluster: _isCluster,
	                                            position: utils.gcj_decTransform(_wcjFrom4326)
											};
											var clusterFeature = _feature.get('features');
											if(!!clusterFeature && clusterFeature instanceof Array && clusterFeature.length === 1) {
												if(clusterFeature[0].get('layer').get('layerId') === registerLayerId) {
													_layer.mouseoverCallback(_callBackData);
													lastMouseOverFeature.set('lastMouseOverFeature', _feature.getId());
													return;
												}
											}
											if(!!!clusterFeature && _layerFeatures[i].getId() === _feature.getId() &&
												_feature.get('layer').get('layerId') === registerLayerId) {
												//比较feature和__feature  比较当前点击图层的ID和注册悬浮事件的图层id
												if(lastMouseOverFeature.get('lastMouseOverFeature') === _feature.getId()) {
													return;
												}
												_layer.mouseoverCallback(_callBackData);
		
												lastMouseOverFeature.set('lastMouseOverFeature', _feature.getId());
											}
		
										}
		
									}
								}
							}
						}
					});
				} else {
					popup.removeSuspensionPopup(_target);
					lastMouseOverFeature.set('lastMouseOverFeature', null);
				}
			} else {
				popup.removeSuspensionPopup(_target);
				lastMouseOverFeature.set('lastMouseOverFeature', null);
			}
		});

	}

	/**
	 * 境界线。
	 * @param _mapObj
	 * @param _extent3857
	 * @param _target
	 * @private
	 */
	var _borderLine = function (paramObj) {
	    var _currentMapExtent = paramObj.extent3857;//当前屏幕范围
	    var _multipleExtent = utils.extentTimes(_currentMapExtent, paramObj.multiple);
	    var _layer = paramObj.layer;

	    var _isOutSide = (function () {
	        var _lastExtent = _layer.get('lastExtent');
	        if(_lastExtent == undefined){
	        	 _layer.set('lastExtent', _multipleExtent);
	        	 return true;
	        }
	        else {
	            if (ol.extent.containsExtent(_lastExtent, _currentMapExtent)) {
	                return false;
	            }
	            else {
	                return true;
	            }
	        }
	    }());

	    if (_isOutSide) {
	    	_layer.set('lastExtent', _multipleExtent);

	        _layer.refreshDataCallback({
	            extent: ol.proj.transformExtent(_multipleExtent,constant.PROJ.EPSG_3857, constant.PROJ.EPSG_4326)
	        });
	    }
	};


	function _pointerdrag(mapId) {
	    var _mapObj = hashMap.get(mapId);
	    if (_mapObj) {
	        var _finallyKeys = [];
	        _mapObj.on('pointerdrag', function (e) {
	            var _linkedMapIds = (function () {
	                var keys = [];
	                hashMap.vals.forEach(function (v, i) {
	                    if (v instanceof ol.Map) {
	                        keys.push(hashMap.keys[i]);
	                    }
	                });
	                return keys;
	            }());
	            for (var i = 0; i < _linkedMapIds.length; i++) {
	                hashMap.keys.filter(function (key) {
	                    if (!!key) {
	                        if ((key.indexOf(_linkedMapIds[i]) === (key.length - _linkedMapIds[i].length))) {
	                            _finallyKeys.push(key);
	                        }
	                    }
	                })
	            }
	            _finallyKeys.forEach(function (key) {
	                var _val = hashMap.get(key);
	                var nowLink = hashMap.get('nowLink');
	                if (nowLink === false || nowLink === undefined) {
	                    if (key.indexOf(mapId) === -1) {
	                        return;
	                    }
	                }
	                if (!!_val) {
	                    if (_val instanceof ol.layer.Layer) {
	                        if (!!_val.get('businessType')) {
	                            var _layerBusinessType = _val.get('businessType');

	                            if (_layerBusinessType === constant.BUSINESSTYPE.VECTOR_CELL) {
	                                if (_mapObj.get('currentMapType') === 'GOOGLE_MAP') {
	                                    if (_val.get('hideWhenPan')) {
	                                        _val.setVisible(false);
	                                    }
	                                }

	                            }
	                        }
	                    }
	                }
	            });
	        })

	    }
	}

	function _pointerup(mapId) {
	    var _mapObj = hashMap.get(mapId);
	    if (_mapObj) {

	        var _finallyKeys = [];
	        _mapObj.on('pointerup', function (e) {
	            var _linkedMapIds = (function () {
	                var keys = [];
	                hashMap.vals.forEach(function (v, i) {
	                    if (v instanceof ol.Map) {
	                        keys.push(hashMap.keys[i]);
	                    }
	                });
	                return keys;
	            }());
	            setTimeout(function () {
	                for (var i = 0; i < _linkedMapIds.length; i++) {
	                    hashMap.keys.filter(function (key) {
	                        if (!!key) {
	                            if ((key.indexOf(_linkedMapIds[i]) === (key.length - _linkedMapIds[i].length))) {
	                                _finallyKeys.push(key);
	                            }
	                        }
	                    })
	                }
	                _finallyKeys.forEach(function (key) {
	                    var _val = hashMap.get(key);
	                    if (!!_val) {
	                        if (_val instanceof ol.layer.Layer) {
	                            if (!!_val.get('businessType')) {
	                                var _layerBusinessType = _val.get('businessType');

	                                //重新绘制小区
	                                if (_layerBusinessType === constant.BUSINESSTYPE.VECTOR_CELL) {
	                                    if (_mapObj.get('currentMapType') === 'GOOGLE_MAP') {
	                                        if (_val.get('hideWhenPan')) {
	                                            _val.setVisible(true);
	                                            var _oldCenter = _mapObj.getView().getCenter();
	                                            _oldCenter = ol.proj.toLonLat(_oldCenter);
	                                            var _newCenter = [_oldCenter[0] + 0.0000000001, _oldCenter[1] + 0.0000000001];
	                                            _newCenter = ol.proj.fromLonLat(_newCenter);
	                                            _mapObj.getView().setCenter(_newCenter);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                })
	            }, 800);
	        })

	    }
	}

	function moveEnd(mapId) {
	    var _mapObj = hashMap.get(mapId);
	    if (_mapObj) {
	    	var initMapParam = _mapObj.get('paramObj');
	        _mapObj.on('moveend', function () {
	        	var _mapSize = _mapObj.getSize();
	        	var _view = _mapObj.getView();
	        	var _extent3857 = _view.calculateExtent(_mapSize);
	            var _extent4326 = ol.proj.transformExtent(_extent3857, constant.PROJ.EPSG_3857, constant.PROJ.EPSG_4326);
	            hashMap.keys.filter(function (key) {
	                return !!key && (key.indexOf(mapId) === (key.length - mapId.length));
	            }).forEach(function (key) {
	                var _layer = hashMap.get(key);
	                if (!!_layer) {
	                    if (_layer instanceof ol.layer.Layer) {

							layerVisibleController(_mapObj, _layer);


	                    	//需要特殊处理的矢量元素
	                        if (!!_layer.get('businessType')) {
	                            var _layerBusinessType = _layer.get('businessType');
	                            if (_layerBusinessType === constant.BUSINESSTYPE.VECTOR_CELL) {
	                                var layerId = _layer.get('layer_id');
	                                var mapId = _mapObj.getTarget();
	                                var noChangeRadius = _layer.get('noChangeRadius');

	                                if (!!noChangeRadius) {
	                                    fusiongis.Cell.clear({
	                                        mapId: mapId,
	                                        layerId: layerId
	                                    });

	                                    if (!!_layer.get('datas')) {
	                                        fusiongis.Cell.setLayerData({
	                                            mapId: mapId,
	                                            layerId: layerId,
	                                            datas: _layer.get('datas'),
	                                            noChangeRadius: noChangeRadius
	                                        })
	                                    }
	                                }

	                            } else if (_layerBusinessType === 'BUBBLE_CIRCLE_LABEL') {
	                                var isRadiuChange = _layer.get('isRadiuChange');
	                                if (!!isRadiuChange) {
	                                    fusiongis.BubbleCircleLabel.clear({
	                                        mapId: _mapObj.getTarget(),
	                                        layerId: _layer.get('layer_id')
	                                    });
	                                    var datas = _layer.get('datas');
	                                    var layerId = _layer.get('layer_id');
	                                    var tipAzimth = _layer.get('tipAzimth');
	                                    var isDis = _layer.get('isDis');
	                                    if (!!_layer.get('datas')) {
	                                        fusiongis.BubbleCircleLabel.setLayerData({
	                                            mapId: _mapObj.getTarget(),
	                                            layerId: layerId,
	                                            datas: datas,
	                                            isRadiuChange: isRadiuChange,
	                                            tipAzimth: tipAzimth,
	                                            isDis : isDis
	                                        });
	                                    }
	                                    fusiongis.BubbleCircleLabel.zoomChangeHightlight({
	                                        mapId: _mapObj.getTarget(),
	                                        layerId: layerId + '&&&highlight'
	                                    })
	                                }
	                            }
	                        }
	                    }
	                }
	            })

	/*************************************************************************************************************************************/
	            //图层警戒线
	            hashMap.keys.filter(function (key) {
	                return !!key && (key.indexOf(mapId) === (key.length - mapId.length));
	            }).forEach(function (key) {
	                var _layer = hashMap.get(key);
	                if (!!_layer) {
	                	if (_layer instanceof ol.layer.Layer) {
	                		var _layerBusinessType = _layer.get('businessType');
	                		if (_layerBusinessType != undefined && !!initMapParam.multiple && _layer.hasOwnProperty('refreshDataCallback')
		                        && typeof _layer.refreshDataCallback === 'function') {
		                        var _multiple = _layer.get('multiple');
		                        var _currentMapZoom = _mapObj.getView().getZoom();
		                        var _minsShowZoom = _layer.get('minShowLevel');
		                        var _maxShowZoom = _layer.get('maxShowLevel');
		                        if (!!_multiple && _minsShowZoom <= _currentMapZoom && _maxShowZoom >= _currentMapZoom) {
		                            _borderLine({
		                            	mapObj: _mapObj,
		                            	layer: _layer,
		                                extent3857: _extent3857,
		                                multiple: _multiple || 1,
		                            });
		                        }
		                    }
	                	}
	                }
	            });
	            _mapObj.set('lastZoom', _view.getZoom());
	        })

	    }
	}

	function _resolutionChange(mapId, initMapParam) {
	    var _mapObj = hashMap.get(mapId);
	    if (!!_mapObj) {
	        var _zoomInOutCtl = document.querySelector('#' + mapId).querySelector('.vGisWeb_olZoom_custom');
	        if (!!_zoomInOutCtl) {
	            var zoomCtrl = document.querySelector('#' + mapId).querySelector('.vGisWeb_custom_zoom_ctrl');
	            if (!!!zoomCtrl) {
	                var _div = domUtil.createDom({
	                    tagName: 'div',
	                    attributes: {
	                        class: 'vGisWeb_custom_zoom_ctrl'
	                    },
	                    text: getZoom(mapId)
	                });
	                _zoomInOutCtl.insertBefore(_div, _zoomInOutCtl.childNodes[0]);
	            }

	            var _view = _mapObj.getView();
	            var _linkedMaps = _view.get('linkedMapIds');
	            _view && _view.on('change:resolution', function (e) {
	            	var _mapSize = _mapObj.getSize();
	                var _extent3857 = _view.calculateExtent(_mapSize);
	                var _extent4326 = ol.proj.transformExtent(_extent3857, constant.PROJ.EPSG_3857, constant.PROJ.EPSG_4326);

	                if (_linkedMaps.length > 0) {
	                    for (var i = 0; i < _linkedMaps.length; i++) {
	                        var zoomCtrl = document.querySelector('#' + _linkedMaps[i]).querySelector('.vGisWeb_custom_zoom_ctrl');
	                        if (zoomCtrl) {
	                            zoomCtrl.innerHTML = _view.getZoom();
	                        }
	                    }
	                } else {
	                    var zoomCtrlSingle = document.querySelector('#' + mapId).querySelector('.vGisWeb_custom_zoom_ctrl');
	                    if (zoomCtrlSingle) {
	                        zoomCtrlSingle.innerHTML = _view.getZoom();
	                    }
	                }


	                hashMap.keys.filter(function (key) {
	                    return !!key && (key.indexOf(mapId) === (key.length - mapId.length));
	                }).forEach(function (key) {
	                    var _layer = hashMap.get(key);
	                    if (!!_layer) {
	                        if (_layer instanceof ol.layer.Layer) {
	                            if (!!_layer.get('businessType')) {
	                                var _layerBusinessType = _layer.get('businessType');

	                                //重新绘制小区
	                                if (_layerBusinessType === constant.BUSINESSTYPE.VECTOR_CELL) {
	                                    var layerId = _layer.get('layer_id');
	                                    var noChangeRadius = _layer.get('noChangeRadius');

	                                    if (!!noChangeRadius) {
	                                        fusiongis.Cell.clear({
	                                            mapId: mapId,
	                                            layerId: layerId
	                                        });

	                                        if (!!_layer.get('datas')) {
	                                            fusiongis.Cell.setLayerData(
	                                                {
	                                                    mapId: mapId,
	                                                    layerId: layerId,
	                                                    datas: _layer.get('datas'),
	                                                    noChangeRadius: noChangeRadius
	                                                }
	                                            )
	                                        }
	                                    }

	                                }

	                                //连线包括直线和曲线
	                                if(_layerBusinessType ===  constant.BUSINESSTYPE.STRAIGHTLINE){
	                                	fusiongis.LineAdd.setNewCoordinate(_layer,mapId);

	                                }
	                            }

	                            //执行图层上注册的回调函数
	                            if (_layer.hasOwnProperty('zoomCallback') && typeof _layer.zoomCallback === 'function') {
	                                _layer.zoomCallback(
	                                    {
	                                        extent: _extent4326,
	                                        zoom: _view.getZoom()
	                                    }
	                                );
	                            }
	                        }
	                    }
	                });
	            })
	        }
	    }

	}

	/**
	 * 销毁地图
	 * @param mapId {String} 地图id
	 */
	var removeMap = function (mapIds) {
	    if (!!mapIds && mapIds.length > 0) {
	        var k;
	        for (k=0; k < mapIds.length; k++) {
	            var mapId = mapIds[k];
	            if (!!mapBox.getMapObj(mapId)) {
	                var _viewPort = mapBox.getMapObj(mapId).getViewport();
	                if (!!_viewPort) {
	                    if (!!_viewPort.parentNode) {
	                        _viewPort.parentNode.removeChild(_viewPort);
	                    }

	                    for (var i = hashMap.keys.length; i > 0; i--) {
	                        var key = hashMap.keys[i];
	                        if (key && key.substring(key.lastIndexOf('_') + 1) === mapId) {
	                            if (key !== mapId) {
	                                hashMap.remove(key);
	                            }
	                        }
	                    }
	                    hashMap.remove(mapId);
	                }
	            }
	        }
	    }
	};

	/**
	 *  这是地图中心点及可视级别
	 * @param paramObj
	 */
	var setMapCenter = function (paramObj) {
	    var _coordinate = null;
	    var _zoom = paramObj.zoom;
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId;
	    var _geoId = paramObj.geoId;
	    var olMap = hashMap.get(_mapId);
	    var _view = olMap && olMap.getView();
	    var _layerIdentify = _layerId + constant.Joiner.UNDERLINE + _mapId;
	    var _layerObj = hashMap.get(_layerIdentify);
	    if (!!paramObj.coordinate) {
	    	var _lastCoordiante =paramObj.coordinate.slice(0);
	    	var _gcjTransFormCoord =utils.gcjTransform(_lastCoordiante);
	        _coordinate = ol.proj.fromLonLat(_gcjTransFormCoord);
	    }
	    else if (!!_geoId) {
	        var getFeatureCenter = ol.proj.fromLonLat([108, 39]);
	        if (_layerObj.get('imgToken') || _layerObj.get('params.imgToken')) {
	        	var imgToken = _layerObj.get('imgToken') || _layerObj.get('params.imgToken');
				var Fcname = imgToken.slice(0, imgToken.indexOf(':'));
	            ajax.postJSON({
	                url: constant.GisRootUrl + '/mapRender/query?FCName=' + Fcname,
	                data: JSON.stringify({
	                    id: [_geoId],
	                    imgToken: imgToken
	                }),
	                success: function (result) {
	                    if (!!result) {
	                        var json = JSON.parse(result);

	                        if (json.status.code === 1 && json.data) {

	                            if (!!_view || !!json.data[0].centerPoint) {
	                                _view.setCenter(ol.proj.fromLonLat(json.data[0].centerPoint));

	                                if (_zoom) {
	                                    _view.setZoom(_zoom);
	                                }
	                            }
	                        }
	                    }
	                    return;
	                },
	                failure: function(result) {
	                	
	                }
	            });
	        }
	        else {
	            getFeatureCenter = (function () {
	                var _layer = hashMap.get(_layerId + constant.Joiner.UNDERLINE + _mapId);
	                var _feature = _layer
	                    && _layer.getSource()
	                    && _layer.getSource().getFeatureById(_geoId);
	                return _feature
	                    && ol.extent.getCenter(_feature.getGeometry().getExtent());
	            }());
	        }
	        _coordinate = getFeatureCenter;
	    }

	    if (!!_view) {
	        if (!!_view) {
	            if (olMap && !!olMap.get('mineCustomMap')) {
	                var _center;
	                var gMap = olMap.get('mineCustomMap');
	                var currMapType = sessionStorage.getItem('mapType');
	                switch(currMapType) {
	                    case constant.MAPTYPE.GOOGLE_MAP:
	                        //谷歌地图时，调用谷歌接口设置中心点和级别
	                        _center = new google.maps.LatLng(paramObj.coordinate[1], paramObj.coordinate[0]);
	                        gMap.setCenter(_center);
	                        if (_zoom !== undefined && _zoom !== null) {
	                            gMap.setZoom(_zoom);
	                        }
	                        break;
	                    case constant.MAPTYPE.GAODE_MAP:
	                        //高德地图时，调用高德接口设置中心点和级别
	                        _center =  utils.gcjTransform(paramObj.coordinate);
	                        if(_zoom && _center && toString.call(_center) === 'Array' && _center.length > 0) {
	                            gmap.setZoomAndCenter(_zoom, [_center[0],_center[1]]);
	                        }
	                        break;
	                }
	            }
	            if (!!_coordinate) {
	                _view.setCenter(_coordinate);
	            }

	            if (_zoom !== undefined && _zoom !== null) {
	                _view.setZoom(_zoom);
	            }
	        }
	    }

	};

	/**
	 * 获取地图当前级别
	 * @param mapId {String} 地图唯一标识
	 */
	var getZoom = function (mapId) {
	    return mapBox.getMapObj(mapId).getView().getZoom();
	};

	/**
	 *
	 * @param _target
	 * @param isTransform
	 * @returns {ol.Extent}
	 */
	var getExtent = function (_target, isTransform) {
	    var _mapObj = hashMap.get(_target);
	    var _currentExtent = _mapObj.getView().calculateExtent(_mapObj.getSize());
	    if (!isTransform) {
	        return _currentExtent;
	    }
	    else {
	        return ol.proj.transformExtent(_currentExtent, constant.PROJ.EPSG_3857,
	            constant.PROJ.EPSG_4326);
	    }
	};

	/**
	 * 更新地图
	 * @param mapIds {Array}
	 */
	var refreshMaps = function (mapIds) {
	    if (mapIds && mapIds instanceof Array) {
	        for (var i = 0; i < mapIds.length; i++) {
	            if (!!mapBox.getMapObj(mapIds[i])) {
	                mapBox.getMapObj(mapIds[i]).updateSize();
	            }
	        }

	    }
	};

	/**
	 * 获取地图中心点
	 * @param mapId
	 * @param opt_projection
	 * @returns {ol.Coordinate}
	 */
	var getCenter = function (mapId, opt_projection) {
	    var _center = mapBox.getMapObj(mapId).getView().getCenter();
	    return ol.proj.toLonLat(_center, opt_projection);
	};

	/**
	 * 设置地图视窗可视范围
	 * @param paramObj
	 */
	var setExtent = function (paramObj) {
	    var _mapId = paramObj.mapId;
	    var _extent = null;
	    var _map = mapBox.getMapObj(_mapId);

	    if (paramObj.extent) {
	        _extent = ol.proj.transformExtent(paramObj.extent, constant.PROJ.EPSG_4326,
	            constant.PROJ.EPSG_3857);
	    }
	    else {
	        ajax.postJSON({
	            url: constant.GisRootUrl + '/getMapExtent/extent?FCName=' + paramObj.fcName,
	            data: JSON.stringify({
	                geoParams: {
	                    fcName: paramObj.fcName
	                }
	            }),
	            success: function (result) {
	                if (!!result) {
	                    var _result = JSON.parse(result);
	                    if (_result && _result.status && _result.status.code === 1) {
	                        if (_result.data) {
	                            var extent = _result.data.mapExtent;
	                            if (extent.length === 0) {
	                                return;
	                            }
	                            _extent = extent;
	                        }
	                    }

	                }
	            },
	            failure: function(result) {
	            	console.log(result);
	            }
	        });
	    }

	    !!_extent && _map.getView().fit(_extent, _map.getSize());
	};

	/**
	 * 更新地图的View
	 */
	var _updateView = function (updateParam) {
	    var mapObj = mapBox.getMapObj(updateParam.mapId);
	    var originParam = mapObj.get('paramObj');
	    updateParam = utils.extend({}, originParam, updateParam);
	    var view = mapObj.getView();
	    if (updateParam.center && updateParam.center instanceof Array) {
	        if (updateParam.center[0] === originParam.center[0] &&
	            updateParam.center[1] === originParam.center[1]) {
	            return;
	        }
	        var _lastCoords =updateParam.center.slice(0);
	        var _gcjTransformCoords =utils.gcjTransform(_lastCoords);
	        view.setCenter(ol.proj.fromLonLat(_gcjTransformCoords));
	    }
	    if (updateParam.defaultZoom) {
	        if (updateParam.defaultZoom === originParam.defaultZoom) {
	            return;
	        }
	        view.setZoom(updateParam.defaultZoom);
	    }
	    if (updateParam.maxZoom || updateParam.minZoom) {
	        if (updateParam.maxZoom === originParam.maxZoom &&
	            updateParam.minZoom === originParam.minZoom) {
	            return;
	        }
	        var sourceMaxZoom = view.get(constant.MAPPROPERTY.DEFAULT_MAX_ZOOM);
	        var sourceMinZoom = view.get(constant.MAPPROPERTY.DEFAULT_MAX_ZOOM);
	        view.set(constant.MAPPROPERTY.DEFAULT_MAX_ZOOM, updateParam.maxZoom || sourceMaxZoom);
	        view.set(constant.MAPPROPERTY.DEFAULT_MIN_ZOOM, updateParam.minZoom || sourceMinZoom);
	    }
	};

	/**
	 * 更新地图的Controls
	 */
	var _updateControls = function (updateParam) {
	    var mapObj = mapBox.getMapObj(updateParam.mapId);

	    var sourceControls = mapObj.getControls().getArray();
	    for (var i = sourceControls.length; i > 0; i--) {
	        mapObj.removeControl(sourceControls[i]);
	    }

	    var controlStyles = updateParam.controlStyles ? updateParam.controlStyles : {
	        scaleLine: 'vGisWeb_scale-line-gis',
	        mousePosition: 'vGisWeb_mouse-position-gis'
	    };

	    var updateControl = ol.control.defaults({
	        zoomOptions: {
	            className: 'vGisWeb_olZoom_custom_un'
	        },
	        attributionOptions: ({
	            collapsible: true
	        })
	    }).getArray();

	    var controls = updateParam.controls;
	    
	    for (var ctrl in controls) {
	    	if(ctrl == undefined || ctrl == null){
	            continue;
	        }
	    	if (controls[ctrl] == undefined || controls[ctrl] == null) {
	    		continue;
	    	}
	    	if (typeof Control[controls[ctrl]] !== 'function') {
	    		continue;
	    	}
	        updateControl.push(Control[controls[ctrl]](
	            controlStyles[ctrl]
	        ));
	    }

	    updateControl.forEach(function (ctrl) {
	        if(ctrl !== undefined || ctrl !== null){
	            mapObj.addControl(ctrl);
	        }
	    });
	    function updateOverMap(updateParam) {
	        if (!!!updateParam.controls['overviewMap']) {
	            var overView = document.getElementById(updateParam.mapId + '_overview');
	            var overViewSpan = document.getElementById(updateParam.mapId + '_overviewSpan');
	            if (!!overView) {
	                overView.style.display = 'none';
	            }
	            if (!!overViewSpan) {
	                overViewSpan.style.display = 'none';
	            }
	        } else if (!!updateParam.controls['overviewMap']) {
	            var overView = document.getElementById(updateParam.mapId + '_overview');
	            var overViewSpan = document.getElementById(updateParam.mapId + '_overviewSpan');
	            if (!!overView) {
	                overView.style.display = 'block';
	            }
	            if (!!overViewSpan) {
	                overViewSpan.style.display = 'block';
	            }
	        }
	    }
	    updateOverMap(updateParam);
	    setTimeout(function () {
	        updateOverMap(updateParam);
	    }, 3000);
	};

	/**
	 * 更新地图的坐标系
	 */
	var _updateProj = function (updateParam) {

	};

	/**
	 * 更新地图的底图
	 */
	var _updateBaseLayer = function (updateParam) {


	    var _mapObj = mapBox.getMapObj(updateParam.mapId);
	    var mapId = updateParam.mapId;
	    var originParam = _mapObj.get('paramObj');
	    originParam.center = ol.proj.toLonLat(_mapObj.getView().getCenter());
	    updateParam = utils.extend({}, originParam, updateParam);
	    destroyCustomMap(updateParam);

	    var layer_id = constant.MAPPROPERTY.BASE_LAYER_ID;
	    var tdMarkerLayer = fusiongis.BaseLayer.getLayer({
	        mapId: updateParam.mapId,
	        layerId: layer_id + '_marker'
	    });
	    if (!!tdMarkerLayer && tdMarkerLayer instanceof ol.layer.Tile) {
	        _mapObj.removeLayer(tdMarkerLayer);
	    }
	    olUtil.removeLayer({
	        mapId: mapId,
	        layer_id: layer_id
	    });
	    switch (updateParam.mapType) {
	        case constant.MAPTYPE.OSM_MAP:
	            mapType.mapTypeToolbar({
	                mapObj: _mapObj
	            });
	            _mapObj.getLayers().insertAt(0, osmMap.createLayer({
	                mapId: mapId,
	                layerId: layer_id,
	                layer_id: layer_id
	            }));
	            break;
	        case constant.MAPTYPE.HUAWEI_MAP:
	            mapType.mapTypeToolbar({
	                mapObj: _mapObj
	            });
	            _mapObj.getLayers().insertAt(0, vMap.createLayer({
	                mapId: mapId,
	                url: updateParam.url,
	                key: updateParam.key,
	                layerId: layer_id,
	                layer_id: layer_id
	            }));
	            break;
	        case constant.MAPTYPE.BING_MAP:
	            if (!!!updateParam.key) {
	                console.warn('bing map api license invalid, please enter valid key!');
	                return;
	            }

	            _mapObj.getLayers().insertAt(0, bingMap.createLayer({
	                mapId: mapId,
	                layerId: layer_id,
	                layer_id: layer_id,
	                key: updateParam.key,
	                layers: updateParam.layers
	            }));

	            mapType.mapTypeToolbar({
	                mapObj: _mapObj,
	                mapType: constant.MAPTYPE.BING_MAP,
	                bingMapKey: updateParam.key
	            });
	            break;
	        case constant.MAPTYPE.WMS_MAP:
	            mapType.mapTypeToolbar({
	                mapObj: _mapObj
	            });
	            _mapObj.getLayers().insertAt(0, wmsMap.createLayer({
	                mapId: mapId,
	                url: updateParam.url,
	                layers: updateParam.layers,
	                layerId: layer_id,
	                layer_id: layer_id,
	                version: updateParam.version,
	                mapName: updateParam.mapName,
	                title: updateParam.title || '',
	                isMapCutting:updateParam.isMapCutting
	            }));
	            break;
	        case constant.MAPTYPE.NAVER_MAP:
	            mapType.mapTypeToolbar({
	                mapObj: _mapObj
	            });
	            _mapObj.getLayers().insertAt(0, naverMap.createLayer({
	                mapId: mapId,
	                layerId: layer_id,
	                layer_id: layer_id
	            }));
	            break;
	        case constant.MAPTYPE.TIANDI_MAP:
	            mapType.mapTypeToolbar({
	                mapObj: _mapObj,
	                mapType: constant.MAPTYPE.TIANDI_MAP
	            });
	            if (updateParam.layers == 'Road') {
	                _mapObj.getLayers().insertAt(0, tiandiMap.createRoadLayer({
	                    mapId: mapId,
	                    layerId: layer_id,
	                    layer_id: layer_id
	                }));
	            }
	            else if (updateParam.layers == 'Satellite') {
	                _mapObj.getLayers().insertAt(0, tiandiMap.createSatelliteLayer({
	                    mapId: mapId,
	                    layerId: layer_id,
	                    layer_id: layer_id
	                }));
	            }
	            else {
	                _mapObj.getLayers().insertAt(0, tiandiMap.createRoadLayer({
	                    mapId: mapId,
	                    layerId: layer_id,
	                    layer_id: layer_id
	                }));
	            }

	            _mapObj.getLayers().insertAt(1, tiandiMap.createMarkerLayer({
	                mapId: mapId,
	                layerId: layer_id + '_marker',
	                layer_id: layer_id
	            }));
	            break;

		         //增加arcgisLayer图层
	         case constant.MAPTYPE.ARCGISTILE_LAYER:
	         	_mapObj.getLayers().insertAt(0, arcgisTileLayer.createArcgisTileLayer({
	         		mapId: mapId,
	         		layerId: layer_id,
	         		layer_id: layer_id,
	         		url: updateParam.url
	         	}));
	         	break;

	        case constant.MAPTYPE.GOOGLE_MAP:
	            if (!!updateParam && !!updateParam.key) {
	                googleMap.loadGoogleAPI(updateParam.key, updateParam.language, function (isTrue) {
	                    if (isTrue) {
	                        if (window.sessionStorage) {
	                            sessionStorage.setItem("key", updateParam.key);
	                        }
	                        googleMap.createCustomMap(updateParam);

	                        mapType.mapTypeToolbar({
	                            mapObj: _mapObj,
	                            mapType: constant.MAPTYPE.GOOGLE_MAP
	                        });
	                    }
	                });
	            }
	            else {
	                console.warn('load google api failed...');
	            }
	            break;
	        case constant.MAPTYPE.BAIDU_MAP:
	            mapType.mapTypeToolbar({
	                mapObj: _mapObj,
	                mapType: constant.MAPTYPE.BAIDU_MAP
	            });
	            _mapObj.getLayers().insertAt(0, bDuMap.createLayer({
	                mapId: mapId,
	                layerId: layer_id,
	            	layer_id: layer_id
	            }));
	            break;
	        case constant.MAPTYPE.GOOGLE_ROAD_MAP:
	            mapType.mapTypeToolbar({
	                mapObj: _mapObj,
	                mapType: constant.MAPTYPE.GOOGLE_ROAD_MAP
	            });
	            _mapObj.getLayers().insertAt(0, xyzGoogleRoad.createLayer({
	                mapId: mapId,
	                layerId: layer_id,
	                layer_id: layer_id
	            }));
	            break;
	        case constant.MAPTYPE.GAODE_MAP:
				if (!!updateParam && !!updateParam.key) {
	                gaodeMap.loadGaodeAPI(updateParam.key, updateParam.language, function (isTrue) {
	                    if (isTrue) {
	                        if (window.sessionStorage) {
	                            sessionStorage.setItem("key", updateParam.key);
	                        }
	                        gaodeMap.createCustomMap(updateParam);

	                        mapType.mapTypeToolbar({
	                            mapObj: _mapObj,
	                            mapType: constant.MAPTYPE.GAODE_MAP,
	                            gaodeMapKey : updateParam.key
	                        });
	                    }
	                });
	            }
	            else {
	                console.warn('load gaode api failed...');
	            }
	            break;
	        case constant.MAPTYPE.YAHOO_MAP:
	            mapType.mapTypeToolbar({
	                mapObj: _mapObj,
	                mapType: constant.MAPTYPE.YAHOO_MAP
	            });
	            _mapObj.getLayers().insertAt(0, yahooMapLayer.createLayer({
	                mapId: mapId,
	                layerId: layer_id,
	                layer_id: layer_id
	            }));
	            break;
	        default :
	            mapType.mapTypeToolbar({
	                mapObj: _mapObj,
	                mapType: constant.MAPTYPE.OSM_MAP
	            });
	            _mapObj.getLayers().insertAt(0, osmMap.createLayer({
	                mapId: mapId,
	                layerId: layer_id,
	                layer_id: layer_id
	            }));
	    }
	    if (window.sessionStorage) {
	        sessionStorage.setItem("mapType", updateParam.mapType);
	    }
	};

	function _updateLayers(updateParam) {
	    var mapId = updateParam.mapId;
	    var _mapObj = mapBox.getMapObj(mapId);
	    var originParam = _mapObj.get('paramObj');
	    updateParam = utils.extend({}, originParam, updateParam);
	    //如果更新前后mapType不一样，那么就会创建新的底图，创建过程中layers已经更新，
	    // 因此可以直接返回
	    if (originParam.mapType !== updateParam.mapType) {
	        return;
	    }

	    if (updateParam.mapType === constant.MAPTYPE.BING_MAP) {
	        var layer_id = constant.MAPPROPERTY.BASE_LAYER_ID;
	        olUtil.removeLayer({
	            mapId: mapId,
	            layer_id: layer_id
	        });

	        var layer = bingMap.createLayer({
	            mapId: mapId,
	            layerId: updateParam.layerId,
	            layer_id: layer_id,
	            key: updateParam.key,
	            layers: updateParam.layers
	        });
	        _mapObj.addLayer(layer);
	    }

	    if (updateParam.mapType === constant.MAPTYPE.GOOGLE_MAP) {
	        googleMap.updateCustomMap(updateParam);
	    }

		if (updateParam.mapType === constant.MAPTYPE.GAODE_MAP) {
	        gaodeMap.updateCustomMap(updateParam);
	    }
	}

	/**
	 *
	 * @param updateParam
	 *        参考{
	             *              center: Array 地图的中心点信息
	             *              defaultZoom: number 地图默认级别
	             *              minZoom: number 地图最小级别
	             *              maxZoom: number 地图最大级别
	             *              proj: String 投影坐标 地图的投影坐标系
	             *              mapId: String 地图DIV 地图Div
	             *              mapType: String 地图类型 地图地图类型
	             *              layerId: String 基本图层图层名称 地图地图图层名称
	             *              url: String 基本图层服务URL
	             *              controls: Array 默认控件
	             *           }
	 */
	var updateMap = function (updateParam) {
	    var updateFun = {
	        center: _updateView,
	        defaultZoom: _updateView,
	        minZoom: _updateView,
	        maxZoom: _updateView,
	        proj: _updateProj,
	        mapType: _updateBaseLayer,
	        layers: _updateLayers,
	        controls: _updateControls
	    };
	    for (var o in updateParam) {
	        if (updateFun.hasOwnProperty(o) && !!updateFun[o] && typeof updateFun[o] === 'function') {
	            updateFun[o](updateParam);
	        }
	    }
	    var mapId = updateParam.mapId;
	    var _mapObj = mapBox.getMapObj(mapId);
	    _mapObj.set('currentMapType', updateParam.mapType);
	    new utils.sessionStorageObj().set('currentMapType', updateParam.mapType);
	    var originParam = _mapObj.get('paramObj');
	    updateParam = utils.extend({}, originParam, updateParam);
	    _mapObj.set('paramObj', updateParam);
	    
	   if (_mapObj) {
	   		var _controls = _mapObj.get('paramObj').controls;
	    	if (_controls != undefined &&  _controls.hasOwnProperty('overviewMap')) {
	    		setTimeout(function() {
	    			overMap.addMinMap(_mapObj.get('paramObj'));
	    		}, 3000);
	    	}
	    }

	};

	/**
	 * 获取当前所有的地图对象或地图对象ID
	 * @param type 'id/map'
	 */
	function getMapList(type) {
	    var keys = hashMap.keys;
	    var mapList = [];
	    keys.forEach(function (key) {
	        var obj = hashMap.get(key);
	        if (obj instanceof ol.Map) {
	            if (type === 'map' || !type) {
	                mapList.push(obj);
	            }
	            else if (type === 'id') {
	                mapList.push(key);
	            }
	        }
	    });
	    return mapList;
	}

	/**
	 * 判断地图是否存在
	 * @param mapId
	 * @returns {boolean|*}
	 * todo:修改接口返回值，之前总是返回false 2016-12-16  rWX330535
	 */
	function isMapExist(mapId) {
	    var _isMapExist = fusiongis.HashMap.containsKey(mapId);
	    return _isMapExist;
	}

	function setZoomVisible(param) {
	    var mapDiv = document.getElementById(param.mapId);
	    var divDoms = mapDiv.getElementsByTagName('div');
	    for (var i in divDoms) {
	        if (divDoms[i].className == 'vGisWeb_olZoom_custom ol-unselectable ol-control') {
	            var _div = divDoms[i];
	        }
	    }
	    if (param.showZoom) {
	        _div.style.display = 'block';
	    } else {
	        _div.style.display = 'none';
	    }

	}
	function mapTypeVisible(mapId, flag) {
	    var mDiv = document.getElementById(mapId);
	    var barDiv = mDiv.getElementsByClassName('map_type_toolbar_container')[0];
	    if (flag) {
	        barDiv.style.display = 'block';
	    } else {
	        barDiv.style.display = 'none';
	    }

	}

	var getCurrentMapInfo = function (callback) {
	    ajax.postJSON({
	        url: fusiongis.Constant.GisRootUrl + '/mapCfgView.do',
	        data: JSON.stringify({
	            subject: {
	                param: {},
	                formatter: {
	                    date: ''
	                }
	            },
	            services: [
	                {
	                    name: 'getMapSource',
	                    param: {}
	                }
	            ]
	        }),
	        success: function (result) {
	            if (!!result) {
	                var _result = JSON.parse(result);
	                if (!!_result && _result.status.code === 1 && !!_result.data) {
	                    var _data = _result.data;
	                    var format_ = _data.mapFormat;
	                    var _key = utils.htmlDecode(_data && _data.mapService);
	                    var _url = utils.htmlDecode(_data && _data.mapService);
	                    var _layers = _data && _data.mapLayer;
	                    var _mapName = utils.htmlDecode(_data && _data.mapName);
	                    var _mapType = undefined;

	                    if (format_ === 3 || format_ === 4 || format_ === 5 || format_ === 9 || format_ === 20) {
	                        _mapType = constant.MAPTYPE.WMS_MAP;
	                    } else if (_result.data.mapFormat === 101) {
	                        _mapType = constant.MAPTYPE.OSM_MAP;
	                    } else if (_result.data.mapFormat === 102) {
	                        _mapType = constant.MAPTYPE.GOOGLE_MAP;
	                    } else if (_result.data.mapFormat === 103) {
	                        _mapType = constant.MAPTYPE.BING_MAP;
	                    } else if (_result.data.mapFormat === 105) {
	                        _mapType = constant.MAPTYPE.HUAWEI_MAP;
	                    } else if(_result.data.mapFormat === 106){
	                        _mapType = constant.MAPTYPE.TIANDI_MAP;
	                    } else if(_result.data.mapFormat === 107){
	                    	_mapType = constant.MAPTYPE.ARCGISTILE_LAYER;
	                    }
	                    else {
	                        _mapType = constant.MAPTYPE.OSM_MAP;
	                    }

	                    if (_result.data.mapFormat === 20) {
	                        //自定义地图导入使用
	                        _url = fusiongis.Constant.GisRootUrl + '/offlineMap/customServer?MAPNAME=' + _mapName + '&LAYERS=' + _layers;
	                    } else if (_result.data.mapFormat === 3) {
	                        //planetServer使用
	                        _url = fusiongis.Constant.GisRootUrl + '/offlineMap/planetServer';
	                        _mapName = undefined;
	                    } else if (_result.data.mapFormat === 4) {
	                        //shapeServer使用
	                        _url = fusiongis.Constant.GisRootUrl + '/offlineMap/shapeServer';
	                        _mapName = undefined;
	                    } else if (_result.data.mapFormat === 5) {
	                        //高铁使用
	                        _url = fusiongis.Constant.GisRootUrl + '/offlineMap/RailwayServer';
	                        _mapName = undefined;
	                    } else if (_result.data.mapFormat === 9) {
	                        //DC融合使用
	                        _url = fusiongis.Constant.GisRootUrl + '/offlineMap/customMap?MAPNAME=' + _mapName + '&LAYERS=' + _layers;
	                    }


	                    if (!!callback && typeof callback == 'function') {
	                        var _center = undefined;
	                        var _zoom = undefined;
	                        (function(){
	                            if (!!_result.data && !!_result.data.centerPoint) {
	                                if (!!_result.data.centerPoint.zoom) {
	                                    _zoom = _result.data.centerPoint.zoom;
	                                }

	                                if (!!_result.data.centerPoint.longitude && !!_result.data.centerPoint.latitude) {
	                                    _center = [_result.data.centerPoint.longitude,_result.data.centerPoint.latitude];
	                                }
	                            }
	                        }());

	                        callback({
	                            status: 1,
	                            message: 'get current map information success!',
	                            mapType: _mapType,
	                            mapFormat:format_,
	                            url: _url,
	                            key: _key,
	                            layers: !!_layers ? _layers : [],
	                            mapName: !!_mapName ? _mapName : undefined,
	                            center: _center,
	                            zoom: _zoom
	                        })
	                    }
	                }
	                else {
	                    if (!!callback && typeof callback == 'function') {
	                        callback({
	                            status: 0,
	                            message: result
	                        })
	                    }
	                }

	            }
	        },
	        failure: function(result) {
	        	console.log('%c get current map information fail----mapCfgView.do', 'font-size: 12px;color: red;')
	        }
	    });
	};
	/********************************
	*加载图层初始化图层显隐控制
	**********************************/
	function layerVisibleInit(mapId) {
	    var mapObj = mapBox.getMapObj(mapId);
	    if(mapObj===undefined){
	        return ;
	    }
	    var layerList = mapObj.getLayers().getArray();
	    layerList.forEach(function(layer) {
	        if (layer instanceof ol.layer.Layer) {
	            layerVisibleController(mapObj, layer);
	        }
	    })
	}
	/*****************************************************************************
	*控制业务图层根据级别进行显示
	*如果图层配置了最大、最小显示级别，那么图层管理器里面的选择状态需要和用户设置的保持一致;
	*如果图层没有设置最大、最小显示级别，那么图层的显示、隐藏由图层管理器里面用户的选择与否决定;
	*如果用户设置了初始图层隐藏，同时也设置了图层级别控制，默认的isShow优先级高；
	******************************************************************************/
	function layerVisibleController(_mapObj, _layer) {
		//isShow
		var _isShow = _layer.get('isShow');
		var _layerAttrUiShow = _layer.get('ui_isShow');
		var _ui = _mapObj.get('paramObj').UI;//discovery,如果是discovery,说明用户不使用我们的里层管理器，需要特殊处理
		var _discovery = _layer.get('discovery');
		var _layerManagerCheckBoxClick = _layer.get('layerManagerCheckBoxClick');//图层管理器里面用户对图层进行了显隐干扰
		var _currentZoom = _mapObj.getView().getZoom();


		if (_layerManagerCheckBoxClick != undefined) {//用户已经干扰图层显隐
			_layer.setVisible(_layerManagerCheckBoxClick);
			if (_layerManagerCheckBoxClick == false) {//用户在图层管理器里面点击复选框，如果图层隐藏了，终止后续操作
				if (_layerAttrUiShow == false) {
					if(!!_mapObj.getTargetElement()) {
						var layerItems = _mapObj.getTargetElement().querySelectorAll('.vGisWeb_component .layerItem');
						if(!!layerItems && layerItems.length > 0) {
							for(var i = 0; i < layerItems.length; i++) {
								var _layerItem = layerItems[i];
								var itemCheckBox = !!_layerItem && _layerItem.querySelectorAll('.visible_check')[0];
								if(_layer.get('layer_id') === itemCheckBox.layerId) {
									_layerItem.querySelectorAll('.visible_check')[0].checked = _layerAttrUiShow;
								}
							}
						}
					}
					return;
				}
				return;
			}
		}
		else if (_isShow != undefined) {
			_layer.setVisible(_isShow);

			if (_ui == 'discovery') {
				if (_discovery == false) {
					//如果用户没用调用我们的图层管理器，并且用户通过调用我们的setVisible将图层隐藏了，那么我们需要将后面通过图层级别控制图层显隐的逻辑跳过
					_layer.setVisible(false);
					return;
				}
			}


			if (!_isShow) {//isShow==false时，后续操作终止
				if(!!_mapObj.getTargetElement()) {
					var layerItems = _mapObj.getTargetElement().querySelectorAll('.vGisWeb_component .layerItem');
					if(!!layerItems && layerItems.length > 0) {
						for(var i = 0; i < layerItems.length; i++) {
							var _layerItem = layerItems[i];
							var itemCheckBox = !!_layerItem && _layerItem.querySelectorAll('.visible_check')[0];
							if(_layer.get('layer_id') === itemCheckBox.layerId) {
								_layerItem.querySelectorAll('.visible_check')[0].checked = _isShow;
							}
						}
					}
				}
				return;
			}
		}


		//用户通过缩放事件配置的图层显隐
		if(_layerAttrUiShow != undefined) {
			_layer.setVisible(_layerAttrUiShow);
			//如果事件里面配置的图层显示、或者隐藏，以下代码将对图层管理器里面的checkbox状态进行更新；
			//minShowLevel/maxShowLevel/_layerAttrIsShow里面的代码也不执行；
			if(!!_mapObj.getTargetElement()) {
				var layerItems = _mapObj.getTargetElement().querySelectorAll('.vGisWeb_component .layerItem');
				if(!!layerItems && layerItems.length > 0) {
					for(var i = 0; i < layerItems.length; i++) {
						var _layerItem = layerItems[i];
						var itemCheckBox = !!_layerItem && _layerItem.querySelectorAll('.visible_check')[0];
						if(_layer.get('layer_id') === itemCheckBox.layerId) {
							_layerItem.querySelectorAll('.visible_check')[0].checked = _layerAttrUiShow;
						}
					}
				}
			}
			return;
		}

		if (_ui == 'discovery') {
			if (_discovery == false) {
				//如果用户没用调用我们的图层管理器，并且用户通过调用我们的setVisible将图层隐藏了，那么我们需要将后面通过图层级别控制图层显隐的逻辑跳过
				return;
			}
		}


		//minShowLevel/maxShowLevel/undefined
		var _minShowLevel = 0;
		var _maxShowLevel = (function(map) {
			var maxZoom = constant.MAPPROPERTY.DEFAULT_MAX_ZOOM;
			if (map.get('paramObj').maxZoom != undefined) {
				maxZoom = parseInt(map.get('paramObj').maxZoom); 
			}
			return maxZoom;
		}(_mapObj));
		var isVisible = false;
		if(isNaN(_layer.get('minShowLevel')) || _layer.get('minShowLevel') == undefined) {
			_minShowLevel =  constant.MAPPROPERTY.DEFAULT_MIN_ZOOM;
		} else {
			_minShowLevel =  _layer.get('minShowLevel');
		}

		if(isNaN(_layer.get('maxShowLevel')) || _layer.get('maxShowLevel') == undefined) {
			_maxShowLevel =  _maxShowLevel;
		} else {
			_maxShowLevel =  _layer.get('maxShowLevel');
		}

		if(_minShowLevel <= _currentZoom && _currentZoom <= _maxShowLevel) {
			isVisible = true;
		}
		_layer.setVisible(isVisible);

		if (_ui == 'discovery') {
	          return;
		}


		if(!!_mapObj.getTargetElement()) {
			var layerItems = _mapObj.getTargetElement().querySelectorAll('.vGisWeb_component .layerItem');
			if(!!layerItems && layerItems.length > 0) {
				for(var i = 0; i < layerItems.length; i++) {
					var _layerItem = layerItems[i];
					var itemCheckBox = !!_layerItem && _layerItem.querySelectorAll('.visible_check')[0];
					var layerId = itemCheckBox.layerId;
					var _isChecked = _layerItem.querySelectorAll('.visible_check')[0].checked;
					var _minLev = _layer.get('minShowLevel');
					var _maxLev = _layer.get('maxShowLevel');
					if(_layer.get('layer_id') === layerId) {
						if((_minLev == undefined && _maxLev == undefined) || isNaN(_minLev) && isNaN(_maxLev)) {
							if(_isChecked == false) {
								_layer.setVisible(false);
							}
						} else {
							_layerItem.querySelectorAll('.visible_check')[0].checked = isVisible;
						}
					}
				}
			}
		}
	}

	var removeAttributionContrl = function(mapId){
	    var _mapObj = hashMap.get(mapId);
	    if(!!_mapObj){
	        var _mapControls = _mapObj.getControls().getArray();
	        _mapControls.forEach(function(control){
	            if(control instanceof ol.control.Attribution){
	                _mapObj.removeControl(control)
	            }
	        })
	    }
	};

	module.exports = {
	    createMap: createMap,
	    destroyCustomMap: destroyCustomMap,
	    getMapObj: mapBox.getMapObj,
	    removeMap: removeMap,
	    setMapCenter: setMapCenter,
	    getZoom: getZoom,
	    getExtent: getExtent,
	    getCenter: getCenter,
	    setExtent: setExtent,
	    refreshMaps: refreshMaps,
	    mapAssociate: multiMap.mapAssociate,
	    getMapList: getMapList,
	    isMapExist: isMapExist,
	    updateMap: updateMap,
	    setZoomVisible: setZoomVisible,
	    mapTypeVisible: mapTypeVisible,
	    getOffLineMapUrls: getOffLineMapUrls,
	    getCurrentMapInfo: getCurrentMapInfo,
	    removeAttributionContrl: removeAttributionContrl,
	    layerVisibleInit:layerVisibleInit
	};

/***/ },
/* 9 */
/*!************************************!*\
  !*** ./src/gis/framework/popup.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var domUtil = __webpack_require__(/*! utils/domUtil */ 10);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var util = __webpack_require__(/*! utils/util */ 1);

	var _overLayers = [];
	var _suspensionOverLayer = null;
	var _menuOverlay = null;

	/**
	 * 地图上添加弹出框
	 * @param options
	 */
	var addPopup = function (options) {

	    var _content = options.content;
	    if (options.position == undefined) {
	    	return;
	    }
	    var _position4326 =util.gcjTransform(options.position);
	    var _position =ol.proj.fromLonLat(_position4326);
	    var _mapId = options.mapId;
	    var _showCloseButton = options.showCloseButton === undefined? true:options.showCloseButton;


	    var _containerId = 'ol-popupContainer-id' + _mapId;

	    var oldPopupContainer = domUtil.getDom(_containerId);
	    if (oldPopupContainer) {
	        oldPopupContainer.parentNode.removeChild(oldPopupContainer);
	    }
	    
	    var _cls = options.radius == undefined ? 'ol-popupContainer-class-radius' : 'ol-popupContainer-class';
	    var popupContainer = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            'id': _containerId,
	            'class': _cls
	        }
	    });

	    var popupClose = domUtil.createDom({
	        tagName: 'a',
	        attributes: {
	            'id': 'ol-popupClose-id',
	            'class': 'ol-popupClose-class',
	            'href': '#'
	        }
	    });

	    var popupContent = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            'id': 'ol-popupContent-id'
	        }
	    });

	    if (!!_content) {
	        if (typeof _content === 'string') {
	            popupContent.innerHTML = _content;
	        }
	        else if (typeof _content === 'object') {
	            popupContent.appendChild(_content);
	        }
	    }

	    popupContainer.appendChild(popupClose);
	    popupContainer.appendChild(popupContent);
	    document.body.appendChild(popupContainer);
	    if(_showCloseButton){
	        popupClose.style.display='block';
	    }else{
	        popupClose.style.display='none';
	    }
	    
	    var overLay = new ol.Overlay(({  
			  element: popupContainer,
			  autoPan: true,  
			  autoPanAnimation: {  
				duration: 250  
			  },
			  autoPanMargin: 15
		})); 
	    
	    overLay.featureCenter = _position;
	    overLay.mapId = _mapId;
	    overLay.set('type', 'popup_in_frame_folder');
	    removePopup(_mapId);
	    mapBox.getMapObj(_mapId).addOverlay(overLay);
	    _overLayers.push(overLay);

	    popupContainer.style.display = 'block';
	    popupClose.style.position = 'absolute';
	    popupClose.style.top = '2px';
	    popupClose.style.right = '8px';

	    popupClose.onclick = function () {
	        removePopup(_mapId);
	    };
		overLay.setPosition(_position);
	    return overLay;
	};

	/**
	 * 增加悬浮弹出框
	 * @param options
	 */
	var addSuspensionPopup = function (options) {

	    var _content = options.content;
	    var _position4326= util.gcjTransform(options.position);
	    var _position = ol.proj.fromLonLat(_position4326);
	    var _mapId = options.mapId;

	    var _containerId = 'ol-susPopupContainer-id' + _mapId;

	    var oldPopupContainer = domUtil.getDom(_containerId);
	    if (oldPopupContainer) {
	        oldPopupContainer.parentNode.removeChild(oldPopupContainer);
	    }
	    var popupContainer = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            'id': _containerId,
	            'class': 'ol-susPopupContainer-class'
	        }
	    });

	    var popupContent = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            'id': 'ol-susPopupContent-id'
	        }
	    });

	    if (typeof _content === 'string') {
	        popupContent.innerHTML = _content;
	    }
	    else {
	        popupContent.appendChild(_content);
	    }

	    popupContainer.appendChild(popupContent);
	    document.body.appendChild(popupContainer);

	    if (!!_suspensionOverLayer) {
	        mapBox.getMapObj(_mapId).removeOverlay(_suspensionOverLayer);
	    }
	    var overLay = new ol.Overlay({
	        element: popupContainer,
	        position: _position,
	        mapId: _mapId,
	        autoPan: true,  
			autoPanAnimation: {  
				duration: 250  
			},
			autoPanMargin: 15
	    });

	    mapBox.getMapObj(_mapId).addOverlay(overLay);
	    _suspensionOverLayer = overLay;

	    popupContainer.style.display = 'block';
	};

	/**
	 * 移除弹出框
	 */
	var removePopup = function (mapId) {
	    if (_overLayers && _overLayers.length > 0) {
	        _overLayers.forEach(function (overlay, index, _overLayers) {
	            if (overlay != undefined &&  overlay.mapId === mapId) {
	            	if (overlay.get('type') == 'popup_in_frame_folder') {
	            		mapBox.getMapObj(mapId).removeOverlay(overlay);
	            		_overLayers.splice(index, 1);
	            	}
	            }
	        });
	    }
	};

	/**
	 * 移除悬浮弹出框
	 */
	var removeSuspensionPopup = function (mapId) {
	    if (_suspensionOverLayer) {
	        mapBox.getMapObj(mapId).removeOverlay(_suspensionOverLayer);
	    }
	};

	/**
	 * 鼠标右键菜单
	 * @param paramObj
	 */
	var addContextMenu = function (paramObj) {
	    var _coordinate4326 = util.gcjTransform(paramObj.position);
	    var _coordinate = ol.proj.fromLonLat(_coordinate4326);
	    var _mapId = paramObj.mapId;
	    var _mapObj = mapBox.getMapObj(_mapId);
	    var _element = paramObj.element;

	    _menuOverlay = new ol.Overlay({
	        element: _element,
	        positioning: 'top-left',
	        position: _coordinate,
	        autoPan: true,  
			autoPanAnimation: {  
				duration: 250  
			},
			autoPanMargin: 15
	    });
	    _menuOverlay.setMap(_mapObj);

	    fusiongis.Events.addClickCallback(_mapId, 'popup-click-event', function () {
	        _menuOverlay.setPosition(undefined);
	    });
	};

	var removeContextMenu = function () {
	    if (!!_menuOverlay) {
	        _menuOverlay.setPosition(undefined);
	    }
	};

	module.exports = {
	    addPopup: addPopup,
	    removePopup: removePopup,
	    getPopups: function () {
	        return _overLayers;
	    },
	    addSuspensionPopup: addSuspensionPopup,
	    removeSuspensionPopup: removeSuspensionPopup,
	    addContextMenu: addContextMenu,
	    removeContextMenu: removeContextMenu
	};


/***/ },
/* 10 */
/*!**********************************!*\
  !*** ./src/gis/utils/domUtil.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var util = __webpack_require__(/*! utils/util */ 1);

	var getDom = function (attr) {
	    if (attr.substring(0, 1) === '.') {
	        return document.getElementsByClassName(attr.substring(1));
	    }
	    return document.getElementById(attr);
	};

	var createDom = function (paramObj) {
	    var _tagName = paramObj.tagName,
	        _attributes = paramObj.attributes,
	        _text = paramObj.text;

	    var element = document.createElement(_tagName);
	    for (var attr in _attributes) {
	        element.setAttribute(attr, _attributes[attr]);
	    }

	    if (_text != undefined) {
	        element.innerHTML = _text;
	    }

	    return element;
	};

	function on(obj, types, fn) {
	    obj.addEventListener(types, fn);
	}

	function off(obj, types, fn) {
	    obj.removeEventListener(types, fn);
	}

	/**
	 * 扩展外部传入的Dom节点。
	 * @paramObj {Object}
	 *  paramObj.mapId {string}
	 *
	 */
	var appendExtendNode = function (paramObj) {
	    var _mapId = paramObj.mapId;
	    var _dom = paramObj.dom;
	    var _top = undefined;
	    var _bottom = undefined;
	    var _left = undefined;
	    var _right = undefined;

	    var _position = ( function () {
	        if (!!paramObj.style) {
	            var _style = paramObj.style;
	            _top = _style.top + 'px' || undefined;
	            _bottom = _style.bottom + 'px' || undefined;
	            _right = _style.right + 'px' || undefined;
	            _left = _style.left + 'px' || undefined;
	        }
	        var _lbrt = [];
	        if (!!_top) {
	            _lbrt.push('top: ' + _top);
	        }

	        if (!!_bottom) {
	            _lbrt.push('bottom: ' + _bottom);
	        }
	        if (!!_right) {
	            _lbrt.push('right: ' + _right);
	        }
	        if (!!_left) {
	            _lbrt.push('left: ' + _left);
	        }
	        return _lbrt.join(';') + ';';
	    }());

	    var _olMap = !!_mapId && hashMap.get(_mapId);
	    var isLoadedMap = (function () {
	        if (!!_olMap && _olMap instanceof ol.Map) {
	            return true;
	        }
	        else {
	            console.error('map init failed, please load map before!!!');
	            return false;
	        }
	    }());

	    if (!!isLoadedMap) {
	        var _mapTargetElement = _olMap.getTargetElement();
	        var mapChildDiv = createDom({
	            tagName: 'div',
	            attributes: {
	                id: util.getUUID(),
	                style: 'position: absolute;z-index: 1000;' + _position
	            }
	        });
	        _mapTargetElement.appendChild(mapChildDiv);

	        if (!!_dom) {
	            mapChildDiv.appendChild(_dom);
	        }
	    }
	};

	module.exports = {
	    on: on,
	    off: off,
	    getDom: getDom,
	    createDom: createDom,
	    appendExtendNode: appendExtendNode
	};

/***/ },
/* 11 */
/*!*******************************!*\
  !*** ./src/gis/maps/event.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var popup = __webpack_require__(/*! tools/popup */ 12);
	var popupInFrame = __webpack_require__(/*! framework/popup */ 9);
	var i18n = __webpack_require__(/*! utils/i18n */ 13);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var ajax = __webpack_require__(/*! utils/ajax */ 14);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var discoveryEvent = __webpack_require__(/*! maps/eventDC */ 15);
	var overlapEvent = __webpack_require__(/*! maps/eventMultiFeature */ 17);
	var noOverLap = __webpack_require__(/*! maps/eventSingleFeature */ 18);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var closeDrawAndMeasure = olUtil.closeDrawAndMeasure;
	var transformLonLat = olUtil.transformLonLat;

	function registerZoomChange(params) {
		var olMap = mapBox.getMapObj(params.mapId);
		if (!olMap) {
			return;
		}
		var callbackList = olMap.get('zoomCallbackList');
		var func = params.callbackfunc;
		if (func && typeof func === 'function') {
			if (params.id) {
				func.id = params.id;
			}
			if (callbackList) {
				callbackList.push(params.callbackfunc);
			}
		}
	}

	function zoomChangeEvent(olMap) {
		if (!!!olMap.get('zoomCallbackList')) {
			olMap.set('zoomCallbackList', []);
		}

		olMap.getView().on('change:resolution', function(evt) {
			var view = evt.target;
			var mapIds = view.get('linkedMapIds');
			if (!mapIds) {
				return;
			}
			mapIds.forEach(function(_mapId) {
				var param = {
					mapId: _mapId,
					zoom: view.getZoom(),
					lonLat: ol.proj.toLonLat(view.getCenter())
				};
				var currentMap = mapBox.getMapObj(_mapId);
				if (currentMap) {
					var zoomCallbackList = currentMap.get('zoomCallbackList');
					zoomCallbackList.forEach(function(callback) {
						callback(param, evt);
					});
				}
			});

		});

	}

	function registerCenterChange(params) {
		var olMap = mapBox.getMapObj(params.mapId);
		if (!olMap) {
			return;
		}
		var callbackList = olMap.get('centerCallbackList');
		var func = params.callbackfunc;
		if (func && typeof func === 'function') {
			if (params.id) {
				func.id = params.id;
			}
			if (callbackList) {
				callbackList.push(params.callbackfunc);
			}
		}
	}

	function centerChangeEvent(olMap) {
		if (!olMap) {
			return;
		}
		if (!!!olMap.get('centerCallbackList')) {
			olMap.set('centerCallbackList', []);
		}

		olMap.getView().on('change:center', function(evt) {
			var view = evt.target;
			var idList = view.get('linkedMapIds');
			idList.forEach(function(_mapId) {
				var param = {
					mapId: _mapId,
					lonLat: ol.proj.toLonLat(olMap.getView().getCenter())
				};
				var currentMap = mapBox.getMapObj(_mapId);
				if (currentMap) {
					var callbackList = currentMap.get('centerCallbackList');
					callbackList.forEach(function(callback) {
						callback(param, evt);
					});
				}
			});
		});

	}

	/**
	 * 四方在编排 toolBar时，会调用次接口将需要执行的动作和按钮进行绑定，最终执行动作在gis内部
	 * @param param
	 */
	var registerDomEvent = function(param) {
		var _mapId = param.mapId;
		var _callback = param.callback;
		var _mapObj = mapBox.getMapObj(_mapId);
		if (!!_mapObj) {
			var _toolbarContainer = _mapObj.getTargetElement().querySelector('.toolbar-container');
			if (!!_toolbarContainer) {
				_toolbarContainer.onclick = function(event) {
					var _target = event.target;
					var mapId = '';
					if (_target.className.indexOf('Gray') !== -1 || _target.className.indexOf('exportData') !== -1) {
						mapId = _target.parentElement.parentElement.parentElement.id;
					} else {
						mapId = _target.parentElement.parentElement.id;
					}

					if (!!_callback && typeof _callback === 'function') {
						_callback({
							mapId: mapId,
							domId: _target.classList[_target.classList.length - 1]
						})
					}
				};
			}
		}

	};



	function mapClick(mapId, initMapParam) {
		if (initMapParam.eventDC != undefined) {
			//discovery special
			discoveryEvent.mapClick(mapId, initMapParam);
		}
		else if (initMapParam.productType != undefined) {
			//only process top 1 feature on layer.
			noOverLap.mapClick(mapId);//只处理最上层的元素点击，有多元素重叠时不处理
		}
		else {
			//return all feature At current Pixel, and list all feature use popup, you will select one option to do  callbackfunction.
			overlapEvent.mapClick(mapId, initMapParam);//多元素重叠事件处理
		}
		
	}

	function mapUnClick(mapId) {
		var mapObj = mapBox.getMapObj(mapId);
		if (mapObj.get('clickHandle')) {
			mapObj.unByKey(mapObj.get('clickHandle'));
			mapObj.set('clickHandle', null);
		}
	}

	function addClickCallback(mapId, clickId, callback, layerId) {
		var mapObj = mapBox.getMapObj(mapId);
		if (clickId !== undefined && typeof callback == 'function') {
			if (!!mapObj.get('callbackList')) {
				mapObj.get('callbackList')[clickId.toString()] = callback;
			}
			var layerObj = (function() {
				if (layerId) {
					return hashMap.get(layerId + '_' + mapId);
				}
			}());
			if (!!mapObj.get('eventKeyANDEventLayerObj')) {
				mapObj.get('eventKeyANDEventLayerObj')[clickId.toString()] = layerObj;
			}
		}
	}

	function removeClickCallback(mapId, clickId) {
		var mapObj = mapBox.getMapObj(mapId);
		if (clickId !== undefined && mapObj.get('callbackList') != undefined) {
			delete mapObj.get('callbackList')[clickId.toString()];
			delete mapObj.get('eventKeyANDEventLayerObj')[clickId.toString()];
		}
	}




	module.exports = {
		zoomChangeEvent: zoomChangeEvent,
		centerChangeEvent: centerChangeEvent,
		onZoomChange: registerZoomChange,
		onCenterChange: registerCenterChange,
		registerDomEvent: registerDomEvent,

		//map click
		mapClick: mapClick,
		mapUnClick: mapUnClick,
		addClickCallback: addClickCallback,
		removeClickCallback: removeClickCallback
	};

/***/ },
/* 12 */
/*!********************************!*\
  !*** ./src/gis/tools/popup.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);

	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var domUtil = __webpack_require__(/*! utils/domUtil */ 10);

	function getMap(mapId) {
	    return mapBox.getMapObj(mapId);
	}

	/**
	 * 根据名字获取overlay
	 * @param mapId
	 * @param ovName
	 */
	function getOverlayByName(mapId, ovName) {
	    var overlays = getMap(mapId).getOverlays().getArray();
	    return utils.find(overlays, function (item) {
	        return item.get('name') === ovName;
	    });
	}

	function setPageOffset(el, x, opt_y) {
	    // Get current pageoffset
	    var cur = el.getBoundingClientRect();

	    // Work out deltas
	    var dx = x - cur.left;
	    var dy = opt_y - cur.top;

	    // Set position to current left/top + delta
	    el.style.left = el.offsetLeft + dx + 'px';
	    el.style.top = el.offsetTop + dy + 'px';
	}

	function PopOver(options) {
	    //处理如果没有点击到图层上而是点击到地图的空白处不弹框
	    if(isNaN(options.position[0]) && isNaN(options.position[1])){
	        return;
	    }
	    this.setOptions(options);
	    this.setElement();

	}

	PopOver.prototype.setOptions = function (options) {
	    this.options = options;
	    this.title = options.title ? options.title : '';
	};

	PopOver.prototype.setElement = function () {
	    var rootElement = document.createElement('div');
	    rootElement.className = 'gisCovery-popup';
	    rootElement.style.minWidth = '100px';

	    var headerElement = document.createElement('div');
	    headerElement.className = 'gisCovery-popup-header';

	    var titleElement = document.createElement('div');
	    titleElement.className = 'gisCovery-popup-title';
	    titleElement.innerHTML = this.title;
	    headerElement.appendChild(titleElement);

	    var closeElement = document.createElement('div');
	    closeElement.className = 'gisCovery-popup-close';
	    closeElement.innerHTML = '✖';
	    headerElement.appendChild(closeElement);

	    var cElement = document.createElement('div');
	    cElement.className = 'gisCovery-popup-content';
	    if (this.options.contentClass) {
	        cElement.classList.add(this.options.contentClass);
	    }
	    if (this.options.contentId) {
	        cElement.id = this.options.contentId;
	    }
	    if (typeof this.options.content === 'string') {
	        cElement.innerHTML = this.options.content;
	    }
	    else {
	        cElement.appendChild(this.options.content);
	    }
	    var arrowElement = document.createElement('div');
	    arrowElement.className = 'gisCovery-popup-arrow';

	    rootElement.appendChild(headerElement);
	    rootElement.appendChild(cElement);
	    rootElement.appendChild(arrowElement);

	    this.headerElement = headerElement;
	    this.contentElement = cElement;
	    this.arrowElement = arrowElement;
	    this.element = rootElement;
	    var self = this;
	    domUtil.on(closeElement, 'click', function () {
	        closePopup(self.options.mapId, 'popup-default');
	    });
	};

	PopOver.prototype.getPosition = function ($element) {
	    $element = $element || this.element.parentNode;
	    return $element.getBoundingClientRect();
	};

	PopOver.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
	    return placement === 'bottom' ? {
	        top: pos.top + pos.height,
	        left: pos.left + pos.width / 2 - actualWidth / 2
	    } :
	            placement === 'top' ? {
	        top: pos.top - actualHeight,
	        left: pos.left + pos.width / 2 - actualWidth / 2
	    } :
	            placement === 'left' ? {
	        top: pos.top + pos.height / 2 - actualHeight / 2,
	        left: pos.left - actualWidth
	    } :
	    {
	        top: pos.top + pos.height / 2 - actualHeight / 2,
	        left: pos.left + pos.width
	    };

	};

	PopOver.prototype.show = function () {
	    var pos = this.getPosition();
	    var $tip = this.element;
	    var actualWidth = $tip.offsetWidth;
	    var actualHeight = $tip.offsetHeight;
	    var calculatedOffset = this.getCalculatedOffset('top', pos, actualWidth, actualHeight);
	    setPageOffset($tip, calculatedOffset.left, calculatedOffset.top + 5);
	};

	PopOver.prototype.destroy = function () {
	    this.element = null;
	    this.headerElement = null;
	    this.contentElement = null;
	    this.arrowElement = null;

	};

	function addPopup(options) {
	    var mapId = options.mapId;
	    var olMap = getMap(mapId);
	    if (!olMap) {
	        return;
	    }
	    var ov = getOverlayByName(mapId, 'popup-default');
	    if (ov) {
	        olMap.removeOverlay(ov);
	    }
	    var pp = new PopOver(options);

	    var popupBase = new ol.Overlay({
	        element: pp.element,
	        autoPan: true,  
			autoPanAnimation: {  
				duration: 250  
			},
			autoPanMargin: 15
	    });

	    popupBase.set('type', 'popups');
	    popupBase.set('name', 'popup-default');
	    var coordinate = utils.gcjTransform(options.position);
	    popupBase.setPosition(ol.proj.fromLonLat(coordinate));
	    popupBase.popover = pp;

	    olMap.addOverlay(popupBase);
	    pp.show();
	}

	function removeAllPopup(mapId) {
	    var map = getMap(mapId);
	    if (!map) {
	        return;
	    }
	    delOverlayByType(mapId, 'popups', function (ov) {
	        if (ov.popover) {
	            ov.popover.destroy();
	        }
	    });
	}

	/**
	 * 根据type删除overlay
	 * @param mapId
	 * @param type
	 * @param callback
	 */
	function delOverlayByType(mapId, type, callback) {
	    var overlays = getMap(mapId).getOverlays().getArray().slice(0);
	    overlays.forEach(function (item) {
	        if (item.get('type') === type) {
	            if (callback) {
	                callback(item);
	            }
	            getMap(mapId).removeOverlay(item);
	        }
	    });
	}

	/**
	 * 关闭popup框
	 * @param mapId
	 * @param popupId
	 */
	function closePopup(mapId, popupId) {
	    var map = getMap(mapId);
	    if (!map) {
	        return;
	    }
	    var ov = getOverlayByName(mapId, popupId);
	    if (ov) {
	        if (ov.popover) {
	            ov.popover.destroy();
	        }
	        map.removeOverlay(ov);
	    }
	}


	    /**
	     * 设置tips的偏移位置
	     * @param offset Array
	     */
	    var setOffset = function (offset,mapId) {
	        if((typeof offset) == 'object' && (offset instanceof Array)){
	            var tipOverlay = getOverlayByName(mapId, 'popup-default');
	            tipOverlay.setOffset(offset);
	        }
	    };

	    /**
	     * 设置tips的位置，可以多次改变
	     * @param position tips的位置
	     * @param isTransfrom 是否转化坐标系
	     */
	    var setPosition = function (position, isTransfrom, panIntoView,mapId) {
	        var tipOverlay = getOverlayByName(mapId, 'popup-default');
	        if (tipOverlay) {
	            if (position === undefined) {
	                tipOverlay.setPosition(position);
	            } else {
	                if (isTransfrom) {
	                    position = transfrom(position);
	                }
	                tipOverlay.setPosition(position);
	            }
	        }
	        if (panIntoView) {
	            var center = mapView.getCenter();
	            var math = utils.getPointQuadrant(center, position);
	            if (math === 1) {
	                tipOverlay.setPositioning('top-right');
	            } else if (math === 2) {
	                tipOverlay.setPositioning('top-left');
	            } else if (math === 3) {
	                tipOverlay.setPositioning('bottom-left');
	            } else if (math === 4) {
	                tipOverlay.setPositioning('bottom-right');
	            }
	        }


	    };


	        /**
	     * 设置tips弹出框的显示位置
	     * @param positioning
	     */
	    var setPositioning = function (positioning,mapId) {
	        var tipOverlay = getOverlayByName(mapId, 'popup-default');
	        tipOverlay.setPositioning(positioning);
	    };

	        /**
	     * 获取tips对象
	     * @returns {*}
	     */
	    var getMapTips = function (mapId) {
	        var tipOverlay = getOverlayByName(mapId, 'popup-default');
	        return tipOverlay;
	    };

	       /**
	     * 获取当前对象的元素对象
	     * @param popupObj
	     * @returns {*}
	     */
	    var getPopupElement = function (mapId) {
	        var tipOverlay = getOverlayByName(mapId, 'popup-default');
	        return tipOverlay.getElement();
	    };

	module.exports = {
	    addPopup: addPopup,
	    removeAllPopup: removeAllPopup,
	    setInnerHTML:PopOver.prototype.setElement,
	    setOffset:setOffset,
	    setPosition:setPosition,
	    setPositioning:setPositioning,
	    getMapTips:getMapTips,
	    getPopupElement:getPopupElement
	};

/***/ },
/* 13 */
/*!*******************************!*\
  !*** ./src/gis/utils/i18n.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	var constant = __webpack_require__(/*! framework/constant */ 2);

	var I18N = constant.I18N;
	var language = (function () {
	    var _language = I18N.EN;

	    if (document.cookie.indexOf('locale=') === -1) {
	        _language = I18N.EN;
	    }
	    else {
	        var _cookies = document.cookie.split(";");

	        function _filterLanguage(targetKey) {
	            for (var i = 0; i < _cookies.length; i++) {
	                var _cookieItem = _cookies[i];
	                var arr = _cookieItem.split("=");
	                if (targetKey == arr[0].trim()) {
	                    if (!!arr[1]) {
	                        return arr[1].trim();
	                    }
	                }
	            }
	        }

	        _language = !!_filterLanguage('locale') && _filterLanguage('locale').slice(0, 2);
	        if (!!!_language) {
	            _language = !!_filterLanguage('exlocale') && _filterLanguage('exlocale').slice(0, 2);
	        }

	        if (!!!_language) {
	            console.log('%c 通过cooie获取国际化资源是被，系统指定en', 'color:blue;font-size:14px;');
	            _language = I18N.EN;
	        }
	    }

	    return _language;
	}());

	/**
	 * 设置语言
	 * @param lan
	 */
	function setLang(lan) {
	    if (lan === I18N.ZH || lan === I18N.EN || lan === I18N.ES) {
	        language = lan;
	    }
	}

	/**
	 * 获取当前语言
	 * @returns {string}
	 */
	function getLang() {
	    return language;
	}

	/**
	 * 根据key获取翻译
	 * @param key
	 * @returns {*}
	 */
	function prop(key) {
	    return i18nProperties[language][key];
	}
	var en = {}, zh = {}, es = {}, i18nProperties = {'en': en, 'zh': zh, 'es': es};
	//chinese
	zh['common.km'] = '公里';
	zh['common.m'] = '米';
	zh['mapClick.popup.title'] = '图层选择';
	zh['measure.message.startHelper'] = '单击确定起点';
	zh['measure.message.helper'] = '单击确定起点，双击结束';
	zh['measure.message.start'] = '起点';
	zh['measure.message.total'] = '总长：';
	zh['measure.angle.now'] = '当前角度：';
	zh['measureArea.message.total'] = '总面积：';
	zh['layerManager.title'] = '图层管理';
	zh['LayerLabel.BASELAYER'] = '底图';
	zh['LayerLabel.BASELAYER_MARKER'] = '底图标签';
	zh['LayerLabel.NE'] = '工参';
	zh['components.drawPolygon'] = '画多边形';
	zh['components.exportImage.title'] = '导出';
	zh['components.exportImage.saveType'] = '保存类型：';
	zh['components.exportImage.OK'] = '确定';
	zh['components.exportImage.Cancel'] = '取消';
	zh['components.exportImage.Layers'] = '图层';
	zh['components.exportImage.format'] = '格式';
	zh['components.exportImage.closeExportBox'] = '关闭导出框界面';
	zh['search.layerName'] = '图层名称';
	zh['search.propertyName'] = '属性名';
	zh['search.propertyValue'] = '属性值';
	zh['search.online'] = '在线搜索';
	zh['search.offline'] = '离线搜索';
	zh['search.title'] = '搜索';
	zh['search.click.search'] = '点击搜索';
	zh['search.current.map.not.support'] = '当前地图不支持搜索，请使用谷歌或者OSM';
	zh['search.elementList'] = '元素列表';
	zh['search.cell'] = '小区';
	zh['search.site'] = '基站';
	zh['search.systemPolygon'] = '系统多边形';
	zh['search.choose'] = '请选择';
	zh['toolbar.layerManger'] = '图层管理';
	zh['toolbar.exportImage'] = '导出图片';
	zh['toolbar.exportData'] = '导出数据';
	zh['toolbar.search'] = '在线 & 离线 搜索';
	zh['toolbar.lonLatGridLine'] = '经纬度栅格线';
	zh['toolbar.drawPolygon'] = '画多边形';
	zh['toolbar.drawLine'] = '画线';
	zh['toolbar.drawPoint'] = '画点';
	zh['toolbar.measureDistance'] = '测量距离';
	zh['toolbar.measureArea'] = '测量面积';
	zh['toolbar.measureAngle'] = '测量角度';
	zh['toolbar.polygonFilter'] = '通过多边形过滤要素';
	zh['toolbar.roadMap'] = '街道地图';
	zh['toolbar.grayMap'] = '灰度地图';
	zh['toolbar.legendSwitch'] = '图例开关';
	zh['filterFeature.wind.head.title'] = '选择需要过滤的图层';
	zh['filterFeature.wind.close.title'] = '点击按钮关闭窗口';
	zh['filterFeature.body.layerId'] = '图层ID';
	zh['map.zoomIn'] = '放大';
	zh['map.zoomOut'] = '缩小';
	zh['imageExport.title'] = '图片导出';
	zh['imageExport.exportTypeSel'] = '--保存类型--';
	zh['dataExport.title'] = '数据导出';
	zh['dataExport.exportTypeSel'] = '--导出类型--';
	zh['featureFilter.title'] = '--元素过滤--';
	zh['featureFilter.layerTypeSel'] = '--请选择图层--';
	zh['MapMsg.mousePositionMsg'] = '鼠标的位置在地图范围之外';
	zh['onclickLayer.noData'] ='没有数据';
	zh['multifeature.popup.title'] ='元素选择';
	zh['multifeature.popup.layer'] ='图层:';
	zh['multifeature.popup.feature'] ='元素ID:';
	//english
	en['common.km'] = 'km';
	en['common.m'] = 'm';
	en['mapClick.popup.title'] = 'Layer Select';
	en['measure.message.startHelper'] = 'Click to determine the location.';
	en['measure.message.helper'] = 'Click to determine the location<br> or double-click to finish.';
	en['measure.message.start'] = 'Start';
	en['measure.message.total'] = 'Total Distance:';
	en['measure.angle.now'] = 'Current angle ： ';
	en['measureArea.message.total'] = 'Total Area：';
	en['layerManager.title'] = 'Layer Management';
	en['LayerLabel.BASELAYER'] = 'Base Layer';
	en['LayerLabel.BASELAYER_MARKER'] = 'Base Layer Maker';
	en['LayerLabel.NE'] = 'NE';
	en['components.drawPolygon'] = 'Draw Polygon';
	en['components.exportImage.title'] = 'Export';
	en['components.exportImage.saveType'] = 'Save as:';
	en['components.exportImage.OK'] = 'OK';
	en['components.exportImage.Cancel'] = 'Cancel';
	en['components.exportImage.Layers'] = 'Layers';
	en['components.exportImage.format'] = 'format';
	en['components.exportImage.closeExportBox'] = 'Close the Export Box interface';
	en['search.layerName'] = 'layer name';
	en['search.propertyName'] = 'attr_ name';
	en['search.propertyValue'] = 'attr_ value';
	en['search.online'] = 'Online search';
	en['search.offline'] = 'Offline search';
	en['search.title'] = 'search';
	en['search.click.search'] = 'click search';
	en['search.current.map.not.support'] = 'current map not support search, please use osm or google';
	en['search.elementList'] = 'element list';
	en['search.cell'] = 'cell';
	en['search.site'] = 'site';
	en['search.systemPolygon'] = 'system polygon';
	en['search.choose'] = 'please choose';
	en['toolbar.layerManger'] = 'layer manager';
	en['toolbar.exportImage'] = 'export image';
	en['toolbar.exportData'] = 'export data';
	en['toolbar.search'] = 'online & offline search';
	en['toolbar.lonLatGridLine'] = 'lonLat grid line';
	en['toolbar.drawPolygon'] = 'draw polygon';
	en['toolbar.drawLine'] = 'draw line';
	en['toolbar.drawPoint'] = 'draw point';
	en['toolbar.measureDistance'] = 'measure distance';
	en['toolbar.measureArea'] = 'measure area';
	en['toolbar.measureAngle'] = 'measure angle';
	en['toolbar.polygonFilter'] = 'filter feature by polygon';
	en['toolbar.roadMap'] = 'road map';
	en['toolbar.grayMap'] = 'gray map';
	en['toolbar.legendSwitch'] = 'legend switch';
	en['filterFeature.wind.head.title'] = 'The layer you want to filter';
	en['filterFeature.wind.close.title'] = 'Click the button to close the window';
	en['filterFeature.body.layerId'] = 'layer ID';
	en['map.zoomIn'] = 'zoom in';
	en['map.zoomOut'] = 'zoom out';
	en['imageExport.title'] = 'image export';
	en['imageExport.exportTypeSel'] = '--save image type--';
	en['dataExport.title'] = 'data export';
	en['dataExport.exportTypeSel'] = '--Export type--';
	en['featureFilter.title'] = '--feature filter--';
	en['featureFilter.layerTypeSel'] = '--select a layer--';
	en['MapMsg.mousePositionMsg'] = 'Position of the mouse on the map range.';
	en['onclickLayer.noDat'] ='No Data';
	en['multifeature.popup.title'] ='feature select';
	en['multifeature.popup.layer'] ='layer:';
	en['multifeature.popup.feature'] ='featureID:';

	//西班牙语
	es['common.km'] = 'kilómetro';
	es['common.m'] = 'metro';
	es['mapClick.popup.title'] = 'Seleccione capa';
	es['measure.message.startHelper'] = 'Haga clic en OK para iniciar';
	es['measure.message.helper'] = 'Haga clic en OK punto de partida, de dos extremos';
	es['measure.message.start'] = 'punto de partida';
	es['measure.angle.now'] = 'Current angle : ';
	es['measure.message.total'] = 'Longitud total：';
	es['measureArea.message.total'] = 'El área total：';
	es['layerManager.title'] = 'capa de Gestión';
	es['LayerLabel.BASELAYER'] = 'arpillera';
	es['LayerLabel.NE'] = 'El trabajo de referencia';
	es['components.drawPolygon'] = 'Videos polígono';
	es['components.exportImage.title'] = 'exportación';
	es['components.exportImage.saveType'] = 'Guardar como tipo：';
	es['components.exportImage.OK'] = 'determinar';
	es['components.exportImage.Cancel'] = 'cancelado';
	es['components.exportImage.Layers'] = 'capas';
	es['components.exportImage.format'] = 'formato';
	es['components.exportImage.closeExportBox'] = 'Cerrar la caja de interconexión de exportación';
	es['onclickLayer.noDat'] ='No Data';

	module.exports = {
	    setLang: setLang,
	    getLang: getLang,
	    prop: prop

	};

/***/ },
/* 14 */
/*!*******************************!*\
  !*** ./src/gis/utils/ajax.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	var utils = __webpack_require__(/*! utils/util */ 1);
	var constant = __webpack_require__(/*! framework/constant */ 2);

	var createXMLHTTPRequest = function () {
	    var xhr = null;
	    if (window.XMLHttpRequest) {
	        xhr = new XMLHttpRequest();
	        if (xhr.overrideMimeType) {
	            xhr.overrideMimeType("text/xml");
	        }
	    }
	    else if (window.ActiveXObject) {
	        var activeName = ["MSXML2.XMLHTTP", "Microsoft.XMLHTTP"];
	        for (var i = 0; i < activeName.length; i++) {
	            try {
	                xhr = new ActiveXObject(activeName[i]);
	                if (xhr) {
	                    break;
	                }
	            }
	            catch (e) {

	            }
	        }
	    }
	    return xhr;
	};


	function setHeader() {
	    if (!!!constant.GlobalVariable.csrfToken) {
	        var xhr = createXMLHTTPRequest();
	        var url = constant.GisRootUrl + '/csrftoken.do';
	        xhr.open("GET", url, true);
	        xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
	        xhr.setRequestHeader('Accept', 'application/json, text/javascript, */*; q=0.01');
	        xhr.send(null);
	        xhr.onreadystatechange = function () {
	            if (xhr.readyState === 4) {
	                var status = xhr.status;
	                if (status >= 200 && status < 300) {
	                    var responseText = xhr.responseText;
	                    if (!!responseText) {
	                        var json = JSON.parse(responseText);
	                        if (json.status.code === 1) {
	                            var key = json._csrf_header;
	                            var value = json._csrf;
	                            constant.GlobalVariable.csrfToken = key + '|' + value;
	                        }
	                    }
	                }
	                else {
	                    console.log('%c fusiongis get csrftoken failed, ajax.setHeader', 'font-size:14px;color:red');
	                }
	            }
	        };
	    }
	}


	var get = function (paramObj) {
	    var xhr = createXMLHTTPRequest();
	    var key = setTimeout(function () {
	        var url = paramObj.url;
	        if (paramObj.data) {
	            url = url + '?' + paramObj.data;
	        }
	        xhr.open("GET", url, true);
	        var csrfToken = constant.GlobalVariable.csrfToken;
	        if (!!csrfToken) {
	            var csrfTokens = csrfToken.split('|');
	            xhr.setRequestHeader(csrfTokens[0], csrfTokens[1]);
	            xhr.onreadystatechange = function () {
	                if (xhr.readyState === 4) {
	                    var status = xhr.status;
	                    if (status >= 200 && status < 300) {
	                        if (paramObj.success && typeof paramObj.success === 'function') {
	                            paramObj.success(xhr.responseText);
	                        }
	                    }
	                    else {
	                        if (paramObj.failure && typeof paramObj.failure === 'function') {
	                            paramObj.failure(xhr.status);
	                        }

	                        if (paramObj.fail && typeof paramObj.fail === 'function') {
	                            paramObj.fail(xhr.status);
	                        }
	                    }
	                    clearTimeout(key);
	                }
	            };
	            xhr.send(null);
	        }
	        else {
	            if (paramObj.failure && typeof paramObj.failure === 'function') {
	                paramObj.failure(xhr.status);
	            }

	            if (paramObj.fail && typeof paramObj.fail === 'function') {
	                paramObj.fail(xhr.status);
	            }
	        }
	    }, 500);
	};

	var post = function (paramObj) {
	    var xhr = createXMLHTTPRequest();
	    if (!!xhr) {
	        var key = setTimeout(function () {
	            xhr.open("POST", paramObj.url, true);
	            xhr.setRequestHeader("Content-Type", "application/json; charset=UTF-8;");
	            var csrfToken = constant.GlobalVariable.csrfToken;
	            if (!!csrfToken) {
	                var csrfTokens = csrfToken.split('|');
	                xhr.setRequestHeader(csrfTokens[0], csrfTokens[1]);
	                xhr.onreadystatechange = function () {
	                    if (xhr.readyState === 4) {
	                        var status = xhr.status;
	                        if (status >= 200 && status < 300) {
	                            if (paramObj.success && typeof paramObj.success === 'function') {
	                                paramObj.success(xhr.responseText);
	                            }
	                        }
	                        else {
	                            if (paramObj.failure && typeof paramObj.failure === 'function') {
	                                paramObj.failure(xhr.status);
	                            }

	                            if (paramObj.fail && typeof paramObj.fail === 'function') {
	                                paramObj.fail(xhr.status);
	                            }
	                        }

	                    }

	                    clearTimeout(key);
	                };
	                xhr.send(paramObj.data);
	            }
	            else {
	                if (paramObj.failure && typeof paramObj.failure === 'function') {
	                    paramObj.failure(xhr.status);
	                }

	                if (paramObj.fail && typeof paramObj.fail === 'function') {
	                    paramObj.fail(xhr.status);
	                }
	            }
	        }, 500);
	    }
	};

	module.exports = {
	    setHeader: setHeader,
	    get: get,
	    post: post,
	    postJSON: post
	};

/***/ },
/* 15 */
/*!*********************************!*\
  !*** ./src/gis/maps/eventDC.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var popup = __webpack_require__(/*! tools/popup */ 12);
	var popupInFrame = __webpack_require__(/*! framework/popup */ 9);
	var i18n = __webpack_require__(/*! utils/i18n */ 13);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var ajax = __webpack_require__(/*! utils/ajax */ 14);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var closeDrawAndMeasure = olUtil.closeDrawAndMeasure;
	var transformLonLat = olUtil.transformLonLat;


	function mapClick(mapId, initMapParam) {
		//所有服务数据返回成功后，一次性将数据返回给用户
		var everyLayerClickCallback = initMapParam.everyLayerClickCallback;
		var g_ = new Map();
		var g__vectorFeature = undefined;
		var g__getGridInfo = undefined;
		var g__getdCellInfo = undefined;
		var g_getdSiteInfo = undefined;
		var g_getdLineInfo = undefined;
		var g_getdServicePolygonInfo = undefined;
		var g_getServicePointInfo = undefined;
		var g_getServiceLineInfo = undefined;
		var g_getServicePolygonInfo = undefined;

		var mapObj = mapBox.getMapObj(mapId);
		//防止注册多个事件
		if (mapObj.get('clickHandle')) {
			return;
		}
		mapObj.set('callbackList', {});
		mapObj.set('eventKeyANDEventLayerObj', {});
		var clickHandle = mapObj.on('click', function (e) {
			var isActive = closeDrawAndMeasure(mapObj.getTarget());
			if (isActive === false) {
				var _callbackList = mapObj.get('callbackList');
				if (_callbackList['measure-distance-click-event']) {     //测距中间拐点处弹出长度提示
					_callbackList['measure-distance-click-event']({e: e});
				}
				return;
			}
			var featuresAtPix = [];
			var pixLonLat = [];
			var businessFeatureArray = [];
			var returnEveryLayClickData = {}; //存放每个图层点击后的数据，统一返回给用户

			mapObj.forEachFeatureAtPixel(e.pixel, function (feature) {
				if (!!feature) {
					var clusterFeature = feature.get('features');
					if (clusterFeature && clusterFeature instanceof Array && clusterFeature.length > 0) {
						businessFeatureArray.push(feature);
					}
					if (feature.get('vectorType') === constant.BUSINESSTYPE.POINT ||
						feature.get('vectorType') === constant.BUSINESSTYPE.LINE ||
						feature.get('vectorType') === constant.BUSINESSTYPE.POLYGON ||
						feature.get('vectorType') === constant.BUSINESSTYPE.ICON ||
						feature.get('vectorType') === constant.BUSINESSTYPE.CIRCLEPOINT||
						feature.get('vectorType') === constant.BUSINESSTYPE.VECTOR_CELL||
						feature.get('vectorType') === constant.BUSINESSTYPE.STRAIGHTLINE ||
						feature.get('vectorType') === constant.BUSINESSTYPE.MULTIPOINT ||
						feature.get('vectorType') === 'ICON_FONT_STYLE'||
						feature.get('vectorType') === 'BUBBLE_CIRCLE_LABEL'||
						feature.get('vectorType')==='unChangePolygon'
					) {
						if (!!!feature.get('highlightFeature')) {
							if (feature.get('vectorType') === constant.BUSINESSTYPE.MULTIPOINT) {
								var closePointAtClick = fusiongis.MuliPoint.getTargetClkPoint(feature.get('data'), e.coordinate);
								feature.set('coordinate', closePointAtClick.coordinate);
								feature.set('data_', closePointAtClick);
							}
							businessFeatureArray.push(feature);
						}
					}
					featuresAtPix.push(feature);
				}
			});

			pixLonLat = mapObj.getCoordinateFromPixel(e.pixel);
			if (!!pixLonLat) {
				pixLonLat = ol.proj.toLonLat(pixLonLat);
			}

			var _callbackList = mapObj.get('callbackList');
			var _eventKeyANDEventLayerObj = mapObj.get('eventKeyANDEventLayerObj');
			if(businessFeatureArray.length > 0) { //代表不同图层的feature
				var _eventData = [];
				for(var i = 0; i < businessFeatureArray.length; i++) {

					var _feature = businessFeatureArray[i];
					if(!_feature) {
						return;
					}
					var _businessType = _feature.get('vectorType');
					var _layer = _feature.get('layer');
					var _featureExtent = _feature.getGeometry().getExtent();
					var _featureCenter = ol.extent.getCenter(_featureExtent);
					var _featureCenter4326 = ol.proj.toLonLat(_featureCenter);

					var callbackData = {
						e: e,
						mapId: mapId,
						layerId: !!_layer && _layer.get('layer_id'),
						layer: _feature.get('layer'),
						businessType: _layer && _layer.get('businessType'),
						feature: _feature,
						data: _feature.get('data_') != undefined ? _feature.get('data_') : _feature.get('data'),
						geoId: _feature.getId() !== undefined ? _feature.getId() : _feature.get('id'),
						lonLat: [_featureCenter4326[0].toFixed(6), _featureCenter4326[1].toFixed(6)],
						pixLonLat: pixLonLat,
						points: transformLonLat(_feature)
					};
					g__vectorFeature = 'yes';
					g_.set('g__vectorFeature', g__vectorFeature);
					if (businessFeatureArray.length === 1) {   //汇聚点的高亮
						var isClusterPoint = businessFeatureArray[0].get('features')
							&& businessFeatureArray[0].get('features') instanceof Array
							&& businessFeatureArray[0].get('features').length === 1;
						var clusterLayer = !!isClusterPoint ?
							businessFeatureArray[0].get('features')[0].get('layer') : undefined;
						callbackData['layer'] = !!isClusterPoint && clusterLayer ?
							clusterLayer : callbackData.layer;
						if (!!_callbackList['point-cluster-click-event']) {
							_callbackList['point-cluster-click-event'](callbackData);
						}
					}
					_eventData.push(callbackData);
				}

				if(_eventData.length > 0) {
					for(var i = 0; i < _eventData.length;i++) {
						var callBackList = []; //代表同一图层的features
						var keys =[];
						for(var key in returnEveryLayClickData ){
							keys.push(key);
						}
						if (keys.indexOf((_eventData[i].layerId).toString()) < 0) {
							for (var j = i; j <= _eventData.length - 1; j++) {
	                            if (_eventData[i].layerId ==_eventData[j].layerId) {
	                                callBackList.push(_eventData[j]);
	                                returnEveryLayClickData[_eventData[i].layerId] = callBackList;
	                            }
	                        }
							
						}
					}
				}
			}

			for (var clickEventUniqueKey in _callbackList) {
				if (_callbackList[clickEventUniqueKey] != undefined && typeof _callbackList[clickEventUniqueKey] === 'function') {
					var _feature = null;
					if (featuresAtPix.length > 0) {
						_feature = featuresAtPix[0];
					}

					var _featureExtent = _feature && _feature.getGeometry().getExtent();
					var _featureCenter = _featureExtent && ol.extent.getCenter(_featureExtent);
					var _featureCenter4326 = [];
					if (!!_featureCenter) {
						_featureCenter4326 = ol.proj.toLonLat(_featureCenter);
					}

					var _layer = _eventKeyANDEventLayerObj[clickEventUniqueKey];
					//geoId, lonLat, mapId, layerType, layerId,points
					if (_layer != undefined) {
						if (_layer.get('businessType') === constant.BUSINESSTYPE.GRID) {
							g__getGridInfo = 'no';
							g_.set('g__getGridInfo', g__getGridInfo);
							_getGridInfo(mapObj, _layer, _feature, e, clickEventUniqueKey, mapId,function (objs) {
								g__getGridInfo = 'yes';
								g_.set('g__getGridInfo', g__getGridInfo);
								if (!!objs && objs.length > 0) {
									returnEveryLayClickData[objs[0].layerId] = objs;
								}
								else {
									returnEveryLayClickData[objs[0].layerId] = [{}];
								}
							})
						} else if (_layer.get('businessType') === 'DCELL') {
							g__getdCellInfo = 'no';
							g_.set('g__getdCellInfo', g__getdCellInfo);
							_getdCellInfo(mapObj, _layer, _feature, e, clickEventUniqueKey,mapId, function (objs) {
								g__getdCellInfo = 'yes';
								g_.set('g__getdCellInfo', g__getdCellInfo);
								if (objs && objs.length > 0) {
									returnEveryLayClickData[objs[0].layerId] = objs;
								}
								else {
									returnEveryLayClickData[objs[0].layerId] = [{}];
								}
							});
						} else if (_layer.get('businessType') === 'DPOINT' || _layer.get('businessType') === 'SITE') {
							g_getdSiteInfo = 'no';
							g_.set('g_getdSiteInfo', g_getdSiteInfo);
							getdSiteInfo(mapObj, _layer, _feature, e, clickEventUniqueKey, mapId,function (objs) {
								g_getdSiteInfo = 'yes';
								g_.set('g_getdSiteInfo', g_getdSiteInfo);
								if (objs && objs.length > 0) {
									returnEveryLayClickData[objs[0].layerId] = objs;
								}
								else {
									returnEveryLayClickData[objs[0].layerId] = [{}];
								}
							});
						} else if (_layer.get('businessType') === 'DLINE') {
							g_getdLineInfo = 'no';
							g_.set('g_getdLineInfo', g_getdLineInfo);
							getdLineInfo(mapObj, _layer, _feature, e, clickEventUniqueKey,mapId, function (objs) {
								g_getdLineInfo = 'yes';
								g_.set('g_getdLineInfo', g_getdLineInfo);
								if (objs && objs.length > 0) {
									returnEveryLayClickData[objs[0].layerId] = objs;
								}
								else {
									returnEveryLayClickData[objs[0].layerId] = [{}];
								}
							});
						} else if (_layer.get('businessType') === 'DPOLYGON') {
							g_getdServicePolygonInfo = 'no';
							g_.set('g_getdServicePolygonInfo', g_getdServicePolygonInfo);
							getdServicePolygonInfo(mapObj, _layer, _feature, e, clickEventUniqueKey,mapId, function (objs) {
								g_getdServicePolygonInfo = 'yes';
								g_.set('g_getdServicePolygonInfo', g_getdServicePolygonInfo);
								if (objs && objs.length > 0) {
									returnEveryLayClickData[objs[0].layerId] = objs;
								}
								else {
									returnEveryLayClickData[objs[0].layerId] = [{}];
								}
							});
						} else if (_layer.get('businessType') === constant.BUSINESSTYPE.SERVICEPOINT) {
							g_getServicePointInfo = 'no';
							g_.set('g_getServicePointInfo', g_getServicePointInfo);
							getServicePointInfo(mapObj, _layer, _feature, e, clickEventUniqueKey,mapId, function (objs) {
								g_getServicePointInfo = 'yes';
								g_.set('g_getServicePointInfo', g_getServicePointInfo);
								if (objs && objs.length > 0) {
									returnEveryLayClickData[objs[0].layerId] = objs;
								}
								else {
									returnEveryLayClickData[objs[0].layerId] = [{}];
								}
							});
						} else if (_layer.get('businessType') === constant.BUSINESSTYPE.SERVICELINE) {
							g_getServiceLineInfo = 'no';
							g_.set('g_getServiceLineInfo', g_getServiceLineInfo);
							getServiceLineInfo(mapObj, _layer, _feature, e, clickEventUniqueKey,mapId, function (objs) {
								g_getServiceLineInfo = 'yes';
								g_.set('g_getServiceLineInfo', g_getServiceLineInfo);
								if (objs && objs.length > 0) {
									returnEveryLayClickData[objs[0].layerId] = objs;
								}
								else {
									returnEveryLayClickData[objs[0].layerId] = [{}];
								}
							});
						} else if (_layer.get('businessType') === constant.BUSINESSTYPE.SERVICEPOLYGON) {
							g_getServicePolygonInfo = 'no';
							g_.set('g_getServicePolygonInfo', g_getServicePolygonInfo);
							getServicePolygonInfo(mapObj, _layer, _feature, e, clickEventUniqueKey,mapId, function (objs) {
								g_getServicePolygonInfo = 'yes';
								g_.set('g_getServicePolygonInfo', g_getServicePolygonInfo);
								if (objs && objs.length > 0) {
									returnEveryLayClickData[objs[0].layerId] = objs;
								}
								else {
									returnEveryLayClickData[objs[0].layerId] = [{}];
								}
							});
						}
						else if(_layer.get('businessType') === 'SERVICELAYER'){
							fusiongis.ServiceLayer.getServiceLayerInfo(mapObj, _layer, e,function (objs) {
								if (objs && objs.length > 0) {
									returnEveryLayClickData[objs[0].layerId] = objs;
								}
							});
						}
					}
				}
			}
			var isAllValidRequstResponse = undefined;
			try {
				isAllValidRequstResponse = setInterval(function () {
					var _g = [];
					g_.forEach(function (v, k) {
						_g.push({
							key: k,
							val: v
						})
					})
		
					//过滤用户添加到地图上的图层
					var _validLayer = _g.filter(function (g) {
						return g.val != undefined;
					})
		
					//通过定时器来完成，当所有的图层都返回数据时，一次性将数据返回给用户，
					var isYes = false;
					var isYesArary = [];
					for (var i = 0; i < _validLayer.length; i++) {
						if (_validLayer[i].val == 'yes') {
							isYes = true;
						}
						else {
							isYes = false;
						}
						isYesArary.push(isYes);
					}
					isYes = isYesArary.every(function(v) {
						return v == true
					});
					if (isYes) {
						if (everyLayerClickCallback != undefined && typeof everyLayerClickCallback == 'function') {
							everyLayerClickCallback(returnEveryLayClickData);
						}
						clearInterval(isAllValidRequstResponse);
						g__vectorFeature = undefined;
						g__getGridInfo = undefined;
						g__getdCellInfo = undefined;
						g_getdSiteInfo = undefined;
						g_getdLineInfo = undefined;
						g_getdServicePolygonInfo = undefined;
						g_getServicePointInfo = undefined;
						g_getServiceLineInfo = undefined;
						g_getServicePolygonInfo = undefined;
					}
		
				}, 500);
			} catch(e) {
				console.error(e.message);
				clearInterval(isAllValidRequstResponse);
			}

		});
		mapObj.set('clickHandle', clickHandle);
	}


	function _getGridInfo(mapObj, layerObj, feature, evt, key,mapId, callback) {
		var isActive = closeDrawAndMeasure(mapObj.getTarget());
		if (isActive === false) {
			return;
		}
		var layerParamObj = layerObj.get('paramObj');
		if (layerObj.get('imgToken') == undefined) {
			callback([
				{
					layerId: !!layerObj && layerObj.get('layer_id')
				}
			]);
			return;
		}
		var paramObj = {
			geometry: {
				x: evt.coordinate[0],
				y: evt.coordinate[1]
			},
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance : 1,
			mapExtent: mapObj.getView().calculateExtent(mapObj.getSize()),
			imgToken: layerObj.get('imgToken')
		};
		var pixLonLat = ol.proj.toLonLat(mapObj.getCoordinateFromPixel(evt.pixel));
		
		//增加遮罩层，避免请求顺序混乱，鼠标当前在的位置的feature没有高亮，而是之前点过的高亮了
		 createMasker(mapId);

		ajax.postJSON({
			url: constant.GisRootUrl + '/gridManager/getGridInfo?cacheKey=' + layerObj.get('imgToken'),
			data: JSON.stringify(paramObj),
			success: function (resultText) {
				if (!resultText) {
					callback([
						{
							layerId: !!layerObj && layerObj.get('layer_id')
						}
					]);
					return;
				}
				
				//请求成功之后,删除遮罩层
				var _maskerDiv =document.getElementById('singleMaskerLayer');
				_maskerDiv.style.display='none';
				
				
				var result = JSON.parse(resultText);
				if (!result || !result.data || !result.data.length) {
					callback([
						{
							layerId: !!layerObj && layerObj.get('layer_id')
						}
					]);
					return;
				}
				if (result.status != undefined && result.status.code == 1) {
					try {
						var backJSON = result.data.map(function (data) {
							return {
								mapId: mapObj.getTarget(),
								layer: layerObj,
								layerId: !!layerObj && layerObj.get('layer_id'),
								layerType: !!layerObj && layerObj.get('businessType'),
								label: !!layerObj && layerObj.get('params.label'),
								feature: feature,
								lonLat: ol.proj.toLonLat(data.centerPoint),
								pixLonLat: pixLonLat,
								geometry: data.geometry,
								geoId: data.id,
								data: data,
								extentInfo: data.extentInfo,
								geoName: data.name,
								key: key,
								originalCenterPoint: data.originalCenterPoint
							};
						});
						callback(backJSON);
					} catch(e){
						callback([
							{
								layerId: !!layerObj && layerObj.get('layer_id')
							}
						]);
						console.log(e);
					}
				}
				else {
					callback([
						{
							layerId: !!layerObj && layerObj.get('layer_id')
						}
					]);
				}
			},
			failure: function(resultText) {
				callback([{
					layerId: !!layerObj && layerObj.get('layer_id')
				}]);
			}
		});
	}

	function createMasker(mapId) {
		var _mapDiv = document.getElementById(mapId);

		if(!document.getElementById('singleMaskerLayer')) {
			var mapZindexDiv = document.createElement('div');
			mapZindexDiv.id ='singleMaskerLayer';

			mapZindexDiv.style.width = '100%';
			mapZindexDiv.style.height = '100%';
			mapZindexDiv.style.position = 'absolute';
			mapZindexDiv.style.top=0;

			mapZindexDiv.style.opacity='0';
			mapZindexDiv.style.zIndex = 9000;
			_mapDiv.appendChild(mapZindexDiv);
		}else{
			var _maskerMapDiv =document.getElementById('singleMaskerLayer');
			_maskerMapDiv.style.display='block';
			
		}
	}

	function _getdCellInfo(olMap, olLayer, feature, evt, key,mapId, callback) {
		var isActive = closeDrawAndMeasure(olMap.getTarget());
		if (isActive === false) {
			return;
		}
		if (!olLayer.getVisible()) {
			callback([
				{
					layerId: !!layerObj && layerObj.get('layer_id')
				}
			]);
			return;
		}

		if (!!evt.coordinate) {
			var geometry = JSON.stringify({
				x: evt.coordinate[0],
				y: evt.coordinate[1]
			});
			var mapExtent = olMap.getView().calculateExtent(olMap.getSize()).join(',');
			var imgToken = olLayer.get('imgToken');
			if (imgToken == undefined) {
				callback([
					{
						layerId: !!olLayer && olLayer.get('layer_id')
					}
				]);
				return;
			}
			var Fcname = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
			var pixLonLat = ol.proj.toLonLat(olMap.getCoordinateFromPixel(evt.pixel));
			var layerParamObj = olLayer.get('paramObj');
			var params = {
				geometry: geometry,
				tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance : 0.1,
				mapExtent: mapExtent,
				imgToken: imgToken,
				FCName: Fcname
			};

		}
		
		createMasker(mapId);

		ajax.get({
			url: constant.GisRootUrl + '/common/mapRender/identify',
			data: utils.getParameterString(params),
			success: function (res) {
				if (!res) {
					callback([
						{
							layerId: !!olLayer && olLayer.get('layer_id')
						}
					]);
					return;
				}
				//请求成功之后,删除遮罩层
				var _maskerDiv =document.getElementById('singleMaskerLayer');
				_maskerDiv.style.display='none';
				
				
				res = JSON.parse(res);
				try {
					if (!res || !res.data || !res.data.length) {
						callback([
							{
								layerId: !!olLayer && olLayer.get('layer_id')
							}
						]);
						return;
					}
		
					var result = utils.sortBy(res.data, function (j) {
						if (j.extentInfo.isDirect === '0') {
							j.extentInfo.radius = j.extentInfo.radius * 2;
						}
						return Number(j.extentInfo.radius);
					});
					var minRadius = result[0].extentInfo.radius;
					result = result.filter(function (item) {
						return item.extentInfo.radius === minRadius;
					});
					result.forEach(function (r) {
						if (r.extentInfo.isDirect === '0') {
							r.extentInfo.radius = r.extentInfo.radius / 2;
						}
					});
					var backJson = result.map(function (item) {
						return {
							mapId: olMap.getTarget(),
							layer: olLayer,
							feature: feature,
							layerId: !!olLayer && olLayer.get('layer_id'),
							layerType: !!olLayer && olLayer.get('businessType'),
							label: !!olLayer && olLayer.get('params.label'),
							lonLat: ol.proj.toLonLat(item.centerPoint),
							pixLonLat: pixLonLat,
							geometry: item.geometry,
							extentInfo: item.extentInfo,
							geoId: item.id,
							geoName: item.name,
							key: key
						};
					});
					if (typeof callback === 'function') {
						callback(backJson);
					}
				} catch (e) {
					if (typeof callback === 'function') {
						callback([
							{
								layerId: olLayer.get('layer_id')
							}
						]);
					}
					console.log(e);
				}
			},
			failure: function(res) {
				if(typeof callback === 'function') {
					callback([{
						layerId: olLayer.get('layer_id')
					}]);
				}
			}
		});
	}

	function getdSiteInfo(olMap, olLayer, feature, evt, key, mapId,callback) {
		var isActive = closeDrawAndMeasure(olMap.getTarget());
		if (isActive === false) {
			return;
		}
		if (!olLayer.getVisible()) {
			callback([
				{
					layerId: !!olLayer && olLayer.get('layer_id')
				}
			]);
			return;
		}
		var mapExtent, imgToken, geometry,dw,_url;
		imgToken = olLayer.get('imgToken');
		if (imgToken == undefined) {
			callback([
				{
					layerId: !!olLayer && olLayer.get('layer_id')
				}
			]);
			return;
		}
		dw = olLayer.get('dw'); //通过取dw的属性判断是否走中间件
		if(dw != undefined) {
			_url = constant.GisRootUrl + '/mapRender/identify';
		} else {
			_url = constant.GisRootUrl + '/common/mapRender/identify';
		}
		geometry = JSON.stringify({
			x: evt.coordinate[0],
			y: evt.coordinate[1]
		});
		mapExtent = olMap.getView().calculateExtent(olMap.getSize()).join(',');
		var fcName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		var pixLonLat = ol.proj.toLonLat(olMap.getCoordinateFromPixel(evt.pixel));
		var layerParamObj = olLayer.get('paramObj');
		var params = {
			geometry: geometry,
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance : 10,
			mapExtent: mapExtent,
			imgToken: imgToken,
			FCName: fcName
		};
		
		createMasker(mapId);
		
		ajax.get({
			url: _url,
			data: utils.getParameterString(params),
			success: function (res) {
				if (!res) {
					callback([
						{
							layerId: !!olLayer && olLayer.get('layer_id')
						}
					]);
					return;
				}
				
				//请求成功之后,删除遮罩层
				var _maskerDiv =document.getElementById('singleMaskerLayer');
				_maskerDiv.style.display='none';
				
				res = JSON.parse(res);
				if (!res || !res.data || !res.data.length) {
					callback([
						{
							layerId: !!olLayer && olLayer.get('layer_id')
						}
					]);
					return;
				}

				try {
					var backJSON = res.data.map(function (item) {
						return {
							mapId: olMap.getTarget(),
							layer: olLayer,
							feature: feature,
							layerId: !!olLayer && olLayer.get('layer_id'),
							layerType: !!olLayer && olLayer.get('businessType'),
							label: !!olLayer && olLayer.get('params.label'),
							lonLat: dw != undefined ? item.centerPoint: ol.proj.toLonLat(item.centerPoint),
							pixLonLat: pixLonLat,
							geometry: item.geometry,
							geoId: item.id,
							geoName: item.name,
							key: key
						};
					});
		
					callback(backJSON);
				} catch (e) {
					if (callback != undefined && typeof callback == 'function') {
						callback([
							{
								layerId: olLayer.get('layer_id')
							}
						]);
					}
					console.log(e);
				}
			},
			failure: function(res) {
				if(callback != undefined && typeof callback == 'function') {
					callback([{
						layerId: olLayer.get('layer_id')
					}]);
				}
			}
		});
	}

	function getdLineInfo(olMap, olLayer, feature, evt, key,mapId, callback) {
		var isActive = closeDrawAndMeasure(olMap.getTarget());
		if (isActive === false) {
			return;
		}
		if (!olLayer.getVisible()) {
			callback([
				{
					layerId: !!olLayer && olLayer.get('layer_id')
				}
			]);
			return;
		}
		var mapExtent, imgToken, geometry, Fcname;
		imgToken = olLayer.get('imgToken');
		if (imgToken == undefined) {
			callback([
				{
					layerId: !!olLayer && olLayer.get('layer_id')
				}
			]);
			return;
		}
		geometry = JSON.stringify({
			x: evt.coordinate[0],
			y: evt.coordinate[1]
		});
		mapExtent = olMap.getView().calculateExtent(olMap.getSize()).join(',');
		Fcname = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		var pixLonLat = ol.proj.toLonLat(olMap.getCoordinateFromPixel(evt.pixel));
		var layerParamObj = olLayer.get('paramObj');
		var params = {
			geometry: geometry,
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  1,
			mapExtent: mapExtent,
			imgToken: imgToken,
			FCName: Fcname
		};
		
		createMasker(mapId);
		
		ajax.get({
			url: constant.GisRootUrl + '/common/mapRender/identify',
			data: utils.getParameterString(params),
			success: function (res) {
				if (!res) {
					callback([]);
					return;
				}
				res = JSON.parse(res);
				if (!res || !res.data || !res.data.length) {
					callback([
						{
							layerId: !!olLayer && olLayer.get('layer_id')
						}
					]);
					return;
				}
				
				var _maskerDiv =document.getElementById('singleMaskerLayer');
				_maskerDiv.style.display='none';

				try { 
					var backJSON = res.data.map(function (item) {
						return {
							mapId: olMap.getTarget(),
							layer: olLayer,
							layerId: !!olLayer && olLayer.get('layer_id'),
							layerType: !!olLayer && olLayer.get('businessType'),
							label: !!olLayer && olLayer.get('params.label'),
							lonLat: ol.proj.toLonLat(item.centerPoint),
							pixLonLat: pixLonLat,
							geometry: item.geometry,
							geoId: item.id,
							geoName: item.name,
							key: key,
							feature: feature
						};
					});
		
					callback(backJSON);
				} catch (e) {
					callback([
						{
							layerId: olLayer.get('layer_id')
						}
					]);
				}
			},
			failure: function(res) {
				callback([{
					layerId: olLayer.get('layer_id')
				}]);

			}
		});
	}

	function getdServicePolygonInfo(mapObj, layerObj, feature, evt, key,mapId, callback) {
		var isActive = closeDrawAndMeasure(mapObj.getTarget());
		if (isActive === false) {
			callback([
				{
					layerId: layerObj.get('layer_id')
				}
			]);
			return;
		}
		var extent = mapObj.getView().calculateExtent(mapObj.getSize());
		var imgToken = layerObj.get('imgToken');
		if (imgToken == undefined) {
			callback([
				{
					layerId: layerObj.get('layer_id')
				}
			]);
			return;
		}
		var fcName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		var pixLonLat = ol.proj.toLonLat(mapObj.getCoordinateFromPixel(evt.pixel));
		var layerParamObj = layerObj.get('paramObj');
		var paramObj = {
			geometry: JSON.stringify({
				x: evt.coordinate[0],
				y: evt.coordinate[1]
			}),
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance : 0.1,
			mapExtent: extent,
			imgToken: imgToken,
			FCName: fcName
		};

	    createMasker(mapId);
	    
		ajax.get({
			url: constant.GisRootUrl + '/common/mapRender/identify',
			data: utils.getParameterString(paramObj),
			success: function (result) {
				if (!result) {
					callback([
						{
							layerId: layerObj.get('layer_id')
						}
					]);
					return;
				}
				
				var _maskerDiv =document.getElementById('singleMaskerLayer');
				_maskerDiv.style.display ='none';
				
				var responseText = JSON.parse(result);
				var status = responseText.status;
				if (status.code === 1) { //请求成功，可能有数据，可能没数据
					if (responseText.data && responseText.data.length > 0) {
						var datas = responseText.data.map(function (data) {
							var oneData = {
								mapId: mapObj.getTarget(),
								layer: layerObj,
								layerId: layerObj.get('layer_id'),
								layerType: layerObj.get('businessType'),
								label: layerObj.get('params.label'),
								lonLat: ol.proj.toLonLat(data.centerPoint),
								pixLonLat: pixLonLat,
								geometry: data.geometry,
								extentInfo: data.extentInfo,
								geoId: data.id,
								geoName: data.name,
								key: key,
								feature: feature
							};

							return oneData;
						});

						if (callback && typeof callback === 'function') {
							callback(datas);
						}
					}
					else {
						callback([
							{
								layerId: layerObj.get('layer_id')
							}
						]);
					}
				}
				else {
					callback([{
						layerId: layerObj.get('layer_id')
					}]);

				}
			},
			failure: function(result) {
				callback([{
					layerId: layerObj.get('layer_id')
				}]);

			}
		});
	};

	function getServicePolygonInfo(mapObj, layerObj, feature, evt, key,mapId, callback) {
		var isActive = closeDrawAndMeasure(mapObj.getTarget());
		if (isActive === false) {
			callback([{
				layerId: layerObj.get('layer_id')
			}]);
			return;
		}
		var extent = mapObj.getView().calculateExtent(mapObj.getSize());
		var imgToken = layerObj.get('params.imgToken');
		if (imgToken == undefined) {
			callback([{
				layerId: layerObj.get('layer_id')
			}]);
			return;
		}
		var Fcname = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		var pixLonLat = ol.proj.toLonLat(mapObj.getCoordinateFromPixel(evt.pixel));
		var layerParamObj = layerObj.get('paramObj');
		var paramObj = {
			geometry: JSON.stringify({
				x: evt.coordinate[0],
				y: evt.coordinate[1]
			}),
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  0.1,
			mapExtent: extent,
			imgToken: layerObj.get('params.imgToken'),
			FCName: Fcname

		};
		
		createMasker(mapId);
		
		ajax.get({
			url: constant.GisRootUrl + '/mapRender/identify',
			data: utils.getParameterString(paramObj),
			success: function (result) {
				if (!result) {
					callback([{
						layerId: layerObj.get('layer_id')
					}]);
					return;
				}
				
				//请求成功之后,删除遮罩层
				var _maskerDiv =document.getElementById('singleMaskerLayer');
				_maskerDiv.style.display='none';
				
				
				var responseText = JSON.parse(result);
				var status = responseText.status;
				if (status.code === 1) { //请求成功，可能有数据，可能没数据
					if (responseText.data && responseText.data.length > 0) {
						var datas = responseText.data.map(function (data) {
							var oneData = {
								mapId: mapObj.getTarget(),
								layer: layerObj,
								layerId: layerObj.get('layer_id'),
								layerType: layerObj.get('businessType'),
								label: layerObj.get('params.label'),
								lonLat: data.centerPoint,
								pixLonLat: pixLonLat,
								geometry: data.geometry,
								extentInfo: data.extentInfo,
								geoId: data.id,
								geoName: data.name,
								key: key,
								feature: feature
							};

							return oneData;
						});

						if (callback && typeof callback === 'function') {
							callback(datas);
						}
					}
					else {
						callback([{
							layerId: layerObj.get('layer_id')
						}]);
					}
				}
			},
			failure: function(result) {
				callback([{
					layerId: layerObj.get('layer_id')
				}]);
			}
		});
	};

	function getServicePointInfo(mapObj, layerObj, feature, evt, key,mapId, callback) {
		var isActive = closeDrawAndMeasure(mapObj.getTarget());
		if (isActive === false) {
			callback([{
				layerId: layerObj.get('layer_id')
			}]);
			return;
		}
		var extent = mapObj.getView().calculateExtent(mapObj.getSize());
		var imgToken = layerObj.get('imgToken');
		if (imgToken == undefined) {
			callback([{
				layerId: layerObj.get('layer_id')
			}]);
			return;
		}
		var fcName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined
		var pixLonLat = ol.proj.toLonLat(mapObj.getCoordinateFromPixel(evt.pixel));
		var layerParamObj = layerObj.get('paramObj');
		var paramObj = {
			geometry: JSON.stringify({
				x: evt.coordinate[0],
				y: evt.coordinate[1]
			}),
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  2,
			mapExtent: extent,
			imgToken: layerObj.get('imgToken'),
			FCName: fcName
		};
		
		createMasker(mapId);
		
		ajax.get({
			url: constant.GisRootUrl + '/mapRender/identify',
			data: utils.getParameterString(paramObj),
			success: function (result) {
				if (!result) {
					callback([{
						layerId: layerObj.get('layer_id')
					}]);
					return;
				}
				
				//请求成功之后,删除遮罩层
				var _maskerDiv =document.getElementById('singleMaskerLayer');
				_maskerDiv.style.display ='none';
				
				var responseText = JSON.parse(result);
				var status = responseText.status;
				if (status.code === 1) { //请求成功，可能有数据，可能没数据
					if (responseText.data && responseText.data.length > 0) {
						var datas = responseText.data.map(function (data) {
							var oneData = {
								mapId: mapObj.getTarget(),
								layer: layerObj,
								layerId: layerObj.get('layer_id'),
								layerType: layerObj.get('businessType'),
								label: layerObj.get('params.label'),
								lonLat: data.centerPoint,
								pixLonLat: pixLonLat,
								geometry: data.geometry,
								extentInfo: data.extentInfo,
								geoId: data.id,
								geoName: data.name,
								key: key,
								feature: feature
							};

							return oneData;
						});

						if (callback && typeof callback === 'function') {
							callback(datas);
						}
					}
					else {
						callback([{
							layerId: layerObj.get('layer_id')
						}]);
					}
				}
				else {
					callback([{
						layerId: layerObj.get('layer_id')
					}]);
				}
			},
			failure: function(result) {
				callback([{
					layerId: layerObj.get('layer_id')
				}]);
			}
		});
	};

	function getServiceLineInfo(mapObj, layerObj, feature, evt, key, mapId,callback) {
		var isActive = closeDrawAndMeasure(mapObj.getTarget());
		if (isActive === false) {
			callback([{
				layerId: layerObj.get('layer_id')
			}]);
			return;
		}
		var extent = mapObj.getView().calculateExtent(mapObj.getSize());
		var imgToken = layerObj.get('imgToken');
		if (imgToken == undefined) {
			callback([{
				layerId: layerObj.get('layer_id')
			}]);
			return;
		}
		var fcName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined
		var pixLonLat = ol.proj.toLonLat(mapObj.getCoordinateFromPixel(evt.pixel));
		var layerParamObj = layerObj.get('paramObj');
		var paramObj = {
			geometry: JSON.stringify({
				x: evt.coordinate[0],
				y: evt.coordinate[1]
			}),
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  10,
			mapExtent: extent,
			imgToken: layerObj.get('imgToken'),
			FCName: fcName
		};
		
		createMasker(mapId);
		
		ajax.get({
			url: constant.GisRootUrl + '/mapRender/identify',
			data: utils.getParameterString(paramObj),
			success: function (result) {
				if (!result) {
					callback([{
						layerId: layerObj.get('layer_id')
					}]);
					return;
				}
				
				//请求成功之后,删除遮罩层
				var _maskerDiv =document.getElementById('singleMaskerLayer');
				_maskerDiv.style.display='none';
				
				var responseText = JSON.parse(result);
				var status = responseText.status;
				if (status.code === 1) { //请求成功，可能有数据，可能没数据
					if (responseText.data && responseText.data.length > 0) {
						var datas = responseText.data.map(function (data) {
							var oneData = {
								mapId: mapObj.getTarget(),
								layer: layerObj,
								layerId: layerObj.get('layer_id'),
								layerType: layerObj.get('businessType'),
								label: layerObj.get('params.label'),
								lonLat: data.centerPoint,
								pixLonLat: pixLonLat,
								geometry: data.geometry,
								extentInfo: data.extentInfo,
								geoId: data.id,
								geoName: data.name,
								key: key,
								feature: feature
							};

							return oneData;
						});

						if (callback && typeof callback === 'function') {
							callback(datas);
						}
					}
					else {
						callback([{
							layerId: layerObj.get('layer_id')
						}]);
					}
				}
			},
			failure: function(result) {
				callback([{
					layerId: layerObj.get('layer_id')
				}]);
			}
		});
	};


	module.exports = {
		mapClick: mapClick
	};

/***/ },
/* 16 */
/*!*********************************!*\
  !*** ./src/gis/utils/olUtil.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var utilView = new ol.View();

	function getLayer(paramObj) {
	    var mapId = paramObj.mapId;
	    var layerId, attr;
	    if (paramObj.layerId) {
	        layerId = paramObj.layerId;
	        attr = 'layerId';
	    }
	    else if (paramObj.layer_id) {
	        layerId = paramObj.layer_id;
	        attr = 'layer_id';
	    }
	    var layers = !!mapBox.getMapObj(mapId) ? mapBox.getMapObj(mapId).getLayers().getArray().slice(0) : [];
	    return utils.find(layers, function (layerObj) {
	        if (layerObj && layerObj.get(attr) === (layerId)) {
	            return layerObj;
	        }
	    });
	}

	function removeLayer(paramObj) {
	    var mapId = paramObj.mapId;
	    var mapObj = mapBox.getMapObj(mapId);
	    var layerId, attr;
	    if (paramObj.layerId) {
	        layerId = paramObj.layerId;
	        attr = 'layerId';
	    }
	    else if (paramObj.layer_id) {
	        layerId = paramObj.layer_id;
	        attr = 'layer_id';
	    }
	    var layers = mapBox.getMapObj(mapId).getLayers().getArray().slice(0);
	    utils.find(layers, function (layerObj) {
	        if (layerObj && layerObj.get(attr) === (layerId)) {
	            mapObj.removeLayer(layerObj);
	            return layerObj;
	        }
	    });
	}

	function _isFinite(cc) {
	    return isFinite(cc) && cc !== null && cc !== false;
	}

	/**
	 * 获取Projection
	 * @param projLike {String|Number|ol.proj.Projection}
	 * @returns {ol.proj.Projection|null}
	 */
	function getProjection(projLike) {
	    if (_isFinite(projLike)) {
	        projLike = 'EPSG:' + projLike;
	        return ol.proj.get(projLike);
	    }
	    else if (typeof projLike === 'string') {
	        projLike = projLike.toUpperCase();
	        return ol.proj.get(projLike);
	    }
	    else if (projLike instanceof ol.proj.Projection) {
	        return projLike;
	    }

	    return null;
	}

	/**
	 * 改变坐标点集coordinates的投影坐标系
	 * @param coordinates {ol.Coordinate[]}
	 * @param source
	 * @param destination
	 * @return {*}
	 */
	function transform(coordinates, source, destination) {
	    if (!source || !destination) {
	        return coordinates;
	    }
	    source = getProjection(source);
	    destination = getProjection(destination);
	    var transformFunc = ol.proj.getTransform(source, destination);
	    if (typeof coordinates[0] === 'string' ||
	        typeof coordinates[0] === 'number') {
	        return transformFunc(coordinates);
	    }
	    else {
	        return coordinates.map(function (coordinate) {
	            return transformFunc(coordinate);
	        });
	    }

	}

	function getMap(mapId) {
	    return mapBox.getMapObj(mapId);
	}

	/**
	 * 根据名字获取overlay
	 * @param mapId
	 * @param ovName
	 */
	function getOverlayByName(mapId, ovName) {
	    var overlays = getMap(mapId).getOverlays().getArray().slice(0);
	    return utils.find(overlays, function (item) {
	        return item.get('name') === ovName;
	    });
	}

	/**
	 * 通过名字获取interaction
	 * @param mapId
	 * @param interName
	 */
	function getIntactByName(mapId, interName) {
	    var interactions = getMap(mapId).getInteractions().getArray().slice(0);
	    return utils.find(interactions, function (item) {
	        return item.get('name') === interName;
	    });
	}

	/**
	 * 根据类型删除Feature
	 * @param source {object}   new ol.source
	 * @param type {String}
	 * */
	function delFeatureByType(source, type) {
	    if (!source) {
	        return;
	    }
	    source.getFeatures().slice(0).forEach(function (feature) {
	        if (feature.get('type') === type) {
	            source.removeFeature(feature);
	        }
	    });
	}

	/**
	 * 获取一个新的弹出框ZIndex,每次在上次的基础上加1
	 * @param mapId
	 * @returns {number}
	 */
	function getPopupZIndex(mapId) {
	    var olMap = getMap(mapId);
	    if (!olMap) {
	        return;
	    }
	    var statistics = olMap.get('statistics');
	    if (!statistics.popupZIndex) {
	        statistics.popupZIndex = 20;
	    }
	    else {
	        statistics.popupZIndex += 1;
	    }
	    return statistics.popupZIndex;
	}

	/**
	 * 获取点集所代表的polygon面积
	 * @param coordinates
	 * @returns {Number}
	 */
	function getPolygonArea(coordinates) {
	    var polygon = new ol.geom.Polygon([coordinates])
	        .transform('EPSG:4326', 'EPSG:3857');
	    return polygon.getArea();
	}

	/**
	 * 根据地图坐标范围获取地图级别
	 * @param params {Object} =
	 * {
	 *      mapId:{string} 地图ID
	 *      extent:{Array} 地图范围数组，数组长度为4
	 *      projection:{string|number} 地图范围所使用的投影坐标系，
	 * }
	 *
	 * @returns {number|undefined}
	 */
	function getZoomForExtent(params) {
	    var olMap = getMap(params.mapId);
	    if (!olMap) {
	        return;
	    }
	    if (!params.extent || params.extent.length !== 4) {
	        return;
	    }
	    if (!params.projection) {
	        params.projection = 'EPSG:4326';
	    }
	    var prj = getProjection(params.projection);
	    var extent3857 = ol.proj.transformExtent(params.extent, prj, 'EPSG:3857');
	    utilView.fit(extent3857, olMap.getSize());
	    return utilView.getZoom();
	}


	function closeDrawAndMeasure(mapId) {
		var measureTypes = ['geoLine', 'geoArea', 'geoAngle'];
		var drawTypes = ['Point', 'LineString', 'Polygon', 'Square', 'Box'];
		
		var measureStatuss =  measureTypes.map(function(item, index) {
			return fusiongis.Measure.isMeasuring({
				mapId: mapId,
				measureType: item
			});
		});
		
		var drawStatuss = drawTypes.map(function(item, index) {
			return fusiongis.Geometry.isDrawing({
				mapId: mapId,
				type: item
			});
		});
		
		var statuss = measureStatuss.concat(drawStatuss);

		
		var _statuss = statuss.filter(function(item, index) {
			return item == true;
		});
		if (_statuss instanceof Array && _statuss.length > 0) {
			return false;//有交互操作
		}
		else {
			return true;
		}
	}


	function transformLonLat(_feature, serverFeature) {
		var finalCoordinates = [];
		if(arguments.length === 2) {
			var layerType = serverFeature.layerType;
			var coordinates = serverFeature.geometry;
			if(!!coordinates) {
				if(typeof coordinates === 'String') {
					coordinates = JSON.parse(coordinates);
				}
				var _polygon = function() {
					for(var i = 0; i < coordinates.length; i++) {
						var coordinate3857 = coordinates[i];
						finalCoordinates.push(ol.proj.toLonLat(coordinate3857));
					}
				};

				var _point = function() {
					for(var i = 0; i < coordinates.length; i++) {
						var _coordinate = coordinates[i];
						finalCoordinates.push(ol.proj.toLonLat(_coordinate));
					}
				};

				var _grid = function() {
					for(var i = 0; i < coordinates.length; i++) {
						var _coordinate = coordinates[i];
						finalCoordinates.push(ol.proj.transformExtent(_coordinate, 'EPSG:3857', 'EPSG:4326'));
					}
				};

				switch(layerType) {
					case constant.BUSINESSTYPE.GRID:
						_grid();
						break;
					case constant.BUSINESSTYPE.SITE:
						_point();
						break;
					case constant.BUSINESSTYPE.SERVICEPOINT:
						_point();
						break;
					case constant.BUSINESSTYPE.CELL:
						_polygon();
						break;
					case constant.BUSINESSTYPE.SERVICELINE:
						_polygon();
						break;
					default:
						_polygon();
				}
			}
		} else {
			var _geometry = _feature && _feature.getGeometry();
			if(!!!_geometry) {
				return;
			}
			if(_geometry instanceof ol.geom.GeometryCollection) {
				return;
			}
			var coordinates3857 = _geometry.getCoordinates();

			if(!!!coordinates3857) {
				return [];
			}

			if(_geometry instanceof ol.geom.Point) {
				finalCoordinates.push(ol.proj.toLonLat(coordinates3857))
			} else if(_geometry instanceof ol.geom.LineString) {
				for(var i = 0; i < coordinates3857.length; i++) {
					var coordinate3857 = coordinates3857[i];
					finalCoordinates.push(ol.proj.toLonLat(coordinate3857));
				}
			} else if(_geometry instanceof ol.geom.Polygon) {
				for(var i = 0; i < coordinates3857[0].length; i++) {
					var coordinate3857 = coordinates3857[0][i];
					finalCoordinates.push(ol.proj.toLonLat(coordinate3857));
				}
			}
		}
		return finalCoordinates;
	}

	module.exports = {
	    getLayer: getLayer,
	    removeLayer: removeLayer,
	    transform: transform,
	    getOverlayByName: getOverlayByName,
	    getIntactByName: getIntactByName,
	    delFeatureByType: delFeatureByType,
	    getPopupZIndex: getPopupZIndex,
	    getZoomForExtent: getZoomForExtent,
	    getPolygonArea: getPolygonArea,
	    closeDrawAndMeasure: closeDrawAndMeasure,
	    transformLonLat: transformLonLat
	};

/***/ },
/* 17 */
/*!*******************************************!*\
  !*** ./src/gis/maps/eventMultiFeature.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var popup = __webpack_require__(/*! tools/popup */ 12);
	var popupInFrame = __webpack_require__(/*! framework/popup */ 9);
	var i18n = __webpack_require__(/*! utils/i18n */ 13);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var ajax = __webpack_require__(/*! utils/ajax */ 14);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var closeDrawAndMeasure = olUtil.closeDrawAndMeasure;
	var transformLonLat = olUtil.transformLonLat;


	function mapClick(mapId, initMapParam) {
		//所有服务数据返回成功后，一次性将数据返回给用户
		var g_ = new Map();
		var g_vectorFeature = undefined;
		var g_getGridInfo = undefined;
		var g_getSiteInfo = undefined;
		var g_getServicePointInfo = undefined;
		var g_getServiceLineInfo = undefined;
		var g_getServicePolygonInfo = undefined;

		var mapObj = mapBox.getMapObj(mapId);
		//防止注册多个事件
		if (mapObj.get('clickHandle')) {
			return;
		}
		mapObj.set('callbackList', {});
		mapObj.set('eventKeyANDEventLayerObj', {});
		var clickHandle = mapObj.on('click', function (e) {
			var isActive = closeDrawAndMeasure(mapObj.getTarget());
			if (isActive === false) {
				var _callbackList = mapObj.get('callbackList');
				if (_callbackList['measure-distance-click-event']) {    ////测距中间拐点处弹出长度提示
					_callbackList['measure-distance-click-event']({e: e});
				}
				return;
			}
			var featuresAtPix = [];
			var pixLonLat = ol.proj.toLonLat(mapObj.getCoordinateFromPixel(e.pixel));
			var businessFeatureArray = [];
			var returnEveryLayClickData = {}; //存放每个图层点击后的数据，统一返回给用户
			var _hasFeatureAtPixel = mapObj.hasFeatureAtPixel(e.pixel);
			if (!_hasFeatureAtPixel) {
				popup.removeAllPopup(mapObj.getTarget());
				popupInFrame.removePopup(mapObj.getTarget());
			}

			mapObj.forEachFeatureAtPixel(e.pixel, function (feature) {
				if (!!feature) {
					var _featureVecType = feature.get('vectorType');
					var _businessType = constant.BUSINESSTYPE;
					var clusterFeature = feature.get('features');
					var _culsterFeatureType ='';
					if (clusterFeature && clusterFeature instanceof Array && clusterFeature.length === 1) {
						culsterFeatureType =clusterFeature[0].get('vectorType');
						businessFeatureArray.push(clusterFeature[0]);
					}
					if (_featureVecType === _businessType.POINT || _featureVecType === _businessType.LINE ||
						_featureVecType === _businessType.POLYGON || _featureVecType === _businessType.ICON ||
						_featureVecType === _businessType.CIRCLEPOINT|| _featureVecType === _businessType.VECTOR_CELL||
						_featureVecType === _businessType.STRAIGHTLINE || _featureVecType === _businessType.ICON_FONT_STYLE ||
						_featureVecType === _businessType.BUBBLE_CIRCLE_LABEL ||
					    _culsterFeatureType ===  'ICON_CLUSTER' ) {

						if (!!!feature.get('highlightFeature')) {
							businessFeatureArray.push(feature);
						}
					}
					featuresAtPix.push(feature);
				}
			});

			var _callbackList = mapObj.get('callbackList');
			var _eventKeyANDEventLayerObj = mapObj.get('eventKeyANDEventLayerObj');
			if(businessFeatureArray.length > 0) { //代表不同图层的feature
				var _eventData = [];
				for(var i = 0; i < businessFeatureArray.length; i++) {

					var _feature = businessFeatureArray[i];
					if(!_feature) {
						return;
					}
					var _businessType = _feature.get('vectorType');
					var _layer = _feature.get('layer');
					var _featureExtent = _feature.getGeometry().getExtent();
					var _featureCenter = ol.extent.getCenter(_featureExtent);
					var _featureCenter4326 = ol.proj.toLonLat(_featureCenter);
					var _centerWcjFrom4326 =utils.gcj_decTransform([_featureCenter4326[0].toFixed(6), _featureCenter4326[1].toFixed(6)]);

					var callbackData = {
						e: e,
						mapId: mapId,
						layerId: !!_layer && _layer.get('layer_id'),
						layer: _feature.get('layer'),
						businessType: _layer && _layer.get('businessType'),
						feature: _feature,
						data: _feature.get('data'),
						geoId: _feature.getId() ? _feature.getId() : _feature.get('id'),
						lonLat: _centerWcjFrom4326,
						pixLonLat: pixLonLat,
						points: transformLonLat(_feature)
					};
					g_vectorFeature = 'yes';
					g_.set('g_vectorFeature', g_vectorFeature);
					if (businessFeatureArray.length === 1) {
						var isClusterPoint = businessFeatureArray[0].get('features')
							&& businessFeatureArray[0].get('features') instanceof Array
							&& businessFeatureArray[0].get('features').length === 1;
						var clusterLayer = !!isClusterPoint ?
							businessFeatureArray[0].get('features')[0].get('layer') : undefined;
						callbackData['layer'] = !!isClusterPoint && clusterLayer ?
							clusterLayer : callbackData.layer;
						if (!!_callbackList['point-cluster-click-event']) {
							_callbackList['point-cluster-click-event'](callbackData);
						}
					}
					_eventData.push(callbackData);
				}

				if(_eventData.length > 0) {
					for(var i = 0; i < _eventData.length;i++) {
						var callBackList = []; //代表同一图层的features
						var keys =[];
						for(var key in returnEveryLayClickData ){
							keys.push(key);
						}
						if (keys.indexOf((_eventData[i].layerId).toString()) < 0) {
							for (var j = i; j <= _eventData.length - 1; j++) {
	                            if (_eventData[i].layerId ==_eventData[j].layerId) {
	                                callBackList.push(_eventData[j]);
	                                returnEveryLayClickData[_eventData[i].layerId] = callBackList;
	                            }
	                        }

						}
					}
				}
			}

			for (var clickEventUniqueKey in _callbackList) {
				if (_callbackList[clickEventUniqueKey] != undefined && typeof _callbackList[clickEventUniqueKey] === 'function') {
					var _feature = null;
					if (featuresAtPix.length > 0) {
						_feature = featuresAtPix[0];
					}

					var _featureExtent = _feature && _feature.getGeometry().getExtent();
					var _featureCenter = _featureExtent && ol.extent.getCenter(_featureExtent);
					var _featureCenter4326 = [];
					if (!!_featureCenter) {
						_featureCenter4326 = ol.proj.toLonLat(_featureCenter);
					}

					var _layer = _eventKeyANDEventLayerObj[clickEventUniqueKey];
					//geoId, lonLat, mapId, layerType, layerId,points
					if (_layer != undefined) {
						if (_layer.get('businessType') === constant.BUSINESSTYPE.GRID) {
							g_getGridInfo = 'no';
							g_.set('g_getGridInfo', g_getGridInfo);
							getGridInfo(mapObj, _layer, _feature, e, clickEventUniqueKey, function (objs) {
								g_getGridInfo = 'yes';
								g_.set('g_getGridInfo', g_getGridInfo);
								if (!!objs && objs.length > 0) {
									returnEveryLayClickData[objs[0].layerId] = objs;
								}
								else {
									returnEveryLayClickData[objs[0].layerId] = [{}];
								}
							})
						}  else if (_layer.get('businessType') === 'SITE') {
							g_getSiteInfo = 'no';
							g_.set('g_getSiteInfo', g_getSiteInfo);
							getSiteInfo(mapObj, _layer, _feature, e, clickEventUniqueKey, function (objs) {
								g_getSiteInfo = 'yes';
								g_.set('g_getSiteInfo', g_getSiteInfo);
								if (objs && objs.length > 0) {
									returnEveryLayClickData[objs[0].layerId] = objs;
								}
								else {
									returnEveryLayClickData[objs[0].layerId] = [{}];
								}
							});
						}  else if (_layer.get('businessType') === constant.BUSINESSTYPE.SERVICEPOINT) {
							g_getServicePointInfo = 'no';
							g_.set('g_getServicePointInfo', g_getServicePointInfo);
							getServicePointInfo(mapObj, _layer, _feature, e, clickEventUniqueKey, function (objs) {
								g_getServicePointInfo = 'yes';
								g_.set('g_getServicePointInfo', g_getServicePointInfo);
								if (objs && objs.length > 0) {
									returnEveryLayClickData[objs[0].layerId] = objs;
								}
								else {
									returnEveryLayClickData[objs[0].layerId] = [{}];
								}
							});
						} else if (_layer.get('businessType') === constant.BUSINESSTYPE.SERVICELINE) {
							g_getServiceLineInfo = 'no';
							g_.set('g_getServiceLineInfo', g_getServiceLineInfo);
							getServiceLineInfo(mapObj, _layer, _feature, e, clickEventUniqueKey, function (objs) {
								g_getServiceLineInfo = 'yes';
								g_.set('g_getServiceLineInfo', g_getServiceLineInfo);
								if (objs && objs.length > 0) {
									returnEveryLayClickData[objs[0].layerId] = objs;
								}
								else {
									returnEveryLayClickData[objs[0].layerId] = [{}];
								}
							});
						} else if (_layer.get('businessType') === constant.BUSINESSTYPE.SERVICEPOLYGON) {
							g_getServicePolygonInfo = 'no';
							g_.set('g_getServicePolygonInfo', g_getServicePolygonInfo);
							getServicePolygonInfo(mapObj, _layer, _feature, e, clickEventUniqueKey, function (objs) {
								g_getServicePolygonInfo = 'yes';
								g_.set('g_getServicePolygonInfo', g_getServicePolygonInfo);
								if (objs && objs.length > 0) {
									returnEveryLayClickData[objs[0].layerId] = objs;
								}
								else {
									returnEveryLayClickData[objs[0].layerId] = [{}];
								}
							});
						}
						else if(_layer.get('businessType') === 'SERVICELAYER'){
							fusiongis.ServiceLayer.getServiceLayerInfo(mapObj, _layer, e,function (objs) {
								if (objs && objs.length > 0) {
									returnEveryLayClickData[objs[0].layerId] = objs;
								}
							});
						}
					}
				}
			}

			var isAllValidRequstResponse = undefined;
			try {
				isAllValidRequstResponse = setInterval(function () {
					var _g = [];
					g_.forEach(function (v, k) {
						_g.push({
							key: k,
							val: v
						})
					})

					//过滤用户添加到地图上的图层
					var _validLayer = _g.filter(function (g) {
						return g.val != undefined;
					})

					//通过定时器来完成，当所有的图层都返回数据时，一次性将数据返回给用户，
					var isYes = false;
					var isYesArary = [];
					for (var i = 0; i < _validLayer.length; i++) {
						if (_validLayer[i].val == 'yes') {
							isYes = true;
						}
						else {
							isYes = false;
						}
						isYesArary.push(isYes);
					}
					isYes = isYesArary.every(function(v) {
						return v == true
					});
					if (isYes) {
						var totalLayerDataLen = Object.getOwnPropertyNames(returnEveryLayClickData).length;
						if (totalLayerDataLen > 0) {
							if (totalLayerDataLen == 1) {
								//the same layer
								
								var _popPosition = undefined;
								for (var key in returnEveryLayClickData) {
									if (_popPosition == undefined) {
										_popPosition = returnEveryLayClickData[key][0].pixLonLat;
									}
									
									if (returnEveryLayClickData[key].length == 1) {
										//the same layer and one feature
										
											var _clickFeatureInfor = returnEveryLayClickData[key][0];
											if (_clickFeatureInfor.layerType == 'GRID') {
												if (_clickFeatureInfor.geometry !=  undefined) {
													fusiongis.Highlight.removeHighlight({
														mapId: _clickFeatureInfor.mapId,
														layerId: _clickFeatureInfor.layerId,
														hTypes: [constant.HTYPE.CLICK]
													});
													fusiongis.Highlight.highlight({
														mapId: _clickFeatureInfor.mapId,
														layerId: _clickFeatureInfor.layerId,
														highlightType: constant.HTYPE.CLICK,
														geometry: _clickFeatureInfor.geometry
													});
												}
											}
											else {
												if (_clickFeatureInfor.geoId != undefined) {
													fusiongis.Highlight.removeHighlight({
														mapId: _clickFeatureInfor.mapId,
														layerId: _clickFeatureInfor.layerId,
														hTypes: [constant.HTYPE.VECTOR]
													});
													fusiongis.Highlight.highlight({
														mapId: _clickFeatureInfor.mapId,
														layerId: _clickFeatureInfor.layerId,
														highlightType: constant.HTYPE.VECTOR,
														geoIds: [_clickFeatureInfor.geoId]
													});
												}
											}

											//UIclickId
											var _eventKey = _clickFeatureInfor.layer == undefined ? undefined :  _clickFeatureInfor.layer.get('UIclickId');
											if (_eventKey == undefined) {
												clearInterval(isAllValidRequstResponse);
												return;
											}
											_callbackList[_eventKey]({
												e: _clickFeatureInfor.e,
												layer: _clickFeatureInfor.layer,
												feature: _clickFeatureInfor.feature,
												featureCenter: _clickFeatureInfor.lonLat,
												data: _clickFeatureInfor.data,
												geoId: _clickFeatureInfor.geoId,
												lonLat: _clickFeatureInfor.lonLat,
												points: _clickFeatureInfor.points,
												businessType: _clickFeatureInfor.businessType,
												layerType: _clickFeatureInfor.businessType,
												mapId: _clickFeatureInfor.mapId,
												target: _clickFeatureInfor.mapId,
												layerId: _clickFeatureInfor.layerId,
												featureId: _clickFeatureInfor.geoId,
												pixLonLat: _clickFeatureInfor.pixLonLat
											});
									}
									else if (returnEveryLayClickData[key].length > 1){
										//the same layer, but many feature overlap

										var _count = 0;
										if (returnEveryLayClickData[key][0] === undefined || returnEveryLayClickData[key][0] === null) {
											return;
										}
										var _mapId = returnEveryLayClickData[key][0].mapId;
										var _layerId = returnEveryLayClickData[key][0].layerId;
										var _layerName = returnEveryLayClickData[key][0].layerId;
										if (returnEveryLayClickData[key][0].layer != undefined) {
											if (returnEveryLayClickData[key][0].layer.get('params.label') != undefined && returnEveryLayClickData[key][0].layer.get('params.label') != null) {
												_layerName = returnEveryLayClickData[key][0].layer.get('params.label');
											}
										}
										var _content = '<div>' +
											'<div style="height: 27px;background-color: rgba(3, 169, 244, 0.67);text-align:left;text-indent: 10px;font-size: 14px;font-weight: bold;line-height: 27px;color: white">'+i18n.prop('multifeature.popup.title')+'</div>' + 
											'<div style="max-width: 250px; max-height: 130px; overflow: auto;font-size: 14px; white-space: nowrap;padding: 0px 10px 5px 10px;"  id="'+ _mapId +'">';
										for (var i = 0; i < returnEveryLayClickData[key].length; i++) {
											var _clickFeatureInfor = returnEveryLayClickData[key][i];
											var _geoId = _clickFeatureInfor.geoId;
											var _geometry = _clickFeatureInfor.points;
											if (_geoId === undefined) {
												continue;
											}
											_count++;
											var _innerHtml = i18n.prop('multifeature.popup.layer') + _layerName + '&nbsp;&nbsp;&nbsp;&nbsp;' + i18n.prop('multifeature.popup.feature') + _geoId;
											_content += '<div style="cursor: pointer; height: 25px; line-height: 25px;"' +
												'geometry="'+  _geometry +'" layerId="'+ _layerId +'" geoId="'+ _geoId +'">' + _innerHtml +'</div>';
										}
										_content += '</div></div>';
										if (_count === 0) {
											return;
										}
										
										popupInFrame.addPopup({
											mapId: _mapId,
											position: _popPosition,
											content: _content,
											showCloseButton: true,
											radius: false
										});
										
										if (document.querySelector('#' + _mapId).querySelector('#' + _mapId) == null 
												|| document.querySelector('#' + _mapId).querySelector('#' + _mapId) == undefined) {
											return;
										}
										var _featuresInclkPix =  document.querySelector('#' + _mapId).querySelector('#' + _mapId).querySelectorAll('div');
										if (_featuresInclkPix != undefined && _featuresInclkPix.length > 0) {
											for (var i = 0; i < _featuresInclkPix.length; i++) {
												var _featureInClkPix = _featuresInclkPix[i];
												if (_featureInClkPix == undefined) {
													return;
												}
												_featureInClkPix.onclick = _featureInClkPix_;
											}
										}
										
										
										function _featureInClkPix_() {
											var _layerType = null;
											var _layer_ = fusiongis.BaseLayer.getLayer({
												mapId: _mapId,
												layerId: _layerId
											});
											if (_layer_ != undefined) {
												_layerType = _layer_.get('layerType');
											}
											if (_layerType == 'GRID') {
												if (this.getAttribute('geometry') != undefined) {
													fusiongis.Highlight.removeHighlight({
														mapId: _mapId,
														layerId: _layerId,
														hTypes: [constant.HTYPE.CLICK]
													});
													fusiongis.Highlight.highlight({
														mapId: _mapId,
														layerId: _layerId,
														highlightType: constant.HTYPE.CLICK,
														geometry: this.getAttribute('geometry')
													});
												}
											}
											else {
												if ([this.getAttribute('geoId')] != undefined) {
													fusiongis.Highlight.removeHighlight({
														mapId: _mapId,
														layerId: _layerId,
														hTypes: [constant.HTYPE.VECTOR]
													});
													fusiongis.Highlight.highlight({
														mapId: _mapId,
														layerId: _layerId,
														highlightType: constant.HTYPE.VECTOR,
														geoIds: [this.getAttribute('geoId')]
													});
												}
											}
											popupInFrame.removePopup(_mapId);



											var _eventKey = returnEveryLayClickData[key][0].layer.get('UIclickId');
											for (var i = 0; i < returnEveryLayClickData[key].length; i++) {
												var _geoId = returnEveryLayClickData[key][i].geoId;
												if (_geoId == this.getAttribute('geoId')) {
													var _clickFeatureInfor = returnEveryLayClickData[key][i];

													_callbackList[_eventKey]({
														e: _clickFeatureInfor.e,
														layer: _clickFeatureInfor.layer,
														feature: _clickFeatureInfor.feature,
														featureCenter: _clickFeatureInfor.lonLat,
														data: _clickFeatureInfor.data,
														geoId: _clickFeatureInfor.geoId,
														lonLat: _clickFeatureInfor.lonLat,
														points: _clickFeatureInfor.points,
														businessType: _clickFeatureInfor.businessType,
														layerType: _clickFeatureInfor.businessType,
														mapId: _clickFeatureInfor.mapId,
														target: _clickFeatureInfor.mapId,
														layerId: _clickFeatureInfor.layerId,
														featureId: _clickFeatureInfor.geoId,
														pixLonLat: _clickFeatureInfor.pixLonLat
													});
													break;
												}
											}
										}
										
										_count = 0;
									}
								}
								
								
							}
							else {
							//different layer

								var _mapId = undefined;
								var _content = undefined;
								var _popupPosition = undefined;
								var _count = 0;
								var _whenOnlyFeatureInfo = {};
								for (var layerId in returnEveryLayClickData) {
									if (_mapId == undefined) {
										_mapId = returnEveryLayClickData[layerId][0].mapId;
										_content = '<div>' +
												'<div style="height: 27px;background-color: rgba(3, 169, 244, 0.67);text-align:left;text-indent: 10px;font-size: 14px;' +
														'font-weight: bold;line-height: 27px;color:white">'+i18n.prop('multifeature.popup.title')+'</div>' +
												'<div style="max-width: 250px; max-height: 130px; overflow: auto;font-size: 14px; white-space: nowrap;padding: 0px 10px 5px 10px;"  id="'+ _mapId +'">';
									}
									if (_popupPosition == undefined) {
										_popupPosition = returnEveryLayClickData[layerId][0].pixLonLat
									}
									

									var _featuresAtOneLayer = returnEveryLayClickData[layerId];
									if (_featuresAtOneLayer != undefined && _featuresAtOneLayer.length > 0) {
										 for (var i = 0; i < _featuresAtOneLayer.length; i++) {
										 	if (_featuresAtOneLayer[i] === undefined || _featuresAtOneLayer[i] === null) {
										 		return;
										 	}
											var _geoId = _featuresAtOneLayer[i].geoId;
											var _layerId = _featuresAtOneLayer[i].layerId;
											var _layerName = _featuresAtOneLayer[i].layerId;
											if (_featuresAtOneLayer[i].layer != undefined) {
												if (_featuresAtOneLayer[i].layer.get('params.label') != undefined && _featuresAtOneLayer[i].layer.get('params.label') != null) {
													_layerName = _featuresAtOneLayer[i].layer.get('params.label');
												}
											}
											var _geometry = _featuresAtOneLayer[i].points;
											if (_geoId === undefined) {
												continue;
											}
											_count++;
											_whenOnlyFeatureInfo.geoId = _geoId;
											_whenOnlyFeatureInfo.geometry = _geometry;
											_whenOnlyFeatureInfo.layerId = _layerId;
											var _innerHtml = i18n.prop('multifeature.popup.layer') + _layerName + '&nbsp;&nbsp;&nbsp;&nbsp;' + i18n.prop('multifeature.popup.feature') + _geoId;
											_content += '<div style="cursor: pointer; height: 25px; line-height: 25px;"' +
												'geometry="'+ _geometry +'" layerId = "' + _layerId + '" geoId = "' + _geoId + '">' + _innerHtml +'</div>';
										 }
									}
								}
								_content += '</div></div>';
								
								if (_count === 1) {
									_onlyFeatureOnDiffLayer();
									clearInterval(isAllValidRequstResponse);
									return;
								}
								
								
								popupInFrame.addPopup({
									mapId: _mapId,
									position: _popupPosition,
									content: _content,
									showCloseButton: true,
									radius: false
								});

								if (document.querySelector('#' + _mapId).querySelector('#' + _mapId) == null 
									|| document.querySelector('#' + _mapId).querySelector('#' + _mapId) == undefined) {
									return;
								}
								var _featuresInclkPix =  document.querySelector('#' + _mapId).querySelector('#' + _mapId).querySelectorAll('div');
								if (_featuresInclkPix != undefined && _featuresInclkPix.length > 0) {
									for (var i = 0; i < _featuresInclkPix.length; i++) {
										var _featureInClkPix = _featuresInclkPix[i];
										if (_featureInClkPix == undefined ) {
											return;
										}
										_featureInClkPix.onclick = __featureInClkPix_;
									}
								}
								
								
								function __featureInClkPix_ (evt) {
									var _featureInClkPix = evt.target;
									var _layerId = _featureInClkPix.getAttribute('layerId');
									var layerType = null;
									var _layer_ = fusiongis.BaseLayer.getLayer({
										mapId: _mapId,
										layerId: _layerId
									});
									if (_layer_ != undefined) {
										layerType = _layer_.get('layerType');
									}
									if (layerType == 'GRID') {
										if (_featureInClkPix.getAttribute('geometry') != undefined) {
											fusiongis.Highlight.removeHighlight({
												mapId: _mapId,
												layerId: _layerId,
												hTypes: [constant.HTYPE.CLICK]
											});
											fusiongis.Highlight.highlight({
												mapId: _mapId,
												layerId: (function() {
													var _layerId = _featureInClkPix.getAttribute('layerId');
													return _layerId;
												}()),
												highlightType: constant.HTYPE.CLICK,
												geometry: _featureInClkPix.getAttribute('geometry')
											});
										}
									}
									else {
										if ([_featureInClkPix.getAttribute('geoId')] != undefined) {
											fusiongis.Highlight.removeHighlight({
												mapId: _mapId,
												layerId: _layerId,
												hTypes: [constant.HTYPE.VECTOR]
											});
											fusiongis.Highlight.highlight({
												mapId: _mapId,
												layerId: (function() {
													var _layerId = _featureInClkPix.getAttribute('layerId');
													return _layerId;
												}()),
												highlightType: constant.HTYPE.VECTOR,
												geoIds: [_featureInClkPix.getAttribute('geoId')]
											});
										}
									}
									popupInFrame.removePopup(_mapId);


									for (var layerId in returnEveryLayClickData) {
										var _layerId = this.getAttribute('layerId');
										if (_layerId == layerId) {

											var _eventKey = returnEveryLayClickData[_layerId][0].layer.get('UIclickId');
											for (var i = 0; i < returnEveryLayClickData[_layerId].length; i++) {
												var _geoId = returnEveryLayClickData[_layerId][i].geoId;
												if (_geoId == this.getAttribute('geoId')) {
													var _clickFeatureInfor = returnEveryLayClickData[_layerId][i];

													_callbackList[_eventKey]({
														e: _clickFeatureInfor.e,
														layer: _clickFeatureInfor.layer,
														feature: _clickFeatureInfor.feature,
														featureCenter: _clickFeatureInfor.lonLat,
														data: _clickFeatureInfor.data,
														geoId: _clickFeatureInfor.geoId,
														lonLat: _clickFeatureInfor.lonLat,
														points: _clickFeatureInfor.points,
														businessType: _clickFeatureInfor.businessType,
														layerType: _clickFeatureInfor.businessType,
														mapId: _clickFeatureInfor.mapId,
														target: _clickFeatureInfor.mapId,
														layerId: _clickFeatureInfor.layerId,
														featureId: _clickFeatureInfor.geoId,
														pixLonLat: _clickFeatureInfor.pixLonLat
													});
													break;
												}
											}

											break;
										}
									}
								}
								
								//different laye and has only one feature was selected.
								function _onlyFeatureOnDiffLayer() {
									var _layerId = _whenOnlyFeatureInfo.layerId;
									var _geoId = _whenOnlyFeatureInfo.geoId;
									var _geometry = _whenOnlyFeatureInfo.geometry;
									var layerType = null;
									var _layer_ = fusiongis.BaseLayer.getLayer({
										mapId: _mapId,
										layerId: _layerId
									});
									if (_layer_ != undefined) {
										layerType = _layer_.get('layerType');
									}
									if (layerType == 'GRID') {
										if (_geometry != undefined) {
											fusiongis.Highlight.removeHighlight({
												mapId: _mapId,
												layerId: _layerId,
												hTypes: [constant.HTYPE.CLICK]
											});
											fusiongis.Highlight.highlight({
												mapId: _mapId,
												layerId: _layerId,
												highlightType: constant.HTYPE.CLICK,
												geometry: _geometry
											});
										}
									}
									else {
										fusiongis.Highlight.removeHighlight({
											mapId: _mapId,
											layerId: _layerId,
											hTypes: [constant.HTYPE.VECTOR]
										});
										fusiongis.Highlight.highlight({
											mapId: _mapId,
											layerId: _layerId,
											highlightType: constant.HTYPE.VECTOR,
											geoIds: [_geoId]
										});
									}


									for (var layerId in returnEveryLayClickData) {
										var _layerId = _whenOnlyFeatureInfo.layerId;
										if (_layerId == layerId) {

											var _eventKey = returnEveryLayClickData[_layerId][0].layer.get('UIclickId');
											for (var i = 0; i < returnEveryLayClickData[_layerId].length; i++) {
												var _geoId = returnEveryLayClickData[_layerId][i].geoId;
												if (_geoId == _whenOnlyFeatureInfo.geoId) {
													var _clickFeatureInfor = returnEveryLayClickData[_layerId][i];

													_callbackList[_eventKey]({
														e: _clickFeatureInfor.e,
														layer: _clickFeatureInfor.layer,
														feature: _clickFeatureInfor.feature,
														featureCenter: _clickFeatureInfor.lonLat,
														data: _clickFeatureInfor.data,
														geoId: _clickFeatureInfor.geoId,
														lonLat: _clickFeatureInfor.lonLat,
														points: _clickFeatureInfor.points,
														businessType: _clickFeatureInfor.businessType,
														layerType: _clickFeatureInfor.businessType,
														mapId: _clickFeatureInfor.mapId,
														target: _clickFeatureInfor.mapId,
														layerId: _clickFeatureInfor.layerId,
														featureId: _clickFeatureInfor.geoId,
														pixLonLat: _clickFeatureInfor.pixLonLat
													});
													break;
												}
											}

											break;
										}
									}
								}
								
								_count = 0;// reset varibal  value
								
								
							}
						}
						clearInterval(isAllValidRequstResponse);
						g_vectorFeature = undefined;
						g_getGridInfo = undefined;
						g_getSiteInfo = undefined;
						g_getServicePointInfo = undefined;
						g_getServiceLineInfo = undefined;
						g_getServicePolygonInfo = undefined;
					}

				}, 500);
			} catch(e) {
				console.error(e.message);
				clearInterval(isAllValidRequstResponse);
			}

		});
		mapObj.set('clickHandle', clickHandle);
	}


	function getGridInfo(mapObj, layerObj, feature, evt, key, callback) {
		var isActive = closeDrawAndMeasure(mapObj.getTarget());
		if (isActive === false) {
			return;
		}
		var layerParamObj = layerObj.get('paramObj');
		var coords = utils.gcjTransform3857(evt.coordinate);
		var paramObj = {
			geometry: {
				x: coords[0],
				y: coords[1]
			},
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  1,
			mapExtent: mapObj.getView().calculateExtent(mapObj.getSize()),
			imgToken: layerObj.get('imgToken')
		};
		var pixLonLat = ol.proj.toLonLat(mapObj.getCoordinateFromPixel(evt.pixel));

		ajax.postJSON({
			url: constant.GisRootUrl + '/gridManager/getGridInfo?cacheKey=' + layerObj.get('imgToken'),
			data: JSON.stringify(paramObj),
			success: function (resultText) {
				if (!resultText) {
					callback([
						{
							layerId: !!layerObj && layerObj.get('layer_id'),
							mapId:  mapObj.getTarget()
						}
					]);
					return;
				}
				var result = JSON.parse(resultText);
				if (!result || !result.data || !result.data.length) {
					callback([
						{
							layerId: !!layerObj && layerObj.get('layer_id'),
							mapId:  mapObj.getTarget()
						}
					]);
					return;
				}
				if (result.status != undefined && result.status.code == 1) {
					try {
						var backJSON = result.data.map(function (data) {
							return {
								mapId: mapObj.getTarget(),
								layer: layerObj,
								layerId: !!layerObj && layerObj.get('layer_id'),
								layerType: !!layerObj && layerObj.get('businessType'),
								label: !!layerObj && layerObj.get('params.label'),
								feature: feature,
								lonLat: ol.proj.toLonLat(data.centerPoint),
								pixLonLat: pixLonLat,
								geometry: data.geometry,
								geoId: data.id,
								data: data,
								extentInfo: data.extentInfo,
								geoName: data.name,
								key: key,
								originalCenterPoint: data.originalCenterPoint
							};
						});
						callback(backJSON);
					} catch(e){
						callback([
							{
								layerId: !!layerObj && layerObj.get('layer_id'),
								mapId:  mapObj.getTarget()
							}
						]);
						console.log(e);
					}
				}
				else {
					callback([
						{
							layerId: !!layerObj && layerObj.get('layer_id'),
							mapId:  mapObj.getTarget()
						}
					]);
				}
			},
			failure: function(resultText) {
				callback([{
					layerId: !!layerObj && layerObj.get('layer_id'),
					mapId:  mapObj.getTarget()
				}]);
			}
		});
	}


	function getSiteInfo(olMap, olLayer, feature, evt, key, callback) {
		var isActive = closeDrawAndMeasure(olMap.getTarget());
		if (isActive === false) {
			return;
		}
		if (!olLayer.getVisible()) {
			callback([
				{
					layerId: !!olLayer && olLayer.get('layer_id'),
					mapId:  olMap.getTarget()
				}
			]);
			return;
		}
		var mapExtent, imgToken, geometry,dw,_url;
		imgToken = olLayer.get('imgToken');
		dw = olLayer.get('dw'); //通过取dw的属性判断是否走中间件
		if(dw != undefined) {
			_url = constant.GisRootUrl + '/mapRender/identify';
		} else {
			_url = constant.GisRootUrl + '/common/mapRender/identify';
		}
		geometry = JSON.stringify({
			x: evt.coordinate[0],
			y: evt.coordinate[1]
		});
		mapExtent = olMap.getView().calculateExtent(olMap.getSize()).join(',');
		var fcName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		var pixLonLat = ol.proj.toLonLat(olMap.getCoordinateFromPixel(evt.pixel));
		var layerParamObj = olLayer.get('paramObj');
		var params = {
			geometry: geometry,
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  10,
			mapExtent: mapExtent,
			imgToken: imgToken,
			FCName: fcName
		};
		ajax.get({
			url: _url,
			data: utils.getParameterString(params),
			success: function (res) {
				if (!res) {
					callback([
						{
							layerId: !!olLayer && olLayer.get('layer_id'),
							mapId:  olMap.getTarget()
						}
					]);
					return;
				}
				res = JSON.parse(res);
				if (!res || !res.data || !res.data.length) {
					callback([
						{
							layerId: !!olLayer && olLayer.get('layer_id'),
							mapId:  olMap.getTarget()
						}
					]);
					return;
				}

				try {
					var backJSON = res.data.map(function (item) {
						return {
							mapId: olMap.getTarget(),
							layer: olLayer,
							feature: feature,
							layerId: !!olLayer && olLayer.get('layer_id'),
							layerType: !!olLayer && olLayer.get('businessType'),
							label: !!olLayer && olLayer.get('params.label'),
							lonLat: dw != undefined ? item.centerPoint: ol.proj.toLonLat(item.centerPoint),
							pixLonLat: pixLonLat,
							geometry: item.geometry,
							geoId: item.id,
							geoName: item.name,
							key: key
						};
					});

					callback(backJSON);
				} catch (e) {
					if (callback != undefined && typeof callback == 'function') {
						callback([
							{
								layerId: olLayer.get('layer_id'),
								mapId:  olMap.getTarget()
							}
						]);
					}
					console.log(e);
				}
			},
			failure: function(res) {
				if(callback != undefined && typeof callback == 'function') {
					callback([{
						layerId: olLayer.get('layer_id'),
						mapId:  olMap.getTarget()
					}]);
				}
			}
		});
	}



	function getServicePolygonInfo(mapObj, layerObj, feature, evt, key, callback) {
		var isActive = closeDrawAndMeasure(mapObj.getTarget());
		if (isActive === false) {
			callback([{
				layerId: layerObj.get('layer_id'),
				mapId: mapObj.getTarget()
			}]);
			return;
		}
		var extent = mapObj.getView().calculateExtent(mapObj.getSize());
		var imgToken = layerObj.get('params.imgToken');
		var Fcname = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		var pixLonLat = ol.proj.toLonLat(mapObj.getCoordinateFromPixel(evt.pixel));
		var layerParamObj = layerObj.get('paramObj');
		var coords = utils.gcjTransform3857(evt.coordinate);
		var paramObj = {
			geometry: JSON.stringify({
				x: coords[0],
				y: coords[1]
			}),
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  0.1,
			mapExtent: extent,
			imgToken: layerObj.get('params.imgToken'),
			FCName: Fcname

		};
		ajax.get({
			url: constant.GisRootUrl + '/mapRender/identify',
			data: utils.getParameterString(paramObj),
			success: function (result) {
				if (!result) {
					callback([{
						layerId: layerObj.get('layer_id'),
						mapId: mapObj.getTarget()
					}]);
					return;
				}
				var responseText = JSON.parse(result);
				var status = responseText.status;
				if (status.code === 1) { //请求成功，可能有数据，可能没数据
					if (responseText.data && responseText.data.length > 0) {
						var datas = responseText.data.map(function (data) {
							var oneData = {
								mapId: mapObj.getTarget(),
								layer: layerObj,
								layerId: layerObj.get('layer_id'),
								layerType: layerObj.get('businessType'),
								label: layerObj.get('params.label'),
								lonLat: data.centerPoint,
								pixLonLat: pixLonLat,
								geometry: data.geometry,
								extentInfo: data.extentInfo,
								geoId: data.id,
								geoName: data.name,
								key: key,
								feature: feature
							};

							return oneData;
						});

						if (callback && typeof callback === 'function') {
							callback(datas);
						}
					}
					else {
						callback([{
							layerId: layerObj.get('layer_id'),
							mapId: mapObj.getTarget()
						}]);
					}
				}
			},
			failure: function(result) {
				callback([{
					layerId: layerObj.get('layer_id'),
					mapId: mapObj.getTarget()
				}]);
			}
		});
	};

	function getServicePointInfo(mapObj, layerObj, feature, evt, key, callback) {
		var isActive = closeDrawAndMeasure(mapObj.getTarget());
		if (isActive === false) {
			callback([{
				layerId: layerObj.get('layer_id'),
				mapId: mapObj.getTarget()
			}]);
			return;
		}
		var extent = mapObj.getView().calculateExtent(mapObj.getSize());
		var imgToken = layerObj.get('imgToken');
		var fcName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined
		var pixLonLat = ol.proj.toLonLat(mapObj.getCoordinateFromPixel(evt.pixel));
		var layerParamObj = layerObj.get('paramObj');
		var coords = utils.gcjTransform3857(evt.coordinate);
		var paramObj = {
			geometry: JSON.stringify({
				x: coords[0],
				y: coords[1]
			}),
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  utils.getCurTolerance(mapObj,layerObj),
			mapExtent: extent,
			imgToken: layerObj.get('imgToken'),
			FCName: fcName
		};
		ajax.get({
			url: constant.GisRootUrl + '/mapRender/identify',
			data: utils.getParameterString(paramObj),
			success: function (result) {
				if (!result) {
					callback([{
						layerId: layerObj.get('layer_id'),
						mapId: mapObj.getTarget()
					}]);
					return;
				}
				var responseText = JSON.parse(result);
				var status = responseText.status;
				if (status.code === 1) { //请求成功，可能有数据，可能没数据
					if (responseText.data && responseText.data.length > 0) {
						var datas = responseText.data.map(function (data) {
							var oneData = {
								mapId: mapObj.getTarget(),
								layer: layerObj,
								layerId: layerObj.get('layer_id'),
								layerType: layerObj.get('businessType'),
								label: layerObj.get('params.label'),
								lonLat: data.centerPoint,
								pixLonLat: pixLonLat,
								geometry: data.geometry,
								extentInfo: data.extentInfo,
								geoId: data.id,
								geoName: data.name,
								key: key,
								feature: feature
							};

							return oneData;
						});

						if (callback && typeof callback === 'function') {
							callback(datas);
						}
					}
					else {
						callback([{
							layerId: layerObj.get('layer_id'),
							mapId: mapObj.getTarget()
						}]);
					}
				}
				else {
					callback([{
						layerId: layerObj.get('layer_id'),
						mapId: mapObj.getTarget()
					}]);
				}
			},
			failure: function(result) {
				callback([{
					layerId: layerObj.get('layer_id'),
					mapId: mapObj.getTarget()
				}]);
			}
		});
	};

	function getServiceLineInfo(mapObj, layerObj, feature, evt, key, callback) {
		var isActive = closeDrawAndMeasure(mapObj.getTarget());
		if (isActive === false) {
			callback([{
				layerId: layerObj.get('layer_id'),
				mapId: mapObj.getTarget()
			}]);
			return;
		}
		var extent = mapObj.getView().calculateExtent(mapObj.getSize());
		var imgToken = layerObj.get('imgToken');
		var fcName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined
		var pixLonLat = ol.proj.toLonLat(mapObj.getCoordinateFromPixel(evt.pixel));
		var layerParamObj = layerObj.get('paramObj');
		var coords = utils.gcjTransform3857(evt.coordinate);
		var paramObj = {
			geometry: JSON.stringify({
				x: coords[0],
				y: coords[1]
			}),
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  utils.getCurTolerance(mapObj,layerObj),
			mapExtent: extent,
			imgToken: layerObj.get('imgToken'),
			FCName: fcName
		};
		ajax.get({
			url: constant.GisRootUrl + '/mapRender/identify',
			data: utils.getParameterString(paramObj),
			success: function (result) {
				if (!result) {
					callback([{
						layerId: layerObj.get('layer_id'),
						mapId: mapObj.getTarget()
					}]);
					return;
				}
				var responseText = JSON.parse(result);
				var status = responseText.status;
				if (status.code === 1) { //请求成功，可能有数据，可能没数据
					if (responseText.data && responseText.data.length > 0) {
						var datas = responseText.data.map(function (data) {
							var oneData = {
								mapId: mapObj.getTarget(),
								layer: layerObj,
								layerId: layerObj.get('layer_id'),
								layerType: layerObj.get('businessType'),
								label: layerObj.get('params.label'),
								lonLat: data.centerPoint,
								pixLonLat: pixLonLat,
								geometry: data.geometry,
								extentInfo: data.extentInfo,
								geoId: data.id,
								geoName: data.name,
								key: key,
								feature: feature
							};

							return oneData;
						});

						if (callback && typeof callback === 'function') {
							callback(datas);
						}
					}
					else {
						callback([{
							layerId: layerObj.get('layer_id'),
							mapId: mapObj.getTarget()
						}]);
					}
				}
			},
			failure: function(result) {
				callback([{
					layerId: layerObj.get('layer_id'),
					mapId: mapObj.getTarget()
				}]);
			}
		});
	};


	module.exports = {
		mapClick: mapClick
	};

/***/ },
/* 18 */
/*!********************************************!*\
  !*** ./src/gis/maps/eventSingleFeature.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var popup = __webpack_require__(/*! tools/popup */ 12);
	var popupInFrame = __webpack_require__(/*! framework/popup */ 9);
	var i18n = __webpack_require__(/*! utils/i18n */ 13);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var ajax = __webpack_require__(/*! utils/ajax */ 14);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var closeDrawAndMeasure = olUtil.closeDrawAndMeasure;
	var transformLonLat = olUtil.transformLonLat;


	function mapClick(mapId) {
		var mapObj = mapBox.getMapObj(mapId);

		//防止注册多个事件
		if (mapObj.get('clickHandle')) {
			return;
		}
		mapObj.set('callbackList', {});
		mapObj.set('eventKeyANDEventLayerObj', {});
		var clickHandle = mapObj.on('click', function(e) {
			var featuresAtPix = [];
			var pixLonLat = [];
			var businessFeatureArray = [];

			mapObj.forEachFeatureAtPixel(e.pixel, function(feature) {
				if (!!feature) {
					var clusterFeature = feature.get('features');
					if (clusterFeature && clusterFeature instanceof Array && clusterFeature.length > 0) {
						businessFeatureArray.push(feature);
					}
					if (feature.get('vectorType') === constant.BUSINESSTYPE.POINT ||
						feature.get('vectorType') === constant.BUSINESSTYPE.LINE ||
						feature.get('vectorType') === constant.BUSINESSTYPE.POLYGON ||
						feature.get('vectorType') === constant.BUSINESSTYPE.ICON ||
						feature.get('vectorType') === constant.BUSINESSTYPE.CIRCLEPOINT ||
						feature.get('vectorType') === constant.BUSINESSTYPE.VECTOR_CELL ||
						feature.get('vectorType') === constant.BUSINESSTYPE.STRAIGHTLINE ||
						feature.get('vectorType') === 'BUBBLE_CIRCLE_LABEL' ||
						feature.get('vectorType') === 'ICON_FONT_STYLE'
					) {
						if (!!!feature.get('highlightFeature')) {
							businessFeatureArray.push(feature);
						}
					}
					featuresAtPix.push(feature);
				}
			});


			pixLonLat = mapObj.getCoordinateFromPixel(e.pixel);
			if (!!pixLonLat) {
				pixLonLat = ol.proj.toLonLat(pixLonLat);
			}

			var _callbackList = mapObj.get('callbackList');
			var _eventKeyANDEventLayerObj = mapObj.get('eventKeyANDEventLayerObj');


			//点线面 点击时弹框选择
			if (businessFeatureArray.length > 1) {
				var isReturnFlag = false, targetFeature;
				businessFeatureArray.forEach(function(feature) {
					if (feature.get('businessType') === 'BUBBLE_CIRCLE_LABEL') {
						isReturnFlag = true;
						targetFeature = feature;
					}
				})
				if (isReturnFlag && targetFeature.get('layer').get('isNotTip')) {  //多图层不弹框只高亮设置
					var callbackData = {
						e: e,
						layer: targetFeature.get('layer'),
						feature: targetFeature
					};
					if (targetFeature.get('businessType') === 'BUBBLE_CIRCLE_LABEL') {
						if (!!_callbackList['bubble-circle-label-click-event']) {
							_callbackList['bubble-circle-label-click-event'](callbackData);
						}
					}
				} else {
					var propContent = document.createElement('div');
					var propUl = document.createElement('ul');
					propContent.appendChild(propUl);
					propContent.style.width = '400px';
					propContent.style.maxHeight = '300px';
					propContent.className = 'clickpop-content';
					businessFeatureArray.forEach(function(vectorFeature) {
						var li = document.createElement('li');
						var geoId = vectorFeature.getId() != undefined ? vectorFeature.getId() : vectorFeature.get('id');
						li.innerHTML = geoId;
						li.className = 'vGisWeb-restrict-line clickpop-line';
						li.title = geoId;
						li.style.cursor = 'pointer';
						li.attributes.feature = vectorFeature;
						li.onclick = function() {
							popup.removeAllPopup(mapId);
							//geoId, lonLat, mapId, layerType, layerId,points
							var callbackData = {
								e: e,
								layer: this.attributes.feature.get('layer'),
								feature: this.attributes.feature
							};
							var _type = this.attributes.feature.get('businessType');
							if (_type === constant.BUSINESSTYPE.POINT) {
								if (!!_callbackList['business_vector_point_event_id']) {
									_callbackList['business_vector_point_event_id'](callbackData);
								}

							}
							//此线的类型是针对多个图层连线的接口主要是针对UI设计器
							else if (_type === constant.BUSINESSTYPE.LINE) {
								if (!!_callbackList['business_line_event_id']) {
									_callbackList['business_line_event_id'](callbackData);
								}

							}
							//矢量的线直线
							else if (_type === constant.BUSINESSTYPE.STRAIGHTLINE) {
								if (!!_callbackList['straightline-click-event']) {
									_callbackList['straightline-click-event'](callbackData);
								}

							}

							else if (_type === constant.BUSINESSTYPE.POLYGON) {
								if (!!_callbackList['business_vector_polygon_event_id']) {
									_callbackList['business_vector_polygon_event_id'](callbackData);
								}
							}
							//新增矢量小区的弹框选择
							else if (_type === constant.BUSINESSTYPE.VECTOR_CELL) {
								if (!!_callbackList['vector-cell-click-event']) {
									_callbackList['vector-cell-click-event'](callbackData);
								}
							}

							else if (_type === 'BUBBLE_CIRCLE_LABEL') {
								if (!!_callbackList['bubble-circle-label-click-event']) {
									_callbackList['bubble-circle-label-click-event'](callbackData);
								}
							}
							else if (_type === 'ICON_FONT_STYLE') {
								if (!!_callbackList['font-style-click-event']) {
									_callbackList['font-style-click-event'](callbackData);
								}
							}
						};
						propUl.appendChild(li);
					});
					popup.addPopup({
						mapId: mapId,
						title: i18n.prop('mapClick.popup.title'),
						position: ol.proj.toLonLat(e.coordinate),
						content: propContent,
						maxHeight: 300,
						width: 280
					});
				}

			} else if (businessFeatureArray.length === 1) {
				popup.removeAllPopup(mapId);
				var _businessType = businessFeatureArray[0].get('vectorType');
				var isClusterPoint = businessFeatureArray[0].get('features')
					&& businessFeatureArray[0].get('features') instanceof Array
					&& businessFeatureArray[0].get('features').length === 1;
				var clusterLayer = !!isClusterPoint ?
					businessFeatureArray[0].get('features')[0].get('layer') : undefined;
				var _layer = businessFeatureArray[0].get('layer');
				var _feature = businessFeatureArray[0];
				if (!_feature) {
					return;
				}
				var _featureExtent = _feature.getGeometry().getExtent();
				var _featureCenter = ol.extent.getCenter(_featureExtent);
				var _featureCenter4326 = ol.proj.toLonLat(_featureCenter);

				var callbackData = {
					e: e,
					layer: !!isClusterPoint && clusterLayer ? clusterLayer
						: businessFeatureArray[0].get('layer'),
					feature: businessFeatureArray[0],
					featureCenter: _featureCenter,
					data: _feature.get('data'),
					businessType: _layer && _layer.get('businessType'),
					layerType: _layer && _layer.get('businessType'),
					mapId: mapId,
					target: mapId,
					layerId: !!_layer && _layer.get('layer_id'),
					featureId: _feature.getId() ? _feature.getId() : _feature.get('id'),
					geoId: _feature.getId() ? _feature.getId() : _feature.get('id'),
					lonLat: [_featureCenter4326[0].toFixed(6), _featureCenter4326[1].toFixed(6)],
					pixLonLat: pixLonLat,
					points: transformLonLat(_feature)
				};
				if (_businessType === constant.BUSINESSTYPE.POINT) {
					if (!!_callbackList['business_vector_point_event_id']) {
						_callbackList['business_vector_point_event_id'](callbackData);
					}

				} else if (_businessType === constant.BUSINESSTYPE.LINE) {
					if (!!_callbackList['business_line_event_id'])
						_callbackList['business_line_event_id'](callbackData);

				}
				//新添加的直线
				else if (_businessType === constant.BUSINESSTYPE.STRAIGHTLINE) {
					if (!!_callbackList['straightline-click-event']) {
						_callbackList['straightline-click-event'](callbackData);
					}
				}

				else if (_businessType === constant.BUSINESSTYPE.POLYGON) {
					if (!!_callbackList['business_vector_polygon_event_id']) {
						_callbackList['business_vector_polygon_event_id'](callbackData);
					}

				} else if (_businessType === constant.BUSINESSTYPE.VECTOR_CELL) {
					if (!!_callbackList['vector-cell-click-event']) {
						_callbackList['vector-cell-click-event'](callbackData);
					}

				} else if (_businessType === constant.BUSINESSTYPE.POINTER_CLUSTER) {
					if (!!_callbackList['point-cluster-click-event']) {
						_callbackList['point-cluster-click-event'](callbackData);
					}
				} else if (_businessType === 'BUBBLE_CIRCLE_LABEL') {
					if (!!_callbackList['bubble-circle-label-click-event']) {
						_callbackList['bubble-circle-label-click-event'](callbackData);
					}
				}
				else if (_businessType === 'ICON_FONT_STYLE') {
					if (!!_callbackList['font-style-click-event']) {
						_callbackList['font-style-click-event'](callbackData);
					}
				} else if (isClusterPoint) {    //汇聚点高亮事件
					if (!!_callbackList['point-cluster-click-event']) {
						_callbackList['point-cluster-click-event'](callbackData);
					}
				}
			} else {
				popup.removeAllPopup(mapId);
				popupInFrame.removePopup(mapId);
				//后面可以在这里面控制点击地图空白处，清除矢量点、线、面、小区的高亮
				if (_callbackList['business_vector_point_event_id']) {
					_callbackList['business_vector_point_event_id']({});
				}
				if(_callbackList['measure-distance-click-event']){    //测距中间拐点处弹出长度提示
					_callbackList['measure-distance-click-event']({e:e});
				}
				if (_callbackList['business_line_event_id']) {
					_callbackList['business_line_event_id']({});
				}
				if (_callbackList['business_vector_polygon_event_id']) {
					_callbackList['business_vector_polygon_event_id']({});
				}
				//直线
				if (_callbackList['straightline-click-event']) {
					_callbackList['straightline-click-event']({});

				}
				if (_callbackList['vector-cell-click-event']) {
					_callbackList['vector-cell-click-event']({});
				}

			}

			for (var clickEventUniqueKey in _callbackList) {
				if (_callbackList[clickEventUniqueKey] != undefined && typeof _callbackList[clickEventUniqueKey] === 'function') {
					if (clickEventUniqueKey == 'business_vector_point_event_id' || clickEventUniqueKey == 'business_line_event_id' ||
						clickEventUniqueKey == 'business_vector_polygon_event_id' || clickEventUniqueKey == 'vector-cell-click-event') {
						continue;
					}
					var _feature = null;
					if (featuresAtPix.length > 0) {
						_feature = featuresAtPix[0];
					}

					var _featureExtent = _feature && _feature.getGeometry().getExtent();
					var _featureCenter = _featureExtent && ol.extent.getCenter(_featureExtent);
					var _featureCenter4326 = [];
					if (!!_featureCenter) {
						_featureCenter4326 = ol.proj.toLonLat(_featureCenter);
					}

					var _layer = _eventKeyANDEventLayerObj[clickEventUniqueKey];
					//geoId, lonLat, mapId, layerType, layerId,points
					if (_layer != undefined) {
						if (_layer.get('businessType') === constant.BUSINESSTYPE.GRID) {
							getGridInfo(mapObj, _layer, _feature, e, clickEventUniqueKey, function(objs) {
								if (!!objs && objs.length > 0) {
									var obj = objs[0];
									_callbackList[obj.key]({
										e: e,
										layer: obj.layer,
										feature: obj.feature,
										featureCenter: obj.lonLat,
										data: obj.data,
										geoId: obj.geoId,
										lonLat: obj.lonLat,
										points: transformLonLat(undefined, {
											layerType: constant.BUSINESSTYPE.GRID,
											geometry: obj.geometry
										}),
										businessType: constant.BUSINESSTYPE.GRID,
										layerType: constant.BUSINESSTYPE.GRID,
										mapId: mapId,
										target: mapId,
										layerId: obj.layerId,
										featureId: obj.geoId,
										pixLonLat: pixLonLat,
										originalCenterPoint: obj.originalCenterPoint,
										transportDataToInnerLayer: [ //将数据直接给内部类，较少一次下发请求，屏蔽内部类再次发送请求
											{
												mapId: obj.mapId,
												layer: obj.layer,
												layerId: obj.layerId,
												layerType: constant.BUSINESSTYPE.GRID,
												geoId: obj.geoId,
												lonLat: obj.lonLat,
												geometry: obj.geometry,
												extentInfo: obj.extentInfo,
												geoName: obj.geoName
											}
										]
									});
								}
							})
						}  else if (_layer.get('businessType') === constant.BUSINESSTYPE.SITE) {
							getSiteInfo(mapObj, _layer, _feature, e, clickEventUniqueKey, function(objs) {
								if (objs && objs.length > 0) {
									var obj = objs[0];
									var layer_ = obj.layer;
									_callbackList[obj.key]({
										e: e,
										layer: layer_,
										feature: obj.feature,
										featureCenter: obj.lonLat,
										data: obj.data,
										geoId: obj.geoId,
										lonLat: obj.lonLat,
										points: transformLonLat(undefined, {
											layerType: constant.BUSINESSTYPE.SITE,
											geometry: obj.geometry
										}),
										businessType: constant.BUSINESSTYPE.SITE,
										layerType: constant.BUSINESSTYPE.SITE,
										mapId: mapId,
										target: mapId,
										layerId: obj.layerId,
										featureId: obj.geoId,
										pixLonLat: pixLonLat,
										transportDataToInnerLayer: [ //将数据直接给内部类，较少一次下发请求，屏蔽内部类再次发送请求
											{
												mapId: mapId,
												layer: layer_,
												layerId: obj.layerId,
												layerType: constant.BUSINESSTYPE.SITE,
												lonLat: obj.lonLat,
												geometry: obj.geometry,
												geoId: obj.geoId,
												geoName: obj.geoName,
												label: obj.label
											}
										]
									});
								}
							});
						}   else if (_layer.get('businessType') === constant.BUSINESSTYPE.SERVICEPOINT) {
							getServicePointInfo(mapObj, _layer, _feature, e, clickEventUniqueKey, function(objs) {
								if (objs && objs.length > 0) {
									var obj = objs[0];
									var _layer = obj.layer;
									_callbackList[obj.key]({
										e: e,
										layer: _layer,
										feature: obj.feature,

										featureCenter: obj.lonLat,
										data: obj.data,
										geoId: obj.geoId,
										lonLat: obj.lonLat,
										points: transformLonLat(undefined, {
											layerType: constant.BUSINESSTYPE.SERVICEPOINT,
											geometry: obj.geometry
										}),
										businessType: constant.BUSINESSTYPE.SERVICEPOINT,
										layerType: constant.BUSINESSTYPE.SERVICEPOINT,
										mapId: mapId,
										target: mapId,
										layerId: !!_layer && _layer.get('layer_id'),
										featureId: obj.geoId,
										pixLonLat: pixLonLat,
										transportDataToInnerLayer: [ //将数据直接给内部类，较少一次下发请求，屏蔽内部类再次发送请求
											{
												lonLat: obj.lonLat,
												geometry: obj.geometry,
												extentInfo: obj.extentInfo,
												geoId: obj.geoId,
												geoName: obj.geoName,
												layerType: constant.BUSINESSTYPE.SERVICEPOINT
											}
										]
									});
								}
							});
						} else if (_layer.get('businessType') === constant.BUSINESSTYPE.SERVICELINE) {
							getServiceLineInfo(mapObj, _layer, _feature, e, clickEventUniqueKey, function(objs) {
								if (objs && objs.length > 0) {
									var obj = objs[0];
									var _layer = obj.layer;
									_callbackList[obj.key]({
										e: e,
										layer: _layer,
										feature: obj.feature,

										featureCenter: obj.lonLat,
										data: obj.data,
										geoId: obj.geoId,
										lonLat: obj.lonLat,
										points: transformLonLat(undefined, {
											layerType: constant.BUSINESSTYPE.SERVICELINE,
											geometry: obj.geometry
										}),
										businessType: constant.BUSINESSTYPE.SERVICELINE,
										layerType: constant.BUSINESSTYPE.SERVICELINE,
										mapId: mapId,
										target: mapId,
										layerId: !!_layer && _layer.get('layer_id'),
										featureId: obj.geoId,
										pixLonLat: pixLonLat,
										transportDataToInnerLayer: [ //将数据直接给内部类，较少一次下发请求，屏蔽内部类再次发送请求
											{
												mapId: mapId,
												layer: _layer,
												layerId: obj.layerId,
												layerType: constant.BUSINESSTYPE.SERVICELINE,
												lonLat: obj.lonLat,
												geometry: obj.geometry,
												extentInfo: obj.extentInfo,
												geoId: obj.geoId,
												geoName: obj.geoName,
												label: obj.label
											}
										]
									});
								}
							});
						} else if (_layer.get('businessType') === constant.BUSINESSTYPE.SERVICEPOLYGON) {
							getServicePolygonInfo(mapObj, _layer, _feature, e, clickEventUniqueKey, function(objs) {
								if (objs && objs.length > 0) {
									var obj = objs[0];
									var _layer = obj.layer;
									_callbackList[obj.key]({
										e: e,
										layer: _layer,
										feature: obj.feature,

										featureCenter: obj.lonLat,
										data: obj.data,
										geoId: obj.geoId,
										lonLat: obj.lonLat,
										points: transformLonLat(undefined, {
											layerType: constant.BUSINESSTYPE.SERVICEPOLYGON,
											geometry: obj.geometry
										}),
										businessType: constant.BUSINESSTYPE.SERVICEPOLYGON,
										layerType: constant.BUSINESSTYPE.SERVICEPOLYGON,
										mapId: mapId,
										target: mapId,
										layerId: !!_layer && _layer.get('layer_id'),
										featureId: obj.geoId,
										pixLonLat: pixLonLat,
										transportDataToInnerLayer: [ //将数据直接给内部类，较少一次下发请求，屏蔽内部类再次发送请求
											{
												mapId: mapId,
												layer: _layer,
												layerId: obj.layerId,
												layerType: constant.BUSINESSTYPE.SERVICEPOLYGON,
												lonLat: obj.lonLat,
												geometry: obj.geometry,
												extentInfo: obj.extentInfo,
												geoId: obj.geoId,
												geoName: obj.geoName,
												label: obj.label
											}
										]
									});
								}
							});
						} else {
							var _getId = function() {
								if (_feature) {
									if (_feature.get('features')) {
										if (_feature.get('features').length === 1) {
											return _feature.get('features')[0].get('id');
										} else {
											return undefined;
										}
									} else {
										return _feature.getId() ? _feature.getId() : _feature.get('id');
									}
								}
							};

							var _getData = function() {
								if (_feature) {
									if (_feature.get('features')) {
										if (_feature.get('features').length === 1) {
											return _feature.get('features')[0].get('data');
										} else {
											return undefined;
										}
									} else {
										return _feature.get('data')
									}
								}
							};

							var _evtData = {
								e: e,
								layer: _layer,
								feature: _feature,

								data: _getData(),
								businessType: _layer && _layer.get('businessType'),
								layerType: _layer && _layer.get('businessType'),
								mapId: mapId,
								geoId: _getId(),
								featureId: _getId(),
								layerId: !!_layer && _layer.get('layer_id'),
								featureCenter: _featureCenter,
								lonLat: !!_featureCenter4326 ? _featureCenter4326 : [108, 34],
								pixLonLat: pixLonLat,
								points: _feature && _feature.getGeometry() && transformLonLat(_feature)
							};
							if (!!_feature && _feature.getGeometry && _feature.getGeometry().getArea) {
								_evtData.area = _feature.getGeometry().getArea();
							}
							if (_feature && _feature.get('layer') && (_feature.get('layer').get('layer_id')
									=== _layer.get('layer_id')||_feature.get('layer').get('layer_id')=== _layer.get('layer_id')+'&&&highlight')) {
									_callbackList[clickEventUniqueKey](_evtData);
								}
						}
					}
				}
			}

		});
		mapObj.set('clickHandle', clickHandle);
	}


	function getGridInfo(mapObj, layerObj, feature, evt, key, callback) {
		var isActive = closeDrawAndMeasure(mapObj.getTarget());
		if (isActive === false) {
			return;
		}
		var extent = mapObj.getView().calculateExtent(mapObj.getSize());
		var pixLonLat = ol.proj.toLonLat(mapObj.getCoordinateFromPixel(evt.pixel));
		var layerParamObj = layerObj.get('paramObj');
		var paramObj = {
			geometry: {
				x: evt.coordinate[0],
				y: evt.coordinate[1]
			},
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  1,
			mapExtent: extent,
			imgToken: layerObj.get('imgToken')
		};

		ajax.postJSON({
			url: constant.GisRootUrl + '/gridManager/getGridInfo?cacheKey=' + layerObj.get('imgToken'),
			data: JSON.stringify(paramObj),
			success: function(resultText) {
				if (!resultText) {
					callback([]);
					return;
				}
				var result = JSON.parse(resultText);
				if (!result || !result.data || !result.data.length) {
					callback([]);
					return;
				}
				if (result.status != undefined && result.status.code == 1) {
					var backJSON = result.data.map(function(data) {
						return {
							mapId: mapObj.getTarget(),
							layer: layerObj,
							layerId: !!layerObj && layerObj.get('layer_id'),
							layerType: !!layerObj && layerObj.get('businessType'),
							label: !!layerObj && layerObj.get('params.label'),
							feature: feature,
							lonLat: ol.proj.toLonLat(data.centerPoint),
							pixLonLat: pixLonLat,
							geometry: data.geometry,
							geoId: data.id,
							data: data,
							extentInfo: data.extentInfo,
							geoName: data.name,
							key: key,
							originalCenterPoint: data.originalCenterPoint
						};
					});
					callback(backJSON);
				} else {
					callback([]);
				}
			},
			failure: function(resultText) {
				callback([]);
			}
		});
	}


	function getSiteInfo(olMap, olLayer, feature, evt, key, callback) {
		var isActive = closeDrawAndMeasure(olMap.getTarget());
		if (isActive === false) {
			return;
		}
		if (!olLayer.getVisible()) {
			callback([]);
			return;
		}
		var mapExtent, imgToken, geometry, dw, _url;
		imgToken = olLayer.get('imgToken');
		dw = olLayer.get('dw'); //通过取dw的属性判断是否走中间件
		if (dw != undefined) {
			_url = constant.GisRootUrl + '/mapRender/identify';
		} else {
			_url = constant.GisRootUrl + '/common/mapRender/identify';
		}
		geometry = JSON.stringify({
			x: evt.coordinate[0],
			y: evt.coordinate[1]
		});
		mapExtent = olMap.getView().calculateExtent(olMap.getSize()).join(',');
		var fcName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		var pixLonLat = ol.proj.toLonLat(olMap.getCoordinateFromPixel(evt.pixel));
		var layerParamObj = olLayer.get('paramObj');
		var params = {
			geometry: geometry,
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  2,
			mapExtent: mapExtent,
			imgToken: imgToken,
			FCName: fcName
		};
		ajax.get({
			url: _url,
			data: utils.getParameterString(params),
			success: function(res) {
				if (!res) {
					callback([]);
					return;
				}
				res = JSON.parse(res);
				if (!res || !res.data || !res.data.length) {
					callback([]);
					return;
				}

				var result = res.data;
				var backJSON = result.map(function(item) {
					return {
						mapId: olMap.getTarget(),
						layer: olLayer,
						feature: feature,
						layerId: !!olLayer && olLayer.get('layer_id'),
						layerType: !!olLayer && olLayer.get('businessType'),
						label: !!olLayer && olLayer.get('params.label'),
						lonLat: ol.proj.toLonLat(item.centerPoint),
						pixLonLat: pixLonLat,
						geometry: item.geometry,
						geoId: item.id,
						geoName: item.name,
						key: key
					};
				});

				callback(backJSON);
			},
			failure: function(res) {
				callback([]);
			}
		});
	}



	function getServicePolygonInfo(mapObj, layerObj, feature, evt, key, callback) {
		var isActive = closeDrawAndMeasure(mapObj.getTarget());
		if (isActive === false) {
			return;
		}
		if (!layerObj.getVisible()) {
			callback([]);
			return;
		}

		var extent = mapObj.getView().calculateExtent(mapObj.getSize());
		var imgToken = layerObj.get('params.imgToken');
		var Fcname = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		var pixLonLat = ol.proj.toLonLat(mapObj.getCoordinateFromPixel(evt.pixel));
		var layerParamObj = layerObj.get('paramObj');
		var paramObj = {
			geometry: JSON.stringify({
				x: evt.coordinate[0],
				y: evt.coordinate[1]
			}),
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  0.1,
			mapExtent: extent,
			imgToken: layerObj.get('params.imgToken'),
			FCName: Fcname

		};
		ajax.get({
			url: constant.GisRootUrl + '/mapRender/identify',
			data: utils.getParameterString(paramObj),
			success: function(result) {
				if (!result) {
					return;
				}
				var responseText = JSON.parse(result);
				var status = responseText.status;
				if (status.code === 1) { //请求成功，可能有数据，可能没数据
					if (responseText.data && responseText.data.length > 0) {
						var datas = responseText.data.map(function(data) {
							var oneData = {
								mapId: mapObj.getTarget(),
								layer: layerObj,
								layerId: layerObj.get('layer_id'),
								layerType: layerObj.get('businessType'),
								label: layerObj.get('params.label'),
								lonLat: data.centerPoint,
								pixLonLat: pixLonLat,
								geometry: data.geometry,
								extentInfo: data.extentInfo,
								geoId: data.id,
								geoName: data.name,
								key: key,
								feature: feature
							};

							return oneData;
						});

						if (callback && typeof callback === 'function') {
							callback(datas);
						}
					}
				}
			},
			failure: function(result) {
				callback([]);
			}
		});
	};

	function getServicePointInfo(mapObj, layerObj, feature, evt, key, callback) {
		var isActive = closeDrawAndMeasure(mapObj.getTarget());
		if (isActive === false) {
			return;
		}
		if (!layerObj.getVisible()) {
			callback([]);
			return;
		}

		var extent = mapObj.getView().calculateExtent(mapObj.getSize());
		var imgToken = layerObj.get('imgToken');
		var fcName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		var pixLonLat = ol.proj.toLonLat(mapObj.getCoordinateFromPixel(evt.pixel));
		var layerParamObj = layerObj.get('paramObj');
		var paramObj = {
			geometry: JSON.stringify({
				x: evt.coordinate[0],
				y: evt.coordinate[1]
			}),
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  utils.getCurTolerance(mapObj,layerObj),
			mapExtent: extent,
			imgToken: layerObj.get('imgToken'),
			FCName: fcName
		};
		ajax.get({
			url: constant.GisRootUrl + '/mapRender/identify',
			data: utils.getParameterString(paramObj),
			success: function(result) {
				if (!result) {
					return;
				}
				var responseText = JSON.parse(result);
				var status = responseText.status;
				if (status.code === 1) { //请求成功，可能有数据，可能没数据
					if (responseText.data && responseText.data.length > 0) {
						var datas = responseText.data.map(function(data) {
							var oneData = {
								mapId: mapObj.getTarget(),
								layer: layerObj,
								layerId: layerObj.get('layer_id'),
								layerType: layerObj.get('businessType'),
								label: layerObj.get('params.label'),
								lonLat: data.centerPoint,
								pixLonLat: pixLonLat,
								geometry: data.geometry,
								extentInfo: data.extentInfo,
								geoId: data.id,
								geoName: data.name,
								key: key,
								feature: feature
							};

							return oneData;
						});

						if (callback && typeof callback === 'function') {
							callback(datas);
						}
					}
				}
			},
			failure: function(result) {
				callback([]);
			}
		});
	};

	function getServiceLineInfo(mapObj, layerObj, feature, evt, key, callback) {
		var isActive = closeDrawAndMeasure(mapObj.getTarget());
		if (isActive === false) {
			return;
		}
		if (!layerObj.getVisible()) {
			callback([]);
			return;
		}

		var extent = mapObj.getView().calculateExtent(mapObj.getSize());
		var imgToken = layerObj.get('imgToken');
		var fcName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		var pixLonLat = ol.proj.toLonLat(mapObj.getCoordinateFromPixel(evt.pixel));
		var layerParamObj = layerObj.get('paramObj');
		var paramObj = {
			geometry: JSON.stringify({
				x: evt.coordinate[0],
				y: evt.coordinate[1]
			}),
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  utils.getCurTolerance(mapObj,layerObj),
			mapExtent: extent,
			imgToken: layerObj.get('imgToken'),
			FCName: fcName
		};
		ajax.get({
			url: constant.GisRootUrl + '/mapRender/identify',
			data: utils.getParameterString(paramObj),
			success: function(result) {
				if (!result) {
					return;
				}
				var responseText = JSON.parse(result);
				var status = responseText.status;
				if (status.code === 1) { //请求成功，可能有数据，可能没数据
					if (responseText.data && responseText.data.length > 0) {
						var datas = responseText.data.map(function(data) {
							var oneData = {
								mapId: mapObj.getTarget(),
								layer: layerObj,
								layerId: layerObj.get('layer_id'),
								layerType: layerObj.get('businessType'),
								label: layerObj.get('params.label'),
								lonLat: data.centerPoint,
								pixLonLat: pixLonLat,
								geometry: data.geometry,
								extentInfo: data.extentInfo,
								geoId: data.id,
								geoName: data.name,
								key: key,
								feature: feature
							};

							return oneData;
						});

						if (callback && typeof callback === 'function') {
							callback(datas);
						}
					}
				}
			},
			failure: function(result) {
				callback([]);
			}
		});
	};

	module.exports = {
		mapClick: mapClick
	};

/***/ },
/* 19 */
/*!*********************************!*\
  !*** ./src/gis/maps/control.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var scaleLine = function (style) {
	    if (style) {
	        return new ol.control.ScaleLine({
	            className: style
	        });
	    }
	    else {
	        return new ol.control.ScaleLine();
	    }
	};

	var mousePosition = function (style) {
	    return new ol.control.MousePosition({
	                projection: constant.PROJ.EPSG_4326,
	                className: style,
	                coordinateFormat: function (param) {
	                    var lon = param[0];
	                    var lat = param[1];
	                    if (lon >= 180 || lon <= -180 || lat >= 90 || lat <= -90) {
	                        return fusiongis.I18n.prop('MapMsg.mousePositionMsg');
	                    } else {
	                        return param;
	                    }
	                }
	            });
	};

	var zoomContent = function (extent, sourceProj, targetProj) {
	    if (extent) {
	        return new ol.control.ZoomToExtent({
	            extent: ol.proj.transformExtent(extent, sourceProj, targetProj)
	        });
	    }
	    else {
	        return new ol.control.ZoomToExtent({
	            extent: ol.proj.transformExtent(
	                [94.37296875000001, 31.667004036130592, 131.28703125000001, 44.28205382728058],
	                constant.PROJ.EPSG_4326, constant.PROJ.EPSG_3857
	            )
	        });
	    }
	};


	module.exports = {
	    scaleLine: scaleLine,
	    mousePosition: mousePosition,
	    zoomContent: zoomContent
	};

/***/ },
/* 20 */
/*!**********************************!*\
  !*** ./src/gis/maps/multimap.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var acrossLine = __webpack_require__(/*! maps/acrossLine */ 21);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var util = __webpack_require__(/*! utils/util */ 1);
	var linkedMapIDs = [];

	/**
	 * 设置地图联动
	 * @param paramObj
	 * paramObj = {
	 * 		isAssociate: boolean
	 * 		mapIds: [],
	 * 	    isOpen: boolean
	 * }
	 */
	function mapAssociate(paramObj) {
	    var _isAssociate = paramObj.isAssociate;
	    var _mapIds = paramObj.mapIds;

	    _mapIds && _mapIds.forEach(function (mapId) {
	        if (_isAssociate) {
	            _addLinkage(mapId);
	            hashMap.put('nowLink', true);
	        }
	        else {
	            _removeLinkAge(mapId);
	            hashMap.put('nowLink', false);
	        }
	    });

	    if (linkedMapIDs.length > 0) {
	        var map;
	        var view;
	        var mapType;
	        linkedMapIDs.forEach(function(v, i){
	            if (i === 0) {
	                map = mapBox.getMapObj(v);
	                if(!map){
	                    return ;
	                }
	                view = map.getView();
	                mapType = map.get('currentMapType');
	                var _ccT = view.getCenter();
	                _ccT = ol.proj.toLonLat(_ccT);
	                _ccT = [_ccT[0] + 0.00000001, _ccT[1]];
	                _ccT = ol.proj.fromLonLat(_ccT);
	                view.setCenter(_ccT);
	            }
	            if (mapType === 'GOOGLE_MAP') {
	                var _googleMap = mapBox.getMapObj(v).get('mineCustomMap');//google map
	                var _center = ol.proj.toLonLat(view.getCenter());
	                _googleMap.setCenter(new google.maps.LatLng(_center[1], _center[0]));
	                _googleMap.setZoom(view.getZoom());
	            }
	            else if (mapType === 'GAODE_MAP') {
	                var _gaodeMap = mapBox.getMapObj(v).get('mineCustomMap');//gaode map
	                var center = ol.proj.toLonLat(view.getCenter());
	                center = util.transformGPS.gcj_encrypt(center[1],center[0]);
	                _gaodeMap.setZoomAndCenter(view.getZoom(),[center.lon,center.lat]);
	            }
	        });
	    }

	    if (paramObj.hasOwnProperty('isOpen')) {
	        acrossLine.acrossLine(paramObj);
	    }
	}

	function _addLinkage(mapId) {
	    var fromMap = mapBox.getMapObj(mapId);
	    if (!!!fromMap) {
	        return;
	    }
	    fromMap.updateSize();
	    if (linkedMapIDs.indexOf(mapId) === -1) {
	        linkedMapIDs.push(mapId);
	    }

	    var masterMap = mapBox.getMapObj(linkedMapIDs[0]);
	    var masterMapView = masterMap.getView();
	    var fromMapView = fromMap.getView();
	    var masterMapType = masterMap.get('currentMapType');

	    if (masterMapType === 'GOOGLE_MAP') {
	        var _googleMap = fromMap.get('mineCustomMap');//google map
	        if (!!!_googleMap) {
	            return;
	        }

	        var _customCenterKey = fromMap.get('customCenterKey');
	        var _customResolutionKey = fromMap.get('customResolutionKey');
	        if (!!_customCenterKey) {
	            fromMap.unByKey(_customCenterKey);
	        }
	        if (!!_customResolutionKey) {
	            fromMap.unByKey(_customResolutionKey);
	        }

	        var _onCenterChanged = function (olEvent) {
	            google.maps.event.trigger(_googleMap, 'resize');
	            var view = olEvent.target;
	            var center = ol.proj.toLonLat(view.getCenter());
	            _googleMap.setCenter(new google.maps.LatLng(center[1], center[0]));
	        };

	        var _onResolutionChanged = function (olEvent) {
	            var view = olEvent.target;
	            _googleMap.setZoom(view.getZoom());
	        };

	        var _customCenterKey = masterMapView.on('change:center', _onCenterChanged);
	        var _customResolutionKey = masterMapView.on('change:resolution', _onResolutionChanged);
	        fromMap.set('customCenterKey', _customCenterKey);
	        fromMap.set('customResolutionKey', _customResolutionKey);
	    }
	    else if (masterMapType === 'GAODE_MAP') {
	        var _gaodeMap = fromMap.get('mineCustomMap');//gaode map
	        if (!!!_gaodeMap) {
	            return;
	        }

	        var _customCenterKey = fromMap.get('customCenterKey');
	        var _customResolutionKey = fromMap.get('customResolutionKey');
	        if (!!_customCenterKey) {
	            fromMap.unByKey(_customCenterKey);
	        }
	        if (!!_customResolutionKey) {
	            fromMap.unByKey(_customResolutionKey);
	        }

	        var _onCenterOrZoomChanged = function (olEvent) {
	            AMap.event.trigger(_gaodeMap, 'resize');
	            var view = olEvent.target;
	            var center = ol.proj.toLonLat(view.getCenter());
	            center = util.transformGPS.gcj_encrypt(center[1],center[0]);
	            _gaodeMap.setZoomAndCenter(view.getZoom(),[center.lon,center.lat]);
	        };

	        var _customCenterKey = masterMapView.on('change:center', _onCenterOrZoomChanged);
	        var _customResolutionKey = masterMapView.on('change:resolution', _onCenterOrZoomChanged);
	        fromMap.set('customCenterKey', _customCenterKey);
	        fromMap.set('customResolutionKey', _customResolutionKey);
	    }
	  
	    fromMapView.setCenter(masterMapView.getCenter());
		fromMapView.setZoom(masterMapView.getZoom());
		
		var mapstercenterchangeKey = masterMapView.on('change:center', function() {
			fromMapView.setCenter(masterMapView.getCenter());
		});
		var mapsterresolutionchangeKey = masterMapView.on('change:resolution', function() {
			fromMapView.setZoom(masterMapView.getZoom());
		});
		if (masterMap.get('mapstercenterchangeKey') == undefined) {
			masterMap.set('mapstercenterchangeKey', []);
		}
		masterMap.get('mapstercenterchangeKey').push(mapstercenterchangeKey);
		
		if (masterMap.get('mapsterresolutionchangeKey') == undefined) {
			masterMap.set('mapsterresolutionchangeKey', []);
		}
		masterMap.get('mapsterresolutionchangeKey').push(mapsterresolutionchangeKey);
		
		var fromcenterchangeKey = fromMapView.on('change:center', function() {
			masterMapView.setCenter(fromMapView.getCenter());
		});
		var fromresolutionchangeKey = fromMapView.on('change:resolution', function() {
			masterMapView.setZoom(fromMapView.getZoom());
		});
		fromMap.set('fromcenterchangeKey', fromcenterchangeKey);
		fromMap.set('fromresolutionchangeKey', fromresolutionchangeKey);

	}

	/**
	 * 解除地图关联
	 * @param mapId
	 */
	function _removeLinkAge(mapId) {
	    var fromMap = mapBox.getMapObj(mapId);
	    if (!fromMap) {
	        for (var i in linkedMapIDs) {
	            if (linkedMapIDs[i] == mapId) {
	                linkedMapIDs.splice(i, 1);
	            }
	        }
	        return;
	    }
	    else {
	        fromMap.updateSize();
	    }
	    if (linkedMapIDs.indexOf(mapId) === -1) {
	        return;
	    }

	    if (linkedMapIDs.length < 1) {
	        return;
	    }

	    var masterMap = mapBox.getMapObj(linkedMapIDs[0]);
	    if(!masterMap){
	        fromMap.unByKey(fromMap.get('fromcenterchangeKey'));
		    fromMap.unByKey(fromMap.get('fromresolutionchangeKey'));
	        return ;
	    }
	    var masterMapType = masterMap.get('currentMapType');
	    var masterMapView = masterMap.getView();
	    var fromMapView = fromMap.getView();

	    if (masterMapType === 'GOOGLE_MAP') {
	        var _googleMap = fromMap.get('mineCustomMap');//google map
	        if (!!!_googleMap) {
	            return;
	        }

	        var _olViewPropery = _googleMap.olViewPropery;
	        var _center = ol.proj.toLonLat(_olViewPropery.center);
	        _googleMap.setCenter(new google.maps.LatLng(_center[1], _center[0]));
	        _googleMap.setZoom(_olViewPropery.zoom);

	        var _customCenterKey = fromMap.get('customCenterKey');
	        var _customResolutionKey = fromMap.get('customResolutionKey');
	        if (!!_customCenterKey) {
	            fromMap.unByKey(_customCenterKey);
	        }
	        if (!!_customResolutionKey) {
	            fromMap.unByKey(_customResolutionKey);
	        }

	        var _onCenterChanged = function (olEvent) {
	            google.maps.event.trigger(_googleMap, 'resize');
	            var view = olEvent.target;
	            var center = ol.proj.toLonLat(view.getCenter());
	            _googleMap.setCenter(new google.maps.LatLng(center[1], center[0]));
	        };

	        var _onResolutionChanged = function (olEvent) {
	            var view = olEvent.target;
	            _googleMap.setZoom(view.getZoom());
	        };

	        var _customCenterKey = fromMapView.on('change:center', _onCenterChanged);
	        var _customResolutionKey = fromMapView.on('change:resolution', _onResolutionChanged);
	        fromMap.set('customCenterKey', _customCenterKey);
	        fromMap.set('customResolutionKey', _customResolutionKey);


	        //刷新googlge Map
	        var gMap =fusiongis.Map.getMapObj(mapId).get('mineCustomMap');
	        google.maps.event.trigger(gMap, 'resize');
	        var center = ol.proj.toLonLat(masterMapView.getCenter());
	        gMap.setCenter(new google.maps.LatLng(center[1], center[0]));
	        gMap.setZoom(masterMapView.getZoom());
	    }
	    else if (masterMapType === 'GAODE_MAP') {
	        var _gaodeMap = fromMap.get('mineCustomMap');//google map
	        if (!!!_gaodeMap) {
	            return;
	        }

	        var _olViewPropery = _gaodeMap.olViewPropery;
	        var center = ol.proj.toLonLat(_olViewPropery.center);
	        center = util.transformGPS.gcj_encrypt(center[1],center[0]);
	        _gaodeMap.setZoomAndCenter(_olViewPropery.zoom,[center.lon,center.lat]);

	        var _customCenterKey = fromMap.get('customCenterKey');
	        var _customResolutionKey = fromMap.get('customResolutionKey');
	        if (!!_customCenterKey) {
	            fromMap.unByKey(_customCenterKey);
	        }
	        if (!!_customResolutionKey) {
	            fromMap.unByKey(_customResolutionKey);
	        }

	        var _onCenterOrZoomChanged = function (olEvent) {
	            AMap.event.trigger(_gaodeMap, 'resize');
	            var view = olEvent.target;
	            var _center = ol.proj.toLonLat(view.getCenter());
	            _center = util.transformGPS.gcj_encrypt(_center[1],_center[0]);
	        	_gaodeMap.setZoomAndCenter(view.getZoom(),[_center.lon,_center.lat]);
	        };
	        var _customCenterKey = fromMapView.on('change:center', _onCenterOrZoomChanged);
	        var _customResolutionKey = fromMapView.on('change:resolution', _onCenterOrZoomChanged);
	        fromMap.set('customCenterKey', _customCenterKey);
	        fromMap.set('customResolutionKey', _customResolutionKey);


	        //刷新gaode Map
	        var aMap =fusiongis.Map.getMapObj(mapId).get('mineCustomMap');
	        AMap.event.trigger(aMap, 'resize');
	        center = ol.proj.toLonLat(masterMapView.getCenter());
	        center = util.transformGPS.gcj_encrypt(center[1],center[0]);
	        aMap.setZoomAndCenter(masterMapView.getZoom(),[center.lon,center.lat]);
	    }
		
		if (masterMap.get('mapstercenterchangeKey') != undefined 
			&& masterMap.get('mapstercenterchangeKey').length > 0) {
			for (var i = 0; i < masterMap.get('mapstercenterchangeKey').length; i++) {
				masterMap.unByKey(masterMap.get('mapstercenterchangeKey')[i]);
			}
			masterMap.set('mapstercenterchangeKey', []);
		}
		
		if (masterMap.get('mapsterresolutionchangeKey') != undefined 
			&&  masterMap.get('mapsterresolutionchangeKey').length > 0) {
			for (var i = 0; i < masterMap.get('mapsterresolutionchangeKey').length; i++) {
				masterMap.unByKey(masterMap.get('mapsterresolutionchangeKey')[i]);
			}
			masterMap.set('mapsterresolutionchangeKey', []);
		}
		fromMap.unByKey(fromMap.get('fromcenterchangeKey'));
		fromMap.unByKey(fromMap.get('fromresolutionchangeKey'));

	}

	module.exports = {
	    mapAssociate: mapAssociate
	};


/***/ },
/* 21 */
/*!************************************!*\
  !*** ./src/gis/maps/acrossLine.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var util =__webpack_require__(/*! utils/util */ 1);

	/**
	 * 开启十字线
	 * @param paramObj
	 * paramObj = {
	 *     isAssociate: boolean
	 *     mapIds: []
	 * }
	 */
	function acrossLine(params) {
	    var mapIds = params.mapIds;
	    if (params.isOpen) {
	        var mapList = [];
	        var crossLength = params.crossLength || 30;
	        if (mapIds && mapIds.length > 0) {
	            for (var i = 0, j = mapIds.length; i < j; i++) {
	            	var _mapId = mapIds[i];
					var _layerId = 'crossLineLayer';
					var _layerIdentify = _layerId + '_' + _mapId;
	                var map = mapBox.getMapObj(_mapId);
	                
	                if(map){
	                    mapList.push(map);
	                    var _coordinates =[[0,0],[1,1]];
	                    var _featureCoords =util.multigcjTransform(_coordinates);
	                    var _style = new ol.style.Style({
	                        stroke: new ol.style.Stroke({
	                            color: params.strokeColor || '#000000',
	                            width: params.width || 2
	                        })
	                    })
	                    var acrossFeature = new ol.Feature({
	                        geometry: new ol.geom.LineString(_featureCoords)
	                    });
	                    var upDownFeature = new ol.Feature({
	                        geometry: new ol.geom.LineString(_featureCoords)
	                    });
	                    acrossFeature.setId(_mapId + '_across');
	                    upDownFeature.setId(_mapId + 'upDown');
	                    acrossFeature.setStyle(_style);
	                    upDownFeature.setStyle(_style);
	                    var crossLayer = new ol.layer.Vector({
	                        source: new ol.source.Vector({
	                            features: [acrossFeature, upDownFeature],
	                            wrapX: false
	                        })

	                    });
	                    map.set('acrossFeature', acrossFeature);
	                    map.set('upDownFeature', upDownFeature);
	                    crossLayer.set('id', _layerId);
	                    crossLayer.set('layer_id', _layerId);
	                    hashMap.put(_layerIdentify, crossLayer);
	                    map.addLayer(crossLayer);
	                    var crossLineHandle = map.on('pointermove', function (e) {
	                        this.getTargetElement().style.cursor = 'default';
	                        var centerPixel = e.pixel;
	                        var v1 = this.getCoordinateFromPixel([centerPixel[0] + crossLength / 2, centerPixel[1]]);
	                        var v2 = this.getCoordinateFromPixel([centerPixel[0] - crossLength / 2, centerPixel[1]]);
	                        var v3 = this.getCoordinateFromPixel([centerPixel[0], centerPixel[1] + crossLength / 2]);
	                        var v4 = this.getCoordinateFromPixel([centerPixel[0], centerPixel[1] - crossLength / 2]);
	                        for (var k = 0; k < mapList.length; k++) {
	                            mapList[k].get('acrossFeature').setGeometry(new ol.geom.LineString(util.multigcjTransform([v1, v2])));
	                            mapList[k].get('upDownFeature').setGeometry(new ol.geom.LineString(util.multigcjTransform([v3, v4])));
	                        }

	                    })
	                    map.set('crossLayer', crossLayer);
	                    map.set('crossLineHandle', crossLineHandle);
	                }
	            }
	        }
	    } else {
	        if (mapIds && mapIds.length > 0) {
	            for (var i = 0, j = mapIds.length; i < j; i++) {
	                var map = mapBox.getMapObj(mapIds[i]);
	                if(map){
	                    map.unByKey(map.get('crossLineHandle'));
	                    map.removeLayer(map.get('crossLayer'));
	                }
	            }
	        }

	    }


	}

	module.exports = {
	    acrossLine: acrossLine
	};

/***/ },
/* 22 */
/*!*******************************!*\
  !*** ./src/gis/maps/views.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var projection = constant.PROJ.EPSG_3857;
	var util = __webpack_require__(/*! utils/util */ 1);

	function createView(paramObj) {
		var _setting = (function (param) {
			var _zoom = param.defaultZoom != undefined ? param.defaultZoom : constant.MAPPROPERTY.DEFAULT_ZOOM;
			var _minZoom = param.minZoom != undefined ? param.minZoom : constant.MAPPROPERTY.DEFAULT_MIN_ZOOM;
			var _maxZoom = param.maxZoom != undefined ? param.maxZoom : constant.MAPPROPERTY.DEFAULT_MAX_ZOOM;
			var _center = param.center != undefined ? ol.proj.fromLonLat(util.gcjTransform(param.center))
				: ol.proj.fromLonLat(util.gcjTransform(constant.MAPPROPERTY.DEFAULT_CENTER));

			if (_minZoom > _maxZoom) {
				var _tempZoom = _minZoom;
				_minZoom = _maxZoom;
				_maxZoom = _tempZoom;
			}

			if (_zoom < _minZoom) {
				_zoom = _minZoom;
			}
			else if (_zoom > _maxZoom) {
				_zoom = _maxZoom;
			}

			return {
				defaulZoom: _zoom,
				minZoom: _minZoom,
				maxZoom: _maxZoom,
				center: _center
			}
		}(paramObj));

		var view = new ol.View({
			center: _setting.center,
			zoom: _setting.defaulZoom,
			maxZoom: _setting.maxZoom,
			minZoom: _setting.minZoom,
			projection: paramObj.proj != undefined ? paramObj.proj : constant.PROJ.EPSG_3857
		});
		view.set('linkedMapIds', [paramObj.mapId]);
		projection = paramObj.proj ? paramObj.proj : constant.PROJ.EPSG_3857;

		return view;
	}

	module.exports = {
		createView: createView,
		projection: projection
	};

/***/ },
/* 23 */
/*!*********************************!*\
  !*** ./src/gis/maps/maptype.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);

	var _createDom = function (param) {
	    var element = document.createElement(param.labelName);
	    !!param.id && element.setAttribute('id', param.id);
	    !!param.class && element.setAttribute('class', param.class);
	    !!param.title && element.setAttribute('title', param.title);
	    return element;
	};

	var mapTypeToolbar = function (paramObj) {
	    var mapObj = paramObj.mapObj;
	    var mapType = paramObj.mapType;
	    var bingMapKey = paramObj.bingMapKey;
	    var gaodeMapKey = paramObj.gaodeMapKey;
	    if (mapObj == undefined) {
	    	return;
	    }
	    var initMapParam = mapObj.get('paramObj');
	    if (initMapParam != undefined && initMapParam.isShowMaptypeToolBar != undefined) {
	    	if (initMapParam.isShowMaptypeToolBar ==  false) {
	    		return;
	    	}
	    }


	    var _mapId = mapObj.getTarget();
	    var _targetElement = mapObj.getTargetElement();

	    var _mapTypeToolbar = null;

	    if (!!!_targetElement.querySelector('.map_type_toolbar_container')) {
	        _mapTypeToolbar = _createDom({
	            labelName: 'div',
	            class: 'map_type_toolbar_container'
	        });
	        mapObj.getTargetElement().appendChild(_mapTypeToolbar);
	    }
	    else {
	        _mapTypeToolbar = _targetElement.querySelector('.map_type_toolbar_container');
	    }

	    (function () {
	        var _childNodes = _mapTypeToolbar && _mapTypeToolbar.childNodes;
	        if (!!_childNodes) {
	            for (var len = _childNodes.length, i = len; i > 0; i--) {
	                _mapTypeToolbar.removeChild(_childNodes[i - 1]);
	            }
	        }
	    }());

	    if (mapType === constant.MAPTYPE.GOOGLE_MAP) {
	        var _layerId = 'base_layer_id_google';

	        var _roadMapBtn = _createDom({
	            labelName: 'div',
	            class: 'small_map_button google road'
	        });

	        var _satelliteMapBtn = _createDom({
	            labelName: 'div',
	            class: 'small_map_button google satellite'
	        });

	        var _terrainMapBtn = _createDom({
	            labelName: 'div',
	            class: 'small_map_button google terrain'
	        });

	        var _hybridMapBtn = _createDom({
	            labelName: 'div',
	            class: 'small_map_button google hybrid'
	        });

	        _mapTypeToolbar.appendChild(_roadMapBtn);
	        _mapTypeToolbar.appendChild(_satelliteMapBtn);
	        _mapTypeToolbar.appendChild(_terrainMapBtn);
	        _mapTypeToolbar.appendChild(_hybridMapBtn);

	        _roadMapBtn.onclick = function () {
	            fusiongis.Map.updateMap({
	                mapId: _mapId,
	                mapType: mapType,
	                layerId: _layerId,
	                layers: 'roadmap'
	            });
	        };

	        _satelliteMapBtn.onclick = function () {
	            fusiongis.Map.updateMap({
	                mapId: _mapId,
	                mapType: mapType,
	                layerId: _layerId,
	                layers: 'satellite'
	            });
	        };

	        _terrainMapBtn.onclick = function () {
	            fusiongis.Map.updateMap({
	                mapId: _mapId,
	                mapType: mapType,
	                layerId: _layerId,
	                layers: 'terrain'
	            });
	        };

	        _hybridMapBtn.onclick = function () {
	            fusiongis.Map.updateMap({
	                mapId: _mapId,
	                mapType: mapType,
	                layerId: _layerId,
	                layers: 'hybrid'
	            });
	        };
	    }
	    else if (mapType === constant.MAPTYPE.BING_MAP) {
	        var _layerId = 'base_layer_id_bing';
	        //Road
	        var _roadMapBtn = _createDom({
	            labelName: 'div',
	            class: 'small_map_button bing road'
	        });

	        //Aerial
	        var _satelliteMapBtn = _createDom({
	            labelName: 'div',
	            class: 'small_map_button bing satellite'
	        });

	        //AerialWithLabels
	        var _hybridMapBtn = _createDom({
	            labelName: 'div',
	            class: 'small_map_button bing hybrid'
	        });

	        _mapTypeToolbar.appendChild(_roadMapBtn);
	        _mapTypeToolbar.appendChild(_satelliteMapBtn);
	        _mapTypeToolbar.appendChild(_hybridMapBtn);

	        _roadMapBtn.onclick = function () {
	            if (!!bingMapKey) {
	                fusiongis.Map.updateMap({
	                    mapId: _mapId,
	                    mapType: mapType,
	                    key: bingMapKey,
	                    layerId: _layerId,
	                    layers: 'Road'
	                });
	            }
	        };

	        _satelliteMapBtn.onclick = function () {
	            if (!!bingMapKey) {
	                fusiongis.Map.updateMap({
	                    mapId: _mapId,
	                    mapType: mapType,
	                    key: bingMapKey,
	                    layerId: _layerId,
	                    layers: 'Aerial'
	                });
	            }
	        };

	        _hybridMapBtn.onclick = function () {
	            if (!!bingMapKey) {
	                fusiongis.Map.updateMap({
	                    mapId: _mapId,
	                    mapType: mapType,
	                    key: bingMapKey,
	                    layerId: _layerId,
	                    layers: 'AerialWithLabels'
	                });
	            }
	        };
	    }
	    else if (mapType === constant.MAPTYPE.TIANDI_MAP) {
	        var _layerId = 'base_layer_id_tiandi';
	        //Road
	        var _roadMapBtn = _createDom({
	            labelName: 'div',
	            class: 'small_map_button tiandi road'
	        });

	        //Satellite
	        var _satelliteMapBtn = _createDom({
	            labelName: 'div',
	            class: 'small_map_button tiandi satellite'
	        });

	        _mapTypeToolbar.appendChild(_roadMapBtn);
	        _mapTypeToolbar.appendChild(_satelliteMapBtn);

	        _roadMapBtn.onclick = function () {
	            fusiongis.Map.updateMap({
	                mapId: _mapId,
	                mapType: mapType,
	                layerId: _layerId,
	                layers: 'Road'
	            });
	        };

	        _satelliteMapBtn.onclick = function () {
	            fusiongis.Map.updateMap({
	                mapId: _mapId,
	                mapType: mapType,
	                layerId: _layerId,
	                layers: 'Satellite'
	            });
	        };

	    }
	    else if (mapType === constant.MAPTYPE.GAODE_MAP) {
	        var _layerId = 'base_layer_id_gaode';
	        //Road
	        var _roadMapBtn = _createDom({
	            labelName: 'div',
	            class: 'small_map_button gaode road'
	        });

	        //Aerial
	        var _satelliteMapBtn = _createDom({
	            labelName: 'div',
	            class: 'small_map_button gaode satellite'
	        });

	        _mapTypeToolbar.appendChild(_roadMapBtn);
	        _mapTypeToolbar.appendChild(_satelliteMapBtn);

	        _roadMapBtn.onclick = function () {
	            if (!!gaodeMapKey) {
	                fusiongis.Map.updateMap({
	                    mapId: _mapId,
	                    mapType: mapType,
	                    key: gaodeMapKey,
	                    layerId: _layerId,
	                    layers: 'Road'
	                });
	            }
	        };

	        _satelliteMapBtn.onclick = function () {
	            if (!!gaodeMapKey) {
	                fusiongis.Map.updateMap({
	                    mapId: _mapId,
	                    mapType: mapType,
	                    key: gaodeMapKey,
	                    layerId: _layerId,
	                    layers: 'satellite'
	                });
	            }
	        };
	    	
	    }

	};

	module.exports = {
	    mapTypeToolbar: mapTypeToolbar
	};

/***/ },
/* 24 */
/*!***********************************!*\
  !*** ./src/gis/maps/googleMap.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var util = __webpack_require__(/*! utils/util */ 1);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var googleStyle = __webpack_require__(/*! maps/googleStyle */ 25);

	/**
	 * 谷歌地图类型
	 * @type {{Hybrid: string, Roadmap: string, Satellite: string, Terrain: string}}
	 */
	var GoogMapTypes = {
	    Hybrid: 'hybrid',
	    Roadmap: 'roadmap',
	    Satellite: 'satellite',
	    Terrain: 'terrain'
	};
	var callbackArr = [];
	var loadApi = false;
	var loadApiComplete = 0;

	var loadGoogleAPI = function (key, language, callback) {
	    if (loadApi === false) {
	        loadApi = true;
	    
	        var script = document.createElement('script');
	        var _protocol = 'http:';
	        if (location.protocol !== 'file:') {
	            _protocol = location.protocol;
	        }
	        //判断下是不是中文系统，如果是中文系统就用国内网址否则用国外网址
	        var _language = language || 'en-US';//zh-CH
	        var _src = _protocol + '//maps.google.com/maps/api/js?v=3&language=' + _language + '&key=' + key;
	        if(navigator.language == "zh-CN"){//中文系统（国内用）
	        	_src =  _protocol + '//ditu.google.cn/maps/api/js?v=3&language=' + _language + '&key=' + key;
	        }else{
	        	_src = _protocol + '//maps.google.com/maps/api/js?v=3&language=' + _language + '&key=' + key;
	        }
					if (!!document.querySelector('#google-api-load-yet')) {
	            script.setAttribute('src', 'http://www.huawei.com/Assets/CBG/js/Huawei.Personalization.CBG.js?ver=1');
	        }
	        else {
	            script.setAttribute('src', _src);
	            script.setAttribute('id', 'google-api-load-yet');
	            callbackArr.push(callback);
	        }
	       

	        script.onload = function () {
	            loadApiComplete = 1;
	            callbackArr.forEach(function (callback) {
	                callback(true);
	            });
	            callbackArr.splice(0);
	        };
	        script.onerror = function () {
	            loadApiComplete = -1;
	            callback(false);
	        };
	        document.body.appendChild(script);
	    }
	    else {
	        if (loadApiComplete > 0) {
	            callback(true);
	        }
	        else if (loadApiComplete < 0) {
	            callback(false);
	        }
	        else {
	            callbackArr.push(callback);
	        }

	    }
	    
	};

	/**
	 * 创建谷歌Map
	 * @param params
	 * @returns
	 */
	function createCustomMap(params) {
	    if (typeof (google) === 'undefined') {
	        return;
	    }
	    var olMap = undefined;
	    if (params.map != undefined) {
	        olMap = params.map;
	    }
	    else {
	        olMap = mapBox.getMapObj(params.mapId);
	    }
	    var olMapTargetElement = olMap.getTargetElement();
	    var googleMapDivDom = document.createElement('div');
	    googleMapDivDom.setAttribute('id', '$$customMap_' + params.mapId);
	    googleMapDivDom.setAttribute('class', 'customMap');
	    googleMapDivDom.style.position = 'absolute';
	    googleMapDivDom.style.zIndex = 0;
	    googleMapDivDom.style.width = '100%';
	    googleMapDivDom.style.height = '100%';
	    olMapTargetElement.insertBefore(googleMapDivDom, olMapTargetElement.firstChild);

	    var mapTypeId;
	    if (params.layers) {
	        mapTypeId = params.layers;
	    }
	    else {
	        mapTypeId = GoogMapTypes.Roadmap;
	    }
	    var _style = params.googleStyle || 'style';
	    var gMapParam = {
	        mapTypeId: mapTypeId,
	        disableDefaultUI: true,
	        keyboardShortcuts: false,
	        draggable: false,
	        disableDoubleClickZoom: true,
	        scrollwheel: false,
	        streetViewControl: false,
	        styles: googleStyle[_style]()
	    };
	    if (!params.googleStyle) {
	        delete gMapParam.styles;
	    }
	    var gmap = new google.maps.Map(googleMapDivDom, gMapParam);

	    var _onCenterChanged = function (olEvent) {
	        google.maps.event.trigger(gmap, 'resize');
	        if (new util.sessionStorageObj().get('currentMapType') != constant.MAPTYPE.GOOGLE_MAP) {
	            return;
	        }
	        var view = olEvent.target;
	        var center = ol.proj.toLonLat(view.getCenter());
	        gmap.setCenter(new google.maps.LatLng(center[1], center[0]));
	    };

	    var _onResolutionChanged = function (olEvent) {
	        if (new util.sessionStorageObj().get('currentMapType') != constant.MAPTYPE.GOOGLE_MAP) {
	            return;
	        }
	        var view = olEvent.target;
	        gmap.setZoom(view.getZoom());
	    };

	    var view = olMap.getView();
	    var _currentMapZoom = view.getZoom();
	    var _currentMapCenter = view.getCenter();
	    //记录Google地图原始中心点和级别
	    gmap.olViewPropery = {};
	    gmap.olViewPropery.zoom = _currentMapZoom;
	    gmap.olViewPropery.center = _currentMapCenter;

	    var _customCenterKey = olMap.get('customCenterKey');
	    var _customResolutionKey = olMap.get('customResolutionKey');
	    if (!!_customCenterKey) {
	        olMap.unByKey(_customCenterKey);
	    }
	    if (!!_customResolutionKey) {
	        olMap.unByKey(_customResolutionKey);
	    }

	    _customCenterKey = view.on('change:center', _onCenterChanged);
	    _customResolutionKey = view.on('change:resolution', _onResolutionChanged);
	    olMap.set('customCenterKey', _customCenterKey);
	    olMap.set('customResolutionKey', _customResolutionKey);
	    olMap.set('mineCustomMap', gmap);
	    var center = ol.proj.toLonLat(view.getCenter());
	    gmap.setCenter(new google.maps.LatLng(parseFloat(center[1]), parseFloat(center[0])));
	    gmap.setZoom(_currentMapZoom);

	    var customMaps = olMapTargetElement.querySelectorAll('.customMap');
	    if (!!customMaps && customMaps.length > 1) {
	        for (var i = customMaps.length - 1; i > 0; i--) {
	            olMap.getTargetElement().removeChild(customMaps[i]);
	        }
	    }

	    return gmap;
	}

	function setVisible(olMap, visible) {
	    var gMapElement = document.getElementById('$$customMap_' + olMap.getTarget());
	    if (!gMapElement) {
	        return;
	    }
	    if (visible) {
	        gMapElement.style.display = '';
	    }
	    else {
	        gMapElement.style.display = 'none';
	    }
	}

	function setOpacity(olMap, opactiy) {
	    var gMapElement = document.getElementById('$$customMap_' + olMap.getTarget());
	    if (!gMapElement) {
	        return;
	    }
	    if (!isFinite(opactiy) || opactiy === null || opactiy === undefined) {
	        return;
	    }
	    opactiy = Number(opactiy);
	    gMapElement.style.opacity = opactiy;
	}

	/**
	 * 更新定制地图
	 * @param params
	 */
	function updateCustomMap(params) {
	    var olMap = mapBox.getMapObj(params.mapId);
	    var gMap = olMap.get('customMap');
	    if (!gMap) {
	        return;
	    }
	    var mapTypeId = params.layers;
	    gMap.setMapTypeId(mapTypeId);

	    var view = olMap.getView();
	    var center = view.getCenter();
	    gMap.setCenter(new google.maps.LatLng(center[1], center[0]));
	    gMap.setZoom(view.getZoom());
	}

	function setImageFilter(params) {
	    var olMap = mapBox.getMapObj(params.mapId);
	    var gMap = olMap.get('customMap');
	    if (!gMap) {
	        return;
	    }

	    gMap.set('styles', [
	        {
	            stylers: [
	                { hue: '#9DF4C3' },
	                { saturation: -100 }
	            ]
	        }
	    ]);
	}

	function removeImageFilter(params) {
	    var olMap = mapBox.getMapObj(params.mapId);
	    var gMap = olMap.get('customMap');
	    if (!gMap) {
	        return;
	    }

	    gMap.set('styles', null);
	}

	module.exports = {
	    loadGoogleAPI: loadGoogleAPI,
	    createCustomMap: createCustomMap,
	    updateCustomMap: updateCustomMap,
	    setVisible: setVisible,
	    setOpacity: setOpacity,
	    setImageFilter: setImageFilter,
	    removeImageFilter: removeImageFilter
	};

/***/ },
/* 25 */
/*!*************************************!*\
  !*** ./src/gis/maps/googleStyle.js ***!
  \*************************************/
/***/ function(module, exports) {

	var style = function () {
	    return [
  {
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#367e87"
      }
    ]
  },
  {
    "elementType": "labels",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#ceedf2"
      }
    ]
  },
  {
    "elementType": "labels.text.stroke",
    "stylers": [
      {
        "color": "#0d3c40"
      }
    ]
  },
  {
    "featureType": "poi",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#4ca498"
      }
    ]
  },
  {
    "featureType": "poi",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#ceedf2"
      }
    ]
  },
  {
    "featureType": "poi",
    "elementType": "labels.text.stroke",
    "stylers": [
      {
        "color": "#105252"
      }
    ]
  },
  {
    "featureType": "road",
    "elementType": "labels",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "road",
    "elementType": "labels.icon",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "road",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#ceedf2"
      }
    ]
  },
  {
    "featureType": "road",
    "elementType": "labels.text.stroke",
    "stylers": [
      {
        "color": "#0d3c40"
      }
    ]
  },
  {
    "featureType": "road.arterial",
    "elementType": "geometry.fill",
    "stylers": [
      {
        "color": "#6dbbb4"
      }
    ]
  },
  {
    "featureType": "road.highway",
    "elementType": "geometry.fill",
    "stylers": [
      {
        "color": "#3e929f"
      }
    ]
  },
  {
    "featureType": "road.highway",
    "elementType": "geometry.stroke",
    "stylers": [
      {
        "color": "#95d2ce"
      },
      {
        "weight": 1
      }
    ]
  },
  {
    "featureType": "road.local",
    "elementType": "geometry.fill",
    "stylers": [
      {
        "color": "#68838b"
      }
    ]
  },
  {
    "featureType": "water",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#25585c"
      }
    ]
  }
];
	};
	var smallStyle = function () {
	    return [
	        {
	            "featureType": "water",
	            "elementType": "geometry",
	            "stylers": [
	                { "color": "#0f171a" }
	            ]
	        },
	        {
	            "featureType": "landscape.man_made",
	            "elementType": "geometry",
	            "stylers": [
	                { "color": "#1a282c" },
	                { "lightness": 10 }
	            ]
	        },
	        {
	            "featureType": "landscape.natural",
	            "elementType": "geometry",
	            "stylers": [
	                { "color": "#1a282c" },
	                { "lightness": 5 }
	            ]
	        },
	        {
	            "featureType": "transit",
	            "elementType": "geometry",
	            "stylers": [
	                { "color": "#1a282c" }
	            ]
	        },
	        {
	            "featureType": "poi",
	            "elementType": "geometry",
	            "stylers": [
	                { "color": "#1a282c" },
	                { "lightness": 16 }
	            ]
	        },
	        {
	            "featureType": "road.arterial",
	            "elementType": "geometry.fill",
	            "stylers": [
	                { "color": "#415e68" },
	                { "weight": 0.1 }
	            ]
	        },
	        {
	            "featureType": "road.highway",
	            "elementType": "geometry",
	            "stylers": [
	                { "weight": 0.6 },
	                { "color": "#415e68" }
	            ]
	        },
	        {
	            "featureType": "administrative",
	            "elementType": "labels.text.stroke",
	            "stylers": [
	                { "color": "#333333" },
	                { "weight": 2 },
	                { "visibility": "off" }
	            ]
	        },
	        {
	            "featureType": "administrative",
	            "elementType": "labels.text.fill",
	            "stylers": [
	                { "color": "#cccccc" },
	                { "visibility": "off" }
	            ]
	        },
	        {
	            "featureType": "transit",
	            "elementType": "labels.text.stroke",
	            "stylers": [
	                { "color": "#00807d" },
	                { "visibility": "off" }
	            ]
	        },
	        {
	            "featureType": "transit",
	            "elementType": "labels.text.fill",
	            "stylers": [
	                { "color": "#999999" },
	                { "visibility": "off" }
	            ]
	        },
	        {
	            "featureType": "poi",
	            "elementType": "labels.text.fill",
	            "stylers": [
	                { "color": "#999999" },
	                { "visibility": "off" }
	            ]
	        },
	        {
	            "featureType": "poi",
	            "elementType": "labels.text.stroke",
	            "stylers": [
	                { "color": "#cccccc" },
	                { "weight": 2 },
	                { "visibility": "off" }
	            ]
	        },
	        {
	            "featureType": "poi",
	            "elementType": "labels.icon",
	            "stylers": [
	                { "hue": "#00c3ff" },
	                { "gamma": 0.6 },
	                { "lightness": -30 },
	                { "visibility": "off" }
	            ]
	        },
	        {
	            "featureType": "transit",
	            "elementType": "labels.icon",
	            "stylers": [
	                { "hue": "#00ccff" },
	                { "lightness": -30 },
	                { "gamma": 0.6 },
	                { "visibility": "off" }
	            ]
	        },
	        {
	            "featureType": "landscape",
	            "elementType": "labels.text.fill",
	            "stylers": [
	                { "lightness": 5 },
	                { "color": "#999999" },
	                { "visibility": "off" }
	            ]
	        },
	        {
	            "featureType": "landscape",
	            "elementType": "labels.text.stroke",
	            "stylers": [
	                { "color": "#00807d" },
	                { "visibility": "off" }
	            ]
	        },
	        {
	            "featureType": "landscape.natural",
	            "elementType": "labels.icon",
	            "stylers": [
	                { "hue": "#00ccff" },
	                { "lightness": -30 },
	                { "gamma": 0.6 },
	                { "visibility": "off" }
	            ]
	        },
	        {
	            "featureType": "administrative",
	            "elementType": "labels.icon",
	            "stylers": [
	                { "hue": "#00c3ff" },
	                { "lightness": -30 },
	                { "gamma": 0.6 },
	                { "visibility": "off" }
	            ]
	        },
	        {
	            "featureType": "administrative",
	            "elementType": "geometry",
	            "stylers": [
	                { "color": "#557580" }
	            ]
	        },
	        {
	            "featureType": "road",
	            "elementType": "labels.text.fill",
	            "stylers": [
	                { "lightness": -5 },
	                { "color": "#00807d" },
	                { "visibility": "off" }
	            ]
	        },
	        {
	            "featureType": "road",
	            "elementType": "labels.text.stroke",
	            "stylers": [
	                { "weight": 1.5 },
	                { "color": "#00807d" },
	                { "visibility": "off" }
	            ]
	        },
	        {
	            "featureType": "road",
	            "elementType": "labels.icon",
	            "stylers": [
	                { "lightness": -40 },
	                { "visibility": "off" }
	            ]
	        },
	        {
	            "featureType": "administrative.country",
	            "stylers": [
	                { "color": "#00fffc" },
	                { "weight": 2 }
	            ]
	        },
	        {
	            "featureType": "road.arterial",
	            "elementType": "geometry.stroke",
	            "stylers": [
	                { "visibility": "off" }
	            ]
	        },
	        {
	            "featureType": "water",
	            "elementType": "labels",
	            "stylers": [
	                { "visibility": "off" }
	            ]
	        }
	    ];
	};

	var hiding = function () {
	    return [
	        {
	            featureType: 'poi.business',
	            stylers: [
	                {visibility: 'off'}
	            ]
	        },
	        {
	            featureType: 'transit',
	            elementType: 'labels.icon',
	            stylers: [
	                {visibility: 'off'}
	            ]
	        }
	    ]
	};

	var retro = function () {

	    return [
	        {elementType: 'geometry', stylers: [
	            {color: '#ebe3cd'}
	        ]},
	        {elementType: 'labels.text.fill', stylers: [
	            {color: '#523735'}
	        ]},
	        {elementType: 'labels.text.stroke', stylers: [
	            {color: '#f5f1e6'}
	        ]},
	        {
	            featureType: 'administrative',
	            elementType: 'geometry.stroke',
	            stylers: [
	                {color: '#c9b2a6'}
	            ]
	        },
	        {
	            featureType: 'administrative.land_parcel',
	            elementType: 'geometry.stroke',
	            stylers: [
	                {color: '#dcd2be'}
	            ]
	        },
	        {
	            featureType: 'administrative.land_parcel',
	            elementType: 'labels.text.fill',
	            stylers: [
	                {color: '#ae9e90'}
	            ]
	        },
	        {
	            featureType: 'landscape.natural',
	            elementType: 'geometry',
	            stylers: [
	                {color: '#dfd2ae'}
	            ]
	        },
	        {
	            featureType: 'poi',
	            elementType: 'geometry',
	            stylers: [
	                {color: '#dfd2ae'}
	            ]
	        },
	        {
	            featureType: 'poi',
	            elementType: 'labels.text.fill',
	            stylers: [
	                {color: '#93817c'}
	            ]
	        },
	        {
	            featureType: 'poi.park',
	            elementType: 'geometry.fill',
	            stylers: [
	                {color: '#a5b076'}
	            ]
	        },
	        {
	            featureType: 'poi.park',
	            elementType: 'labels.text.fill',
	            stylers: [
	                {color: '#447530'}
	            ]
	        },
	        {
	            featureType: 'road',
	            elementType: 'geometry',
	            stylers: [
	                {color: '#f5f1e6'}
	            ]
	        },
	        {
	            featureType: 'road.arterial',
	            elementType: 'geometry',
	            stylers: [
	                {color: '#fdfcf8'}
	            ]
	        },
	        {
	            featureType: 'road.highway',
	            elementType: 'geometry',
	            stylers: [
	                {color: '#f8c967'}
	            ]
	        },
	        {
	            featureType: 'road.highway',
	            elementType: 'geometry.stroke',
	            stylers: [
	                {color: '#e9bc62'}
	            ]
	        },
	        {
	            featureType: 'road.highway.controlled_access',
	            elementType: 'geometry',
	            stylers: [
	                {color: '#e98d58'}
	            ]
	        },
	        {
	            featureType: 'road.highway.controlled_access',
	            elementType: 'geometry.stroke',
	            stylers: [
	                {color: '#db8555'}
	            ]
	        },
	        {
	            featureType: 'road.local',
	            elementType: 'labels.text.fill',
	            stylers: [
	                {color: '#806b63'}
	            ]
	        },
	        {
	            featureType: 'transit.line',
	            elementType: 'geometry',
	            stylers: [
	                {color: '#dfd2ae'}
	            ]
	        },
	        {
	            featureType: 'transit.line',
	            elementType: 'labels.text.fill',
	            stylers: [
	                {color: '#8f7d77'}
	            ]
	        },
	        {
	            featureType: 'transit.line',
	            elementType: 'labels.text.stroke',
	            stylers: [
	                {color: '#ebe3cd'}
	            ]
	        },
	        {
	            featureType: 'transit.station',
	            elementType: 'geometry',
	            stylers: [
	                {color: '#dfd2ae'}
	            ]
	        },
	        {
	            featureType: 'water',
	            elementType: 'geometry.fill',
	            stylers: [
	                {color: '#b9d3c2'}
	            ]
	        },
	        {
	            featureType: 'water',
	            elementType: 'labels.text.fill',
	            stylers: [
	                {color: '#92998d'}
	            ]
	        }
	    ]
	};

	var night = function () {
	    return [
	        {elementType: 'geometry', stylers: [
	            {color: '#242f3e'}
	        ]},
	        {elementType: 'labels.text.stroke', stylers: [
	            {color: '#242f3e'}
	        ]},
	        {elementType: 'labels.text.fill', stylers: [
	            {color: '#746855'}
	        ]},
	        {
	            featureType: 'administrative.locality',
	            elementType: 'labels.text.fill',
	            stylers: [
	                {color: '#d59563'}
	            ]
	        },
	        {
	            featureType: 'poi',
	            elementType: 'labels.text.fill',
	            stylers: [
	                {color: '#d59563'}
	            ]
	        },
	        {
	            featureType: 'poi.park',
	            elementType: 'geometry',
	            stylers: [
	                {color: '#263c3f'}
	            ]
	        },
	        {
	            featureType: 'poi.park',
	            elementType: 'labels.text.fill',
	            stylers: [
	                {color: '#6b9a76'}
	            ]
	        },
	        {
	            featureType: 'road',
	            elementType: 'geometry',
	            stylers: [
	                {color: '#38414e'}
	            ]
	        },
	        {
	            featureType: 'road',
	            elementType: 'geometry.stroke',
	            stylers: [
	                {color: '#212a37'}
	            ]
	        },
	        {
	            featureType: 'road',
	            elementType: 'labels.text.fill',
	            stylers: [
	                {color: '#9ca5b3'}
	            ]
	        },
	        {
	            featureType: 'road.highway',
	            elementType: 'geometry',
	            stylers: [
	                {color: '#746855'}
	            ]
	        },
	        {
	            featureType: 'road.highway',
	            elementType: 'geometry.stroke',
	            stylers: [
	                {color: '#1f2835'}
	            ]
	        },
	        {
	            featureType: 'road.highway',
	            elementType: 'labels.text.fill',
	            stylers: [
	                {color: '#f3d19c'}
	            ]
	        },
	        {
	            featureType: 'transit',
	            elementType: 'geometry',
	            stylers: [
	                {color: '#2f3948'}
	            ]
	        },
	        {
	            featureType: 'transit.station',
	            elementType: 'labels.text.fill',
	            stylers: [
	                {color: '#d59563'}
	            ]
	        },
	        {
	            featureType: 'water',
	            elementType: 'geometry',
	            stylers: [
	                {color: '#17263c'}
	            ]
	        },
	        {
	            featureType: 'water',
	            elementType: 'labels.text.fill',
	            stylers: [
	                {color: '#515c6d'}
	            ]
	        },
	        {
	            featureType: 'water',
	            elementType: 'labels.text.stroke',
	            stylers: [
	                {color: '#17263c'}
	            ]
	        }
	    ]
	};

	var silver = function () {
	    return [
	        {
	            elementType: 'geometry',
	            stylers: [
	                {color: '#f5f5f5'}
	            ]
	        },
	        {
	            elementType: 'labels.icon',
	            stylers: [
	                {visibility: 'off'}
	            ]
	        },
	        {
	            elementType: 'labels.text.fill',
	            stylers: [
	                {color: '#616161'}
	            ]
	        },
	        {
	            elementType: 'labels.text.stroke',
	            stylers: [
	                {color: '#f5f5f5'}
	            ]
	        },
	        {
	            featureType: 'administrative.land_parcel',
	            elementType: 'labels.text.fill',
	            stylers: [
	                {color: '#bdbdbd'}
	            ]
	        },
	        {
	            featureType: 'poi',
	            elementType: 'geometry',
	            stylers: [
	                {color: '#eeeeee'}
	            ]
	        },
	        {
	            featureType: 'poi',
	            elementType: 'labels.text.fill',
	            stylers: [
	                {color: '#757575'}
	            ]
	        },
	        {
	            featureType: 'poi.park',
	            elementType: 'geometry',
	            stylers: [
	                {color: '#e5e5e5'}
	            ]
	        },
	        {
	            featureType: 'poi.park',
	            elementType: 'labels.text.fill',
	            stylers: [
	                {color: '#9e9e9e'}
	            ]
	        },
	        {
	            featureType: 'road',
	            elementType: 'geometry',
	            stylers: [
	                {color: '#ffffff'}
	            ]
	        },
	        {
	            featureType: 'road.arterial',
	            elementType: 'labels.text.fill',
	            stylers: [
	                {color: '#757575'}
	            ]
	        },
	        {
	            featureType: 'road.highway',
	            elementType: 'geometry',
	            stylers: [
	                {color: '#dadada'}
	            ]
	        },
	        {
	            featureType: 'road.highway',
	            elementType: 'labels.text.fill',
	            stylers: [
	                {color: '#616161'}
	            ]
	        },
	        {
	            featureType: 'road.local',
	            elementType: 'labels.text.fill',
	            stylers: [
	                {color: '#9e9e9e'}
	            ]
	        },
	        {
	            featureType: 'transit.line',
	            elementType: 'geometry',
	            stylers: [
	                {color: '#e5e5e5'}
	            ]
	        },
	        {
	            featureType: 'transit.station',
	            elementType: 'geometry',
	            stylers: [
	                {color: '#eeeeee'}
	            ]
	        },
	        {
	            featureType: 'water',
	            elementType: 'geometry',
	            stylers: [
	                {color: '#c9c9c9'}
	            ]
	        },
	        {
	            featureType: 'water',
	            elementType: 'labels.text.fill',
	            stylers: [
	                {color: '#9e9e9e'}
	            ]
	        }
	    ]
	};
	module.exports = {
	    style: style,
	    smallStyle: smallStyle,
	    hiding: hiding,
	    retro: retro,
	    night: night,
	    silver: silver
	};

/***/ },
/* 26 */
/*!*******************************!*\
  !*** ./src/gis/maps/gaode.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var util = __webpack_require__(/*! utils/util */ 1);
	/**
	 * 高德地图类型
	 * @type {Roadmap: string, Satellite: string}
	 */
	var gaodeMapTypes = {
	    Roadmap: 'roadmap',
	    Satellite: 'satellite'
	};

	var callbackArr = [];
	var loadApi = false;
	var loadApiComplete = 0;
	/*
	 * 加载高德地图API
	 */
	var loadGaodeAPI = function (key, language, callback) {
	    if (loadApi === false) {
	        loadApi = true;
	        var script = document.createElement('script');
	        var _protocol = 'http:';
	        if (location.protocol !== 'file:') {
	            _protocol = location.protocol;
	        }
	        var _language = language || 'en-US';//zh-CH
	        var _src = _protocol + '//webapi.amap.com/maps?v=1.3&language=' + _language + '&key=' + key;

	        script.setAttribute('src', _src);
	        callbackArr.push(callback);

	        script.onload = function () {
	            loadApiComplete = 1;
	            callbackArr.forEach(function (callback) {
	                callback(true);
	            });
	            callbackArr.splice(0);
	        };
	        script.onerror = function () {
	            loadApiComplete = -1;
	            callback(false);
	        };
	        document.body.appendChild(script);
	    }
	    else {
	        if (loadApiComplete > 0) {
	            callback(true);
	        }
	        else if (loadApiComplete < 0) {
	            callback(false);
	        }
	        else {
	            callbackArr.push(callback);
	        }

	    }
	};
	/**
	 * 创建高德地图
	 * @param {Object} params
	 */
	function createCustomMap(params) {
	    if (typeof AMap === 'undefined') {
	        return;
	    }
	    var olMap = undefined;
	    if (params.map != undefined) {
	    	olMap = params.map;
	    }
	    else {
	    	olMap = mapBox.getMapObj(params.mapId);
	    }
	    var olMapTargetElement = olMap.getTargetElement();
	    var targetMap = document.getElementById('#$$customMap_' + params.mapId);
	    if (targetMap) {
	        olMapTargetElement.removeChild(targetMap);
	    }
	    var gaodeMapDivDom = document.createElement('div');
	    gaodeMapDivDom.setAttribute('id', '$$customMap_' + params.mapId);
	    gaodeMapDivDom.setAttribute('class', 'customMap');
	    gaodeMapDivDom.style.position = 'absolute';
	    gaodeMapDivDom.style.zIndex = 0;
	    gaodeMapDivDom.style.width = '100%';
	    gaodeMapDivDom.style.height = '100%';
	    olMapTargetElement.insertBefore(gaodeMapDivDom, olMapTargetElement.firstChild);
	    var gMapParam = {
	        resizeEnable: true, //	Boolean	是否监控地图容器尺寸变化，默认值为false
	        dragEnable: false, //	Boolean	地图是否可旋转，默认false （自v1.3 新增）
	        zoomEnable: false, //	Boolean	地图是否可通过鼠标拖拽平移，默认为true。此属性可被setStatus/getStatus 方法控制
	        doubleClickZoom: false, //	Boolean	地图是否可通过双击鼠标放大地图，默认为true。此属性可被setStatus/getStatus 方法控制
	        keyboardEnable: false, //	Boolean	地图是否可通过键盘控制，方向键控制地图平移，"+"和"-"可以控制地图的缩放
	        scrollWheel: false
	    };
	    //若创建的是卫星地图，则需传递layers参数，默认街道地图不用
	    if (params && params.layers && params.layers === gaodeMapTypes.Satellite) {
	        gMapParam.layers = [new AMap.TileLayer.Satellite(), new AMap.TileLayer.RoadNet()];
	    } else {
	    	delete gMapParam.layers;	
	    }
	    var gmap = new AMap.Map(gaodeMapDivDom.id, gMapParam);
	    var _onCenterOrZoomChanged = function (olEvent) {
		 	if (new util.sessionStorageObj().get('currentMapType') != constant.MAPTYPE.GAODE_MAP) {
	        	return;
	        }
	        AMap.event.trigger(gmap, 'resize');
	        var view = olEvent.target;
	        var center = ol.proj.toLonLat(view.getCenter());
	       // center = util.transformGPS.gcj_encrypt(center[1],center[0]);
	        gmap.setZoomAndCenter(view.getZoom(), center);
	    };

	    var view = olMap.getView();
	    var _currentMapZoom = view.getZoom();
	    var _currentMapCenter = view.getCenter();
	    //记录高德地图原始中心点和级别
	    gmap.olViewPropery = {};
	    gmap.olViewPropery.zoom = _currentMapZoom;
	    gmap.olViewPropery.center = _currentMapCenter;

	    var _customCenterKey = olMap.get('customCenterKey');
	    var _customResolutionKey = olMap.get('customResolutionKey');
	    if (!!_customCenterKey) {
	        olMap.unByKey(_customCenterKey);
	    }
	    if (!!_customResolutionKey) {
	        olMap.unByKey(_customResolutionKey);
	    }

	    _customCenterKey = view.on('change:center', _onCenterOrZoomChanged);
	    _customResolutionKey = view.on('change:resolution', _onCenterOrZoomChanged);
	    olMap.set('customCenterKey', _customCenterKey);
	    olMap.set('customResolutionKey', _customResolutionKey);
	    olMap.set('mineCustomMap', gmap);
	    // 设置缩放级别和中心点
	    var center = ol.proj.toLonLat(view.getCenter());
	    //center = util.transformGPS.gcj_encrypt(center[1],center[0]);
	    gmap.setZoomAndCenter(_currentMapZoom, center);

	    var customMaps = olMapTargetElement.querySelectorAll('.customMap');
	    if (!!customMaps && customMaps.length > 1) {
	        for (var i = customMaps.length - 1; i > 0; i--) {
	            olMap.getTargetElement().removeChild(customMaps[i]);
	        }
	    }

	    return gmap;
	}
	/**
	 * 更新定制地图
	 * @param params
	 */
	function updateCustomMap(params) {
	    var olMap = mapBox.getMapObj(params.mapId);
	    var gMap = olMap.get('customMap');
	    if (!gMap) {
	        return;
	    }
	    //重新创建当前指定的地图
		createCustomMap(params);
	    var view = olMap.getView();
	    var _currentMapZoom = view.getZoom();
	    var center = ol.proj.toLonLat(view.getCenter());
	    //center = util.transformGPS.gcj_encrypt(center[1],center[0]);
	    gMap.setZoomAndCenter(_currentMapZoom, center);
	}

	function setVisible(olMap, visible) {
	    var gMapElement = document.getElementById('$$customMap_' + olMap.getTarget());
	    if (!gMapElement) {
	        return;
	    }
	    if (visible) {
	        gMapElement.style.display = '';
	    }
	    else {
	        gMapElement.style.display = 'none';
	    }
	}

	function setOpacity(olMap, opactiy) {
	    var gMapElement = document.getElementById('$$customMap_' + olMap.getTarget());
	    if (!gMapElement) {
	        return;
	    }
	    if (!isFinite(opactiy) || opactiy === null || opactiy === undefined) {
	        return;
	    }
	    opactiy = Number(opactiy);
	    gMapElement.style.opacity = opactiy;
	}

	function setImageFilter(params) {
	    var olMap = mapBox.getMapObj(params.mapId);
	    var gMap = olMap.get('customMap');
	    if (!gMap) {
	        return;
	    }

	    gMap.set('styles', [
	        {
	            stylers: [
	                { hue: '#9DF4C3' },
	                { saturation: -100 }
	            ]
	        }
	    ]);
	}

	function removeImageFilter(params) {
	    var olMap = mapBox.getMapObj(params.mapId);
	    var gMap = olMap.get('customMap');
	    if (!gMap) {
	        return;
	    }

	    gMap.set('styles', null);
	}

	module.exports = {
	    loadGaodeAPI: loadGaodeAPI,
	    createCustomMap: createCustomMap,
	    updateCustomMap: updateCustomMap,
	    setVisible: setVisible,
	    setOpacity: setOpacity,
	    setImageFilter: setImageFilter,
	    removeImageFilter: removeImageFilter
	};

/***/ },
/* 27 */
/*!********************************!*\
  !*** ./src/gis/maps/osmMap.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);

	var layer = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId;
	    var url = undefined;
	    if (location.protocol === 'http:' || location.protocol === 'file:') {
	        url = 'http://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'
	    }

	    var _layer = new ol.layer.Tile({
	        source: new ol.source.OSM({
	            url: url,
	            wrapX: false
	        })
	    });

	    _layer.set('type', constant.CUSTOMTYPE.LAYERTILETYPE);
	    _layer.set('layerId', _layerId);
	    _layer.set('layer_id', paramObj.layer_id);
	    _layer.set('mapType', constant.Search_Engine.OSM);

	    hashMap.put(_layerId, _layer);
	    return _layer;
	};
	module.exports = {
	    createLayer: layer
	};

/***/ },
/* 28 */
/*!*********************************!*\
  !*** ./src/gis/maps/bingMap.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var u = __webpack_require__(/*! utils/util */ 1);

	/**
	 * bing地图类型
	 * @type {{Road: string, Aerial: string, AerialWithLabels: string, CollinsBart: string, OrdnanceSurvey: string}}
	 */
	var BingMapTypes = {
	    Road: 'Road',
	    Aerial: 'Aerial',
	    AerialWithLabels: 'AerialWithLabels',
	    Birdseye: 'Birdseye',
	    BirdseyeWithLabels: 'BirdseyeWithLabels',
	    CollinsBart: 'CollinsBart',
	    OrdnanceSurvey: 'OrdnanceSurvey'
	};
	/*
	 url:https://msdn.microsoft.com/en-us/library/ff701716.aspx

	 Aerial - Aerial imagery.
	 AerialWithLabels - Aerial imagery with a road overlay.
	 Birdseye - Bird’s eye (oblique-angle) imagery
	 BirdseyeWithLabels - Bird’s eye imagery with a road overlay.
	 Road - Roads without additional imagery.
	 OrdnanceSurvey - Ordnance Survey imagery. This imagery is visible only for the London area.
	 */

	/**
	 * 创建bing地图类型
	 * @param paramObj
	 * @returns {ol.layer.Tile}
	 */
	function createLayer(paramObj) {
	    var bmType;
	    if (paramObj.layers) {
	        bmType = paramObj.layers;
	    }
	    else {
	        bmType = BingMapTypes.Road;
	    }

	    var _tile = new ol.layer.Tile({
	        source: new ol.source.BingMaps({
	            imagerySet: bmType,
	            key: paramObj.key || undefined,
	            wrapX: false
	        })
	    });
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId;
	    _tile.set('type', constant.CUSTOMTYPE.LAYERTILETYPE);
	    _tile.set('layerId', _layerId);
	    _tile.set('layer_id', paramObj.layer_id);
	    hashMap.put(_layerId, _tile);
	    return _tile;
	}

	module.exports = {
	    BingMapTypes: BingMapTypes,
	    createLayer: createLayer
	};

/***/ },
/* 29 */
/*!******************************!*\
  !*** ./src/gis/maps/vMap.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);

	var layer = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId;
	    var _url = 'http://gis.huawei.com/gis/cbb/rest/ogcservices/v1r1/gmapwmts/MapServer/tile/{z}/{y}/{x}';
	    var _layer = new ol.layer.Tile({
	        source: new ol.source.XYZ({
	            url:_url + '?key=' + paramObj.key,
	            attributions: [
	                new ol.Attribution({
	                    html: '<a href="http://gis.huawei.com/gis/" target="_blank" title="huawei Map">GisSpace</a>'
	                })
	            ],
	            wrapX: false,
	        	crossOrigin: 'anonymous'
	        })
	    });
	    _layer.set('type', constant.CUSTOMTYPE.LAYERTILETYPE);
	    _layer.set('layerId', _layerId);
	    _layer.set('layer_id', paramObj.layer_id);
	    hashMap.put(_layerId, _layer);
	    return _layer;
	};

	module.exports = {
	    createLayer: layer
	};

/***/ },
/* 30 */
/*!********************************!*\
  !*** ./src/gis/maps/wmsMap.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var layer = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId;
	    var _tile;
		if(paramObj&&paramObj.isMapCutting){
			_tile = new ol.layer.Tile({
				source: new ol.source.XYZ({
					url: paramObj.url,
					params: {
						LAYERS: paramObj.layers,
						MAPNAME: paramObj.mapName,
						VERSION: paramObj.version || '1.1.1',
						mapName: paramObj.mapName
					},
					wrapX: false
				})
			})
		}else if(paramObj && paramObj.title){
	    	_tile = new ol.layer.Tile({
	            source:  new ol.source.TileWMS({
		            url: paramObj.url,
		            params: {
		                VERSION: paramObj.version || '1.1.1',
		                LAYERS: paramObj.layers
		            },
		            wrapX: false
	          })
	       });
	    }else{
		    _tile = new ol.layer.Image({
		        source: new ol.source.ImageWMS({
		            url: paramObj.url,
		            params: {
		                LAYERS: paramObj.layers,
		                MAPNAME: paramObj.mapName,
		                VERSION: paramObj.version || '1.1.1',
						mapName: paramObj.mapName
		            },
		            wrapX: false
		        })
		    });
	    }
	    _tile.set('type', constant.CUSTOMTYPE.LAYERTILETYPE);
	    _tile.set('layerId', _layerId);
	    _tile.set('layer_id', paramObj.layer_id);
	    hashMap.put(_layerId, _tile);
	    return _tile;
	};

	module.exports = {
	    createLayer: layer
	};

/***/ },
/* 31 */
/*!**********************************!*\
  !*** ./src/gis/maps/naverMap.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);

	var layer = function (paramObj) {
	    var _identify = paramObj.layerId + '_' + paramObj.mapId;

	    var _layer = new ol.layer.Tile({
	        title : 'VWorld Gray Map',
	        visible : true,
	        type : 'base',
	        source : new ol.source.XYZ({
	            url : 'http://xdworld.vworld.kr:8080/2d/Base/201512/{z}/{x}/{y}.png',
	            attributions: [
	                new ol.Attribution({
	                    html: ['&copy; <a href="http://map.vworld.kr">V-World Map</a>']
	                })
	            ],
	            wrapX:false
	        })
	    });

	    _layer.set('layer_id', paramObj.layer_id);

	    hashMap.put(_identify, _layer);
	    return _layer;
	};
	module.exports = {
	    createLayer: layer
	};

/***/ },
/* 32 */
/*!***********************************!*\
  !*** ./src/gis/maps/tiandiMap.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);

	var attribution = new ol.Attribution({
	    html: '&copy; <a href="http://www.tianditu.cn/index/contact.html?type=3/">map world</a>'
	});

	var layerRoad = function (paramObj) {
	    var _identify = paramObj.layerId + '_' + paramObj.mapId;
	    var _layerRoad = new ol.layer.Tile({
	        attributions: [attribution],
	        source: new ol.source.XYZ({
	            attributions: [attribution],
	            url: 'http://t3.tianditu.com/DataServer?T=vec_w&x={x}&y={y}&l={z}',
	            wrapX:false
	        })
	    });
	    _layerRoad.set('layer_id', paramObj.layer_id);
	    hashMap.put(_identify, _layerRoad);
	    return _layerRoad;
	};

	var layerMarker = function (paramObj) {
	    var _identify = paramObj.layerId + '_' + paramObj.mapId;
	    var _layerMaker = new ol.layer.Tile({
	        attributions: [attribution],
	        source: new ol.source.XYZ({
	            attributions: [attribution],
	            url: 'http://t3.tianditu.com/DataServer?T=cva_w&x={x}&y={y}&l={z}',
	            wrapX:false
	        })
	    });
	    _layerMaker.set('layer_id', paramObj.layer_id);
	    hashMap.put(_identify, _layerMaker);
	    return _layerMaker;
	};

	var layerSatellite = function (paramObj) {
	    var _identify = paramObj.layerId + '_' + paramObj.mapId;
	    var _layerSatellite = new ol.layer.Tile({
	        attributions: [attribution],
	        source: new ol.source.XYZ({
	            attributions: [attribution],
	            url: 'http://t3.tianditu.com/DataServer?T=img_w&x={x}&y={y}&l={z}',
	            wrapX:false
	        })
	    });
	    _layerSatellite.set('layer_id', paramObj.layer_id);
	    hashMap.put(_identify, _layerSatellite);
	    return _layerSatellite;
	};
	module.exports = {
	    createRoadLayer: layerRoad,
	    createMarkerLayer: layerMarker,
	    createSatelliteLayer: layerSatellite
	};

/***/ },
/* 33 */
/*!*****************************!*\
  !*** ./src/gis/maps/bDu.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);

	var addLayer  = function(paramObj) {
		// 自定义分辨率和瓦片坐标系
		var resolutions = [];
		var maxZoom = 18;
		
		// 计算百度使用的分辨率
		for(var i = 0; i <= maxZoom; i++) {
			resolutions[i] = Math.pow(2, maxZoom - i);
		}
		var tilegrid = new ol.tilegrid.TileGrid({
			origin: [0, 0], // 设置原点坐标
			resolutions: resolutions // 设置分辨率
		});
		
		var bDuSource= new ol.source.TileImage({
			projection: 'EPSG:3857',
			tileGrid: tilegrid,
			tileUrlFunction: function(tileCoord, pixelRatio, proj) {
				var z = tileCoord[0];
				var x = tileCoord[1];
				var y = tileCoord[2];
		
				if(x < 0) {
					x = 'M' + (-x);
				}
				if(y < 0) {
					y = 'M' + (-y);
				}
		
				return [
					"http://online0.map.bdimg.com/onlinelabel/?qt=tile&x=" + x + "&y=" + y + "&z=" + z + "&styles=pl&udt=20170730&scaler=1&p=0",
					"http://online1.map.bdimg.com/onlinelabel/?qt=tile&x=" + x + "&y=" + y + "&z=" + z + "&styles=pl&udt=20170730&scaler=1&p=0",
					"http://online2.map.bdimg.com/onlinelabel/?qt=tile&x=" + x + "&y=" + y + "&z=" + z + "&styles=pl&udt=20170730&scaler=1&p=0",
					"http://online3.map.bdimg.com/onlinelabel/?qt=tile&x=" + x + "&y=" + y + "&z=" + z + "&styles=pl&udt=20170730&scaler=1&p=0"
				]
			},
			wrapX:false
		});
		
		var bduLayer = new ol.layer.Tile({
			source: bDuSource
		});
		var _identify = paramObj.layerId + '_' + paramObj.mapId;
		bduLayer.set('type', constant.CUSTOMTYPE.LAYERTILETYPE);
		bduLayer.set('layerId', _identify);
	    bduLayer.set('layer_id', paramObj.layer_id);
		hashMap.put(_identify, bduLayer);
		return bduLayer;
	};

	module.exports = {
	    createLayer: addLayer
	};

/***/ },
/* 34 */
/*!***************************************!*\
  !*** ./src/gis/maps/xyzGoogleRoad.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);

	var addLayer  = function(paramObj) {
		var googleMapLayer = new ol.layer.Tile({
	        source: new ol.source.XYZ({
	            url:'http://www.google.cn/maps/vt/pb=!1m4!1m3!1i{z}!2i{x}!3i{y}!2m3!1e0!2sm!3i345013117!3m8!2szh-CN!3scn!5e1105!12m4!1e68!2m2!1sset!2sRoadmap!4e0',
	            wrapX: false
	        })
	    });
		var _identify = paramObj.layerId + '_' + paramObj.mapId;
		googleMapLayer.set('type', constant.CUSTOMTYPE.LAYERTILETYPE);
		googleMapLayer.set('layerId', _identify);
	    googleMapLayer.set('layer_id', paramObj.layer_id);
		hashMap.put(_identify, googleMapLayer);
		return googleMapLayer;
	};

	module.exports = {
	    createLayer: addLayer
	};

/***/ },
/* 35 */
/*!*******************************!*\
  !*** ./src/gis/maps/yahoo.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);

	var addLayer  = function(paramObj) {
		var yahooMapLayer = new ol.layer.Tile({
		    source: new ol.source.XYZ({
		        tileSize: 512,
		        url:'https://{0-3}.base.maps.api.here.com/maptile/2.1/maptile/newest/normal.day/{z}/{x}/{y}/512/png8?lg=ENG&ppi=250&token=TrLJuXVK62IQk0vuXFzaig%3D%3D&requestid=yahoo.prod&app_id=eAdkWGYRoc4RfxVo0Z4B',
		        wrapX: false
		    })
		});
		var _identify = paramObj.layerId + '_' + paramObj.mapId;
		yahooMapLayer.set('type', constant.CUSTOMTYPE.LAYERTILETYPE);
		yahooMapLayer.set('layerId', _identify);
	    yahooMapLayer.set('layer_id', paramObj.layer_id);
		hashMap.put(_identify, yahooMapLayer);
		return yahooMapLayer;
	};

	module.exports = {
	    createLayer: addLayer
	};

/***/ },
/* 36 */
/*!*******************************************!*\
  !*** ./src/gis/layers/arcgisTileLayer.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);

	var arcgisTileLayer = function(paramObj) {

		var _layerId = paramObj.layerId + '_' + paramObj.mapId;
		var _mapObj = mapBox.getMapObj(paramObj.mapId);
		var arcgisTileLayer = null;


		if(hashMap.containsKey(_layerId)) {
			arcgisTileLayer = hashMap.get(_layerId);
		} else {
			var _url = 'https://sampleserver1.arcgisonline.com/ArcGIS/rest/services/Specialty/ESRI_StateCityHighway_USA/MapServer';
			if (paramObj.url.indexOf(_url) != -1) {
				arcgisTileLayer = new ol.layer.Tile({
					opacity: 0.7,
					source: new ol.source.TileArcGISRest({
						url: paramObj.url,
						wrapX: false
					})
				});
			}
			else {
				arcgisTileLayer = new ol.layer.Tile({
				opacity: 0.7,
				source: new ol.source.TileArcGISRest({
					url: paramObj.url,
					wrapX: false,
					crossOrigin: 'anonymous'
				})
			});
			}

			arcgisTileLayer.set('type', constant.CUSTOMTYPE.LAYERTILETYPE);
			arcgisTileLayer.set('businessType', constant.CUSTOMTYPE.LAYERTILETYPE);
			arcgisTileLayer.set('layerId', _layerId);
			arcgisTileLayer.set('layer_id', paramObj.mapId);
			

			if(paramObj.minShowLevel != undefined) {
				arcgisTileLayer.set('minShowLevel', parseInt(paramObj.minShowLevel));
			}

			if(paramObj.maxShowLevel != undefined) {
				arcgisTileLayer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));
			}

			hashMap.put(_layerId, arcgisTileLayer);
			_mapObj.addLayer(arcgisTileLayer);
			if(paramObj.zindex !== undefined){
	        	arcgisTileLayer.setZIndex(paramObj.zindex);
	    	}
		}


		return arcgisTileLayer;

	};

	module.exports = {
		createArcgisTileLayer: arcgisTileLayer
	};

/***/ },
/* 37 */
/*!*********************************!*\
  !*** ./src/gis/maps/overMap.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var dragForOverViewMap = __webpack_require__(/*! maps/dragForOverView */ 38);

	var constant = __webpack_require__(/*! framework/constant */ 2);
	var util = __webpack_require__(/*! utils/util */ 1);

	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var googleMap = __webpack_require__(/*! maps/googleMap */ 24);
	var gaodeMap = __webpack_require__(/*! maps/gaode */ 26);
	var osmMap = __webpack_require__(/*! maps/osmMap */ 27);
	var bingMap = __webpack_require__(/*! maps/bingMap */ 28);
	var vMap = __webpack_require__(/*! maps/vMap */ 29);
	var wmsMap = __webpack_require__(/*! maps/wmsMap */ 30);
	var tiandiMap = __webpack_require__(/*! maps/tiandiMap */ 32);
	var arcgisTileLayer = __webpack_require__(/*! layers/arcgisTileLayer */ 36);

	function addBox(vectorLayer, mainMap) {
		var mainMapExtent = mainMap.getView().calculateExtent(mainMap.getSize());

		var coor = [
			[
				[mainMapExtent[0], mainMapExtent[1]],
				[mainMapExtent[2], mainMapExtent[1]],
				[mainMapExtent[2], mainMapExtent[3]],
				[mainMapExtent[0], mainMapExtent[3]],
				[mainMapExtent[0], mainMapExtent[1]]
			]
		];

		vectorLayer.getSource().clear();
		var polygonFeature = new ol.Feature(new ol.geom.Polygon(coor));
		vectorLayer.getSource().addFeature(polygonFeature);
	}

	function removeCtrAndInterAction(overViewMap) {
		var _controls = overViewMap.getControls().getArray();
		var interactions = overViewMap.getInteractions().getArray();

		for (var i = _controls.length; i >= 0; i--) {
			overViewMap.removeControl(_controls[i]);
		}

		for (var j = interactions.length - 2; j >= 0; j--) {
			interactions[j].setActive(false);
			overViewMap.removeInteraction(interactions[j]);
		}
	}

	function setMapType(_mapObj, paramObj) {
		var _paramobj = util.extend({}, paramObj);
		var _target = _paramobj.mapId + '_overview';
		var _mapType = _paramobj.mapType;
		var _url = _paramobj.url;
		var _mapKey = _paramobj.key;
		var _mapName = _paramobj.mapName;
		var _layers = _paramobj.layers;
		var _version = _paramobj.version;
		var _language = _paramobj.language;
		var layer_id = _layerId = constant.MAPPROPERTY.BASE_LAYER_ID;
		_paramobj.mapId = _target;
		_paramobj.map = _mapObj;

		switch (_mapType) {
			case constant.MAPTYPE.OSM_MAP:
				_mapObj.getLayers().insertAt(0, osmMap.createLayer({
					mapId: _target,
					layerId: _layerId,
					layer_id: layer_id
				}));
				break;
			case constant.MAPTYPE.HUAWEI_MAP:
				_mapObj.getLayers().insertAt(0, vMap.createLayer({
					mapId: _target,
					url: _url,
					key: _mapKey,
					layerId: _layerId,
					layer_id: layer_id
				}));
				break;
			case constant.MAPTYPE.WMS_MAP:
				_mapObj.getLayers().insertAt(0, wmsMap.createLayer({
					mapId: _target,
					url: _url,
					layers: _layers,
					version: _version,
					layerId: _layerId,
					layer_id: layer_id,
					mapName: _mapName,
					title: _paramobj.title || ''
				}));
				break;
			case constant.MAPTYPE.BING_MAP:
				_mapObj.getLayers().insertAt(0, bingMap.createLayer({
					mapId: _target,
					key: _mapKey,
					layerId: _layerId,
					layer_id: layer_id,
					layers: _layers
				}));
				break;
			case constant.MAPTYPE.GOOGLE_MAP:
				if (!!_mapKey) {
					googleMap.loadGoogleAPI(_mapKey, _language, function (isTrue) {
						if (isTrue) {
							if (window.sessionStorage) {
								sessionStorage.setItem("key", _mapKey);
							}
							googleMap.createCustomMap(_paramobj);
						}
					});
				}
				else {
					console.error('load google api failed...');
				}
				break;
			case constant.MAPTYPE.TIANDI_MAP:
				var tdMarkerLayer = fusiongis.BaseLayer.getLayer({
					mapId: _target,
					layerId: layer_id + '_marker'
				});
				if (!!tdMarkerLayer && tdMarkerLayer instanceof ol.layer.Tile) {
					_mapObj.removeLayer(tdMarkerLayer);
				}

				_mapObj.getLayers().insertAt(0, tiandiMap.createRoadLayer({
					mapId: _target,
					layerId: layer_id,
					layer_id: layer_id
				}));
				_mapObj.getLayers().insertAt(1, tiandiMap.createMarkerLayer({
					mapId: _target,
					layerId: layer_id + '_marker',
					layer_id: layer_id + '_marker'
				}));
				break;
			case constant.MAPTYPE.BAIDU_MAP:
				_mapObj.getLayers().insertAt(0, bDuMap.createLayer({
					mapId: _target,
					layerId: _layerId,
					layer_id: layer_id
				}));
				break;
			case constant.MAPTYPE.GAODE_MAP:
				if (!!_mapKey) {
					gaodeMap.loadGaodeAPI(_mapKey, _language, function (isTrue) {
						if (isTrue) {
							if (window.sessionStorage) {
								sessionStorage.setItem("key", _mapKey);
							}
							gaodeMap.createCustomMap(_paramobj);
						}
					});
				}
				else {
					console.error('load gaode api failed...');
				}
				break;
			case constant.MAPTYPE.ARCGISTILE_LAYER:
				_mapObj.getLayers().insertAt(0, arcgisTileLayer.createArcgisTileLayer({
					mapId: _target,
					layerId: _layerId,
					layer_id: layer_id,
					url: _url
				}));
				break;
			default:
				_mapObj.getLayers().insertAt(0, osmMap.createLayer({
					mapId: _target,
					layerId: _layerId,
					layer_id: layer_id
				}));
		}
	}

	function addMinMap(initmapParam) {
		var mainMap = mapBox.getMapObj(initmapParam.mapId);
		var arrowSpanId = initmapParam.mapId + '_overviewSpan';
		var minMapId = initmapParam.mapId + '_overview';
		if (!mainMap) {
			return;
		}

		var arrowSpan = document.querySelector('#' + arrowSpanId);
		var minMapDiv = document.querySelector('#' + minMapId);
		if (arrowSpan != undefined) {
			mainMap.getTargetElement().removeChild(arrowSpan);
		}

		if (minMapDiv != undefined) {
			mainMap.getTargetElement().removeChild(minMapDiv);
		}
		
		var _arrowLeftOrRight = '2px';
		var _arrowBottom = '2px'
		var _boxLeftOrRight = '10px';
		var _boxBottom = '10px';
		var _direction = 'left';
		var _op = 'opacity: 0';
		var _filter = 'filter:alpha(opacity=0)';
		if (initmapParam.overViewObj != undefined) {
			if (initmapParam.overViewObj.right != undefined) {
				if (initmapParam.overViewObj.right.arrowRight != undefined) {
					_arrowLeftOrRight = initmapParam.overViewObj.right.arrowRight +'px';
				}
				if (initmapParam.overViewObj.right.arrowBottom) {
					_arrowBottom = initmapParam.overViewObj.right.arrowBottom +'px';
				}
				if (initmapParam.overViewObj.right.boxBottom) {
					_boxBottom = initmapParam.overViewObj.right.boxBottom +'px';
				}
				if (initmapParam.overViewObj.right.boxRight) {
					_boxLeftOrRight = initmapParam.overViewObj.right.boxRight +'px';
				}
				_direction = 'right';
			}
			else if (initmapParam.overViewObj.left != undefined) {
				if (initmapParam.overViewObj.left.arrowRight != undefined) {
					_arrowLeftOrRight = initmapParam.overViewObj.left.arrowLeft +'px';
				}
				if (initmapParam.overViewObj.left.arrowBottom) {
					_arrowBottom = initmapParam.overViewObj.left.arrowBottom + 'px';
				}
				if (initmapParam.overViewObj.left.boxBottom) {
					_boxBottom = initmapParam.overViewObj.left.boxBottom + 'px';
				}
				if (initmapParam.overViewObj.left.boxRight) {
					_boxLeftOrRight = initmapParam.overViewObj.left.boxLeft + 'px';
				}
				_direction = 'left';
			}
		}
		

		var span = document.createElement('span');
		span.setAttribute('style', 'width: 15px;height:15px;position: absolute;z-index: 2;border: 1px solid gray;'+_direction+':'+_arrowLeftOrRight+';bottom:'+_arrowBottom+';' +
			'color: rgb(255,255,255);cursor: pointer;font-size: 18.4px;background-color: rgba(0,60,136,.5);font-weight: 700;line-height: 15px;' +
			'border-radius:2px;-webkit-border-radius:2px; -moz-border-radius: 2px');
		span.setAttribute('id', arrowSpanId);
		span.innerHTML = '\u00BB';
		mainMap.getTargetElement().appendChild(span);

		var overview = document.createElement('div');
		overview.setAttribute('style', 'z-index: -1;width: 150px;background-color: white;height:150px;position: absolute;border: 1px solid gray;'+_direction+':' + _boxLeftOrRight + ';bottom:'+_boxBottom + ';' + _op + ';' + _filter);
		overview.setAttribute('id', minMapId);
		mainMap.getTargetElement().appendChild(overview);
		var isShow = false;
		span.onclick = function () {
			overview.style.opacity = 1;
			overview.style.filter="alpha(opacity=100)";
			overview.style.removeProperty('z-index');
			
			if (isShow) {
				this.innerHTML = '\u00BB';
				overview.style.display = 'none';
				isShow = false;
			} else {
				this.innerHTML = '\u00AB';
				overview.style.display = 'block';
				isShow = true;
			}
		}

		var overViewMap = new ol.Map({
			target: overview,
			view: new ol.View({
				center: mainMap.getView().getCenter()
			})
		});
		setMapType(overViewMap, initmapParam);
		overViewMap.addInteraction(dragForOverViewMap.addDrag(mainMap));

		removeCtrAndInterAction(overViewMap);

		overViewMap.on('pointermove', function (evt) {
			overViewMap.getTargetElement().style.cursor = 'pointer';
		});


		var vectorLayer = new ol.layer.Vector({
			source: new ol.source.Vector({ wrapX: false }),
			style: new ol.style.Style({
				fill: new ol.style.Fill({
					color: 'rgba(160,160,160,0.2)'
				}),
				stroke: new ol.style.Stroke({
					color: 'gray',
					width: 2
				})
			})
		});
		overViewMap.addLayer(vectorLayer);
		addBox(vectorLayer, mainMap);

		if (initmapParam.mapType = constant.MAPTYPE.GOOGLE_MAP) {
			delayLink(overViewMap, mainMap);
		}

		mainMap.on('moveend', function () {
			delayLink(overViewMap, mainMap);

			addBox(vectorLayer, mainMap);
		})

		function delayLink() {
			setTimeout(function () {
				var view = overViewMap.getView();
				var pan = ol.animation.pan({
					duration: 250,
					source: (view.getCenter())
				});
				overViewMap.beforeRender(pan);
				view.setCenter(util.gcjTransform3857(mainMap.getView().getCenter()));
				view.setZoom((function () {
					var zoom = mainMap.getView().getZoom();
					var extendZoom = {};
					extendZoom[0] = 0;
					extendZoom[1] = 0;
					extendZoom[2] = 0;
					extendZoom[3] = 0;
					extendZoom[4] = 0;
					extendZoom[5] = 1;
					extendZoom[6] = 1;
					extendZoom[7] = 2;
					extendZoom[8] = 3;
					extendZoom[9] = 4;
					extendZoom[10] = 5;
					extendZoom[11] = 6;
					extendZoom[12] = 7;
					extendZoom[13] = 8;
					extendZoom[14] = 9;
					extendZoom[15] = 10;
					extendZoom[16] = 11;
					extendZoom[17] = 12;
					return extendZoom[zoom];
				}()));
			}, 300);
		}
	}

	module.exports = {
		addMinMap: addMinMap
	};

/***/ },
/* 38 */
/*!*****************************************!*\
  !*** ./src/gis/maps/dragForOverView.js ***!
  \*****************************************/
/***/ function(module, exports) {

	var app = {};


	/** 
	 * @constructor 
	 * @extends {ol.interaction.Pointer} 
	 */
	app.Drag = function (map) {

	    ol.interaction.Pointer.call(this, {
	        handleDownEvent: app.Drag.prototype.handleDownEvent,
	        handleDragEvent: app.Drag.prototype.handleDragEvent,
	        handleMoveEvent: app.Drag.prototype.handleMoveEvent,
	        handleUpEvent: app.Drag.prototype.handleUpEvent
	    });

	    this.mainMap = map;
	    this.id = 'custom';

	    /** 
	     * @type {ol.Pixel} 
	     * @private 
	     */
	    this.coordinate_ = null;

	    /** 
	     * @type {string|undefined} 
	     * @private 
	     */
	    this.cursor_ = 'pointer';

	    /** 
	     * @type {ol.Feature} 
	     * @private 
	     */
	    this.feature_ = null;

	    /** 
	     * @type {string|undefined} 
	     * @private 
	     */
	    this.previousCursor_ = undefined;

	};
	ol.inherits(app.Drag, ol.interaction.Pointer);


	/** 
	 * @param {ol.MapBrowserEvent} evt Map browser event. 
	 * @return {boolean} `true` to start the drag sequence. 
	 */
	app.Drag.prototype.handleDownEvent = function (evt) {
	    var map = evt.map;

	    var feature = map.forEachFeatureAtPixel(evt.pixel, function (feature) {
	        return feature;
	    });

	    if (feature) {
	        this.coordinate_ = evt.coordinate;
	        this.feature_ = feature;
	    }

	    return !!feature;
	};


	/** 
	 * @param {ol.MapBrowserEvent} evt Map browser event. 
	 */
	app.Drag.prototype.handleDragEvent = function (evt) {
	    var deltaX = evt.coordinate[0] - this.coordinate_[0];
	    var deltaY = evt.coordinate[1] - this.coordinate_[1];

	    var geometry = this.feature_.getGeometry();
	    geometry.translate(deltaX, deltaY);

	    this.coordinate_[0] = evt.coordinate[0];
	    this.coordinate_[1] = evt.coordinate[1];
	};


	/** 
	 * @param {ol.MapBrowserEvent} evt Event. 
	 */
	app.Drag.prototype.handleMoveEvent = function (evt) {
	    if (this.cursor_) {
	        var map = evt.map;
	        var feature = map.forEachFeatureAtPixel(evt.pixel, function (feature) {
	            return feature;
	        });
	        var element = evt.map.getTargetElement();
	        if (feature) {
	            if (element.style.cursor != this.cursor_) {
	                this.previousCursor_ = element.style.cursor;
	                element.style.cursor = this.cursor_;
	            }
	        } else if (this.previousCursor_ !== undefined) {
	            element.style.cursor = this.previousCursor_;
	            this.previousCursor_ = undefined;
	        }
	    }
	};


	/** 
	 * @return {boolean} `false` to stop the drag sequence. 
	 */
	app.Drag.prototype.handleUpEvent = function (evt) {
	    var map = evt.map;
	    var polygonCoordinates = new ol.geom.Polygon(this.feature_.getGeometry().getCoordinates());
	    var polygonCenter = polygonCoordinates.getInteriorPoint().getCoordinates();//线的形成面的中间点
	    map.getView().setCenter(polygonCenter);
	    this.mainMap.getView().setCenter(polygonCenter);
	    this.coordinate_ = null;
	    this.feature_ = null;
	    return false;
	}; 

	module.exports = {
		addDrag: function(map) {
			return new app.Drag(map);
		}
	}


/***/ },
/* 39 */
/*!*****************************************!*\
  !*** ./src/gis/layers/bLayerManager.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var i18n = __webpack_require__(/*! utils/i18n */ 13);
	var bLayer = __webpack_require__(/*! businessLayers/bLayer */ 40);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var eventTool = __webpack_require__(/*! utils/eventTool */ 62);
	var map = new Map();
	map.set('refreshLayerManager_key', []);
	map.set('isToggleLayerManager',false);
	function monitorLayers(params) {
	    var olMap = mapBox.getMapObj(params.mapId);

	    if (!!!olMap.getTargetElement().querySelector('.vGisWeb_component')) {
	        (function (_mapObj) {
	            var componentContainer = document.createElement('div');
	            componentContainer.className = 'vGisWeb_component';
	            _mapObj.getTargetElement().appendChild(componentContainer);
	            _mapObj.set('component.container', componentContainer);
	        }(olMap));
	    }
	    var length_handler = olMap.get('layerManager.layersChange');
	    if (length_handler) {
	        olMap.unByKey(length_handler);
	    }

	    length_handler = olMap.getLayers().on('change:length', function (evt) {
	        syncLayers(params.mapId);
	        if(!map.get('isToggleLayerManager')){
	            fusiongis.Map.layerVisibleInit(params.mapId);
	        }
	    });
	    olMap.set('layerManager.layersChange', length_handler);
	    var layerManager = new LayerManager(params.mapId);
	}

	function syncLayers(mapId) {
	    var olMap = mapBox.getMapObj(mapId);
	    if (olMap == undefined) {
	        return;
	    }
	    var layerList = olMap.getLayers().getArray();
	    layerList.forEach(function (layer) {
	        if (layer.get('layer_id') != undefined && layer.get('layer_id') != null && layer.get('layer_id') != '' && layer.get('layer_id') != 'base_layer') {
	            layerList = utils.sortBy(layerList, function (layer) {
			        return layer.getZIndex();
			    });
	        }
	    });
	    

	    if (isLayersChange(olMap, layerList) === false) {
	        return;
	    }

	    var args = [];
	    args.mapId = mapId;
	    args.changeType = 'list';

	    layerList.forEach(function (layer) {
	        if (layer.get('layer_id') != undefined && layer.get('layer_id') != null && layer.get('layer_id') != '' ) {
	            layerIterator(mapId, layer, args);
	        }
	    });

	    onLayersLengthChange(args);
	}

	function layerIterator(mapId, olLayer, args) {
	    var layerType = '';
	    var anotherName = '';//别名
	    var layerId = olLayer.get('layer_id');
	    if (layerId === constant.MAPPROPERTY.BASE_LAYER_ID) {
	        layerType = 'BASELAYER';
	        anotherName = i18n.prop('LayerLabel.BASELAYER');
	    }
	    else if (layerId === ' base_layer_marker') {
	        layerType = 'BASELAYER';
	        anotherName = i18n.prop('LayerLabel.BASELAYER_MARKER');
	    }
	    else {
	        layerType = olLayer.get('businessType');
	        //如果创建图层时，没有设置paras.label属性，直接将图层ID显示在图层管理器上作为别名
	        anotherName = !!!olLayer.get('params.label') ? layerId : olLayer.get('params.label');
	    }
	    if (layerId === 'auto_increase_reduce' || layerId.indexOf('&&&highlight') !== -1) {
	        return;
	    }
	    args.push({
	        mapId: mapId,
	        layerName: anotherName,//图层管理器上显示的图层别名
	        layerId: layerId,
	        layerType: layerType,
	        visible: olLayer.getVisible(),
	        opacity: olLayer.getOpacity(),
	        zIndex: olLayer.getZIndex(),
	        showLabel: !!olLayer.get('state.showLabel')
	    });

	    handleVisibleChange(mapId, olLayer, layerType);
	    handleOpacityChange(mapId, olLayer, layerType);
	    handleNameChange(mapId, olLayer, layerType);
	}

	function handleVisibleChange(mapId, olLayer, layerType) {
	    var vKey = olLayer.get('layerManager.visibleChange');
	    if (vKey) {
	        return;
	    }
	    vKey = olLayer.on('change:visible', function (evt) {
	        var changeParam = {
	            mapId: mapId,
	            layerName: olLayer.get('params.label'),
	            layerId: olLayer.get('layer_id'),
	            layerType: layerType,
	            changeType: 'visible',
	            visible: olLayer.getVisible(),
	            opacity: olLayer.getOpacity(),
	            zIndex: olLayer.getZIndex(),
	            showLabel: !!olLayer.get('state.showLabel')
	        };

	        var olMap = mapBox.getMapObj(mapId);
	        var layerManager = olMap.get('layerManager.manager');
	        layerManager.displayOpacity(changeParam);
	    });
	    olLayer.set('layerManager.visibleChange', vKey);
	}

	function handleOpacityChange(mapId, olLayer, layerType) {
	    var oKey = olLayer.get('layerManager.opacityChange');
	    if (oKey) {
	        return;
	    }

	    oKey = olLayer.on('change:opacity', function () {
	        var changeParam = {
	            mapId: mapId,
	            layerName: olLayer.get('params.label'),
	            layerId: olLayer.get('layer_id'),
	            layerType: layerType,
	            changeType: 'opacity',
	            visible: olLayer.getVisible(),
	            opacity: olLayer.getOpacity(),
	            zIndex: olLayer.getZIndex(),
	            showLabel: !!olLayer.get('state.showLabel')
	        };

	        var olMap = mapBox.getMapObj(mapId);
	        var layerManager = olMap.get('layerManager.manager');
	        layerManager.displayVisibility(changeParam);
	    });

	    olLayer.set('layerManager.opacityChange', oKey);
	}

	function handleNameChange(mapId, olLayer, layerType) {
	    var oKey = olLayer.get('layerManager.nameChange');
	    if (oKey) {
	        return;
	    }

	    oKey = olLayer.on('change:params.label', function () {
	        var changeParam = {
	            mapId: mapId,
	            layerName: olLayer.get('params.label'),
	            layerId: olLayer.get('layer_id'),
	            layerType: layerType,
	            changeType: 'layerName',
	            visible: olLayer.getVisible(),
	            opacity: olLayer.getOpacity(),
	            zIndex: olLayer.getZIndex(),
	            showLabel: !!olLayer.get('state.showLabel')
	        };

	        var olMap = mapBox.getMapObj(mapId);
	        var layerManager = olMap.get('layerManager.manager');
	        layerManager.displayLayerName(changeParam);
	    });

	    olLayer.set('layerManager.nameChange', oKey);
	}

	function isLayersChange(olMap, layerList) {
	    var bLayers = olMap.get('layerManager.bLayers');
	    if (bLayers) {
	        var layerGroups = utils.sortGroupBy(layerList, function (layer) {
	            return layer.getZIndex();
	        });
	        var bGroups = utils.sortGroupBy(bLayers, function (layer) {
	            return layer.getZIndex();
	        });

	        if (layerGroups.length === bGroups.length) {
	            var sameFlag = true;
	            for (var i = 0, li = layerGroups.length; i < li; i++) {
	                var group = layerGroups[i];
	                if (group.length !== bGroups[i].length) {
	                    sameFlag = false;
	                    break;
	                }
	                for (var j = 0, lj = group.length; j < lj; j++) {
	                    if (bGroups[i].indexOf(group[i][j]) === -1) {
	                        sameFlag = false;
	                        break;
	                    }
	                }
	                if (sameFlag === false) {
	                    break;
	                }
	            }
	            if (sameFlag === true) {
	                return false;
	            }
	        }

	    }
	    olMap.set('layerManager.bLayers', layerList);
	    return true;
	}

	function onLayersLengthChange(changeParam) {
	    var mapId = changeParam.mapId;
	    var olMap = mapBox.getMapObj(mapId);
	    var layerManager = olMap.get('layerManager.manager');
	    layerManager.appendLayers(changeParam);
	}


	function LayerManager(mapId) {
	    this.mapId = mapId;
	    this.isShow = false;
	    var olMap = mapBox.getMapObj(this.mapId);
	    var o = olMap.get('layerManager.manager');
	    if (o) {
	        o.destroy();
	        olMap.unset('layerManager.manager');
	    }
	    this.createElement();
	    this.addEventHandle();
	    olMap.set('layerManager.manager', this);
	}

	LayerManager.prototype.createElement = function () {

	    this.element = document.createElement('div');
	    this.element.className = 'bLayerManager';
	    this.element.style.display = 'none';

	    this.headerElement = document.createElement('div');
	    this.headerElement.className = 'header';

	    this.titleElement = document.createElement('div');
	    this.titleElement.className = 'title';
	    this.titleElement.innerHTML = i18n.prop('layerManager.title');

	    this.closeElement = document.createElement('div');
	    this.closeElement.className = 'closeIcon';
	    this.closeElement.innerHTML = '✖';

	    this.headerElement.appendChild(this.titleElement);
	    this.headerElement.appendChild(this.closeElement);

	    this.contentElement = document.createElement('div');
	    this.contentElement.className = 'content';

	    this.element.appendChild(this.headerElement);
	    this.element.appendChild(this.contentElement);

	    var olMap = mapBox.getMapObj(this.mapId);
	    if (!!olMap.get('component.container')) {
	        olMap.get('component.container').appendChild(this.element);
	    }
	};

	LayerManager.prototype.appendLayers = function (params) {
	    var self = this;
	    params = this.reSortLayers(params);
	    var content = this.contentElement;
	    for (var i = content.childNodes.length - 1; i >= 0; i--) {
	        content.removeChild(content.childNodes[i]);
	    }

	    params.forEach(function (layerParam, index) {
	        if (layerParam.layerId) {
	            self.appendLayer(params, layerParam, index);
	        }
	        else {
	            self.appendLayerGroup(params, layerParam, index);
	        }
	    });
	};

	LayerManager.prototype.appendLayer = function (params, layerParam, index) {
	    var itemElement = document.createElement('div');
	    itemElement.className = 'layerItem';
	    itemElement.mapId = layerParam.mapId;
	    itemElement.layerType = layerParam.layerType;
	    itemElement.layerId = layerParam.layerId;

	    //控制图层隐藏显示
	    var visibleCheck = document.createElement('input');
	    visibleCheck.className = 'visible_check';
	    visibleCheck.mapId = layerParam.mapId;
	    visibleCheck.layerType = layerParam.layerType;
	    visibleCheck.layerId = layerParam.layerId;
	    visibleCheck.setAttribute('type', 'checkbox');
	    visibleCheck.setAttribute('layer_type', layerParam.layerType);
	    visibleCheck.setAttribute('layer_id', layerParam.layerId);
	    visibleCheck.checked = layerParam.visible;

	    eventTool.add(visibleCheck, 'click', function (e) {
	        var _layerObj = layers.getLayer({ mapId: layerParam.mapId, layerId: layerParam.layerId });
	        _layerObj != undefined && _layerObj.set('layerManagerCheckBoxClick', e.target.checked);
	    });

	    ///图层管理器上显示的图表
	    var iconElement = document.createElement('div');
	    if (layerParam.visible) {
	        iconElement.className = layerParam.layerType + '_ICON layerIcon';
	    }
	    else {
	        iconElement.className = layerParam.layerType + '_GRAYICON layerIcon';
	    }

	    //图层管理器上显示的文字信息
	    var layerNameSpan = document.createElement('div');
	    layerNameSpan.className = 'layerName';
	    layerNameSpan.mapId = layerParam.mapId;
	    layerNameSpan.layerType = layerParam.layerType;
	    layerNameSpan.layerId = layerParam.layerId;
	    layerNameSpan.innerHTML = layerParam.layerName;
	    layerNameSpan.setAttribute('title', layerParam.layerName);

	    //透明度
	    var range = document.createElement('input');
	    range.className = 'range';
	    range.mapId = layerParam.mapId;
	    range.layerType = layerParam.layerType;
	    range.layerId = layerParam.layerId;
	    range.opacity = layerParam.opacity;
	    range.setAttribute("type", "range");
	    range.setAttribute("max", '100');
	    range.setAttribute("min", '0');
	    range.value = layerParam.opacity * 100;

	    //标签
	    var labelBlock = document.createElement('div');
	    labelBlock.className = 'label_block';
	    var labelCheck = document.createElement('input');
	    labelCheck.className = 'label_check';
	    labelCheck.mapId = layerParam.mapId;
	    labelCheck.layerType = layerParam.layerType;
	    labelCheck.layerId = layerParam.layerId;
	    labelCheck.setAttribute('type', 'checkbox');
	    labelCheck.checked = layerParam.showLabel;
	    var Aa = document.createElement('label');
	    if (layerParam.showLabel) {
	        Aa.className = 'active_label';
	    }
	    else {
	        Aa.className = 'inactive_label';
	    }
	    Aa.innerHTML = 'Aa';
	    labelBlock.appendChild(labelCheck);
	    labelBlock.appendChild(Aa);

	    var upArrow = document.createElement('div');
	    if (index !== 0) {
	        upArrow.className = 'active_up_arrow';
	    }
	    else {
	        upArrow.className = 'inactive_up_arrow';
	    }

	    upArrow.mapId = layerParam.mapId;
	    upArrow.layerType = layerParam.layerType;
	    upArrow.layerId = layerParam.layerId;
	    upArrow.mIndex = index;
	    upArrow.zIndex = layerParam.zIndex;

	    var downArrow = document.createElement('div');
	    if (index !== params.length - 1) {
	        downArrow.className = 'active_down_arrow';
	    }
	    else {
	        downArrow.className = 'inactive_down_arrow';
	    }

	    downArrow.mapId = layerParam.mapId;
	    downArrow.layerType = layerParam.layerType;
	    downArrow.layerId = layerParam.layerId;
	    downArrow.mIndex = index;
	    downArrow.zIndex = layerParam.zIndex;

	    itemElement.appendChild(visibleCheck);
	    itemElement.appendChild(iconElement);
	    itemElement.appendChild(layerNameSpan);
	    itemElement.appendChild(range);
	    itemElement.appendChild(labelBlock);
	    itemElement.appendChild(upArrow);
	    itemElement.appendChild(downArrow);

	    this.contentElement.appendChild(itemElement);

	    //增加图例名称节点
	    var _layerObj = layers.getLayer({ mapId: layerParam.mapId, layerId: layerParam.layerId });
	    if (!!_layerObj && !!_layerObj.get('mineLegendName')) {
	        var legendNameNode = document.createElement('div');
	        legendNameNode.setAttribute('class', 'legend_name');
	        legendNameNode.innerHTML = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --' + _layerObj.get('mineLegendName');
	        legendNameNode.setAttribute('title', utils.htmlDecode(_layerObj.get('mineLegendName')));
	        this.contentElement.appendChild(legendNameNode);
	    }
	};

	LayerManager.prototype.appendLayerGroup = function (params, layerParam, index) {
	    var itemElement = document.createElement('div');
	    itemElement.className = 'layerItem';
	    itemElement.mapId = layerParam.mapId;
	    itemElement.groupType = layerParam.groupType;

	    var visibleCheck = document.createElement('input');
	    visibleCheck.className = 'visible_check';
	    visibleCheck.mapId = layerParam.mapId;
	    visibleCheck.groupType = layerParam.groupType;
	    visibleCheck.setAttribute('type', 'checkbox');
	    visibleCheck.checked = layerParam.visible;

	    var iconElement = document.createElement('div');
	    if (layerParam.visible) {
	        iconElement.className = layerParam.groupType + '_ICON layerIcon';
	    }
	    else {
	        iconElement.className = layerParam.groupType + '_GRAYICON layerIcon';
	    }

	    var layerNameSpan = document.createElement('span');
	    layerNameSpan.className = 'layerName';
	    layerNameSpan.innerHTML = layerParam.groupName;

	    var range = document.createElement('input');
	    range.className = 'range';
	    range.mapId = layerParam.mapId;
	    range.groupType = layerParam.groupType;
	    range.opacity = layerParam.opacity;
	    range.setAttribute("type", "range");
	    range.setAttribute("max", '100');
	    range.setAttribute("min", '0');
	    range.value = layerParam.opacity * 100;

	    var labelBlock = document.createElement('div');
	    labelBlock.className = 'label_block';
	    var labelCheck = document.createElement('input');
	    labelCheck.setAttribute('type', 'checkbox');
	    labelCheck.className = 'label_check';
	    labelCheck.mapId = layerParam.mapId;
	    labelCheck.groupType = layerParam.groupType;
	    labelCheck.checked = layerParam.showLabel;

	    var Aa = document.createElement('label');
	    if (layerParam.showLabel) {
	        Aa.className = 'active_label';
	    }
	    else {
	        Aa.className = 'inactive_label';
	    }
	    Aa.innerHTML = 'Aa';
	    labelBlock.appendChild(labelCheck);
	    labelBlock.appendChild(Aa);

	    var upArrow = document.createElement('div');
	    if (index !== 0) {
	        upArrow.className = 'active_up_arrow';
	    }
	    else {
	        upArrow.className = 'inactive_up_arrow';
	    }

	    upArrow.mapId = layerParam.mapId;
	    upArrow.groupType = layerParam.groupType;
	    upArrow.mIndex = index;
	    upArrow.zIndex = layerParam.zIndex;

	    var downArrow = document.createElement('div');
	    if (index !== params.length - 1) {
	        downArrow.className = 'active_down_arrow';
	    }
	    else {
	        downArrow.className = 'inactive_down_arrow';
	    }

	    downArrow.mapId = layerParam.mapId;
	    downArrow.groupType = layerParam.groupType;
	    downArrow.mIndex = index;
	    downArrow.zIndex = layerParam.zIndex;

	    itemElement.appendChild(visibleCheck);
	    itemElement.appendChild(iconElement);
	    itemElement.appendChild(layerNameSpan);
	    itemElement.appendChild(range);
	    itemElement.appendChild(labelBlock);
	    itemElement.appendChild(upArrow);
	    itemElement.appendChild(downArrow);
	    this.contentElement.appendChild(itemElement);
	};

	LayerManager.prototype.reSortLayers = function (layers) {
	    layers = this.transformLayerGroup(layers);
	    var layerGroups = utils.sortGroupBy(layers, function (layer) {
	        return -layer.zIndex;
	    });

	//  for (var i = 0, l = layerGroups.length; i < l; i++) {
	//      if (layerGroups[i].length > 1) {
	//          var group = layerGroups[i];
	//          var zIndex = group[0].zIndex;
	//          for (var j = 0; j < group.length; j++) {
	//              var changeIndex = zIndex + group.length - 1 - j;
	//              bLayer.setZIndex({
	//                  mapId: this.mapId,
	//                  layerId: group[j].layerId,
	//                  zIndex: changeIndex
	//              });
	//              group[j].zIndex = changeIndex;
	//          }
	//      }
	//  }
	    layers = utils.flatten(layerGroups);
	    var curIndex;
	    for (var m = layers.length - 1; m > -1; m--) {
	        if (m === layers.length - 1) {
	            curIndex = layers[m].zIndex;
	            continue;
	        }
	        if (layers[m].zIndex <= curIndex) {
	            layers[m].zIndex = curIndex + 1;
	        }
	        curIndex = layers[m].zIndex;
	    }
	    return layers;
	};

	LayerManager.prototype.transformLayerGroup = function (layers) {
	    var olMap = mapBox.getMapObj(this.mapId);
	    var config = constant.layerGroup;
	    for (var groupType in config) {
	        if (!config.hasOwnProperty(groupType)) {
	            return;
	        }
	        var layerGroup = {
	            mapId: this.mapId,
	            groupType: groupType,
	            groupName: i18n.prop('LayerLabel.' + groupType),
	            noAttrs: true
	        };

	        var groupLayerTypes = constant.layerGroup[groupType];
	        var tempLayers = [];
	        for (var i = layers.length - 1; i > -1; i--) {
	            var layer = layers[i];
	            if (layer.groupType) {
	                continue;
	            }
	            var layerTye = layer.layerType;
	            for (var j = 0; j < groupLayerTypes.length; j++) {
	                if (!tempLayers[j]) {
	                    tempLayers[j] = [];
	                }
	                if (groupLayerTypes[j] === layerTye) {
	                    if (layerGroup.noAttrs) {
	                        layerGroup.visible = layer.visible;
	                        layerGroup.opacity = layer.opacity;
	                        layerGroup.zIndex = Math.floor(layer.zIndex);
	                        layerGroup.showLabel = layer.showLabel;
	                        olMap.set('layerGroup.ZIndex.' + groupType, layerGroup.zIndex);
	                        delete layerGroup.noAttrs;
	                    }
	                    var cutLayer = layers.splice(i, 1)[0];
	                    tempLayers[j].push(cutLayer);
	                }

	            }
	        }
	        layerGroup.layers = utils.flatten(tempLayers.reverse());
	        if (layerGroup.layers.length > 0) {
	            layers.push(layerGroup);
	        }

	    }
	    return layers;
	};

	LayerManager.prototype.displayOpacity = function (params) {
	    var ranges = document.querySelectorAll('#' + params.mapId + ' .layerItem .range');
	    var range = utils.find(ranges, function (range) {
	        return range.layerId === params.layerId;
	    });
	    if (range && range.opacity !== params.opacity) {
	        range.opacity = params.opacity;
	        range.value = params.opacity * 100;
	    }
	};

	LayerManager.prototype.displayVisibility = function (params) {
	    var cbs = document.querySelectorAll('#' + params.mapId + ' .layerItem .visible_check');
	    var cb = utils.find(cbs, function (cb) {
	        return cb.layerId === params.layerId;
	    });
	    if (cb && cb.checked !== params.visible) {
	        cb.checked = params.visible;
	    }
	};

	LayerManager.prototype.displayLayerName = function (params) {
	    var layerNames = document.querySelectorAll('#' + params.mapId + ' .layerItem .layerName');
	    var nameSpan = utils.find(layerNames, function (span) {
	        return span.layerId === params.layerId;
	    });
	    if (nameSpan && nameSpan.innerHTML !== params.layerName) {
	        nameSpan.innerHTML = params.layerName;
	    }
	};

	LayerManager.prototype.addEventHandle = function () {
	    var self = this;
	    this.contentElement.addEventListener('click', function (evt) {
	        var element = evt.target;

	        //控制图层显示、隐藏及图表变化
	        if (element.className === 'visible_check') {
	            bLayer.setVisible({
	                mapId: element.mapId,
	                layerId: element.layerId,
	                groupType: element.groupType,
	                visible: element.checked
	            });
	            var iconType = element.layerType || element.groupType;
	            if (element.checked) {
	                element.nextSibling.className = iconType + '_ICON layerIcon';
	            }
	            else {
	                element.nextSibling.className = iconType + '_GRAYICON layerIcon';
	            }
	        }

	        //控制图层上元素标签显示、隐藏
	        if (element.className === 'label_check') {
	            bLayer.setShowLabel({
	                mapId: element.mapId,
	                layerId: element.layerId,
	                layerType: element.layerType,
	                groupType: element.groupType,
	                showLabel: element.checked
	            });

	            if (element.checked) {
	                element.nextSibling.className = 'active_label';
	            }
	            else {
	                element.nextSibling.className = 'inactive_label';
	            }
	        }

	        //调整图层z-index
	        var tuElement;
	        if (element.className === 'active_up_arrow') {
	            tuElement = document.querySelectorAll('#' + element.mapId + ' .layerItem')[element.mIndex - 1];
	        }
	        else if (element.className === 'active_down_arrow') {
	            tuElement = document.querySelectorAll('#' + element.mapId + ' .layerItem')[element.mIndex + 1];
	        }
	        if (!!tuElement) {
	            bLayer.swapLayerZIndex({
	                mapId: element.mapId,
	                sourceLayerId: element.layerId,
	                sourceGroupType: element.groupType,
	                targetLayerId: tuElement.layerId,
	                targetGroupType: tuElement.groupType,
	                classname: element.className
	            });
	            syncLayers(element.mapId);
	        }
	    });

	    //改变图层透明度
	    this.contentElement.addEventListener('change', function (evt) {
	        var element = evt.target;
	        if (element.className === 'range') {
	            var opacity = element.value / element.max;
	            bLayer.setOpacity({
	                mapId: element.mapId,
	                layerId: element.layerId,
	                groupType: element.groupType,
	                opacity: opacity
	            });
	        }
	    });

	    this.closeElement.addEventListener('click', function (evt) {
	        self.hide();
	    });
	};

	LayerManager.prototype.show = function () {
	    this.isShow = true;
	    this.element.style.display = '';
	};

	LayerManager.prototype.hide = function () {
	    this.isShow = false;
	    this.element.style.display = 'none';
	};

	LayerManager.prototype.destroy = function () {
	    this.element.getParent().removeChild(this.element);
	    this.element = null;
	    this.headerElement = null;
	    this.closeElement = null;
	    this.contentElement = null;
	    var olMap = mapBox.getMapObj(this.mapId);
	    olMap.unset('layerManager.manager');
	};

	module.exports = {
	    monitorLayers: monitorLayers,
	    toggle: function (params) {
	        map.set('isToggleLayerManager',true);
	    	if (map.get('refreshLayerManager_key').length < 10) {
	            var layer = new ol.layer.Vector();
	            layer.set('layer_id', 'auto_increase_reduce');
	            mapBox.getMapObj(params.mapId).addLayer(layer);
	            map.get('refreshLayerManager_key').push(layer);
	        }
	        else {
	           var _layers = map.get('refreshLayerManager_key');
	            if (!!_layers && _layers.length >= 0) {
	                _layers.forEach(function(v, i) {
	                    mapBox.getMapObj(params.mapId).removeLayer(v);
	                    map.get('refreshLayerManager_key').splice(i, 1);
	                });
	            }
	        }
	        
	        
	        var mapObj = mapBox.getMapObj(params.mapId);
	        var layerMgr = mapObj.get('layerManager.manager');
	        layerMgr.isShow = !layerMgr.isShow;
	        if (layerMgr.isShow) {
	            layerMgr.show();
	        }
	        else {
	            layerMgr.hide();
	        }
	        setTimeout(function(){
	            map.set('isToggleLayerManager',false);
	        })
	    },
	    syncLayers: syncLayers
	};

/***/ },
/* 40 */
/*!******************************************!*\
  !*** ./src/gis/businessLayers/bLayer.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var Layers = __webpack_require__(/*! layers/layers */ 41);
	var googleMap = __webpack_require__(/*! maps/googleMap */ 24);

	function getBsHandler(layerType) {
	    var handler;
	    if (layerType === constant.BUSINESSTYPE.POINT) {
	        handler = __webpack_require__(/*! businessLayers/point */ 42);
	    }
	    if (layerType === constant.BUSINESSTYPE.CIRCLEPOINT) {
	        handler = __webpack_require__(/*! businessLayers/circlePoint */ 44);
	    }
	    if (layerType === constant.BUSINESSTYPE.POLYGON) {
	        handler = __webpack_require__(/*! businessLayers/polygon */ 45);
	    }
	    if (layerType === constant.BUSINESSTYPE.CELL) {
	        handler = __webpack_require__(/*! businessLayers/cell */ 46);
	    }
	    if(layerType === constant.BUSINESSTYPE.VECTOR_CELL){
	        handler =__webpack_require__(/*! layers/cell */ 47);
	    }
	    if (layerType === constant.BUSINESSTYPE.SITE) {
	        handler = __webpack_require__(/*! businessLayers/site */ 49);
	    }
	    if (layerType === constant.BUSINESSTYPE.GRID) {
	        handler = __webpack_require__(/*! businessLayers/grid */ 50);
	    }
	    if (layerType === constant.BUSINESSTYPE.SERVICEPOLYGON) {
	        handler = __webpack_require__(/*! businessLayers/servicePolygon */ 51);
	    }
	    if (layerType === constant.BUSINESSTYPE.SERVICEPOINT) {
	        handler = __webpack_require__(/*! businessLayers/servicePoint */ 52);
	    }
	    if (layerType === constant.BUSINESSTYPE.SERVICELINE) {
	        handler = __webpack_require__(/*! businessLayers/serviceLine */ 53);
	    }
	    if (layerType === constant.BUSINESSTYPE.LINE) {
	        handler = __webpack_require__(/*! businessLayers/line */ 54);
	    }
	    if(layerType ===constant.BUSINESSTYPE.STRAIGHTLINE){
	    	handler = __webpack_require__(/*! layers/straightLine */ 55);	
	    }
	    if (layerType === 'DPOLYGON') {
	        handler = __webpack_require__(/*! businessLayers/dcServicePolygon */ 56);
	    }
	    if (layerType === 'DPOINT') {
	        handler = __webpack_require__(/*! businessLayers/dcServicePoint */ 57);
	    }
	    if (layerType === 'DLINE') {
	        handler = __webpack_require__(/*! businessLayers/dcServiceLine */ 58);
	    }
	    if(layerType === 'BUBBLE_CIRCLE_LABEL'){
	        handler = __webpack_require__(/*! layers/bubbleCircleLabel */ 59);
	    }
	    if (layerType === 'ICON_FONT_STYLE') {
	        handler = __webpack_require__(/*! layers/fontStyle */ 60);
	    }
	    if (layerType === constant.BUSINESSTYPE.MULTIPOINT) {
	        handler = __webpack_require__(/*! businessLayers/multiPoint */ 61);
	    }
	    return handler;
	}

	function getLayersByGroup(params) {
	    var layerGroup = constant.layerGroup[params.groupType];
	    if (!layerGroup) {
	        return;
	    }
	    var olMap = mapBox.getMapObj(params.mapId);

	    var layers = olMap.getLayers().getArray().slice(0);
	    return layers.filter(function (layer) {
	        var layerType = layer.get('businessType');
	        var isInGroup = false;
	        for (var i = 0, l = layerGroup.length; i < l; i++) {
	            if (layerType === layerGroup[i]) {
	                isInGroup = true;
	                break;
	            }
	        }
	        return isInGroup;
	    });

	}

	function getLayerGroupZIndex(params) {
	    var olMap = mapBox.getMapObj(params.mapId);
	    var zIndex = olMap.get('layerGroup.ZIndex.' + params.groupType);
	    if (zIndex === null || zIndex === undefined) {
	        zIndex = 0;
	    }
	    return zIndex;
	}

	function setShowLabel(params) {
	    if (params.layerId) {
	        var handler = getBsHandler(params.layerType);
	        if (!handler || !handler.setShowLabel) {
	            return;
	        }
	        handler.setShowLabel(params);
	    } else if (params.groupType) {
	        var layers = getLayersByGroup(params);
	        layers.forEach(function (layer) {
	            var handler = getBsHandler(layer.get('businessType'));
	            if (!handler || !handler.setShowLabel) {
	                return;
	            }
	            handler.setShowLabel({
	                mapId: params.mapId,
	                layerId: layer.get('layer_id'),
	                layerType: layer.get('businessType'),
					showLabel: params.showLabel
	            });
	        });
	    }

	}


	function getLayer(paramObj) {
	    var mapId = paramObj.mapId;
	    var layerId = paramObj.layerId;
	    var layers = mapBox.getMapObj(mapId).getLayers().getArray().slice(0);
	    return utils.find(layers, function (layerObj) {
	        if (layerObj && layerObj.get('layer_id') === (layerId)) {
	            return layerObj;
	        }
	    });
	}

	function swapLayerZIndex(params) {
	    var mapId = params.mapId, sIndex, tIndex;

	    if (params.sourceLayerId) {
	        sIndex = getLayer({
	            mapId: mapId,
	            layerId: params.sourceLayerId
	        }).getZIndex();
	    } else if (params.sourceGroupType) {
	        sIndex = getLayerGroupZIndex({
	            mapId: mapId,
	            groupType: params.sourceGroupType
	        });
	    }

	    if (params.targetLayerId) {
	        tIndex = getLayer({
	            mapId: mapId,
	            layerId: params.targetLayerId
	        }).getZIndex();
	    } else if (params.targetGroupType) {
	        tIndex = getLayerGroupZIndex({
	            mapId: mapId,
	            groupType: params.targetGroupType
	        });
	    }
	    
	    if (sIndex === tIndex) {
	    	if (params.classname === 'active_up_arrow') {
	    		tIndex += 1;
	    	}
	    	else if (params.classname === 'active_down_arrow') {
	    		tIndex -= 1;
	    	}
	    	
	    }

	    if (params.sourceLayerId) {
	        getLayer({
	            mapId: mapId,
	            layerId: params.sourceLayerId
	        }).setZIndex(tIndex);
	    } else if (params.sourceGroupType) {
	        setLayerGroupIndex({
	            mapId: mapId,
	            groupType: params.sourceGroupType,
	            zIndex: tIndex
	        });
	    }

	    if (params.targetLayerId) {
	        getLayer({
	            mapId: mapId,
	            layerId: params.targetLayerId
	        }).setZIndex(sIndex);
	    } else if (params.targetGroupType) {
	        setLayerGroupIndex({
	            mapId: mapId,
	            groupType: params.targetGroupType,
	            zIndex: sIndex
	        });
	    }
	}

	function setLayerGroupIndex(params) {
	    var groupLayerTypes = constant.layerGroup[params.groupType];
	    if (!groupLayerTypes) {
	        return;
	    }
	    var olMap = mapBox.getMapObj(params.mapId);
	    var layers = getLayersByGroup(params);
	    var cursor = [];
	    for (var x = 0; x < groupLayerTypes.length; x++) {
	        cursor.push(0);
	    }
	    olMap.set('layerGroup.ZIndex.' + params.groupType, params.zIndex);
	    layers.forEach(function (layer) {
	        var layerType = layer.get('businessType');
	        for (var i = 0, l = groupLayerTypes.length; i < l; i++) {
	            if (layerType === groupLayerTypes[i]) {
	                layer.setZIndex(params.zIndex + 0.1 * i + cursor[i] * 0.001);
	                cursor[i]++;
	            }
	        }
	    });
	}

	function setOpacity(params) {
	    if (params.layerId) {
	        var layer = getLayer(params);
	        layer.setOpacity(params.opacity);
	        Layers.setEffectLayerOpacity(layer, params.opacity);
	        if (params.layerId === constant.MAPPROPERTY.BASE_LAYER_ID) {
	            setCustomMapOpacity(params.mapId, params.opacity);
	        }
	    } else if (params.groupType) {
	        var layers = getLayersByGroup(params);
	        layers.forEach(function (layer) {
	            layer.setOpacity(params.opacity);
	            Layers.setEffectLayerOpacity(layer, params.opacity);
	        });
	    }
	}

	function setVisible(params) {
	    if (params.layerId) {
	        var layer = getLayer(params);
	        layer.setVisible(params.visible);
	        Layers.setEffectLayerVisible(layer, params.visible);
	        if (params.layerId === constant.MAPPROPERTY.BASE_LAYER_ID) {
	            setCustomMapVisible(params.mapId, params.visible);
	        }
	    } else if (params.groupType) {
	        var layers = getLayersByGroup(params);
	        layers.forEach(function (layer) {
	            layer.setVisible(params.visible);
	            Layers.setEffectLayerVisible(layer, params.visible);
	        });
	    }
	}

	function setZIndex(params) {
	    if (params.layerId) {
	        var layer = getLayer(params);
	        if (params.layerId = constant.MAPPROPERTY.BASE_LAYER_ID) {
	            layer.setZIndex(0);
	        }
	        else if (params.layerId = 'base_layer_marker') {
	            layer.setZIndex(1);
	        }
	        else {
	            layer.setZIndex(params.zIndex);
	        }
	    } else if (params.groupType) {
	        setLayerGroupIndex(params);
	    }
	}

	function setCustomMapVisible(mapId, visible) {
	    var olMap = mapBox.getMapObj(mapId);
	    if (!olMap) {
	        return;
	    }
	    var params = olMap.get('paramObj');
	    if (params.mapType.toUpperCase() === constant.MAPTYPE.GOOGLE_MAP) {
	        googleMap.setVisible(olMap, visible);
	    }
	}

	function setCustomMapOpacity(mapId, opacity) {
	    var olMap = mapBox.getMapObj(mapId);
	    if (!olMap) {
	        return;
	    }
	    var params = olMap.get('paramObj');
	    if (params.mapType.toUpperCase() === constant.MAPTYPE.GOOGLE_MAP) {
	        googleMap.setOpacity(olMap, opacity);
	    }
	}

	module.exports = {
	    getBsHandler: getBsHandler,
	    setShowLabel: setShowLabel,
	    setVisible: setVisible,
	    swapLayerZIndex: swapLayerZIndex,
	    setOpacity: setOpacity,
	    setZIndex: setZIndex
	};

/***/ },
/* 41 */
/*!**********************************!*\
  !*** ./src/gis/layers/layers.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var utils = __webpack_require__(/*! utils/util */ 1);
	/**
	 * 获取地图图层
	 * @param paramObj
	 * {
	 *      mapId  :{string} 地图Id,
	 *      layerId:{string} 图层Id
	 * }
	 * @returns {ol.layer.Layer||undefined}
	 */
	function getLayer(paramObj) {
	    if (paramObj.layerId) {
	        return hashMap.get(paramObj.layerId + '_' + paramObj.mapId);
	    }
	}

	function setEffectLayerVisible(layer, visible) {
	    var effectLayers = layer.get('effectLayers');
	    if (effectLayers) {
	        effectLayers.forEach(function (eLayer) {
	            if (eLayer.get('effectCombine.visible') !== false) {
	                eLayer.setVisible(visible);
	            }
	        });
	    }
	}

	function setEffectLayerOpacity(layer, opactiy) {
	    var effectLayers = layer.get('effectLayers');
	    if (effectLayers) {
	        effectLayers.forEach(function (eLayer) {
	            if (eLayer.get('effectCombine.opacity') !== false) {
	                eLayer.setOpacity(opactiy);
	            }
	        });
	    }
	}

	/**
	 * 添加图层的效果图层
	 * @param params
	 */
	function addEffectLayer(params) {
	    var layer;
	    if (params.layer) {
	        layer = params.layer;
	    }
	    else {
	        layer = getLayer(params);
	    }
	    if (!layer || !params.effectLayer) {
	        return;
	    }
	    var effectLayers = layer.get('effectLayers');
	    if (!effectLayers) {
	        effectLayers = [];
	        layer.set('effectLayers', effectLayers);
	    }
	    if (effectLayers.indexOf(params.effectLayer) === -1) {
	        effectLayers.push(params.effectLayer);
	    }

	}

	/**
	 * 删除图层依附的效果图层
	 * @param params
	 */
	function removeEffectLayer(params) {
	    var layer;
	    if (params.layer) {
	        layer = params.layer;
	    }
	    else {
	        layer = getLayer(params);
	    }
	    if (!layer) {
	        return;
	    }
	    var effectLayers = layer.get('effectLayers');
	    if (!effectLayers) {
	        return;
	    }
	    var olMap = mapBox.getMapObj(params.mapId);
	    !!effectLayers && effectLayers.forEach(function (effectLayer) {
	        if (!effectLayer.get('state.deleted')) {
	            effectLayer.set('state.deleted', true);
	            if (effectLayer.onDestroy) {
	                effectLayer.onDestroy();
	            }
	            effectLayer.setMap(null);
	            if (!!effectLayer) {
	                olMap.removeLayer(effectLayer);
	            }

	        }
	    });
	    layer.set('effectLayers', null);
	}

	/**
	 * 获取当前地图上的所有图层
	 * @param mapId
	 * @returns {Array}
	 */
	var getLayers = function (mapId) {
	    var _subffix = '_' + mapId;
	    var _targetLayers = [];
	    hashMap.keys.forEach(function (layerId) {
	        if (layerId && utils.endsWith(layerId, _subffix)) {
	            _targetLayers.push(hashMap.get(layerId));
	        }
	    });
	    return _targetLayers;
	};

	module.exports = {
	    getLayer: getLayer,
	    addEffectLayer: addEffectLayer,
	    removeEffectLayer: removeEffectLayer,
	    setEffectLayerVisible: setEffectLayerVisible,
	    setEffectLayerOpacity: setEffectLayerOpacity,
	    getLayers: getLayers
	};


/***/ },
/* 42 */
/*!*****************************************!*\
  !*** ./src/gis/businessLayers/point.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var event = __webpack_require__(/*! maps/event */ 11);

	var render = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId,
	        _layer = null;
	    var _mapObj = mapBox.getMapObj(paramObj.mapId);
	    var _isShow = paramObj.isShow != undefined ? paramObj.isShow : true;
	    var _label = paramObj.label ? paramObj.label : paramObj.layerId;
	    if (hashMap.containsKey(_layerId)) {
	        _layer = hashMap.get(_layerId);
	    }
	    else {
	        _layer = new ol.layer.Vector({
	            source: new ol.source.Vector({
	                wrapX: false
	            })
	        });

	        ///自定义属性，方便后面通过类型判断对象
	        _layer.set('type', constant.CUSTOMTYPE.LAYERTYPE);
	        _layer.set('map', _mapObj);
	        _layer.set('layerId', _layerId);
	        _layer.set('layer_id', paramObj.layerId);
	        _layer.set('businessType', constant.BUSINESSTYPE.POINT);
	        _layer.set('params.label', _label);
	        _layer.set('isVectorType',true);
	        _layer.set('state.showLabel', !!paramObj.showLabel);
	        _layer.set('legendName', paramObj.legendName);
	        var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.LANDMARKER;
	        _layer.setZIndex(_ZIndex);
	        _layer.set('clickId', 'business_vector_point_event_id');
	        _layer.set('isShow', _isShow);
	        if (!!paramObj.multiple) {
	            _layer.set('multiple', paramObj.multiple);
	        }
	        if (paramObj.minShowLevel != undefined) {
	            _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	        }

	        if (paramObj.maxShowLevel != undefined) {
	            _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));
	        }
	        hashMap.put(_layerId, _layer);
	        _mapObj.addLayer(_layer);

	    }

	    event.addClickCallback(paramObj.mapId, 'business_vector_point_event_id', function (e) {
	        if (e.layer && e.layer.get('businessType') === constant.BUSINESSTYPE.POINT &&
	            e.feature && e.feature.get('businessType') === constant.BUSINESSTYPE.POINT) {
	            var feature = e.feature;
	            //调用高亮的方法
	            highlight(e.layer, 'click', {mapId: paramObj.mapId, layerId: paramObj.layerId, feature: feature});
	        }
	    }, paramObj.layerId)

	};

	var setLayerData = function (paramObj) {
	    var _features = [];
	    var _datas = paramObj.datas;
	    var layer = layers.getLayer(paramObj);
	    layer.set('legendName', paramObj.legendName);
	    layer.set('paramObj',paramObj);
	    if (paramObj.label) {
	        layer.set('params.label', paramObj.label);
	    }
	    if (utils.isValid(_datas) || _datas.length > 0) {

	        layer.set('state.showLabel', !!paramObj.showLabel);
	        var source = layer.getSource();
	        _datas.forEach(function (pointData) {
	            var _coordinate= utils.gcjTransform(pointData.coordinate);
	            _coordinate = ol.proj.fromLonLat(_coordinate);
	            var _strokeWidth = pointData.strokeWidth !== undefined ? pointData.strokeWidth : 0;

	            //增加传入一个样式的参数
	            var _pointStyle =pointData.pointStyle !==undefined ? pointData.pointStyle :'';

	            var _fill = new ol.style.Fill({
	            	color: pointData.fillColor ? pointData.fillColor : 'red'
	            });
	            var _stroke = new ol.style.Stroke({
	            	color: pointData.strokeColor ? pointData.strokeColor : '#319FD3',
	            	width: pointData.strokeWidth ? parseInt(pointData.strokeWidth) : 0
	            });



	            var defaultHighLight = {
	                fillColor: pointData.fillColor,
	                strokeColor: 'black',
	                strokeWidth: _strokeWidth,
	                labelFillColor: pointData.labelFillColor || 'black',
	                labelStrokeColor: pointData.labelStrokeColor || '#ffffff',
	                radius: pointData.radius || 5
	            };

	            var _feature = new ol.Feature({
	                geometry: new ol.geom.Point(_coordinate),
	                data: pointData,
	                layerId: paramObj.layerId,
	                mapId: paramObj.mapId,
	                businessType: constant.BUSINESSTYPE.POINT,
	                select: pointData.hightLight ? pointData.hightLight : defaultHighLight
	            });

	            if (pointData.hightLight) {
	                for (var index in defaultHighLight) {
	                    pointData.hightLight[index] ? pointData.hightLight[index] : pointData.hightLight[index] = defaultHighLight[index];
	                }
	            }
	            _feature.setId(pointData.id);
	            _feature.set('layer', layer);
	            _feature.set('vectorType', constant.BUSINESSTYPE.POINT);



	            var shapeStyle = new ol.style.Style({
	            	image: new ol.style.Circle({
	            		radius: pointData.radius ? pointData.radius : 5,
	            		fill: _fill,
	            		stroke: _stroke
	            	})
	            });
	            var _featureStyle = getPointStyle({
	            	fillColor: pointData.fillColor,
	            	strokeColor: pointData.strokeColor,
	            	strokeWidth: pointData.strokeWidth,
	            	radius: pointData.radius,
	            	type: _pointStyle,
	            	labelStrokeWidth:pointData.labelStrokeWidth,
	            	labelOffsetX:pointData.labelOffsetX,
	            	labelOffsetY:pointData.labelOffsetY,
	            	fontStyle:!!pointData.fontStyle ? pointData.fontStyle : 'normal Arial' ,
	            	fontSize:!!pointData.fontSize ? pointData.fontSize : '14px',
	            	fontFamily:pointData.fontFamily,
	            	labelFillColor:pointData.labelFillColor,
	            	labelStrokeColor:pointData.labelStrokeColor,
	            	label:pointData.label
	            });

	            _feature.setStyle(_featureStyle);
	            _feature.set('defaultStyle', _featureStyle);
	            _feature.set('shapeStyle', shapeStyle);
	            _features.push(_feature);

	        });
	        source.addFeatures(_features);
	    }

	};

	function highlight(olLayer, hType, param) {
	    if (olLayer) {
	        var olMap = olLayer.get('map');
	        var mapId = olMap.getTarget();
	        var layerId = olLayer.get('layer_id');
	        var layerType = olLayer.get('businessType');
	        highlights.removeHighlight({
	            mapId: mapId,
	            layerId: layerId,
	            hTypes: [hType]
	        });

	        var hLayer = highlights.getHLayer({
	            mapId: mapId,
	            layerId: layerId
	        });
	        if (hType === constant.HTYPE.CLICK) {
	            if (param.feature) {
	                var _feature = param.feature;
	                var _geoId = _feature.getId();
	                var _highlightStyle = _feature.get('select');
	                var _data = _feature.get('data');

	                var font = _data.fontStyle + ' ' + _data.fontSize + ' ' + _data.fontFamily;
	                var _style = new ol.style.Style({
	                    image: new ol.style.Circle({
	                        radius: _highlightStyle.radius,
	                        stroke: new ol.style.Stroke({
	                            width: _highlightStyle.strokeWidth != undefined ? _highlightStyle.strokeWidth : 2,
	                            color: _highlightStyle.strokeColor != undefined ? _highlightStyle.strokeColor : 'black'
	                        }),
	                        fill: new ol.style.Fill({
	                            color: _highlightStyle.fillColor != undefined ? _highlightStyle.fillColor : 'red'
	                        })
	                    }),
	                    text: new ol.style.Text({
	                        text: _data.label || '',
	                        font: font !== 'undefined undefined undefined' ? font : 'normal 14px Arial',
	                        fill: new ol.style.Fill({
	                            color: _highlightStyle.labelFillColor != undefined ? _highlightStyle.labelFillColor : 'black'
	                        }),
	                        stroke: new ol.style.Stroke({
	                            color: _highlightStyle.labelStrokeColor != undefined ? _highlightStyle.labelStrokeColor : 'black',
	                            width: _data.labelStrokeWidth !== undefined ? _data.labelStrokeWidth : 1
	                        }),
	                        offsetX: _data.labelOffsetX !== undefined ? _data.labelOffsetX : 30,
	                        offsetY: _data.labelOffsetY !== undefined ? _data.labelOffsetY : -15
	                    })
	                });
	                var tempFeature = _feature.clone();
	                tempFeature.setStyle(_style);
	                tempFeature.setId(_geoId);
	                tempFeature.set('mapId', mapId);
	                tempFeature.set('layerId', layerId);
	                tempFeature.set('layerType', layerType);
	                tempFeature.set('hType', hType);
	                tempFeature.set('highlightFeature', true);
	                tempFeature.set('layer',hLayer);

	                //数组copy
	                hLayer.getSource().addFeature(tempFeature);
	            }
	        } else if (hType === constant.HTYPE.VECTOR) {
	            param.geoIds.map(function (geoId) {
	                var feature = olLayer.getSource().getFeatureById(geoId);
	                if (!feature) {
	                    return;
	                }
	                var highlightStyle = feature.get('select');

	                var _tempFeature = feature.clone();

	                var _data = _tempFeature.get('data');
	                var font = _data.fontStyle + ' ' + _data.fontSize + ' ' + _data.fontFamily;
	                var _style = new ol.style.Style({
	                    image: new ol.style.Circle({
	                        radius: highlightStyle.radius,
	                        fill: new ol.style.Fill({
	                            color: highlightStyle.fillColor
	                        }),
	                        stroke: new ol.style.Stroke({
	                            color: highlightStyle.strokeColor,
	                            width: highlightStyle.strokeWidth
	                        })
	                    })/*,
	                    text: new ol.style.Text({
	                        text: _data.label || '',
	                        font: font !== 'undefined undefined undefined' ? font : 'normal 14px Arial',
	                        fill: new ol.style.Fill({
	                            color: highlightStyle.labelFillColor
	                        }),
	                        stroke: new ol.style.Stroke({
	                            color: highlightStyle.labelStrokeColor,
	                            width: _data.labelStrokeWidth !== undefined ? _data.labelStrokeWidth : 1
	                        }),
	                        offsetX: _data.labelOffsetX !== undefined ? _data.labelOffsetX : 30,
	                        offsetY: _data.labelOffsetY !== undefined ? _data.labelOffsetY : -15
	                    })*/
	                });

	                _tempFeature.setStyle(_style);
	                _tempFeature.setId(geoId);
	                _tempFeature.set('mapId', mapId);
	                _tempFeature.set('layerId', layerId);
	                _tempFeature.set('layerType', layerType);
	                _tempFeature.set('hType', hType);
	                _tempFeature.set('highlightFeature', true);
	                _tempFeature.set('layer',hLayer);
	                hLayer.getSource().addFeature(_tempFeature);
	            });

	        }
	    }
	}

	var getLineLonLat = function (param, callback) {
	    var lineLngLat;
	    var olLayer = layers.getLayer({
	        mapId: param.mapId,
	        layerId: param.layerId
	    });
	    if (!olLayer) {
	        callback();
	        return;
	    }
	    var feature = olLayer.getSource().getFeatureById(param.geoId);
	    var geom = feature.getGeometry();
	    lineLngLat = new ol.proj.toLonLat(geom.getCoordinates());
	    callback(lineLngLat);
	};

	function setShowLabel(param) {
	    var layer = layers.getLayer(param);
	    if (!layer) {
	        return;
	    }
	    var showLabel = layer.get('state.showLabel');
	    var features = layer.getSource().getFeatures().slice(0);
	    features.forEach(function (f) {
	        if (param.showLabel && !showLabel) {
	            f.setStyle(f.get('defaultStyle'));
	        }
	        else if (!param.showLabel && showLabel) {
	            f.setStyle(f.get('shapeStyle'));
	        }
	    });
	    layer.set('state.showLabel', !!param.showLabel);
	}

	function setSinglePointStyle(params) {
		var _feature = params.feature;
		if(_feature) {
		    var _type = params.type.split(':')[1];
		    var styleObj ={
		    	fillColor:params.fillColor,
		    	strokeColor:params.strokeColor,
		    	strokeWidth:params.strokeWidth,
		    	radius:params.radius,
		    	fontStyle:params.fontStyle,
		    	fontSize: params.fontSize,
		    	fontFamily:params.fontFamily,
		    	labelOffsetX:params.labelOffsetX,
		    	labelOffsetY:params.labelOffsetY,
		    	label:params.label,
		    	type:_type
		    };
		    var _style=getPointStyle(styleObj);
			_feature.setStyle(_style);
		}
	}

	function getPointStyle(params) {
		var _type = params.type;
		var _style = null;
		var font = params.fontStyle + ' ' + params.fontSize + ' ' + params.fontFamily;
		var _offsetX = params.labelOffsetX !== undefined ? params.labelOffsetX : 30;
		var _offsetY = params.labelOffsetY !== undefined ? params.labelOffsetY : -15;
		var _labelWidth = params.labelStrokeWidth !== undefined ? parseInt(params.labelStrokeWidth) : 1;

		var _fill = new ol.style.Fill({
			color: params.fillColor ? params.fillColor : 'red'
		});

		var _stroke = new ol.style.Stroke({
			color: params.strokeColor ? params.strokeColor : '#319FD3',
			width: params.strokeWidth ? parseInt(params.strokeWidth) : 0
		});

		var _defaultStyle = new ol.style.Style({
			image: new ol.style.Circle({
				radius: params.radius ? params.radius : 5,
				fill: _fill,
				stroke: _stroke
			}),
			text: new ol.style.Text({
				text: params.label ? params.label : '',
				fill: new ol.style.Fill({
					color: params.labelFillColor ? params.labelFillColor : 'black'
				}),
				font: font !== 'undefined undefined undefined' ? font : 'normal 14px Arial',
				offsetX: _offsetX,
				offsetY: _offsetY,
				stroke: new ol.style.Stroke({
					color: params.labelStrokeColor || '#ffffff',
					width: _labelWidth
				})
			})
		});

		var _xStyle = new ol.style.Style({
			image: new ol.style.RegularShape({
				fill: _fill,
				stroke: _stroke,
				points: 4,
				radius: params.radius ? params.radius : 10,
				radius2: 0,
				angle: Math.PI / 4
			})
		});

		var _crossStyle = new ol.style.Style({
			image: new ol.style.RegularShape({
				fill: _fill,
				stroke: _stroke,
				points: 4,
				radius: params.radius ? params.radius : 10,
				radius2: 0,
				angle: 0
			})
		});

		var _starStyle = new ol.style.Style({
			image: new ol.style.RegularShape({
				fill: _fill,
				stroke: _stroke,
				points: 5,
				radius: params.radius ? params.radius : 10,
				radius2: 4,
				angle: 0
			})
		});

		var _triangleStyle = new ol.style.Style({
			image: new ol.style.RegularShape({
				fill: _fill,
				stroke: _stroke,
				points: 3,
				radius: params.radius ? params.radius : 10,
				rotation: Math.PI / 4,
				angle: 0
			})
		});
		var squareStyle = new ol.style.Style({
			image: new ol.style.RegularShape({
				fill: _fill,
				stroke: _stroke,
				points: 4,
				radius: params.radius ? params.radius : 10,
				angle: Math.PI / 4
			})
		});
		var uniqueTextStyle = new ol.style.Style({
	        text: new ol.style.Text({
	           text: params.label || '',// 必传
	           fill: _fill,
	           stroke: _stroke,
	           font: font || '10px sans-seri',//必传
	           textAlign: params.textAlign || 'start',
	           textBaseline: params.textBaseline || 'alphabetic',
	           offsetY: _offsetY,
	           offsetX: _offsetX
	         })
	    });

		switch(_type) {
			case '':
				_style = _defaultStyle;
				break;
			case 'x':
				_style = _xStyle;
				break;
			case 'cross':
				_style = _crossStyle;
				break;
			case 'star':
				_style = _starStyle;
				break;
			case 'triangle':
				_style = _triangleStyle;
				break;
			case 'square':
				_style = squareStyle;
				break;
			//字体文本格式的自定义图标
			case 'isUnique':
			    _style = uniqueTextStyle;
			    break;
			default:
		}

		return _style;

	}
	module.exports = {
	    addLayer: render,
	    setLayerData: setLayerData,
	    highlight: highlight,
	    getLineLonLat: getLineLonLat,
	    setShowLabel: setShowLabel,
	    setSinglePointStyle:setSinglePointStyle
	};


/***/ },
/* 43 */
/*!*************************************!*\
  !*** ./src/gis/layers/highlight.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var bLayer = __webpack_require__(/*! businessLayers/bLayer */ 40);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);

	function getHLayer(params) {
	    var olMap = mapBox.getMapObj(params.mapId);
	    var olLayer = layers.getLayer(params);
	    if (!!!olLayer) {
	        return;
	    }
	    var layerId = olLayer.get('layer_id');
	    var hLayerId = layerId + '&&&highlight';
	    var hLayer = olUtil.getLayer({
	        mapId: params.mapId,
	        layerId: hLayerId
	    });
	    if (hLayer) {
	        return hLayer;
	    }

	    hLayer = new ol.layer.Vector({
	        source: new ol.source.Vector({
	            wrapX: false
	        })
	    });
	    hLayer.set('mapId', params.mapId);
	    hLayer.set('source_layerId', layerId);
	    hLayer.set('layerId', hLayerId);
	    hLayer.set('layer_id', hLayerId);
	    hLayer.setZIndex(olLayer.getZIndex()+1);
	    layers.addEffectLayer({
	        layer: olLayer,
	        effectLayer: hLayer
	    });
	    olMap.addLayer(hLayer);
	    return hLayer;
	}

	function removeHighlight(params) {
	    if (params.layerId) {
	        var hLayer = getHLayer({
	            mapId: params.mapId,
	            layerId: params.layerId
	        });
	        var olLayer = baseLayer.getLayer({
	            mapId: params.mapId,
	            layerId: params.layerId
	        });
	        if (olLayer != undefined &&  olLayer.hasOwnProperty('mouseoverCallback')
	            && typeof olLayer.mouseoverCallback === 'function'
	            && !(hLayer.hasOwnProperty('mouseoverCallback'))) {
	            hLayer.mouseoverCallback = olLayer.mouseoverCallback;
	        }
	        var source = hLayer && hLayer.getSource();
	        if(!!!source){
	            return;
	        }
	        if (!params.hTypes || !params.hTypes.length) {
	            source.clear();
	            return;
	        }
	        var features = source.getFeatures().slice(0);
	        features && features.forEach(function (f) {
	            var hType = f.get('hType');
	            if (params.hTypes.indexOf(hType) > -1) {
	                source.removeFeature(f);
	            }
	        });
	    }
	}

	function highlight(params) {
	    var olLayer = layers.getLayer({
	        layerId: params.layerId,
	        mapId: params.mapId
	    });
	    if (!olLayer) {
	        return;
	    }
	    var layerType = olLayer.get('businessType');
	    var handle = bLayer.getBsHandler(layerType);
	    if (!handle || !handle.highlight) {
	        return;
	    }
	    handle.highlight(olLayer, params.highlightType, params);
	}

	module.exports = {
	    highlight: highlight,
	    getHLayer: getHLayer,
	    removeHighlight: removeHighlight
	};

/***/ },
/* 44 */
/*!***********************************************!*\
  !*** ./src/gis/businessLayers/circlePoint.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);
	var event = __webpack_require__(/*! maps/event */ 11);

	var render = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId,
	        _layer = null;
	    var _mapObj = mapBox.getMapObj(paramObj.mapId);

	    if (hashMap.containsKey(_layerId)) {
	        _layer = hashMap.get(_layerId);
	    }
	    else {
	        _layer = new ol.layer.Vector({
	            source: new ol.source.Vector({
	                wrapX: false
	            })
	        });
	        var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex :constant.Z_INDEX.LANDMARKER;
	        ///自定义属性，方便后面通过类型判断对象
	        _layer.set('type', constant.CUSTOMTYPE.LAYERTYPE);
	        _layer.set('map', _mapObj);
	        _layer.set('layerId', _layerId);
	        _layer.set('layer_id', paramObj.layerId);
	        _layer.set('businessType', constant.BUSINESSTYPE.CIRCLEPOINT);
	        _layer.set('isVectorType',true);
	        _layer.set('params.label', paramObj.label);
	        _layer.set('state.showLabel', !!paramObj.showLabel);
	        _layer.setZIndex(_ZIndex);
	        hashMap.put(_layerId, _layer);
	        _mapObj.addLayer(_layer);

	    }

	    _layer.set('legendName', paramObj.legendName);
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	    }

	    if (!!paramObj.multiple) {
	        _layer.set('multiple', paramObj.multiple);
	    }
	    _layer.set('clickid', 'business_vector_circlePoint_event_id');
	    
	    event.addClickCallback(paramObj.mapId, 'business_vector_circlePoint_event_id', function(e) {
	    	if(e.layer && e.layer.get('businessType') === constant.BUSINESSTYPE.CIRCLEPOINT &&
	    		e.feature && e.feature.get('businessType') === constant.BUSINESSTYPE.CIRCLEPOINT) {
	    		var feature = e.feature;
	    		//调用高亮的方法
	    		highlight(e.layer, 'click', {
	    			mapId: paramObj.mapId,
	    			layerId: paramObj.layerId,
	    			feature: feature
	    		});
	    	}
	    }, paramObj.layerId)
	};

	var setLayerData = function (paramObj) {
	    var _features = [];
	    var _datas = paramObj.datas;
	    var layer = layers.getLayer(paramObj);
	    layer.set('legendName', paramObj.legendName);
	    layer.set('paramObj',paramObj);
	    if (paramObj.label) {
	        layer.set('params.label', paramObj.label);
	    }
	    if (utils.isValid(_datas) || _datas.length > 0) {
	        var source = layer.getSource();
	        _datas.forEach(function (pointData) {
	            var _coordinate = utils.gcjTransform(pointData.coordinate);
	            _coordinate = ol.proj.fromLonLat(_coordinate);
	            var _strokeWidth = pointData.strokeWidth !== undefined ? pointData.strokeWidth : 2;
	            var font = pointData.fontStyle + ' '+ pointData.fontSize + ' '+ pointData.fontFamily;
	            var _labelWidth = pointData.labelStrokeWidth !== undefined ? pointData.labelStrokeWidth : 2;
	            var _offsetX = pointData.labelOffsetX !== undefined ? pointData.labelOffsetX : 30;
	            var _offsetY = pointData.labelOffsetY !== undefined ? pointData.labelOffsetY : -15;
	            var defaultHighLight = {
	                fillColor: pointData.fillColor || 'red',
	              //  strokeColor: pointData.strokeColor || 'white',
	                strokeColor:'black',
	                strokeWidth: _strokeWidth,
	                labelFillColor: pointData.labelFillColor || 'black',
	                labelStrokeColor: pointData.labelStrokeColor || '#ffffff',
	                radius: pointData.radius || 5
	            };
	            var _feature = new ol.Feature({
	                geometry: new ol.geom.Point(_coordinate),
	                data: pointData,
	                layerId: paramObj.layerId,
	                mapId: paramObj.mapId,
	                businessType: constant.BUSINESSTYPE.CIRCLEPOINT,
	                select: pointData.hightLight ? pointData.hightLight : defaultHighLight
	            });
	            if(pointData.hightLight) {
	                for (var index in defaultHighLight) {
	                    pointData.hightLight[index] ? pointData.hightLight[index] : pointData.hightLight[index] = defaultHighLight[index];
	                }
	            }
	            _feature.setId(pointData.id);

	            var _defaultStyle = new ol.style.Style({
	                image: new ol.style.Circle({
	                    radius: pointData.radius ? pointData.radius : 5,
	                    fill: new ol.style.Fill({
	                        color: pointData.fillColor ? pointData.fillColor : 'red'
	                    })
	                }),
	                text: new ol.style.Text({
	                    text: pointData.name ? pointData.name : '',
	                    fill: new ol.style.Fill({
	                        color: pointData.labelFillColor ? pointData.labelFillColor : 'black'
	                    }),
	                    font: 'normal 14px Arial',
	                    offsetX: _offsetX,
	                    offsetY: _offsetY,
	                    stroke: new ol.style.Stroke({
	                        color: pointData.labelStrokeColor || '#ffffff',
	                        width: _labelWidth
	                    })
	                })
	            });
	            var shapeStyle = new ol.style.Style({
	                image: new ol.style.Circle({
	                    radius: pointData.radius ? pointData.radius : 5,
	                    fill: new ol.style.Fill({
	                        color: pointData.fillColor || 'green'
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color: pointData.strokeColor || 'black',
	                        width: _strokeWidth
	                    })
	                })
	            });
	            _feature.setStyle(_defaultStyle);
	            _feature.set('vectorType','CIRCLEPOINT');
	            _feature.set('layer',layer);
	            _feature.set('defaultStyle', _defaultStyle);
	            _feature.set('shapeStyle', shapeStyle);
	            _features.push(_feature);
	        });
	        source.addFeatures(_features);
	    }
	};
	function highlight (olLayer,hType,param){
	    if(olLayer){
	    	
	    	var olMap = olLayer.get('map');
	        var mapId = olMap.getTarget();
	        var layerId = olLayer.get('layer_id');
	        var layerType = olLayer.get('businessType');
	        highlights.removeHighlight({
	            mapId: mapId,
	            layerId: layerId,
	            hTypes: [hType]
	        });
	        
	        var hLayer = highlights.getHLayer({
	            mapId: mapId,
	            layerId: layerId
	        });
	        
	        
	        
	        if (hType === constant.HTYPE.CLICK) {
	            if(param.feature){
	            	var _feature = param.feature;
	                var _geoId = _feature.getId();
	                var hightLight = _feature.get('select');
	                var _data = _feature.get('data');
	                
	                
	                var font = _data.fontStyle + ' '+ _data.fontSize + ' '+ _data.fontFamily;
	                var _style=new ol.style.Style({
	                    image:new ol.style.Circle({
	                        radius: hightLight.radius,
	                        stroke: new ol.style.Stroke({
	                            width: hightLight.strokeWidth,
	                            color: hightLight.strokeColor
	                        }),
	                        fill: new ol.style.Fill({
	                            color: hightLight.fillColor
	                        })
	                    }),
	                    text: new ol.style.Text({
	                        text: _data.name || '',
	                        font: font !== 'undefined undefined undefined' ? font : 'normal 13px Arial',
	                        fill: new ol.style.Fill({
	                            color: hightLight.labelFillColor
	                        }),
	                        stroke: new ol.style.Stroke({
	                            color: hightLight.labelStrokeColor,
	                            width: _data.labelStrokeWidth !== undefined ? _data.labelStrokeWidth : 2
	                        }),
	                        offsetX: _data.labelOffsetX !== undefined ?_data.labelOffsetX : 30,
	                        offsetY: _data.labelOffsetY !== undefined ? _data.labelOffsetY : -15
	                    })
	                });
	                
	                var tempFeature = _feature.clone();
	                tempFeature.setStyle(_style);
	                
	                tempFeature.setId(_geoId);
	                
	                tempFeature.set('mapId', mapId);
	                tempFeature.set('layerId', layerId);
	                tempFeature.set('layerType', layerType);
	                tempFeature.set('hType', hType);
	                tempFeature.set('highlightFeature', true);  
	                                //数组copy
	                hLayer.getSource().addFeature(tempFeature);

	            }

	        } else if (hType === constant.HTYPE.VECTOR) {
	            param.geoIds.map(function (geoId) {
	                var feature = olLayer.getSource().getFeatureById(geoId);
	                if (!feature) {
	                    return;
	                }
	                
	                
	                var hightLight = feature.get('select');
	                
	                
	                var _tempFeature = feature.clone();
	                var _data = _tempFeature.get('data');
	                
	                var font = _data.fontStyle + ' '+ _data.fontSize + ' '+ _data.fontFamily;
	                var _style = new ol.style.Style({
	                    image: new ol.style.Circle({
	                        radius: hightLight.radius,
	                        fill: new ol.style.Fill({
	                            color: hightLight.fillColor
	                        }),
	                        stroke: new ol.style.Stroke({
	                            color: hightLight.strokeColor,
	                            width: hightLight.strokeWidth
	                        })
	                    }),
	                    text: new ol.style.Text({
	                        text: _data.name || '',
	                        font: font !== 'undefined undefined undefined' ? font : 'normal 13px Arial',
	                        fill: new ol.style.Fill({
	                            color: hightLight.labelFillColor
	                        }),
	                        stroke: new ol.style.Stroke({
	                            color: hightLight.labelStrokeColor,
	                            width: _data.labelStrokeWidth !== undefined ? _data.labelStrokeWidth : 2
	                        }),
	                        offsetX: _data.labelOffsetX !== undefined ?_data.labelOffsetX : 30,
	                        offsetY: _data.labelOffsetY !== undefined ? _data.labelOffsetY : -15
	                    })
	                });
	                
	                
	                _tempFeature.setStyle(_style);
	                _tempFeature.setId(geoId);
	                _tempFeature.set('mapId', mapId);
	                _tempFeature.set('layerId', layerId);
	                _tempFeature.set('layerType', layerType);
	                _tempFeature.set('hType', hType);
	                _tempFeature.set('highlightFeature', true);
	                
	                hLayer.getSource().addFeature(_tempFeature);
	            });
	        }
	    }
	}
	var getLineLonLat = function (param, callback) {
	    var lineLngLat;
	    var olLayer = layers.getLayer({
	        mapId: param.mapId,
	        layerId: param.layerId
	    });
	    if (!olLayer) {
	        callback();
	        return;
	    }
	    var feature = olLayer.getSource().getFeatureById(param.geoId);
	    var geom = feature.getGeometry();
	    lineLngLat = new ol.proj.toLonLat(geom.getCoordinates());
	    callback(lineLngLat);
	};

	function setShowLabel(param) {
	    var layer = layers.getLayer(param);
	    if (!layer) {
	        return;
	    }
	    var showLabel = layer.get('state.showLabel');
	    var features = layer.getSource().getFeatures().slice(0);
	    features.forEach(function (f) {
	        if (param.showLabel && !showLabel) {
	            f.setStyle(f.get('defaultStyle'));
	        }
	        else if (!param.showLabel && showLabel) {
	            f.setStyle(f.get('shapeStyle'));
	        }
	    });
	    layer.set('state.showLabel', !!param.showLabel);
	}

	module.exports = {
	    addLayer: render,
	    setLayerData: setLayerData,
	    highlight: highlight,
	    getLineLonLat: getLineLonLat,
	    setShowLabel: setShowLabel
	};


/***/ },
/* 45 */
/*!*******************************************!*\
  !*** ./src/gis/businessLayers/polygon.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var event = __webpack_require__(/*! maps/event */ 11);

	function render(paramObj) {
	    var _layerIdentify = paramObj.layerId + '_' + paramObj.mapId;
	    var _mapObj = hashMap.get(paramObj.mapId);
	    var _zoom = _mapObj.getView().getZoom();
	    var _isShow = paramObj.isShow != undefined ? paramObj.isShow : true;
	    var _label = paramObj.label ? paramObj.label : paramObj.layerId;
	    if (!hashMap.containsKey(_layerIdentify)) {
	        var _layer = new ol.layer.Vector({
	            source: new ol.source.Vector({
	                wrapX: false
	            }),
	            updateWhileAnimating: true,
	            updateWhileInteracting: true
	        });
	        hashMap.put(_layerIdentify, _layer);

	        _layer.set('type', constant.CUSTOMTYPE.LAYERTYPE);
	        _layer.set('map', _mapObj);
	        _layer.set('layerId', _layerIdentify);
	        _layer.set('layer_id', paramObj.layerId);
	        _layer.set('params.label', _label);
	        _layer.set('isVectorType',true);
	        _layer.set('state.showLabel', !!paramObj.showLabel);
	        _layer.set('businessType', constant.BUSINESSTYPE.POLYGON);
	        _layer.set('legendName', paramObj.legendName);
	        var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.TEMPPOLYGON;
	        _layer.setZIndex(_ZIndex);
	        _layer.set('multiple', !!paramObj.multiple);
	        _layer.set('clickId', 'business_vector_polygon_event_id');
	        _layer.set('isShow', _isShow);
	        if (paramObj.minShowLevel != undefined) {
	            _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	        }

	        if (paramObj.maxShowLevel != undefined) {
	            _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));
	        }
	        _mapObj.addLayer(_layer);
	    }

	    event.addClickCallback(paramObj.mapId, 'business_vector_polygon_event_id', function (e) {
	        if (e.layer && e.layer.get('businessType') === constant.BUSINESSTYPE.POLYGON &&
	            e.feature && e.feature.get('businessType') === constant.BUSINESSTYPE.POLYGON) {
	            var feature = e.feature;
	            highlight(e.layer, 'click', {mapId: paramObj.mapId, layerId: paramObj.layerId, feature: feature});
	        }
	    }, paramObj.layerId)
	}

	/**
	 *
	 * @param paramObj
	 *      paramObj = {
	 *          datas: [
	 *              {
	 *                  id: ##,
	 *                  coordinates: [[x, y],[x, y],...],
	 *                  fillColor: ##,
	 *                  strokeColor: ##,
	 *                  strokeWidth: ##,
	 *                  label: ##
	 *              }
	 *          ]
	 *
	 *      }
	 */
	function setLayerData(paramObj) {
	    var _features = [];
	    var _datas = paramObj.datas;
	    var layer = layers.getLayer(paramObj);
	    if (paramObj.label) {
	        layer.set('params.label', paramObj.label);
	    }
	    layer.set('paramObj',paramObj);
	    if (utils.isValid(_datas) || _datas.length > 0) {

	        layer.set('state.showLabel', true);
	        layer.set('legendName', paramObj.legendName);
	        var source = layer.getSource();
	        _datas.forEach(function (data) {
	            var _coordinates = data.coordinates;
	            _coordinates = utils.transformMultArray(_coordinates);
	            var font = data.fontStyle + ' ' + data.fontSize + ' ' + data.fontFamily;
	            var _strokeWidth = data.strokeWidth !== undefined ? data.strokeWidth : 2;
	            var _labelWidth = data.labelStrokeWidth !== undefined ? data.labelStrokeWidth : 1;
	            var _geoPolygon = new ol.geom.Polygon([_coordinates]);
	            var _labelPoint = ol.extent.getCenter(_geoPolygon.getExtent());
	            var defaultHighLight = {
	                fillColor: data.fillColor ? data.fillColor : 'rgba(255,0,255,0.3)',
	                strokeColor: 'black',
	                strokeWidth: _strokeWidth,
	                labelFillColor: data.labelFillColor || 'black',
	                labelStrokeColor: data.labelStrokeColor || '#ffffff'
	            };
	            var _feature = new ol.Feature({
	                geometry: _geoPolygon.transform(constant.PROJ.EPSG_4326, constant.PROJ.EPSG_3857),
	                labelPoint: ol.proj.fromLonLat(_labelPoint),
	                businessType: constant.BUSINESSTYPE.POLYGON,
	                data: data,
	                layerId: paramObj.layerId,
	                mapId: paramObj.mapId,
	                select: data.hightLight ? data.hightLight : defaultHighLight
	            });
	            if (data.hightLight) {
	                for (var index in defaultHighLight) {
	                    data.hightLight[index] ? data.hightLight[index] : data.hightLight[index] = defaultHighLight[index];
	                }
	            }
	            _feature.setId(data.id);
	            _feature.set('layer', layer);
	            _feature.set('vectorType', constant.BUSINESSTYPE.POLYGON);

	            var _style = new ol.style.Style({
	                fill: new ol.style.Fill({
	                    color: data.fillColor || 'rgba(0,0,0,0)'
	                }),
	                stroke: new ol.style.Stroke({
	                    color: data.strokeColor || '#000',
	                    width: _strokeWidth
	                }),
	                text: new ol.style.Text({
	                    text: data.label ? data.label : '',
	                    fill: new ol.style.Fill({
	                        color: data.labelFillColor || 'black'
	                    }),
	                    font: !!font ? font : 'normal 14px Arial',
	                    stroke: new ol.style.Stroke({
	                        color: data.labelStrokeColor || '#ffffff',
	                        width: _labelWidth
	                    })
	                })
	            });

	            var shapeStyle = new ol.style.Style({
	                fill: new ol.style.Fill({
	                    color: data.fillColor || 'rgba(0,0,0,0)'
	                }),
	                stroke: new ol.style.Stroke({
	                    color: data.strokeColor || '#000',
	                    width: _strokeWidth
	                })
	            });

	            _feature.setStyle(_style);
	            _feature.set('defaultStyle', _style);
	            _feature.set('shapeStyle', shapeStyle);
	            _feature.set('state.showLabel', true);
	            if (!!_geoPolygon && _geoPolygon.getArea() > 0) {
	                _features.push(_feature);
	            }
	        });

	        source.addFeatures(_features);
	    }

	}


	function highlight(olLayer, hType, params) {
	    if (olLayer) {
	        var olMap = olLayer.get('map');
	        var mapId = olMap.getTarget();
	        var layerId = olLayer.get('layer_id');
	        var layerType = olLayer.get('businessType');

	        var hLayer = highlights.getHLayer({
	            mapId: mapId,
	            layerId: layerId
	        });
	        hLayer.getSource().clear();
	        if (hType === constant.HTYPE.CLICK) {
	            if (params.feature) {
	                var _geoId = params.feature.getId();
	                var _feature = params.feature;
	                var _highLight = _feature.get('select');
	                var _data = _feature.get('data');

	                var tempFeature = _feature.clone();
	                var font = _data.fontStyle + ' ' + _data.fontSize + ' ' + _data.fontFamily;
	                var _style = new ol.style.Style({
	                    fill: new ol.style.Fill({
	                        color: _highLight.fillColor
	                    }),
	                    stroke: new ol.style.Stroke({
	                        width: _highLight.strokeWidth,
	                        color: _highLight.strokeColor
	                    }),
	                    text: new ol.style.Text({
	                        text: _data.label || '',
	                        fill: new ol.style.Fill({
	                            color: _highLight.labelFillColor
	                        }),
	                        font: !!font ? font : 'normal 14px Arial',
	                        stroke: new ol.style.Stroke({
	                            color: _highLight.labelStrokeColor,
	                            width: _data.labelStrokeWidth !== undefined ? _data.labelStrokeWidth : 1
	                        })
	                    })
	                });
	                tempFeature.setStyle(_style);
	                tempFeature.setId(_geoId);
	                tempFeature.set('mapId', mapId);
	                tempFeature.set('layerId', layerId);
	                tempFeature.set('layerType', layerType);
	                tempFeature.set('hType', hType);
	                tempFeature.set('highlightFeature', true);
	                tempFeature.set('layer',hLayer);
	                hLayer.getSource().addFeature(tempFeature);
	            }

	        }
	        else if (hType === constant.HTYPE.VECTOR) {
	        	if(params.geoIds.length > 0) {

	        		params.geoIds.map(function(geoId) {
	        			var _feature = olLayer.getSource().getFeatureById(geoId);
	        			if(!_feature) {
	        				return;
	        			}
	        			var _highlightStyle = _feature.get('select');
	        			var _data = _feature.get('data');
						var font = _data.fontStyle + ' ' + _data.fontSize + ' ' + _data.fontFamily;
	        			var _style = new ol.style.Style({
	        				fill: new ol.style.Fill({
	        					color: _highlightStyle.fillColor
	        				}),
	        				stroke: new ol.style.Stroke({
	        					width: _highlightStyle.strokeWidth,
	        					color: _highlightStyle.strokeColor
	        				}),
	        				text: new ol.style.Text({
	        					text: _data.label || '',
	        					fill: new ol.style.Fill({
	        						color: _highlightStyle.labelFillColor
	        					}),
	        					font: !!font ? font : 'normal 14px Arial',
	        					stroke: new ol.style.Stroke({
	        						color: _highlightStyle.labelStrokeColor,
	        						width: _data.labelStrokeWidth !== undefined ? _data.labelStrokeWidth : 1
	        					})
	        				})
	        			});
	        			var _tempFeature = _feature.clone();
	        			_tempFeature.setStyle(_style);
	        			_tempFeature.setId(geoId);
	        			_tempFeature.set('mapId', mapId);
	        			_tempFeature.set('layerId', layerId);
	        			_tempFeature.set('layerType', layerType);
	        			_tempFeature.set('hType', hType);
	        			_tempFeature.set('highlightFeature', true);
	                    		_tempFeature.set('layer',hLayer);
	        			hLayer.getSource().addFeature(_tempFeature);
	        		});
	        	}



	        }
	    }
	}

	function getLineLonLat(param, callback) {
	    var olLayer = layers.getLayer({
	        mapId: param.mapId,
	        layerId: param.layerId
	    });
	    if (!olLayer && param.sourceLayerType !== 'POLYGON') {
	        callback();
	        return;
	    }
	    var points =null;
	    var targetPoint_3857 = ol.proj.fromLonLat(param.targetPoint);
	    if (utils.isValid(param.coordinates)&&param.coordinates!=='') {
	        if (!(param.coordinates instanceof Array) && param.coordinates.indexOf('POLYGON') > -1) {
	            var wktCoordinate = fusiongis.Util.getWKTFromText(param.coordinates);
	            if (wktCoordinate.coordinates.length === 1
	                && wktCoordinate.coordinates[0] instanceof Array) {
	                var points_4326 = wktCoordinate.coordinates[0];
	                var points_3857 = [];
	                for (var i = 0; i < points_4326.length; i++) {
	                    points_3857.push(ol.proj.fromLonLat(points_4326[i]));
	                }
	            }
	        }

	        points = points_3857;
	    } else {
	    	var geometry = olLayer.getSource().getFeatureById(param.geoId).getGeometry();
	    	points = geometry.getCoordinates()[0]; //��ά����
	    }
	    var temp = (points[0][0] - targetPoint_3857[0]) * (points[0][0] - targetPoint_3857[0]) +
	        (points[0][1] - targetPoint_3857[1]) * (points[0][1] - targetPoint_3857[1]);
	    var distance = 0, num = 0;
	    points.forEach(function (point, i) {
	        distance = (point[0] - targetPoint_3857[0]) * (point[0] - targetPoint_3857[0]) +
	            (point[1] - targetPoint_3857[1]) * (point[1] - targetPoint_3857[1]);
	        if (temp > distance) {
	            temp = distance;
	            num = i;
	        }
	    });
	    callback(ol.proj.toLonLat(points[num]));
	}

	function setShowLabel(param) {
	    var layer = layers.getLayer(param);
	    if (!layer) {
	        return;
	    }
	    var showLabel = layer.get('state.showLabel');
	    var features = layer.getSource().getFeatures().slice(0);
	    features.forEach(function (f) {
	        if (param.showLabel && !showLabel) {
	            f.setStyle(f.get('defaultStyle'));
	        }
	        else if (!param.showLabel && showLabel) {
	            f.setStyle(f.get('shapeStyle'));
	        }
	    });
	    layer.set('state.showLabel', !!param.showLabel);
	}

	module.exports = {
	    addLayer: render,
	    setLayerData: setLayerData,
	    highlight: highlight,
	    getLineLonLat: getLineLonLat,
	    setShowLabel: setShowLabel
	};

/***/ },
/* 46 */
/*!****************************************!*\
  !*** ./src/gis/businessLayers/cell.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 加载服务栅格。
	 * 1、下发查询条件，获取ImageToken;
	 * 2、下发查询条件，export服务栅格图片。
	 *
	 *
	 */
	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var ajax = __webpack_require__(/*! utils/ajax */ 14);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);
	var event = __webpack_require__(/*! maps/event */ 11);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);

	function addLayer(paramObj) {
		var layerId = paramObj.layerId + '_' + paramObj.mapId;
		var olMap = hashMap.get(paramObj.mapId);
		var _zoom = olMap.getView().getZoom();
		var _isShow = paramObj.isShow != undefined ? paramObj.isShow : true;
		var _label = paramObj.label ? paramObj.label : paramObj.layerId;
		var olLayer = null;
		if(!hashMap.containsKey(layerId)) {
			olLayer = new ol.layer.Image({
				source: new ol.source.ImageWMS({
					params: {
						VERSION: '1.1.1'
					},
					wrapX: false
				})
			});
			if(!!paramObj.multiple) {
				olLayer.set('multiple', paramObj.multiple);
			}
			hashMap.put(layerId, olLayer);
			olMap.addLayer(olLayer);
		} else {
			olLayer = hashMap.get(layerId);
		}
		var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.CELL;
		olLayer.setZIndex(_ZIndex);
		olLayer.set('type', constant.CUSTOMTYPE.LAYERIMGTYPE);
		olLayer.set('isVectorType',false);
		olLayer.set('businessType', constant.BUSINESSTYPE.CELL);
		olLayer.set('params.label', _label);
		olLayer.set('state.showLabel', !!paramObj.showLabel);
		olLayer.set('layerId', layerId);
		olLayer.set('map', olMap);
		olLayer.set('layer_id', paramObj.layerId);
		olLayer.set('legendName', paramObj.legendName);
		olLayer.set('isShow', _isShow);
		if (paramObj.minShowLevel != undefined) {
			olLayer.set('minShowLevel', parseInt(paramObj.minShowLevel));
		}

		if (paramObj.maxShowLevel != undefined) {
			olLayer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));
		}

		olLayer.set('clickId', 'business_service_cell_event_id');
		event.addClickCallback(paramObj.mapId, 'business_service_cell_event_id', function(e) {
			if(e.layer && e.layer.get('businessType') === constant.BUSINESSTYPE.CELL) {
				var mapObj = mapBox.getMapObj(paramObj.mapId);

				var transportDataToInnerLayer = e.transportDataToInnerLayer;
				if(transportDataToInnerLayer) {
					if(!!transportDataToInnerLayer && transportDataToInnerLayer.length > 0) {
						highlight(e.layer, 'click', transportDataToInnerLayer[0]);
					}
				} else {
					highlights.removeHighlight({
						mapId: paramObj.mapId,
						layerId: paramObj.layerId,
						hTypes: ['click']
					});
				}
			}

	    }, paramObj.layerId)
	}

	/**
	 *
	 * @param paramObj = {
	 *      data: {
	 *          mapId: ''
	 *          layerId: ''
	 *          layerType: 'POLYGON'
	 *          isUserDefinedLegend: 1, 是否使用用户自定义的图例 0：是， 1：否
	 *          renderParam: {
	 *              legendInfo : {
	 *                  legendType : 'singleColor' //图例类型'singleColor' | 'rangeColor' | 'singleSymbol' | 'rangeSymbol'
	 *                  renderStyle: {String} //渲染的样式Border、Fill
	 *                  legendList : [
	 *                      {
	 *                          'label' : '较差' //单一值名称
	 *                          'value' : [string1, string2]//分段值
	 *                          'style' : '255,255,0' //RGB色值,,或者 符号文件的地址
	 *                          'count' : 1000, ///
	 *                          'percent' : 0.2 ///
	 *                      }
	 *                  ]
	 *               }
	 *          },
	 *          queryParam: {
	 *
	 *          },
	 *          geoParams: {
	 *
	 *          }
	 *      }
	 * }
	 */
	function setLayerData(paramObj) {
	    var layer = layers.getLayer(paramObj);
	    layer.set('params.imgToken', paramObj.imgToken);
	    layer.set('imgToken', paramObj.imgToken);
	    layer.set('imgTokenLabel', paramObj.imgTokenLabel);
	    layer.set('params.imgTokenLabel', paramObj.imgTokenLabel);
	    layer.set('legendName', paramObj.legendName);
	    layer.set('paramObj',paramObj);
	    if (paramObj.label) {
	        layer.set('params.label', paramObj.label);
	    }
	    layer.set('state.showLabel', !!paramObj.showLabel);
	    var imgToken = (paramObj.showLabel ? paramObj.imgTokenLabel : paramObj.imgToken);
	    var Fcname = imgToken != undefined ? imgToken.slice(0,imgToken.indexOf(':')) : undefined;
	    var updateParams = {
	        VERSION: '1.1.1',
	        imgToken: imgToken,
	        FCName:Fcname
	    };
	    if (layer) {
	        layer.getSource().setUrl(constant.GisRootUrl + '/mapRender/export');
	        layer.getSource().updateParams(updateParams);
	    }
	}

	function getClickData(olMap, olLayer, evt, callback) {
		if(!olLayer.getVisible()) {
			callback([]);
			return;
		}
		var cellPath, mapExtent, imgToken, geometry;

		if(!!evt.coordinate) {
			geometry = JSON.stringify({
				x: evt.coordinate[0],
				y: evt.coordinate[1]
			});
			mapExtent = olMap.getView().calculateExtent(olMap.getSize()).join(',');
			var Fcname = olLayer.get('params.imgToken').slice(0, olLayer.get('params.imgToken').indexOf(':'));
			var layerParamObj = olLayer.get('paramObj');
			var params = {
				geometry: geometry,
				tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  0.1,
				mapExtent: mapExtent,
				imgToken: olLayer.get('params.imgToken'),
				FCName: Fcname
			};
			cellPath = constant.GisRootUrl + '/mapRender/identify';
		}
		ajax.get({
			url: cellPath,
			data: utils.getParameterString(params),
			success: function(res) {
				if(!res) {
					callback([]);
					return;
				}
				res = JSON.parse(res);
				if(!res || !res.data || !res.data.length) {
					callback([]);
					return;
				}

				var result = utils.sortBy(res.data, function(j) {
					if(j.extentInfo.isDirect === '0') {
						j.extentInfo.radius = j.extentInfo.radius * 2;
					}
					return Number(j.extentInfo.radius);
				});
				var minRadus = result[0].extentInfo.radius;
				result = result.filter(function(item) {
					return item.extentInfo.radius === minRadus;
				});
				result.forEach(function(r) {
					if(r.extentInfo.isDirect === '0') {
						r.extentInfo.radius = r.extentInfo.radius / 2;
					}
				});
				var backJson = result.map(function(item) {
					return {
						mapId: olMap.getTarget(),
						layerId: olLayer.get('layer_id'),
						layerType: olLayer.get('businessType'),
						label: olLayer.get('params.label'),
						lonLat: item.centerPoint,
						geometry: item.geometry,
						extentInfo: item.extentInfo,
						geoId: item.id,
						geoName: item.name
					};
				});
				callback(backJson);
			},
			failure: function() {
				if(typeof callback === 'function') {
					callback([]);
				}
			}
		});
	}

	function highlight(olLayer, hType, params, callback) {
		var olMap = olLayer.get('map');
		var mapId = olMap.getTarget();
		var layerId = olLayer.get('layer_id');
		var layerType = olLayer.get('businessType');
		var nFeature;

		highlights.removeHighlight({
			mapId: mapId,
			layerId: layerId,
			hTypes: ['click']
		});
		if(hType === constant.HTYPE.CLICK) {
			var points = null;
			if($.isArray(params.geometry)) {
				points = params.geometry;
			} else { //字符串
				points = JSON.parse(params.geometry);
			}

			var _lineString = new ol.geom.LineString(points);
			_lineString = utils.transformMultArrayFrom3857(_lineString.getCoordinates());
			nFeature = new ol.Feature({
				geometry: new ol.geom.Polygon([_lineString]),
				mapId: mapId,
				layerId: layerId,
				layerType: layerType,
				hType: hType
			});

			var _style = new ol.style.Style({
				stroke: new ol.style.Stroke({
					width: 2,
					color: 'black'
				})
			});

			nFeature.setStyle(_style);
			var hLayer = highlights.getHLayer({
				mapId: mapId,
				layerId: layerId
			});
			hLayer.getSource().addFeature(nFeature);

		} else if(hType === constant.HTYPE.VECTOR) {
			queryGeometry(olLayer, params, function(result) {
				if(!result) {
					return;
				}
				var features = [];

	            var _style = new ol.style.Style({
	                stroke: new ol.style.Stroke({
	                    width: 2,
	                    color: 'black'
	                })
	            });
	            result.map(function (r) {
	                var _polygons =null;
	                if($.isArray(r.geometry)){
	                    _polygons =r.geometry;
	                }else{
	                    _polygons =JSON.parse(r.geometry);
	                }
					_polygons = utils.transformMultArrayFrom3857(_polygons);
					nFeature = new ol.Feature({
						geometry: new ol.geom.Polygon([_polygons]),
						mapId: mapId,
						layerId: layerId,
						layerType: layerType,
						hType: hType
					});
					nFeature.setStyle(_style);
					features.push(nFeature);
				});

				var hLayer = highlights.getHLayer({
					mapId: mapId,
					layerId: layerId
				});
				hLayer.getSource().addFeatures(features);
				if(callback) {
					callback(result);
				}
			});
		}
	}

	function queryGeometry(olLayer, params, callback) {
		var imgToken = olLayer.get('params.imgToken');
		var Fcname = imgToken != undefined ?  imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		var url = constant.GisRootUrl + '/mapRender/query?FCName=' + Fcname;

		ajax.postJSON({
			url: url,
			data: JSON.stringify({
				id: params.geoIds,
				imgToken: imgToken
			}),
			success: function(rs) {
				var result = JSON.parse(rs);
				if(!result || !result.data || !result.data.length) {
					callback(null);
				} else {
					callback(result.data);
				}
			},
			failure: function(e) {
				console.log(e);
				callback(null);
			}
		});
	}

	//获取连线端点的位置（经纬度）
	function getLineLonLat(param, callback) {
		var lineLngLat;
		var olLayer = layers.getLayer({
			mapId: param.mapId,
			layerId: param.layerId
		});
		if(!olLayer) {
			callback();
			return;
		}
		var geoIds = param.geoId.indexOf(',')!== -1 ? param.geoId.split(',')  : [param.geoId] ;
		queryGeometry(olLayer, {
			geoIds: geoIds
		}, function(res) {
			if(!res) {
				return;
			}
			lineLngLat = res;//res[0].extentInfo.circleCenter;
			//lineLngLat = ol.proj.fromLonLat(lineLngLat);
			callback(lineLngLat);
		});
	}

	function setShowLabel(param) {
		var layer = layers.getLayer(param);
		if(!layer) {
			return;
		}
		var imgToken;
		if(param.showLabel) {
			imgToken = layer.get('params.imgTokenLabel');
		} else {
			imgToken = layer.get('params.imgToken');
		}
		var updateParams = {
			VERSION: '1.1.1',
			imgToken: imgToken
		};
		layer.set('state.showLabel', !!param.showLabel);
		layer.getSource().updateParams(updateParams);
	}

	module.exports = {
		addLayer: addLayer,
		setLayerData: setLayerData,
		getClickData: getClickData,
		highlight: highlight,
		getLineLonLat: getLineLonLat,
		setShowLabel: setShowLabel
	};

/***/ },
/* 47 */
/*!********************************!*\
  !*** ./src/gis/layers/cell.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 小区业务
	 */
	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);
	var algorithm = __webpack_require__(/*! framework/algorithm */ 48);
	var constant = __webpack_require__(/*! framework/constant */ 2);

	/**
	 * 建议数据不要大于3000
	 * @param paramObj
	 */
	var addLayer = function (paramObj) {
	    var _layerIdentify = paramObj.layerId + '_' + paramObj.mapId;
	    var _layer = null;
	    var _mapObj = hashMap.get(paramObj.mapId);
	    var _zoom = _mapObj.getView().getZoom();

	    var isShow = paramObj.isShow != undefined ? paramObj.isShow : true;
	    if (hashMap.containsKey(_layerIdentify)) {
	        _layer = hashMap.get(_layerIdentify);
	    }
	    else {
	        baseLayer.createLayer(paramObj);
	        _layer = hashMap.get(_layerIdentify);
	    }

	    if (!!paramObj.multiple) {
	        _layer.set('multiple', paramObj.multiple);
	    }

	    _layer.set('businessType', constant.BUSINESSTYPE.VECTOR_CELL);
	    _layer.set('layer_id', paramObj.layerId);
	    _layer.set('params.label', paramObj.label!==undefined ?paramObj.label : paramObj.layerId);
	    _layer.set('isVectorType',true);
	    _layer.set('layerId', _layerIdentify);
	    var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.CELL;
	    _layer.setZIndex(_ZIndex);
	    _layer.set('hideWhenPan', paramObj.hideWhenPan);
	    _layer.set('legendName', 'mineLegendName');
	    _layer.set('isShow', isShow);
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	    }


	    _layer.set('clickId', 'vector-cell-click-event');
	    fusiongis.Events.addClickCallback(paramObj.mapId, 'vector-cell-click-event', function (obj) {
	        if (obj.layer && obj.layer.get('businessType') === constant.BUSINESSTYPE.VECTOR_CELL &&
	            obj.feature && obj.feature.get('businessType') === constant.BUSINESSTYPE.VECTOR_CELL) {

	            highlights.removeHighlight({
	                mapId: paramObj.mapId,
	                layerId: paramObj.layerId,
	                hTypes: ['click']
	            });
	            var feature = obj.feature;
	            //调用高亮的方法
	            highlight(obj.layer,'click', {mapId: paramObj.mapId, layerId: paramObj.layerId, feature: feature});
	        }
	    }, paramObj.layerId);
	    
	    setLayerData(paramObj);
	};

	var setLayerData = function (paramObj) {
	    var _layerIdentify = paramObj.layerId + '_' + paramObj.mapId;
	    var _layer = hashMap.get(_layerIdentify);
	    var _glbSource = _layer.getSource();
	    var _features = [];
	    var _datas = paramObj.datas;
	    var legendInfo = paramObj.legendInfo;
	    var legendData = {};
	    if (!!legendInfo) {
	        var requestParam = {
	            mapId: paramObj.mapId,
	            layerId: paramObj.layerId,
	            legendInfo: legendInfo,
	            label: legendInfo.legendName,
	            businessType: constant.BUSINESSTYPE.CELL
	        };
	        legendData = legendInfo.legendList;
	        if (!!paramObj.legendInfo) {
	            if (!!paramObj.legendInfo.legendName) {
	                _layer.set('legendName', paramObj.legendInfo.legendName);
	            }
	        }
	        fusiongis.Legend.createLegend(requestParam);
	    }
	    _layer.set('datas', _datas);
	    _layer.set('noChangeRadius', paramObj.noChangeRadius);
	    _layer.set('legendData', legendData);

	    var _mapObj = hashMap.get(paramObj.mapId);
	    if (utils.isValid(_datas) && _datas.length > 0) {
	        if (_datas.length > 3000) {
	            console.warn("建议数据量控制在3000，大于3000建议使用服务类型小区！！");
	        }


	        for (var i = _datas.length - 1; i > 0; i--) {
	            for (var j = 0; j < i; j++) {
	                if (_datas[i].azimuth === _datas[j].azimuth) {
	                    if (_datas[i].radius > _datas[j].radius) {
	                        var temp = _datas[i];
	                        _datas[i] = _datas[j];
	                        _datas[j] = temp;
	                    }
	                }

	            }
	        }


	        _datas.forEach(function (cellData, index, _datas) {
	            var _cellType = cellData.cellType ? cellData.cellType : "sector";
	            var _coordinate = utils.gcjTransform(cellData.coordinate);
	            var _lon = _coordinate[0];
	            var _lat = _coordinate[1];
	            var _strokeWidth = cellData.strokeWidth !== undefined ? cellData.strokeWidth : 2;
	            if (_lon > 180 || _lon < -180) {
	                console.warn("经度需要大于等于-180，且小于等于180！！");
	                return false;
	            }
	            if (_lat > 90 || _lat < -90) {
	                console.warn("纬度需要大于等于-90，且小于等于90！！");
	                return false;
	            }
	            var _radius = cellData.radius;
	            if (_radius <= 0) {
	                console.warn("小区半径必须大于0！！");
	                return false;
	            }
	            var _azimuth = cellData.azimuth;
	            if (_azimuth < 0 || _azimuth > 360) {
	                console.warn("小区方位角必须大于等于0， 或者小于等于360！！");
	                return false;
	            }

	            var _angle = cellData.angle;
	            if (_angle <= 0 || _angle > 360) {
	                console.warn("小区角度必须大于0，小于等于360！！");
	                return false;
	            }
	            var _linearRing;
	            if (paramObj.noChangeRadius) {
	                _radius = _radius ? _radius : 40;
	                var pixel = _mapObj.getPixelFromCoordinate(ol.proj.fromLonLat(cellData.coordinate));
	                var _pixelList, _coordinates = [];
	                if (_cellType === 'arrow') {
	                    _pixelList = algorithm.createArrow(pixel[0], pixel[1], _radius, _azimuth, _angle);
	                }
	                else if (_cellType === 'sector') {
	                    _pixelList = algorithm.createSector(pixel[0], pixel[1], _radius, _azimuth, _angle);
	                }
	                else if (_cellType === 'triangle') {
	                    _pixelList = algorithm.createTriangle(pixel[0], pixel[1], _radius, _azimuth, _angle);
	                }
	                for (var k = 0; k < _pixelList.length; k++) {
	                    _coordinates.push(_mapObj.getCoordinateFromPixel(_pixelList[k]))
	                }
	                _linearRing = new ol.geom.LinearRing(_coordinates);
	            }
	            else {
	                _radius = _radius ? _radius : 4000;
	                var _coordinate3857 = ol.proj.fromLonLat([_lon, _lat]);
	                var _coordinates;
	                if (_cellType === 'arrow') {
	                    _coordinates =
	                        algorithm.createArrow(_coordinate3857[0], _coordinate3857[1], _radius, _azimuth, _angle);
	                }
	                else if (_cellType === 'sector') {
	                    _coordinates =
	                        algorithm.createSector(_coordinate3857[0], _coordinate3857[1], _radius, _azimuth, _angle);
	                }
	                else if (_cellType === 'triangle') {
	                    _coordinates =
	                        algorithm.createTriangle(_coordinate3857[0], _coordinate3857[1], _radius, _azimuth, _angle);
	                }
	                _linearRing = new ol.geom.LinearRing(_coordinates);
	            }
	            var ring = _linearRing.getCoordinates();
	            var _polygon = null;
	            if (_angle === 360) {
	                var pointRadius = cellData.pointRadius || 0;
	                _polygon = new ol.geom.GeometryCollection();
	                ring.splice(0, 2);
	                ring.splice(ring.length - 1, 2);
	                _polygon.setGeometries([new ol.geom.Circle(ol.proj.fromLonLat([_lon, _lat]), pointRadius), new ol.geom.Polygon([ring])]);
	            } else {
	                _polygon = new ol.geom.Polygon([ring]);

	            }


	            var lData = _layer.get('legendData');
	            if (!!legendInfo) {
	                if (legendInfo.legendType === 'singleColor') {
	                    for (var i = 0, len = lData.length; i < len; i++) {
	                        var singleFlag =false;
	                        if(lData[i].value[0] !==''){
	                            if (parseFloat(lData[i].value[0]) === parseFloat(cellData.value)) {
	                                singleFlag =true;
	                            }
	                        }else{
	                            singleFlag=true;
	                        }
	                        if (singleFlag) {
	                            if (lData[i].fillColor) {
	                                var fillArr = lData[i].fillColor.split(',');
	                                var borderArr = lData[i].borderColor.split(',');
	                                cellData.fillColor = fillArr.length === 3 ? 'rgb(' + lData[i].fillColor + ')' : 'rgba(' + lData[i].fillColor + ')';
	                                cellData.strokeColor = borderArr.length === 3 ? 'rgb(' + lData[i].borderColor + ')' : 'rgba(' + lData[i].borderColor + ')';
	                                cellData.strokeWidth = lData[i].borderWidth;
	                                break;
	                            } else {
	                                if(lData[i].style){
	                                    var styleArr = lData[i].style.split(',');
	                                    if (styleArr.length === 3) {
	                                        cellData.fillColor = 'rgb(' + lData[i].style + ')';
	                                        cellData.strokeColor = 'rgb(' + lData[i].style + ')';
	                                        cellData.strokeWidth = 3;
	                                        break;
	                                    } else if (styleArr.length === 4) {
	                                        cellData.fillColor = 'rgba(' + lData[i].style + ')';
	                                        cellData.strokeColor = 'rgba(' + lData[i].style + ')';
	                                        cellData.strokeWidth = 3;
	                                        break;
	                                    }
	                                }

	                            }
	                        }
	                    }
	                }
	                if (legendInfo.legendType === 'rangeColor') {
	                    for (var i = 0, len = lData.length; i < len; i++) {
	                        var isFlag =false;
	                        //如果图例是区间值类型，有三种情况
	                        if(lData[i].value[0]!=='' && lData[i].value[1]===''){
	                            //起始值已填结束值没填即0到正无穷
	                            if (parseFloat(cellData.value) >=parseFloat(lData[i].value[0])) {
	                                isFlag =true;
	                            }
	                        }else if(lData[i].value[0]==='' && lData[i].value[1]!==''){
	                            //起始值没填结束值已填即负无穷到指定值
	                            if(parseFloat(cellData.value)<=parseFloat(lData[i].value[1])){
	                                isFlag =true;
	                            }
	                        }else if(parseFloat(cellData.value) <= parseFloat(lData[i].value[1])
	                            && parseFloat(cellData.value) >= parseFloat(lData[i].value[0])){
	                            //起始值和结束值都填写
	                            isFlag = true;

	                        }else{//起始值和结束值都没填即负无穷到正无穷
	                            isFlag =true;
	                        }
	                        if (isFlag) {
	                            if (lData[i].fillColor) {
	                                var fillArr = lData[i].fillColor.split(',');
	                                var borderArr = lData[i].borderColor.split(',');
	                                cellData.fillColor = fillArr.length === 3 ? 'rgb(' + lData[i].fillColor + ')' : 'rgba(' + lData[i].fillColor + ')';
	                                cellData.strokeColor = borderArr.length === 3 ? 'rgb(' + lData[i].borderColor + ')' : 'rgba(' + lData[i].borderColor + ')';
	                                cellData.strokeWidth = lData[i].borderWidth;
	                                break;
	                            } else {
	                                if(lData[i].style){
	                                    var styleArr = lData[i].style.split(',');
	                                    if (styleArr.length === 3) {
	                                        cellData.fillColor = 'rgb(' + lData[i].style + ')';
	                                        cellData.strokeColor = 'rgb(' + lData[i].style + ')';
	                                        cellData.strokeWidth = 3;
	                                        break;
	                                    } else if (styleArr.length === 4) {
	                                        cellData.fillColor = 'rgba(' + lData[i].style + ')';
	                                        cellData.strokeColor = 'rgba(' + lData[i].style + ')';
	                                        cellData.strokeWidth = 3;
	                                        break;
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }


	            var defaultHighLight = {
	            	fillColor: cellData.fillColor,
	            	strokeColor: 'black',
	            	strokeWidth: _strokeWidth,
	            	labelFillColor: cellData.labelFillColor || 'black',
	            	labelStrokeColor: cellData.labelStrokeColor || '#ffffff',
	            	label: cellData.label !== undefined ? cellData.label : '',
	            	radius: cellData.radius || 5
	            };

	            var _feature = new ol.Feature({
	                geometry: _polygon,
	                businessType: constant.BUSINESSTYPE.VECTOR_CELL,
	                data: cellData,
	                select: cellData.hightLight ? cellData.hightLight :defaultHighLight
	            });

	            if(cellData.hightLight){
	                for(var index in defaultHighLight){
	                    cellData.hightLight[index] ?  cellData.hightLight[index] : cellData.hightLight[index]= defaultHighLight[index];
	                }
	            }

	            _feature.setId(cellData.id);
	            _feature.set('data', cellData);
	            _feature.set('layer', _layer);
	            _feature.set('vectorType', constant.BUSINESSTYPE.VECTOR_CELL);

	            var _style = new ol.style.Style({
	                fill: new ol.style.Fill({
	                    color: cellData.fillColor || '#836FFF'
	                }),
	                stroke: new ol.style.Stroke({
	                    color: cellData.strokeColor || '#76EEC6',
	                    width: cellData.strokeWidth || 2
	                }),
	                text: new ol.style.Text({
	                    text: (cellData.label!==undefined ? cellData.label : '').toString()
	                })
	            });
	            _feature.setStyle(_style);
	            _feature.set('defaultStyle', _style);

	            _features.push(_feature);

	        });
	        if (typeof _glbSource.addFeatures === 'function') {
	        	_glbSource.addFeatures(_features);	
	        }
	    }
	};

	var highlight =function(olLayer,hType,param){
	    if(olLayer){
	        var olMap = olLayer.get('map');
	        var mapId = olMap.getTarget();
	        var layerId = olLayer.get('layer_id');
	        var layerType = olLayer.get('businessType');

	        highlights.removeHighlight({
	            mapId: mapId,
	            layerId: layerId,
	            hTypes: [hType]
	        });
	        var hLayer = highlights.getHLayer({
	            mapId: mapId,
	            layerId: layerId
	        });

	        if (hType === constant.HTYPE.CLICK) {
	            if(param.feature){
	                var geoId =param.feature.getId();
	                var feature =param.feature;
	                var highLight = param.feature.get('select');
	                var tempFeature = feature.clone();

	                var _style = new ol.style.Style({
	                    fill: new ol.style.Fill({
	                        color: highLight.fillColor || '#836FFF'
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color:highLight.strokeColor,
	                        width: highLight.strokeWidth || 2
	                    }),
	                    text: new ol.style.Text({
	                        text: (highLight.label!==undefined ? highLight.label : '').toString()
	                    })
	                });
	                tempFeature.setStyle(_style);
	                tempFeature.setId(geoId);
	                tempFeature.set('mapId', mapId);
	                tempFeature.set('layerId', layerId);
	                tempFeature.set('layerType', layerType);
	                tempFeature.set('hType', hType);
	                tempFeature.set('highlightFeature', true);
	                //数组copy
	                hLayer.getSource().addFeature(tempFeature);
	            }
	        } else if (hType === constant.HTYPE.VECTOR) {
	            var features=param.geoIds.map(function (geoId) {
	                var feature = olLayer.getSource().getFeatureById(geoId);
	                var highLight = feature.get('select');
	                var tempFeature = feature.clone();
	                var _style = new ol.style.Style({
	                    fill: new ol.style.Fill({
	                        color: highLight.fillColor || '#836FFF'
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color:highLight.strokeColor,
	                        width: highLight.strokeWidth || 2
	                    }),
	                    text: new ol.style.Text({
	                        text: (highLight.label!==undefined ? highLight.label : '').toString()
	                    })
	                });
	                tempFeature.setStyle(_style);
	                tempFeature.setId(geoId);
	                tempFeature.set('mapId', mapId);
	                tempFeature.set('layerId', layerId);
	                tempFeature.set('layerType', layerType);
	                tempFeature.set('hType', hType);
	                tempFeature.set('highlightFeature', true);
	                return tempFeature;
	            });
	            hLayer.getSource().addFeatures(features);
	        }
	    }
	};

	var clear = function (paramObj) {
	    var layerObj = fusiongis.BaseLayer.getLayer(paramObj);
	    if (!!layerObj && !!layerObj.getSource()) {
	        layerObj.getSource().clear();
	    }
	};

	module.exports = {
	    addCell: addLayer,
	    addLayer: addLayer,
	    setLayerData: setLayerData,
	    highlight: highlight,
	    clear: clear
	};


/***/ },
/* 48 */
/*!****************************************!*\
  !*** ./src/gis/framework/algorithm.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var utils = __webpack_require__(/*! utils/util */ 1);

	/**
	 * 三叶草扇形图形的绘制, 正北方为0,方向角度数为顺时钟旋转，5度定一个点来计算边数。
	 * @param originx 小区所在位置经度
	 * @param originy 小区所在位置纬度
	 * @param radius 小区扇瓣半径
	 * @param rotation 小区的方位角
	 * @param angleRange 小区扇瓣的角度范围
	 *
	 */
	var createSector = function (originx, originy, radius, rotation, angleRange) {
	    var finalRadius = radius;
	    var anglePerPoint = 5;
	    var sides = angleRange / anglePerPoint;
	    var angle = anglePerPoint * Math.PI / 180;
	    var rotatedAngle = Math.PI / 2 - (rotation + angleRange / 2) / 180 * Math.PI;
	    var x, y;
	    var coordinates = [];
	    coordinates.push([originx, originy]);
	    for (var i = 0; i < sides + 1; i++) {
	        x = originx + finalRadius * Math.cos(rotatedAngle);
	        y = originy + finalRadius * Math.sin(rotatedAngle);
	        coordinates.push([x, y]);
	        rotatedAngle += angle;
	    }
	    coordinates.push([originx, originy]);
	    return coordinates;
	};

	/**
	 * 三角形小区。
	 * @param originx 小区所在位置x
	 * @param originy 小区所在位置y
	 * @param radius 小区扇瓣半径
	 * @param rotation 小区的方位角
	 * @param angleRange 小区扇瓣的角度范围
	 *
	 */
	var createTriangle = function (originx, originy, radius, rotation, angleRange) {
	    var coordinates = [];
	    coordinates.push([originx, originy]);
	    var finalRadius = radius;
	    var rotatedAngle = Math.PI / 2 - (rotation + angleRange / 2) / 180 * Math.PI;
	    var x1 = originx + finalRadius * Math.cos(rotatedAngle);
	    var y1 = originy + finalRadius * Math.sin(rotatedAngle);
	    coordinates.push([x1, y1]);
	    rotatedAngle = Math.PI / 2 - (rotation - angleRange / 2) / 180 * Math.PI;
	    var x2 = originx + finalRadius * Math.cos(rotatedAngle);
	    var y2 = originy + finalRadius * Math.sin(rotatedAngle);
	    coordinates.push([x2, y2]);
	    coordinates.push([originx, originy]);
	    return coordinates;
	};
	/**
	 * 箭头小区。
	 * @param originx 小区所在位置经度
	 * @param originy 小区所在位置纬度
	 * @param radius 小区半径
	 * @param rotation 小区的方位角
	 * @param angleRange 小区的角度范围
	 *
	 */
	var createArrow = function (originx, originy, radius, rotation, angleRange) {
	    var finalRadius = radius;
	    var arrowCoordinates = [];
	    //箭头左边点
	    var rotatedAngle = Math.PI / 2 - (rotation + angleRange / 2) / 180 * Math.PI;
	    var x1 = originx + finalRadius / 2 * Math.cos(rotatedAngle);
	    var y1 = originy + finalRadius / 2 * Math.sin(rotatedAngle);
	    //箭头右边点
	    rotatedAngle = Math.PI / 2 - (rotation - angleRange / 2) / 180 * Math.PI;
	    var x2 = originx + finalRadius / 2 * Math.cos(rotatedAngle);
	    var y2 = originy + finalRadius / 2 * Math.sin(rotatedAngle);
	    rotatedAngle = Math.PI / 2 - rotation / 180 * Math.PI;
	    //箭头顶点
	    var x3 = originx + finalRadius * Math.cos(rotatedAngle);
	    var y3 = originy + finalRadius * Math.sin(rotatedAngle);
	    //箭头下部点
	    var x4 = originx + finalRadius / 2 * Math.cos(rotatedAngle);
	    var y4 = originy + finalRadius / 2 * Math.sin(rotatedAngle);
	    arrowCoordinates.push([originx, originy]);
	    arrowCoordinates.push([x4, y4]);
	    arrowCoordinates.push([x2, y2]);
	    arrowCoordinates.push([x3, y3]);
	    arrowCoordinates.push([x1, y1]);
	    arrowCoordinates.push([x4, y4]);
	    arrowCoordinates.push([originx, originy]);
	    return arrowCoordinates;

	};

	var wgs84Sphere = new ol.Sphere(6378137);
	var u = utils;

	/**
	 * 计算两个坐标点之间的距离，坐标系为EPSG:4326
	 * @param coordinates
	 * @returns {number}
	 */
	function calcLength(coordinates) {
	    if (!coordinates || !u.isArray(coordinates)) {
	        return 0;
	    }
	    var c1 = coordinates[0];
	    var c2 = coordinates[1];
	    if (!c1 || !c2) {
	        return 0;
	    }
	    return wgs84Sphere.haversineDistance(ol3Coordinate(c1), ol3Coordinate(c2));
	}

	/**
	 * 计算几个坐标点围成的面积，坐标系为EPSG:4326
	 * @param coordinates
	 */
	function calcArea(coordinates) {
	    if (!coordinates || !u.isArray(coordinates)) {
	        return 0;
	    }
	    var tc = [], l = coordinates.length;
	    for (var i = 0; i < l; i++) {
	        tc.push(ol3Coordinate(coordinates[i]));
	    }
	    return wgs84Sphere.geodesicArea(tc);
	}

	/**
	 * 将入参转换为openlayers中的coordinate
	 * @param c
	 * @returns {ol.Coordinate}
	 */
	function ol3Coordinate(c) {
	    if (u.isArray(c) && c.length === 2 && u.isFinite(c[0]) && u.isFinite(c[1])) {
	        return [Number(c[0]), Number(c[1])];
	    }
	    else if (u.isObject(c) && u.isFinite(c.lon) && u.isFinite(c.lat)) {
	        return [Number(c.lon), Number(c.lat)];
	    }
	    else if (u.isObject(c) && u.isFinite(c.longitude) && u.isFinite(c.latitude)) {
	        return [Number(c.longitude), Number(c.latitude)];
	    }
	    else {
	        return null;
	    }
	}

	/**
	 * 判断画多边形是否有交叉
	 * @param line1StartX
	 * @param line1StartY
	 * @param line1EndX
	 * @param line1EndY
	 * @param line2StartX
	 * @param line2StartY
	 * @param line2EndX
	 * @param line2EndY
	 * @return {*}
	 * */
	function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
	    // if the lines intersect, the result contains the x and y
	    // of the intersection (treating the lines as infinite)
	    // and booleans for whether line segment 1 or line segment 2 contain the point
	    var denominator, a, b, numerator1, numerator2, result = {
	        x: null,
	        y: null,
	        onLine1: false,
	        onLine2: false
	    };
	    denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) -
	        ((line2EndX - line2StartX) * (line1EndY - line1StartY));
	    if (denominator === 0) {
	        if (result.x !== null && result.y !== null) {
	            return result;
	        }
	        else {
	            return false;
	        }
	    }
	    a = line1StartY - line2StartY;
	    b = line1StartX - line2StartX;
	    numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);
	    numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);
	    a = numerator1 / denominator;
	    b = numerator2 / denominator;

	    // if we cast these lines infinitely in both directions, they intersect here:
	    result.x = line1StartX + (a * (line1EndX - line1StartX));
	    result.y = line1StartY + (a * (line1EndY - line1StartY));

	    // if line1 is a segment and line2 is infinite, they intersect if:
	    if (a > 0 && a < 1) {
	        result.onLine1 = true;
	    }
	    // if line2 is a segment and line1 is infinite, they intersect if:
	    if (b > 0 && b < 1) {
	        result.onLine2 = true;
	    }
	    // if line1 and line2 are segments, they intersect if both of the above are true
	    if (result.onLine1 && result.onLine2) {
	        return [result.x, result.y];
	    }
	    else {
	        return false;
	    }
	}

	/**
	 * 检测点集所代表的多边形是否交叉
	 * @param coordinates
	 * @return {{points: Array, cross: boolean}}
	 * */
	function checkGeometryCross(coordinates) {
	    var results = {points: [], cross: false};
	    coordinates.forEach(function (ring1) {
	        coordinates.forEach(function (ring2) {
	            for (var i = 0; i < ring1.length - 1; i++) {
	                for (var k = 0; k < ring2.length - 1; k++) {
	                    var intersection = lineIntersects(ring1[i][0], ring1[i][1],
	                        ring1[i + 1][0], ring1[i + 1][1],
	                        ring2[k][0], ring2[k][1], ring2[k + 1][0], ring2[k + 1][1]);
	                    if (intersection) {
	                        results.cross = true;
	                        results.points.push([intersection[0], intersection[1]]);
	                    }
	                }
	            }
	        });
	    });
	    return results;
	}

	module.exports = {
	    checkGeometryCross: checkGeometryCross,
	    createSector: createSector,
	    createArrow: createArrow,
	    createTriangle:createTriangle,
	    calcLength: calcLength,
	    calcArea: calcArea
	};

/***/ },
/* 49 */
/*!****************************************!*\
  !*** ./src/gis/businessLayers/site.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 加载服务栅格。
	 * 1、下发查询条件，获取ImageToken;
	 * 2、下发查询条件，export服务栅格图片。
	 *
	 *
	 */
	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var ajax = __webpack_require__(/*! utils/ajax */ 14);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);
	var event = __webpack_require__(/*! maps/event */ 11);

	function addLayer(paramObj) {
		var layerId = paramObj.layerId + '_' + paramObj.mapId;
		var olMap = mapBox.getMapObj(paramObj.mapId);
		var _zoom = olMap.getView().getZoom();
		var isShow = paramObj.isShow != undefined ? paramObj.isShow : true;
		var _label = paramObj.label ? paramObj.label : paramObj.layerId;
		var olLayer = null;
		if(!hashMap.containsKey(layerId)) {
			olLayer = new ol.layer.Image({
				source: new ol.source.ImageWMS({
					params: {
						VERSION: '1.1.1'
					},
					wrapX: false
				})
			});
			hashMap.put(layerId, olLayer);
			olMap.addLayer(olLayer);
		} else {
			olLayer = hashMap.get(layerId);
		}
		var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.SITE;
		olLayer.setZIndex(_ZIndex);
		olLayer.set('type', constant.CUSTOMTYPE.LAYERIMGTYPE);
		olLayer.set('businessType', constant.BUSINESSTYPE.SITE);
		olLayer.set('params.label', _label);
		olLayer.set('state.showLabel', !!paramObj.showLabel);
		olLayer.set('isVectorType',false);
		olLayer.set('layerId', layerId);
		olLayer.set('map', olMap);
		olLayer.set('layer_id', paramObj.layerId);
		olLayer.set('multiple', paramObj.multiple);
		olLayer.set('legendName', paramObj.legendName);
		olLayer.set('isShow', isShow);
		if (paramObj.minShowLevel != undefined) {
			_layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
		}

		if (paramObj.maxShowLevel != undefined) {
			_layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));
		}

		olLayer.set('clickId', 'business_service_site_event_id');
		event.addClickCallback(paramObj.mapId, 'business_service_site_event_id', function(e) {
			if(e.layer && e.layer.get('businessType') === constant.BUSINESSTYPE.SITE) {
				var mapObj = mapBox.getMapObj(paramObj.mapId);

				var transportDataToInnerLayer = e.transportDataToInnerLayer;
				if(transportDataToInnerLayer) {
					if(!!transportDataToInnerLayer && transportDataToInnerLayer.length > 0) {
						highlight(e.layer, 'click', transportDataToInnerLayer[0]);
					}
				} else {
					highlights.removeHighlight({
						mapId: paramObj.mapId,
						layerId: paramObj.layerId,
						hTypes: ['click']
					});
				}
			}
		}, paramObj.layerId)
	}

	/**
	 *
	 * @param paramObj = {
	 *      data: {
	 *          mapId: ''
	 *          layerId: ''
	 *          layerType: 'POLYGON'
	 *          isUserDefinedLegend: 1, 是否使用用户自定义的图例 0：是， 1：否
	 *          renderParam: {
	 *              legendInfo : {
	 *                  legendType : 'singleColor' //图例类型'singleColor' | 'rangeColor' | 'singleSymbol' | 'rangeSymbol'
	 *                  renderStyle: {String} //渲染的样式Border、Fill
	 *                  legendList : [
	 *                      {
	 *                          'label' : '较差' //单一值名称
	 *                          'value' : [string1, string2]//分段值
	 *                          'style' : '255,255,0' //RGB色值,,或者 符号文件的地址
	 *                          'count' : 1000, ///
	 *                          'percent' : 0.2 ///
	 *                      }
	 *                  ]
	 *               }
	 *          },
	 *          queryParam: {
	 *
	 *          },
	 *          geoParams: {
	 *
	 *          }
	 *      }
	 * }
	 */
	function setLayerData(paramObj) {
		var layer = layers.getLayer(paramObj);
		layer.set('params.imgToken', paramObj.imgToken);
		layer.set('params.imgTokenLabel', paramObj.imgTokenLabel);
		layer.set('state.showLabel', !!paramObj.showLabel);
		layer.set('legendName', paramObj.legendName);
		layer.set('paramObj',paramObj);
		if(paramObj.label) {
			layer.set('params.label', paramObj.label);
		}
		var imgToken = (paramObj.showLabel ? paramObj.imgTokenLabel : paramObj.imgToken);
		var Fcname = imgToken.slice(0, imgToken.indexOf(':'));
		var updateParams = {
			VERSION: '1.1.1',
			imgToken: imgToken,
			Fcname: Fcname
		};
		if(layer) {
			layer.getSource().setUrl(constant.GisRootUrl + '/mapRender/export');
			layer.getSource().updateParams(updateParams);
		}
	}

	function getClickData(olMap, olLayer, evt, callback) {
		if(!olLayer.getVisible()) {
			callback([]);
			return;
		}
		var sitePath, mapExtent, imgToken, geometry;

		imgToken = olLayer.get('params.imgToken');

		var Fcname = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;

		sitePath = constant.GisRootUrl + '/mapRender/identify';
		geometry = JSON.stringify({
			x: evt.coordinate[0],
			y: evt.coordinate[1]
		});
		mapExtent = olMap.getView().calculateExtent(olMap.getSize()).join(',');
		var layerParamObj = olLayer.get('paramObj');
		var params = {
			geometry: geometry,
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  1,
			mapExtent: mapExtent,
			imgToken: olLayer.get('params.imgToken'),
			FCName: Fcname
		};
		ajax.get({
			url: sitePath,
			data: utils.getParameterString(params),
			success: function(res) {
				if(!res) {
					callback([]);
					return;
				}
				res = JSON.parse(res);
				if(!res || !res.data || !res.data.length) {
					callback([]);
					return;
				}

				var result = res.data;
				var backJSON = result.map(function(item) {
					return {
						mapId: olMap.getTarget(),
						layerId: olLayer.get('layer_id'),
						layerType: olLayer.get('businessType'),
						label: olLayer.get('params.label'),
						lonLat: evt.coordinate,
						geometry: item.geometry,
						geoId: item.id,
						geoName: item.name
					};
				});

				callback(backJSON);
			},
			failure: function(res) {
				callback([]);
			}
		});
	}

	function highlight(olLayer, hType, params, callback) {
		var olMap = olLayer.get('map');
		var mapId = olMap.getTarget();
		var layerId = olLayer.get('layer_id');
		var layerType = olLayer.get('businessType');
		var nFeature;

		highlights.removeHighlight({
			mapId: mapId,
			layerId: layerId
		});
		if(hType === constant.HTYPE.CLICK) {
			var points = utils.transformMultArray(params.geometry);
			nFeature = new ol.Feature({
				geometry: new ol.geom.Point(points),
				mapId: mapId,
				layerId: layerId,
				layerType: layerType,
				hType: hType
			});

			var _style = new ol.style.Style({
				image: new ol.style.Circle({
					stroke: new ol.style.Stroke({
						width: 2,
						color: '#000'
					}),
					radius: 5
				})
			});

			nFeature.setStyle(_style);
			var hLayer = highlights.getHLayer({
				mapId: mapId,
				layerId: layerId
			});
			nFeature.set('layer',hLayer);
			hLayer.getSource().addFeature(nFeature);

		} else if(hType === constant.HTYPE.VECTOR) {
			queryGeometry(olLayer, params, function(result) {
				var points;
				if(!result) {
					return;
				}
				//适配高德地图火星坐标系
				points = utils.transformMultArray(result[0].geometry);
				nFeature = new ol.Feature({
					geometry: new ol.geom.Point(points),
					mapId: mapId,
					layerId: layerId,
					layerType: layerType,
					hType: hType
				});

				var _style = new ol.style.Style({
					image: new ol.style.Circle({
						stroke: new ol.style.Stroke({
							width: 2,
							color: '#000'
						}),
						radius: 5
					})
				});

				nFeature.setStyle(_style);
				var hLayer = highlights.getHLayer({
					mapId: mapId,
					layerId: layerId
				});
				nFeature.set('layer',hLayer);
				hLayer.getSource().addFeature(nFeature);
				if(callback) {
					callback(result);
				}
			});
		}
	}

	function queryGeometry(olLayer, params, callback) {
		var imgToken = olLayer.get('params.imgToken');
		var Fcname = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		var action = constant.GisRootUrl + '/mapRender/query?FCName=' + Fcname;

		ajax.postJSON({
			url: action,
			data: JSON.stringify({
				id: params.geoIds,
				imgToken: imgToken
			}),
			success: function(rs) {
				var result = JSON.parse(rs);
				if(!result || !result.data || !result.data.length) {
					callback(null);
				} else {
					callback(result.data);
				}
			},
			failure: function(e) {
				callback(null);

			}
		});
	}

	//获取连线端点的位置（经纬度）
	function getLineLonLat(param) {
		var lineLngLat;
		var olLayer = layers.getLayer({
			mapId: param.mapId,
			layerId: param.sourceLayerId
		});
		if(!olLayer) {
			return;
		}
		queryGeometry(olLayer, {
			geoIds: param.layerId,
			imgToken: olLayer.get('params.imgToken')
		}, function(res) {
			if(!res) {
				return;
			}
			lineLngLat = res.extentInfo.circleCenter;
		});
		return lineLngLat;
	}

	function setShowLabel(param) {
		var layer = layers.getLayer(param);
		if(!layer) {
			return;
		}
		var imgToken;
		if(param.showLabel) {
			imgToken = layer.get('params.imgTokenLabel');
		} else {
			imgToken = layer.get('params.imgToken');
		}
		var updateParams = {
			VERSION: '1.1.1',
			imgToken: imgToken
		};
		layer.set('state.showLabel', !!param.showLabel);
		layer.getSource().updateParams(updateParams);
	}

	module.exports = {
		addLayer: addLayer,
		setLayerData: setLayerData,
		getClickData: getClickData,
		highlight: highlight,
		getLineLonLat: getLineLonLat,
		setShowLabel: setShowLabel
	};

/***/ },
/* 50 */
/*!****************************************!*\
  !*** ./src/gis/businessLayers/grid.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var maps = __webpack_require__(/*! maps/map */ 8);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var ajax = __webpack_require__(/*! utils/ajax */ 14);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);
	var event = __webpack_require__(/*! maps/event */ 11);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var addLayer = function(paramObj) {
		var _layerId = paramObj.layerId + '_' + paramObj.mapId;
		var _map = hashMap.get(paramObj.mapId);
		var _zoom = _map.getView().getZoom();
		var _isShow = paramObj.isShow != undefined ? paramObj.isShow : true;
		var _label = paramObj.label ? paramObj.label : paramObj.layerId;
		var type = paramObj.gridType === undefined ? 1 : paramObj.gridType;
		var _layer = null;
		if(!hashMap.containsKey(_layerId)) {
			if(type === 1) {
				_layer = new ol.layer.Tile({
					source: new ol.source.TileWMS({
						wrapX: false
					})
				});
			} else {
				_layer = new ol.layer.Image({
					source: new ol.source.ImageWMS({
						wrapX: false
					})
				});
			}

			if(!!paramObj.multiple) {
				_layer.set('multiple', paramObj.multiple);
			}
			hashMap.put(_layerId, _layer);
	        _map.addLayer(_layer);
		} else {
			_layer = hashMap.get(_layerId);
		}
	    var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.GRID;
	    _layer.setZIndex(_ZIndex);
	    _layer.set('type', constant.CUSTOMTYPE.LAYERTILETYPE);
	    _layer.set('businessType', constant.BUSINESSTYPE.GRID);
	    _layer.set('isVectorType', false);
	    _layer.set('params.label', _label);
	    _layer.set('layerId', _layerId);
	    _layer.set('map', _map);
	    _layer.set('layer_id', paramObj.layerId);
	    _layer.set('clickId', 'business_grid_event_id');
	    _layer.set('legendName', paramObj.legendName);
	    _layer.set('isShow', _isShow);
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));
	    }

		event.addClickCallback(paramObj.mapId, 'business_grid_event_id', function(object) {
			var layer = baseLayer.getLayer({
				mapId: paramObj.mapId,
				layerId: paramObj.layerId
			});
			if(layer && layer.get('gridType') !== 8) {
				var mapObj = mapBox.getMapObj(paramObj.mapId);

				var transportDataToInnerLayer = object.transportDataToInnerLayer;
				if(transportDataToInnerLayer) {
					if(!!transportDataToInnerLayer && transportDataToInnerLayer.length > 0) {
						highlight(layer, 'click', transportDataToInnerLayer[0]);
					}
				} else {
					highlights.removeHighlight({
						mapId: paramObj.mapId,
						layerId: paramObj.layerId,
						hTypes: ['click']
					});
				}
			}
		}, paramObj.layerId)
	};

	var setLayerData = function(paramObj) {
		var _imgTokenParam = paramObj.imgTokenParam;
		var _imgToken = paramObj.imgToken;
		var _mapId = paramObj.mapId;
		var _layerId = paramObj.layerId;
		var _gridType = paramObj.gridType ? paramObj.gridType : 1;
		var _layers = paramObj.layers ? paramObj.layers : undefined;
		var _isSolidGrid = paramObj.ISSOLIDGRID;
		var layer = layers.getLayer({
			mapId: _mapId,
			layerId: _layerId
		});

		if(layer) {
			var source;
			if(paramObj.label) {
				layer.set('label', paramObj.label);
			}
			if(_gridType === 8 || _isSolidGrid === false) {
				source = new ol.source.ImageWMS({
					url: constant.GisRootUrl + '/gridManager/export',
					params: {
						GRIDTYPE: _gridType,
						LAYERS: _layers,
						IMGTOKEN: _imgToken,
						VERSION: '1.1.1',
						ISSOLIDGRID: _isSolidGrid,
						cacheKey: _imgToken
					},
					wrapX: false
				});
			} else {
				source = new ol.source.TileWMS({
					url: constant.GisRootUrl + '/gridManager/export',
					params: {
						GRIDTYPE: _gridType,
						LAYERS: _layers,
						IMGTOKEN: _imgToken,
						VERSION: '1.1.1',
						ISSOLIDGRID: _isSolidGrid,
						cacheKey: _imgToken
					},
					wrapX: false
				});
			}
			layer.setSource(source);
			layer.set('imgToken', _imgToken);
			layer.set('gridType', _gridType);
			layer.set('legendName', paramObj.legendName);
			layer.set('paramObj',paramObj);

	    }
	};

	var getClickData = function (mapObj, layerObj, evt, callback) {
	    var extent = maps.getExtent(mapObj.getTarget());
	    var layerParamObj = layerObj.get('paramObj');
	    var paramObj = {
	        geometry: {x: evt.coordinate[0], y: evt.coordinate[1]},
	        tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  1,
	        mapExtent: extent,
	        imgToken: layerObj.get('imgToken')
	    };
	    ajax.postJSON({
	        url: constant.GisRootUrl + '/gridManager/getGridInfo?cacheKey=' + layerObj.get('imgToken'),
	        data: JSON.stringify(paramObj),
	        success: function (result) {
	            var responseText = JSON.parse(result);
	            var status = responseText.status;
	            var data = responseText.data && responseText.data.length > 0 && responseText.data[0];
	            if (status.code === 1) { //请求成功，可能有数据，可能没数据
	                if (data) {
	                    if (callback && typeof callback === 'function') {
	                        callback([
	                            {
	                                mapId: mapObj.getTarget(),
	                                layerId: layerObj.get('layer_id'),
	                                layerType: layerObj.get('businessType'),
	                                label: layerObj.get('params.label'),
	                                lonLat: data.centerPoint,
	                                geometry: data.geometry,
	                                extentInfo: data.extentInfo,
	                                geoId: data.id,
	                                geoName: data.name
	                            }
	                        ]);
	                    }
	                }
	                else {
	                    callback([]);
	                }
	            }
	            else {
	                callback([]);
	            }
	        },
	        failure: function(result) {
	        	callback([]);
	        }
	    });
	};

	function highlight(layerObj, hType, params) {
	    var olMap = layerObj.get('map');
	    var mapId = olMap.getTarget();
	    var layerId = layerObj.get('layer_id');
	    var layerType = layerObj.get('businessType');

	    highlights.removeHighlight({
	        mapId: mapId,
	        layerId: layerId,
	        hTypes: ['click']
	    });

	    if (hType === constant.HTYPE.CLICK) {
	        _clickHighlight(mapId, layerId, layerType, hType, params);
	    }
	    else if (hType === constant.HTYPE.VECTOR) {
	        _vectorHighlight(mapId, layerId, layerType, hType, params, layerObj);
	    }
	}

	/**
	 * 点击高亮栅格
	 * @param mapId
	 * @param layerId
	 * @param layerType
	 * @param hType
	 * @param params
	 * @private
	 */
	function _clickHighlight(mapId, layerId, layerType, hType, params) {
	    var points = params.geometry;
	    
		var point0 = utils.gcjTransform([points[0], points[1]]);
		var point1 = utils.gcjTransform([points[2], points[1]]);
		var point2 = utils.gcjTransform([points[2], points[3]]);
		var point3 = utils.gcjTransform([points[0], points[3]]);

	    var feature = new ol.Feature({
	        geometry: new ol.geom.Polygon([[point0, point1, point2, point3]]),
	        mapId: mapId,
	        layerId: layerId,
	        layerType: layerType,
	        hType: hType
	    });

	    var style = new ol.style.Style({
	        stroke: new ol.style.Stroke({
	            width: 2,
	            color: 'black'
	        })
	    });

	    feature.setStyle(style);
	    var layerObj = highlights.getHLayer({
	        mapId: mapId,
	        layerId: layerId
	    });
	    layerObj.getSource().addFeature(feature);
	}

	/**
	 * 通过数据高亮栅格
	 * @param mapId
	 * @param layerId
	 * @param layerType
	 * @param hType
	 * @param pointData
	 * @param layerObj
	 * @private
	 */
	function _vectorHighlight(mapId, layerId, layerType, hType, pointData, layerObj) {
	    var points = [];
	    pointData.coordinates.forEach(function (coordinate) {
	        points.push({
	            x: coordinate[0],
	            y: coordinate[1]
	        });
	    });
	    ajax.postJSON({
	        url: constant.GisRootUrl + '/gridManager/queryGridInfo?cacheKey='  + layerObj.get('imgToken'),
	        data: JSON.stringify({
	            points: points,
	            imgToken: layerObj.get('imgToken')
	        }),
	        success: function (result) {
	            if (!result) {
	                return;
	            }
	            result = JSON.parse(result);
	            if (result.status.code !== 1 || !result.data || !result.data.length) {
	                return;
	            }

	            var features = result.data.map(function (pointData) {
	                var points = pointData.geometry;
	                points = utils.transformMultArrayFrom3857(points);
					var point0 = [points[0], points[1]];
					var point1 = [points[2], points[1]];
					var point2 = [points[2], points[3]];
					var point3 = [points[0], points[3]];


				    var feature = new ol.Feature({
				        geometry: new ol.geom.Polygon([[point0, point1, point2, point3]]),
	                    mapId: mapId,
	                    layerId: layerId,
	                    layerType: layerType,
	                    hType: hType
	                });

	                var style = new ol.style.Style({
	                    stroke: new ol.style.Stroke({
	                        width: 2,
	                        color: 'black'
	                    })
	                });

	                feature.setStyle(style);
	                return feature;
	            });

	            var layerObj = highlights.getHLayer({
	                mapId: mapId,
	                layerId: layerId
	            });
	            layerObj.getSource().addFeatures(features);
	        },
	        failure: function(result) {
	        	console.log(result);
	        }
	    });
	}

	module.exports = {
	    addLayer: addLayer,
	    setLayerData: setLayerData,
	    getClickData: getClickData,
	    highlight: highlight
	};

/***/ },
/* 51 */
/*!**************************************************!*\
  !*** ./src/gis/businessLayers/servicePolygon.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @file 服务Polygon
	 */

	var ol = __webpack_require__(/*! ol */ 4);
	var maps = __webpack_require__(/*! maps/map */ 8);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var ajax = __webpack_require__(/*! utils/ajax */ 14);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);
	var event = __webpack_require__(/*! maps/event */ 11);

	var addLayer = function(paramObj) {
		var _layerId = paramObj.layerId + '_' + paramObj.mapId;
		var _map = hashMap.get(paramObj.mapId);
		var _zoom = _map.getView().getZoom();
		var _label = paramObj.label ? paramObj.label : paramObj.layerId;
		var _isShow = paramObj.isShow != undefined ? paramObj.isShow : true;
		var _layer = null;
		if (!hashMap.containsKey(_layerId)) {
			_layer = new ol.layer.Image({
				source: new ol.source.ImageWMS({
					params: {
						VERSION: '1.1.1'
					},
					wrapX: false
				})
			});
			hashMap.put(_layerId, _layer);
			_map.addLayer(_layer);
		} else {
			_layer = hashMap.get(_layerId);
		}
		var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.POLYGON;
		_layer.setZIndex(_ZIndex);
		_layer.set('type', constant.CUSTOMTYPE.LAYERTILETYPE);
		_layer.set('businessType', constant.BUSINESSTYPE.SERVICEPOLYGON);
		_layer.set('params.label', _label);
		_layer.set('isVectorType', false);
		_layer.set('layerId', _layerId);
		_layer.set('map', _map);
		_layer.set('layer_id', paramObj.layerId);
		_layer.set('multiple', paramObj.multiple);
		_layer.set('legendName', paramObj.legendName);
		_layer.set('clickId', 'business_service_polygon_event_id');
		_layer.set('isShow', _isShow);
		if (paramObj.minShowLevel != undefined) {
			_layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
		}

		if (paramObj.maxShowLevel != undefined) {
			_layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));
		}
		event.addClickCallback(paramObj.mapId, 'business_service_polygon_event_id', function(object) {
			if (object.layer && object.layer.get('businessType') === constant.BUSINESSTYPE.SERVICEPOLYGON) {
				var mapObj = mapBox.getMapObj(paramObj.mapId);

				var transportDataToInnerLayer = object.transportDataToInnerLayer;
				if (transportDataToInnerLayer) {
					if (!!transportDataToInnerLayer && transportDataToInnerLayer.length > 0) {
						highlight(object.layer, 'click', transportDataToInnerLayer[0]);
					}
				} else {
					highlights.removeHighlight({
						mapId: paramObj.mapId,
						layerId: paramObj.layerId,
						hTypes: ['click']
					});
				}
			}
		}, paramObj.layerId)
	};

	var setLayerData = function(paramObj) {
		var layer = layers.getLayer(paramObj);
		layer.set('legendName', paramObj.legendName);
		layer.set('paramObj', paramObj);
		if (layer) {
			if (paramObj.label) {
				layer.set('params.label', paramObj.label);
			}
			layer.set('params.imgToken', paramObj.imgToken);
			layer.set('imgToken', paramObj.imgToken);
			layer.set('params.imgTokenLabel', paramObj.imgTokenLabel);
			var imgToken = (paramObj.isShowLabel ? paramObj.imgTokenLabel : paramObj.imgToken);
			var FCName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
			var source = new ol.source.ImageWMS({
				url: constant.GisRootUrl + '/mapRender/export',
				params: {
					imgToken: imgToken,
					VERSION: '1.1.1',
					FCName: FCName
				},
				wrapX: false
			});
			layer.setSource(source);
		}

	};

	var highlight = function(layerObj, highlightType, param) {
		var olMap = layerObj.get('map');
		var mapId = olMap.getTarget();
		var layerId = layerObj.get('layer_id');
		var layerType = layerObj.get('businessType');

		highlights.removeHighlight({
			mapId: mapId,
			layerId: layerId,
			hTypes: ['click']
		});

		if (highlightType === constant.HTYPE.CLICK) {
			_clickHighlight(mapId, layerId, layerType, highlightType, param);
		} else if (highlightType === constant.HTYPE.VECTOR) {
			_vectorHighlight(mapId, layerId, layerType, highlightType, param, layerObj);
		}
	};

	function _clickHighlight(mapId, layerId, layerType, highlightType, params) {
		var points = utils.multigcjTransform(params.geometry);
		var feature = new ol.Feature({
			geometry: new ol.geom.Polygon([points]),
			mapId: mapId,
			layerId: layerId,
			layerType: layerType,
			hType: highlightType
		});

		var style = new ol.style.Style({
			stroke: new ol.style.Stroke({
				width: 2,
				color: 'black'
			})
		});

		feature.setStyle(style);
		var layerObj = highlights.getHLayer({
			mapId: mapId,
			layerId: layerId
		});
		feature.set('layer', layerObj);
		layerObj.getSource().addFeature(feature);
	}

	function _vectorHighlight(mapId, layerId, layerType, highlightType, param, layerObj) {
		var imgToken = layerObj.get('params.imgToken');
		var Fcname = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		ajax.postJSON({
			url: constant.GisRootUrl + '/mapRender/query?FCName=' + Fcname,
			data: JSON.stringify({
				id: param.geoIds,
				imgToken: layerObj.get('params.imgToken')
			}),
			success: function(result) {
				if (!result) {
					return;
				}
				result = JSON.parse(result);
				if (result.status.code !== 1 || !result.data || !result.data.length) {
					return;
				}

				var features = result.data.map(function(pointData) {
					var points = pointData.geometry;
					var pointsDimension = utils.arrayDimensionCheck(points);
					var _points = pointsDimension && pointsDimension === 3 ? points :
						pointsDimension && pointsDimension === 2 ? [points] : undefined;
					var points_ = utils.transformMultArrayFrom3857(_points);	
					var feature = new ol.Feature({
						geometry: new ol.geom.Polygon(points_),
						mapId: mapId,
						layerId: layerId,
						layerType: layerType,
						hType: highlightType
					});

					var style = new ol.style.Style({
						stroke: new ol.style.Stroke({
							width: 2,
							color: 'black'
						})
					});

					feature.setStyle(style);
					feature.set('layer', highlights.getHLayer({
						mapId: mapId,
						layerId: layerId
					}));
					return feature;
				});

				var layerObj = highlights.getHLayer({
					mapId: mapId,
					layerId: layerId
				});
				layerObj.getSource().addFeatures(features);
			},
			failure: function(result) {
				console.log(result);
			}
		});
	}

	var getClickData = function(mapObj, layerObj, evt, callback) {
		if (!layerObj.getVisible()) {
			callback([]);
			return;
		}

		var extent = maps.getExtent(mapObj.getTarget());
		var imgToken = layerObj.get('params.imgToken');
		var FCName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		var layerParamObj = layerObj.get('paramObj');
		var paramObj = {
			geometry: JSON.stringify({
				x: evt.coordinate[0],
				y: evt.coordinate[1]
			}),
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance : 0.1,
			mapExtent: extent,
			imgToken: layerObj.get('params.imgToken'),
			FCName: FCName
		};
		ajax.get({
			url: constant.GisRootUrl + '/mapRender/identify',
			data: utils.getParameterString(paramObj),
			success: function(result) {
				if (!result) {
					return;
				}
				var responseText = JSON.parse(result);
				var status = responseText.status;
				if (status.code === 1) { //请求成功，可能有数据，可能没数据
					if (responseText.data && responseText.data.length > 0) {
						var datas = responseText.data.map(function(data) {
							var oneData = {
								mapId: mapObj.getTarget(),
								layerId: layerObj.get('layer_id'),
								layerType: layerObj.get('businessType'),
								label: layerObj.get('params.label'),
								lonLat: data.centerPoint,
								geometry: data.geometry,
								extentInfo: data.extentInfo,
								geoId: data.id,
								geoName: data.name
							};

							return oneData;
						});

						if (callback && typeof callback === 'function') {
							callback(datas);
						}
					} else {
						callback([]);
					}
				} else {
					callback([]);
				}
			},
			failure: function(result) {
				console.log(result);
				callback([]);

			}
		});
	};

	function setShowLabel(param) {
		var layer = layers.getLayer(param);
		if (!layer) {
			return;
		}
		var imgToken;
		if (param.showLabel) {
			imgToken = layer.get('params.imgTokenLabel');
		} else {
			imgToken = layer.get('params.imgToken');
		}
		var updateParams = {
			VERSION: '1.1.1',
			imgToken: imgToken
		};
		layer.getSource().updateParams(updateParams);
	}

	module.exports = {
		addLayer: addLayer,
		setLayerData: setLayerData,
		getClickData: getClickData,
		highlight: highlight,
		setShowLabel: setShowLabel
	};

/***/ },
/* 52 */
/*!************************************************!*\
  !*** ./src/gis/businessLayers/servicePoint.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @file 服务Point
	 */

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var maps = __webpack_require__(/*! maps/map */ 8);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var ajax = __webpack_require__(/*! utils/ajax */ 14);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);
	var event = __webpack_require__(/*! maps/event */ 11);
	var map = new Map();
	map.set('refreshLayerManager_key', []);

	var addLayer = function(paramObj) {
		var _layerId = paramObj.layerId + '_' + paramObj.mapId;
		var _map = mapBox.getMapObj(paramObj.mapId);
		var _label = paramObj.label ? paramObj.label : paramObj.layerId;
		var _isShow = paramObj.isShow != undefined ? paramObj.isShow : true;
		var _zoom = _map.getView().getZoom();
		var _layer = null;
		if(!hashMap.containsKey(_layerId)) {
			_layer = new ol.layer.Image({
				source: new ol.source.ImageWMS({
					params: {
						VERSION: '1.1.1'
					},
					wrapX: false
				})
			});
			if(!!paramObj.multiple) {
				_layer.set('multiple', paramObj.multiple);
			}
			hashMap.put(_layerId, _layer);
			_map.addLayer(_layer);
		} else {
			_layer = hashMap.get(_layerId);
		}
		_layer.set('isShow', _isShow);
		var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.MARKER;
		_layer.setZIndex(_ZIndex);
		_layer.set('type', constant.CUSTOMTYPE.LAYERTILETYPE);
		_layer.set('businessType', constant.BUSINESSTYPE.SERVICEPOINT);
		_layer.set('params.label', _label);
		_layer.set('isVectorType',false);
		_layer.set('layerId', _layerId);
		_layer.set('map', _map);
		_layer.set('legendName', paramObj.legendName);
		_layer.set('layer_id', paramObj.layerId);
		_layer.set('clickId', 'business_service_point_event_id');
		if (paramObj.minShowLevel != undefined) {
			_layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
		}

		if (paramObj.maxShowLevel != undefined) {
			_layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));
		}
		event.addClickCallback(paramObj.mapId, 'business_service_point_event_id', function(responseObj) {
			if(responseObj.layer && responseObj.layer.get('businessType') === constant.BUSINESSTYPE.SERVICEPOINT) {
				var mapObj = mapBox.getMapObj(paramObj.mapId);
				var transportDataToInnerLayer = responseObj.transportDataToInnerLayer;
				if(transportDataToInnerLayer) {
					highlight(responseObj.layer, 'click', transportDataToInnerLayer[0]);
				} else {
					highlights.removeHighlight({
						mapId: paramObj.mapId,
						layerId: paramObj.layerId,
						hTypes: ['click']
					});
				}
			}
		}, paramObj.layerId)
	};

	var setLayerData = function(paramObj) {
		var layer = layers.getLayer(paramObj);
		var imgToken = paramObj.imgToken;
		var FCName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		layer.set('legendName', paramObj.legendName);
		if(paramObj.label) {
			layer.set('params.label', paramObj.label);
		}
		if(paramObj.isCluster) {
			layer.set('isCluster', paramObj.isCluster);
		}
		layer.set('imgToken', paramObj.imgToken);

		layer.set('params.imgTokenLabel',paramObj.imgTokenLabel);
		layer.set('params.imgToken',paramObj.imgToken);

		layer.set('paramObj',paramObj);
		var updateParams = {
			VERSION: '1.1.1',
			imgToken: paramObj.imgToken,
			FCName: FCName
		};
		if(layer) {
			layer.getSource().setUrl(constant.GisRootUrl + '/mapRender/export');
			layer.getSource().updateParams(updateParams);
		}
		
		
		if (map.get('refreshLayerManager_key').length < 10) {
	        var layer = new ol.layer.Vector();
	        layer.set('layer_id', 'auto_increase_reduce');
	        mapBox.getMapObj(paramObj.mapId).addLayer(layer);
	        map.get('refreshLayerManager_key').push(layer);
	    }
	    else {
	       var _layers = map.get('refreshLayerManager_key');
	        if (!!_layers && _layers.length >= 0) {
	            _layers.forEach(function(v, i) {
	                mapBox.getMapObj(paramObj.mapId).removeLayer(v);
	                map.get('refreshLayerManager_key').splice(i, 1);
	            });
	        }
	    }
		
		
	};

	var highlight = function(layerObj, highlightType, param) {
		var olMap = layerObj.get('map');
		var mapId = olMap.getTarget();
		var layerId = layerObj.get('layer_id');
		var layerType = layerObj.get('businessType');

		highlights.removeHighlight({
			mapId: mapId,
			layerId: layerId,
			hTypes: ['click']
		});

		if(highlightType === constant.HTYPE.CLICK) {
			_clickHighlight(mapId, layerId, layerType, highlightType, param);
		} else if(highlightType === constant.HTYPE.VECTOR) {
			_vectorHighlight(mapId, layerId, layerType, highlightType, param, layerObj);
		}
	};

	function _clickHighlight(mapId, layerId, layerType, highlightType, params) {
		var points = utils.multigcjTransform(params.geometry,true);
		var feature = new ol.Feature({
			geometry: new ol.geom.Point(points[0]),
			mapId: mapId,
			layerId: layerId,
			layerType: layerType,
			hType: highlightType
		});

		var style = new ol.style.Style({
			image: new ol.style.Circle({
				stroke: new ol.style.Stroke({
					width: 1.5,
					color: '#000'
				}),
				radius: 4
			})
		});

		feature.setStyle(style);
		var layerObj = highlights.getHLayer({
			mapId: mapId,
			layerId: layerId
		});
		feature.set('layer', layerObj);
		layerObj.getSource().addFeature(feature);
	}

	function _vectorHighlight(mapId, layerId, layerType, highlightType, param, layerObj) {
		var imgToken = layerObj.get('imgToken');
		var Fcname = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		ajax.postJSON({
			url: constant.GisRootUrl + '/mapRender/query?FCName=' + Fcname,
			data: JSON.stringify({
				id: /*[param.geoId]*/ param.geoIds,
				imgToken: layerObj.get('imgToken')
			}),
			success: function(result) {
				if(!result) {
					return;
				}
				result = JSON.parse(result);
				if(result.status.code !== 1 || !result.data || !result.data.length) {
					return;
				}

				var features = result.data.map(function(pointData) {
					var points = utils.transformMultArrayFrom3857(pointData.geometry);
					var feature = new ol.Feature({
						geometry: new ol.geom.Point(points[0]),
						mapId: mapId,
						layerId: layerId,
						layerType: layerType,
						hType: highlightType
					});

					var style = new ol.style.Style({
						image: new ol.style.Circle({
							stroke: new ol.style.Stroke({
								width: 1.5,
								color: '#000'
							}),
							radius: 4
						})
					});

					feature.setStyle(style);
					feature.set('layer', highlights.getHLayer({
						mapId: mapId,
						layerId: layerId
					}));
					return feature;
				});

				var layerObj = highlights.getHLayer({
					mapId: mapId,
					layerId: layerId
				});
				layerObj.getSource().addFeatures(features);
			},
			failure: function(result) {
				console.log( '' +constant.GisRootUrl + '/mapRender/query?FCName=' + Fcname + ' ....fail');
			}
		});
	}

	function setShowLabel(param) {
		var layer = layers.getLayer(param);
		if(!layer||layer.get('isCluster')) {
			return;
		}
		var imgToken;
		if(param.showLabel) {
			imgToken = layer.get('params.imgTokenLabel');
		} else {
			imgToken = layer.get('params.imgToken');
		}
		var updateParams = {
			VERSION: '1.1.1',
			imgToken: imgToken
		};
		layer.set('state.showLabel', !!param.showLabel);
		layer.getSource().updateParams(updateParams);
	}

	var getClickData = function(mapObj, layerObj, evt, callback) {
		if(!layerObj.getVisible()){
			callback([]);
			return;
		}

		var extent = maps.getExtent(mapObj.getTarget());
		var imgToken = layerObj.get('imgToken');
		var FCName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		var layerParamObj = layerObj.get('paramObj');
		var paramObj = {
			geometry: JSON.stringify({
				x: evt.coordinate[0],
				y: evt.coordinate[1]
			}),
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  10,
			mapExtent: extent,
			imgToken: layerObj.get('imgToken'),
			FCName: FCName
		};
		ajax.get({
			url: constant.GisRootUrl + '/mapRender/identify',
			data: utils.getParameterString(paramObj),
			success: function(result) {
				if(!result) {
					return;
				}
				var responseText = JSON.parse(result);
				var status = responseText.status;
				var data = responseText.data && responseText.data.length > 0 && responseText.data[0];
				if(status.code === 1) { //请求成功，可能有数据，可能没数据
					if(data) {
						if(callback && typeof callback === 'function') {
							callback([{
								mapId: mapObj.getTarget(),
								layerId: layerObj.get('layer_id'),
								layerType: layerObj.get('businessType'),
								geoId: data.id,
								geoName: data.name,
								lonLat: data.centerPoint,
								geometry: data.geometry,
								extentInfo: data.extentInfo
							}]);
						}
					} else {
						callback([]);
					}
				} else {
					callback([]);
				}
			},
			failure: function(result) {
				console.log(result);
				callback([]);

			}
		});
	};

	module.exports = {
		addLayer: addLayer,
		setLayerData: setLayerData,
		getClickData: getClickData,
		highlight: highlight,
		setShowLabel:setShowLabel
	};

/***/ },
/* 53 */
/*!***********************************************!*\
  !*** ./src/gis/businessLayers/serviceLine.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 服务Point
	 */
	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var maps = __webpack_require__(/*! maps/map */ 8);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var ajax = __webpack_require__(/*! utils/ajax */ 14);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);
	var event = __webpack_require__(/*! maps/event */ 11);

	var addLayer = function(paramObj) {
		var _layerId = paramObj.layerId + '_' + paramObj.mapId;
		var _map = mapBox.getMapObj(paramObj.mapId);
		var _label = paramObj.label ? paramObj.label : paramObj.layerId;
		var _isShow = paramObj.isShow != undefined ? paramObj.isShow : true;
		var _layer = null;
		if(!hashMap.containsKey(_layerId)) {
			_layer = new ol.layer.Image({
				source: new ol.source.ImageWMS({
					params: {
						VERSION: '1.1.1'
					},
					wrapX: false
				})
			});
			if(!!paramObj.multiple) {
				_layer.set('multiple', paramObj.multiple);
			}
			hashMap.put(_layerId, _layer);
			_map.addLayer(_layer);
		} else {
			_layer = hashMap.get(_layerId);
		}
		var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.LINE;
		_layer.setZIndex(_ZIndex);
		_layer.set('type', constant.CUSTOMTYPE.LAYERTILETYPE);
		_layer.set('businessType', constant.BUSINESSTYPE.SERVICELINE);
		_layer.set('params.label', _label);
		_layer.set('isVectorType',false);
		_layer.set('layerId', _layerId);
		_layer.set('map', _map);
		_layer.set('legendName', paramObj.legendName);
		_layer.set('layer_id', paramObj.layerId);
		_layer.set('clickId', 'business_service_line_event_id');
		_layer.set('isShow', _isShow);
		if (paramObj.minShowLevel != undefined) {
			_layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
		}

		if (paramObj.maxShowLevel != undefined) {
			_layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));
		}

		event.addClickCallback(paramObj.mapId, 'business_service_line_event_id', function(object) {
			if(object.layer && object.layer.get('businessType') === constant.BUSINESSTYPE.SERVICELINE) {
				var mapObj = mapBox.getMapObj(paramObj.mapId);

				var transportDataToInnerLayer = object.transportDataToInnerLayer;
				if(transportDataToInnerLayer) {
					if(!!transportDataToInnerLayer && transportDataToInnerLayer.length > 0) {
						highlight(object.layer, 'click', transportDataToInnerLayer[0]);
					}
				} else {
					highlights.removeHighlight({
						mapId: paramObj.mapId,
						layerId: paramObj.layerId,
						hTypes: ['click']
					});
				}
			}
		}, paramObj.layerId)
	};

	var setLayerData = function(paramObj) {
		var layer = layers.getLayer(paramObj);

		var FCName = paramObj.imgToken.slice(0, paramObj.imgToken.indexOf(':'));
		if(paramObj.label) {
			layer.set('params.label', paramObj.label);
		}
		layer.set('imgToken', paramObj.imgToken);
		layer.set('legendName', paramObj.legendName);
		layer.set('params.imgTokenLabel',paramObj.imgTokenLabel);
		layer.set('params.imgToken',paramObj.imgToken);

		layer.set('paramObj',paramObj);
		var updateParams = {
			VERSION: '1.1.1',
			imgToken: paramObj.imgToken,
			FCName: FCName
		};
		if(layer) {
			layer.getSource().setUrl(constant.GisRootUrl + '/mapRender/export');
			layer.getSource().updateParams(updateParams);
		}
	};

	var highlight = function(layerObj, highlightType, param) {
		var olMap = layerObj.get('map');
		var mapId = olMap.getTarget();
		var layerId = layerObj.get('layer_id');
		var layerType = layerObj.get('businessType');

		highlights.removeHighlight({
			mapId: mapId,
			layerId: layerId,
			hTypes: ['click']
		});

		if(highlightType === constant.HTYPE.CLICK) {
			_clickHighlight(mapId, layerId, layerType, highlightType, param);
		} else if(highlightType === constant.HTYPE.VECTOR) {
			_vectorHighlight(mapId, layerId, layerType, highlightType, param, layerObj);
		}
	};

	function _clickHighlight(mapId, layerId, layerType, highlightType, params) {
		var points = utils.multigcjTransform(params.geometry,true);
		var feature = new ol.Feature({
			geometry: new ol.geom.LineString(points),
			mapId: mapId,
			layerId: layerId,
			layerType: layerType,
			hType: highlightType
		});

	    var style = new ol.style.Style({
	        stroke: new ol.style.Stroke({
	            width: 2,
	            color: 'black'
	        })
	    });

	    feature.setStyle(style);
	    var layerObj = highlights.getHLayer({
	        mapId: mapId,
	        layerId: layerId
	    });
		feature.set('layer', layerObj);
	    layerObj.getSource().addFeature(feature);
	}

	function _vectorHighlight(mapId, layerId, layerType, highlightType, param, layerObj) {

		var Fcname = layerObj.get('imgToken').slice(0, layerObj.get('imgToken').indexOf(':'));
		ajax.postJSON({
			url: constant.GisRootUrl + '/mapRender/query?FCName=' + Fcname,
			data: JSON.stringify({
				id: param.geoIds,
				imgToken: layerObj.get('imgToken')
			}),
			success: function(result) {
				if(!result) {
					return;
				}
				result = JSON.parse(result);
				if(result.status.code !== 1 || !result.data || !result.data.length) {
					return;
				}

	            var features = result.data.map(function (pointData) {
					var points = utils.transformMultArrayFrom3857(pointData.geometry);
	                var feature = new ol.Feature({
	                    geometry: new ol.geom.LineString(points),
	                    mapId: mapId,
	                    layerId: layerId,
	                    layerType: layerType,
	                    hType: highlightType
	                });

					var style = new ol.style.Style({
						stroke: new ol.style.Stroke({
							width: 2,
							color: 'black'
						})
					});

					feature.setStyle(style);
					feature.set('layer', highlights.getHLayer({
						mapId: mapId,
						layerId: layerId
					}));
					return feature;
				});

				var layerObj = highlights.getHLayer({
					mapId: mapId,
					layerId: layerId
				});
				layerObj.getSource().addFeatures(features);
			},
			failure: function(result) {
				console.log(result);
			}
		});
	}

	function setShowLabel(param) {
		var layer = layers.getLayer(param);
		if(!layer) {
			return;
		}
		var imgToken;
		if(param.showLabel) {
			imgToken = layer.get('params.imgTokenLabel');
		} else {
			imgToken = layer.get('params.imgToken');
		}
		var updateParams = {
			VERSION: '1.1.1',
			imgToken: imgToken
		};
		layer.set('state.showLabel', !!param.showLabel);
		layer.getSource().updateParams(updateParams);
	}

	var getClickData = function(mapObj, layerObj, evt, callback) {
		if(!layerObj.getVisible()){
			callback([]);
			return;
		}

		var extent = maps.getExtent(mapObj.getTarget());
		var imgToken = layerObj.get('imgToken');
		var FCName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		var layerParamObj = layerObj.get('paramObj');
		var paramObj = {
			geometry: JSON.stringify({
				x: evt.coordinate[0],
				y: evt.coordinate[1]
			}),
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  10,
			mapExtent: extent,
			imgToken: layerObj.get('imgToken'),
			FCName: FCName
		};
		ajax.get({
			url: constant.GisRootUrl + '/mapRender/identify',
			data: utils.getParameterString(paramObj),
			success: function(result) {
				if(!result) {
					return;
				}
				var responseText = JSON.parse(result);
				var status = responseText.status;
				var data = responseText.data && responseText.data.length > 0 && responseText.data[0];
				if(status.code === 1) { //请求成功，可能有数据，可能没数据
					if(data) {
						if(callback && typeof callback === 'function') {
							callback(
								[{
									mapId: mapObj.getTarget(),
									layerId: layerObj.get('layer_id'),
									layerType: layerObj.get('businessType'),
									geoId: data.id,
									geoName: data.name,
									lonLat: data.centerPoint,
									geometry: data.geometry,
									extentInfo: data.extentInfo
								}]
							);
						}
					} else {
						callback([]);
					}
				} else {
					callback([]);
				}
			},
			failure: function(result) {
				console.error(result);
				callback([]);

			}
		});
	};

	module.exports = {
		addLayer: addLayer,
		setLayerData: setLayerData,
		getClickData: getClickData,
		highlight: highlight,
		setShowLabel:setShowLabel
	};

/***/ },
/* 54 */
/*!****************************************!*\
  !*** ./src/gis/businessLayers/line.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var event = __webpack_require__(/*! maps/event */ 11);

	var addLayer = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId,
	        _layer = null;
	    var _mapObj = mapBox.getMapObj(paramObj.mapId);

	    if (hashMap.containsKey(_layerId)) {
	        _layer = hashMap.get(_layerId);
	    }
	    else {
	        _layer = new ol.layer.Vector({
	            source: new ol.source.Vector({
	                wrapX: false
	            })
	        });

	        ///自定义属性，方便后面通过类型判断对象
	        _layer.set('type', constant.CUSTOMTYPE.LAYERTYPE);
	        _layer.set('map', _mapObj);
	        _layer.set('layerId', _layerId);
	        _layer.set('layer_id', paramObj.layerId);
	        _layer.set('businessType', constant.BUSINESSTYPE.LINE);
	        _layer.set('params.label', paramObj.label);
	        _layer.set('isVectorType',true);
	        _layer.set('state.showLabel', !!paramObj.showLabel);
	        _layer.set('legendName', paramObj.legendName);
	        var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.LINE;
	        _layer.setZIndex(_ZIndex);
	        _layer.set('clickId', 'business_line_event_id');
	        if (paramObj.minShowLevel != undefined) {
	            _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	        }

	        if (paramObj.maxShowLevel != undefined) {
	            _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	        }
	        hashMap.put(_layerId, _layer);
	        _mapObj.addLayer(_layer);
	    }

	    event.addClickCallback(paramObj.mapId, 'business_line_event_id', function (e) {
	        if (e.layer && e.layer.get('businessType') === constant.BUSINESSTYPE.LINE &&
	            e.feature && e.feature.get('businessType') === constant.BUSINESSTYPE.LINE) {
	            var feature = e.feature;
	            //调用高亮的方法
	            highlight(e.layer, 'click', {mapId: paramObj.mapId, layerId: paramObj.layerId, feature: feature});
	        }
	    }, paramObj.layerId)
	};

	var setLayerData = function (paramObj) {
	    var _features = [];
	    var _datas = paramObj.datas;
	    var layer = layers.getLayer(paramObj);
	    layer.set('legendName', paramObj.legendName);
	    layer.set('paramObj',paramObj);
	    if (paramObj.label) {
	        layer.set('params.label', paramObj.label);
	    }
	    if (utils.isValid(_datas) || _datas.length > 0) {

	        layer.set('state.showLabel', true);
	        var source = layer.getSource();
	        _datas.forEach(function (lineData) {
	            var _coordinate = olUtil.transform(lineData.coordinates, 4326, 3857);
	            _coordinate = utils.transformMultArray(_coordinate);
	            var _strokeWidth = lineData.strokeWidth !== undefined ? lineData.strokeWidth : 2;
	            var font = lineData.fontStyle + ' ' + lineData.fontSize + ' ' + lineData.fontFamily;
	            var _labelWidth = lineData.labelStrokeWidth !== undefined ? lineData.labelStrokeWidth : 1;
	            var defaultHighLight = {
	                strokeColor: 'black',
	                fillColor: lineData.fillColor ? lineData.fillColor : 'rgba(255,0,255,0.3)',
	                strokeWidth: _strokeWidth,
	                labelFillColor: lineData.labelFillColor || 'black',
	                labelStrokeColor: lineData.labelStrokeColor || '#ffffff'
	            };
	            var _feature = new ol.Feature({
	                geometry: new ol.geom.LineString(_coordinate),
	                data: lineData,
	                layerId: paramObj.layerId,
	                mapId: paramObj.mapId,
	                businessType: constant.BUSINESSTYPE.LINE,
	                select: lineData.hightLight ? lineData.hightLight : defaultHighLight
	            });
	            if (lineData.hightLight) {
	                for (var index in defaultHighLight) {
	                    lineData.hightLight[index] ? lineData.hightLight[index] : lineData.hightLight[index] = defaultHighLight[index];
	                }
	            }
	            _feature.setId(lineData.id);
	            _feature.set('data', lineData);
	            _feature.set('layer', layer);
	            _feature.set('vectorType', constant.BUSINESSTYPE.LINE);

	            var _defaultStyle = new ol.style.Style({
	                fill: new ol.style.Fill({
	                    color: lineData.fillColor ? lineData.fillColor : 'rgba(0,0,0,0)'
	                }),
	                stroke: new ol.style.Stroke({
	                    color: lineData.strokeColor || '#000',
	                    width: _strokeWidth
	                }),
	                text: new ol.style.Text({
	                    text: lineData.label || '',
	                    fill: new ol.style.Fill({
	                        color: lineData.labelFillColor || 'black'
	                    }),
	                    font: font !== undefined ? font : 'normal 14px Arial',
	                    stroke: new ol.style.Stroke({
	                        color: lineData.labelStrokeColor || '#ffffff',
	                        width: _labelWidth
	                    })
	                })
	            });

	            var shapeStyle = new ol.style.Style({
	                fill: new ol.style.Fill({
	                    color: lineData.fillColor || 'rgba(0,0,0,0)'
	                }),
	                stroke: new ol.style.Stroke({
	                    color: lineData.strokeColor || '#000',
	                    width: _strokeWidth
	                })
	            });
	            _feature.setStyle(_defaultStyle);
	            _feature.set('defaultStyle', _defaultStyle);
	            _feature.set('shapeStyle', shapeStyle);
	            _features.push(_feature);

	        });
	        source.addFeatures(_features);
	    }

	};

	function highlight(olLayer, hType, params) {
	    if (olLayer) {
	        var olMap = olLayer.get('map');
	        var mapId = olMap.getTarget();
	        var layerId = olLayer.get('layer_id');
	        var layerType = olLayer.get('businessType');

	        var highlightLayer = highlights.getHLayer({
	            mapId: mapId,
	            layerId: layerId
	        });
	        highlightLayer.getSource().clear();
	        if (hType === constant.HTYPE.CLICK) {
	            if (params.feature) {
	                var _feature = params.feature;
	                var _geoId = _feature.getId();
	                var _highlightStyle = _feature.get('select');
	                var _data = _feature.get('data');

	                var _style = new ol.style.Style({
	                    stroke: new ol.style.Stroke({
	                        width: _highlightStyle.strokeWidth,
	                        color: _highlightStyle.strokeColor
	                    })/*,
	                    text: new ol.style.Text({
	                        text: _data.label || '',
	                        font: 'normal 14px Arial',
	                        fill: new ol.style.Fill({
	                            color: _highlightStyle.labelFillColor
	                        }),
	                        stroke: new ol.style.Stroke({
	                            color: _highlightStyle.labelStrokeColor,
	                            width: _data.labelStrokeWidth !== undefined ? _data.labelStrokeWidth : 1
	                        })
	                    })*/
	                });
	                var tempFeature = _feature.clone();
	                tempFeature.setStyle(_style);
	                tempFeature.setId(_geoId);
	                tempFeature.set('mapId', mapId);
	                tempFeature.set('layerId', layerId);
	                tempFeature.set('layerType', layerType);
	                tempFeature.set('hType', hType);
	                tempFeature.set('highlightFeature', true);
	                tempFeature.set('layer',highlightLayer);
	                highlightLayer.getSource().addFeature(tempFeature);
	            }

	        }
	        else if (hType === constant.HTYPE.VECTOR) {
	        	if(params.geoIds.length > 0) {
	        		params.geoIds.map(function(geoId) {
	        			var _feature = olLayer.getSource().getFeatureById(geoId);
	        			if(!_feature) {
	        				return;
	        			}
	        			var _highlightStyle = _feature.get('select');
	        			var _data = _feature.get('data');
	        			var _style = new ol.style.Style({
	        				stroke: new ol.style.Stroke({
	        					color: _highlightStyle.strokeColor,
	        					width: _highlightStyle.strokeWidth
	        				})
	        				/*,
	        				                    text: new ol.style.Text({
	        				                        text: _data.name || '',
	        				                        font: 'normal 14px Arial',
	        				                        fill: new ol.style.Fill({
	        				                            color: _highlightStyle.labelFillColor
	        				                        }),
	        				                        stroke: new ol.style.Stroke({
	        				                            color: _highlightStyle.labelStrokeColor,
	        				                            width: _data.labelStrokeWidth !== undefined ? _data.labelStrokeWidth : 1
	        				                        })
	        				                    })*/
	        			});
	        			var _tempFeature = _feature.clone();
	        			_tempFeature.setStyle(_style);
	        			_tempFeature.setId(geoId);
	        			_tempFeature.set('mapId', mapId);
	        			_tempFeature.set('layerId', layerId);
	        			_tempFeature.set('layerType', layerType);
	        			_tempFeature.set('hType', hType);
	        			_tempFeature.set('highlightFeature', true);
	                    		_tempFeature.set('layer',highlightLayer);
	        			highlightLayer.getSource().addFeature(_tempFeature);
	        		});
	        	}



	        }
	    }

	}

	var getLineLonLat = function (param, callback) {
	    var lineLngLat;
	    var olLayer = layers.getLayer({
	        mapId: param.mapId,
	        layerId: param.layerId
	    });
	    if (!olLayer) {
	        callback();
	        return;
	    }
	    var feature = olLayer.getSource().getFeature(param.geoId);
	    var geom = feature.getGeometry();
	    lineLngLat = new ol.proj.toLonLat(geom.getCoordinates());
	    callback(lineLngLat);
	};

	function setShowLabel(param) {
	    var layer = layers.getLayer(param);
	    if (!layer) {
	        return;
	    }
	    var showLabel = layer.get('state.showLabel');
	    var features = layer.getSource().getFeatures().slice(0);
	    features.forEach(function (f) {
	        if (param.showLabel && !showLabel) {
	            f.setStyle(f.get('defaultStyle'));
	        }
	        else if (!param.showLabel && showLabel) {
	            f.setStyle(f.get('shapeStyle'));
	        }
	    });
	    layer.set('state.showLabel', !!param.showLabel);
	}

	module.exports = {
	    addLayer: addLayer,
	    setLayerData: setLayerData,
	    highlight: highlight,
	    getLineLonLat: getLineLonLat,
	    setShowLabel: setShowLabel
	};


/***/ },
/* 55 */
/*!****************************************!*\
  !*** ./src/gis/layers/straightLine.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);
	/*绘制直线*/
	var _createLayer = function (paramObj) {
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId + '_' + _mapId;
	    var _mapObj = hashMap.get(_mapId);

	    if (!utils.isValid(hashMap.get(_layerId))) {
	        var _layer = new ol.layer.Vector({
	            source: new ol.source.Vector({
	                wrapX: false
	            })
	        });

	        if (!!paramObj.multiple) {
	            _layer.set('multiple', paramObj.multiple);
	        }
	        //矢量图层
	        _layer.set('type', constant.CUSTOMTYPE.LAYERTYPE);
	        _layer.set('map', _mapObj);
	        _layer.set('layerId', _layerId);
	        _layer.set('layer_id', paramObj.layerId);
	        if(paramObj.isBezier ===1){
	        	_layer.set('businessType', constant.BUSINESSTYPE.BEZIERLINE);
	        }else{
	        	_layer.set('businessType', constant.BUSINESSTYPE.STRAIGHTLINE);
	        }
	        
	        
	        _layer.set('params.label', paramObj.label);
	        //设置线的index属性
			var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.LINE;
	        _layer.setZIndex(_ZIndex);
	        _mapObj.addLayer(_layer);

	        hashMap.put(_layerId, _layer);
	    }
	    else {
	        _layer = hashMap.get(_layerId);
	    }
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	    }
	    return _layer;
	};

	/**
	 * 线渲染，
	 * @param paramObj
	 * paramObj = {
	 *     mapId:{String} 地图唯一标识
	 *     layerId:{String}图层唯一标识
	 *     id:{String}线唯一标识
	 *     name:{String}线名字
	 *     coordinates:[[x,y],[x,y]]点集数据
	 *     color:{String}
	 * }
	 * */
	function projChange(Arr) {
	    var points3857 = [];
	    Arr.forEach(function (point) {
	        var point3857 = ol.proj.transform(point, constant.PROJ.EPSG_4326, constant.PROJ.EPSG_3857);
	        points3857.push(point3857);
	    });
	    return points3857;
	}

	var addLine = function (paramObj, callback) {

	    var lineId = paramObj.lineGeoId;
	    var lineName = paramObj.name;
	    var pointsArr = paramObj.coordinates;
	    var lineColor = paramObj.strokeColor;
	    var lineWidth = paramObj.strokeWidth;
	    var fillColor = paramObj.fillColor;
	    var labelStrokeColor =paramObj.labelStrokeColor;
	    var labelFillColor =paramObj.labelFillColor;
	    var layer = _createLayer(paramObj);
	    var source = layer.getSource();
	    var pointsArr3857 = projChange(pointsArr);

	    var lineStr = new ol.geom.LineString(pointsArr3857);
	    var defaultHighLight = {
	        fillColor:fillColor,
	        strokeColor:'black',
	        strokeWidth: lineWidth || 3,
	        labelFillColor: labelFillColor || 'black',
	        labelStrokeColor: labelStrokeColor || '#ffffff'
	    };
	                
	                
	    var lineFeature = new ol.Feature({
	        geometry: lineStr,
	        lineData: paramObj,
	        businessType: paramObj.isBezier ===1 ? constant.BUSINESSTYPE.BEZIERLINE:constant.BUSINESSTYPE.STRAIGHTLINE,
	        select: paramObj.hightLight ? paramObj.hightLight : defaultHighLight
	    });
	    
	    if(paramObj.hightLight){
	        for(var index in defaultHighLight){
	            paramObj.hightLight[index] ?  paramObj.hightLight[index] : paramObj.hightLight[index]= defaultHighLight[index];
	        }
	    }
	    var lineStyle = new ol.style.Style({
	        stroke: new ol.style.Stroke({
	            color: lineColor || 'rgba(138,43,226,0.5)',
	            width: lineWidth || 3
	        }),
	        text: new ol.style.Text({
	            text: lineName,
	            font: '12px Calibri,sans-serif',
	            fill: new ol.style.Fill({
	                color: fillColor || 'rgba(138,43,226,0.5)'
	            }),
	            stroke: new ol.style.Stroke({
	                color: lineColor || 'rgba(138,43,226,0.5)',
	                width: lineWidth || 3
	            })
	        })
	    });
	    lineFeature.setStyle(lineStyle);
	    lineFeature.set('layer',layer);
	    lineFeature.setId(lineId);

	    if(paramObj.isBezier === 1) {
	    	 lineFeature.set('vectorType', constant.BUSINESSTYPE.BEZIERLINE);
	    } else {
	    	 lineFeature.set('vectorType', constant.BUSINESSTYPE.STRAIGHTLINE);
	    }
	   
	    lineFeature.set('data', pointsArr);
	    lineFeature.set('coordinates', pointsArr3857);//连线坐标
	    source.addFeature(lineFeature);
	    
	    if(paramObj.isBezier === 1) { //曲线
	    	if(callback) {
	    		callback(paramObj.coordinates,lineFeature);
	    	} else {
	    		return paramObj.coordinates;
	    	}

	    } else { //直线
	    	callback(lineFeature);
	    }

	    layer.set('clickId', 'straightline-click-event');
	    fusiongis.Events.addClickCallback(paramObj.mapId, 'straightline-click-event', function(e) {

	    	if(e.layer && e.layer.get('businessType') === constant.BUSINESSTYPE.STRAIGHTLINE &&
	    		e.feature && e.feature.get('businessType') === constant.BUSINESSTYPE.STRAIGHTLINE) {
	    		var feature = e.feature;
	    		//调用高亮的方法
	    		highlight(e.layer, 'click', {
	    			mapId: paramObj.mapId,
	    			layerId: paramObj.layerId,
	    			feature: feature
	    		});
	    	}
	    }, paramObj.layerId)
	};

	function highlight(olLayer, hType, param) {
		if(olLayer) {
			var olMap = olLayer.get('map');
			var mapId = olMap.getTarget();
			var layerId = olLayer.get('layer_id');
			var layerType = olLayer.get('businessType');

			highlights.removeHighlight({
				mapId: mapId,
				layerId: layerId,
				hTypes: [hType]
			});

			var hLayer = highlights.getHLayer({
				mapId: mapId,
				layerId: layerId
			});

			if(hType === constant.HTYPE.CLICK) {
				if(param.feature) {

					var arrowFeature = param.feature.get('arrow');
					var arrowTempFeature = arrowFeature;//箭头的feature
					var arrowFeature_geoId = arrowFeature.getId();
					var arrow_hightLight = arrowFeature.get('select');

					var geoId = param.feature.getId();
					var tempFeature = param.feature;//线feature
					
					var hightLight = param.feature.get('select');

					var _data = param.feature.get('lineData');

					var _style = new ol.style.Style({
						stroke: new ol.style.Stroke({
							width: hightLight.strokeWidth,
							color: hightLight.strokeColor
						}),
						text: new ol.style.Text({
							text: _data !== undefined ? _data.name : '',
							font: '12px Calibri,sans-serif',
							fill: new ol.style.Fill({
								color: hightLight.labelFillColor
							}),
							stroke: new ol.style.Stroke({
								color: hightLight.labelStrokeColor,
								width: hightLight.strokeWidth
							})
						})
					});

					var _arrowStyle = new ol.style.Style({
						image: new ol.style.RegularShape({
							fill: new ol.style.Fill({
								color: arrow_hightLight.labelFillColor || '#208089'
							}),
							stroke: new ol.style.Stroke({
								color: arrow_hightLight.strokeColor || '#000',
								width: arrow_hightLight.strokeWidth || 1
							}),
							cursor: 'point',
							points: 3,
							radius: arrow_hightLight.arrowRadius,
							rotation: arrow_hightLight.rotation,
							angle: 0
						})
					});

					arrowTempFeature.setStyle(_arrowStyle);
					arrowTempFeature.setId(arrowFeature_geoId);
					arrowTempFeature.set('mapId', mapId);
					arrowTempFeature.set('layerId', layerId);
					arrowTempFeature.set('layerType', layerType);
					arrowTempFeature.set('hType', hType);
					arrowTempFeature.set('highLightFeatrue', true);//标识高亮的箭头featrue

					tempFeature.setStyle(_style);
					tempFeature.setId(geoId);
					tempFeature.set('mapId', mapId);
					tempFeature.set('layerId', layerId);
					tempFeature.set('layerType', layerType);
					tempFeature.set('hType', hType);
					tempFeature.set('highLightFeatrue', true);//标识高亮的线的feature
					
					tempFeature.set('arrow', arrowTempFeature);

					//数组copy
					hLayer.getSource().addFeature(arrowTempFeature);
					hLayer.getSource().addFeature(tempFeature);
				}
			} else if(hType === constant.HTYPE.VECTOR) {

				param.geoIds.map(function(geoId) {
					var feature = olLayer.getSource().getFeatureById(geoId);

					var _arrowFeature = feature.get('arrow');
					var _arrowGeoId = _arrowFeature.getId();

					if(!feature || !_arrowFeature) {
						return;
					}

					var highlightStyle = feature.get('select');
					var arrow_highlightStyle = _arrowFeature.get('select');

					var _tempFeature = feature.clone();
					var _arrowTempFeature = _arrowFeature.clone();

					var _data = _tempFeature.get('lineData');
					var font = _data.fontStyle + ' ' + _data.fontSize + ' ' + _data.fontFamily;
					var _style = new ol.style.Style({
						stroke: new ol.style.Stroke({
							width: highlightStyle.strokeWidth,
							color: highlightStyle.strokeColor
						}),
						text: new ol.style.Text({
							text: _data.name || '',
							font: font !== undefined ? font : '12px Calibri,sans-serif',
							fill: new ol.style.Fill({
								color: highlightStyle.labelFillColor
							}),
							stroke: new ol.style.Stroke({
								color: highlightStyle.labelStrokeColor,
								width: highlightStyle.strokeWidth
							})
						})
					});

					var _arrowStyle = new ol.style.Style({
						image: new ol.style.RegularShape({
							fill: new ol.style.Fill({
								color: arrow_highlightStyle.labelFillColor || '#208089'
							}),
							stroke: new ol.style.Stroke({
								color: arrow_highlightStyle.strokeColor || '#000',
								width: arrow_highlightStyle.strokeWidth || 1
							}),
							cursor: 'point',
							points: 3,
							radius: arrow_highlightStyle.arrowRadius,
							rotation: arrow_highlightStyle.rotation,
							angle: 0
						})
					});

					_arrowTempFeature.setStyle(_arrowStyle);
					_arrowTempFeature.setId(_arrowGeoId);
					_arrowTempFeature.set('mapId', mapId);
					_arrowTempFeature.set('layerId', layerId);
					_arrowTempFeature.set('layerType', layerType);
					_arrowTempFeature.set('hType', hType);
					_arrowTempFeature.set('highlightFeature', true);

					_tempFeature.setStyle(_style);
					_tempFeature.setId(geoId);
					_tempFeature.set('mapId', mapId);
					_tempFeature.set('layerId', layerId);
					_tempFeature.set('layerType', layerType);
					_tempFeature.set('hType', hType);
					_tempFeature.set('highlightFeature', true);
					
					//将高亮的线和箭头关联
					_tempFeature.set('arrow', _arrowTempFeature);

					hLayer.getSource().addFeature(_tempFeature);
					hLayer.getSource().addFeature(_arrowTempFeature);
				});
			}
		}
	}

	module.exports = {
	    addLine: addLine,
	    highlight: highlight
	};

/***/ },
/* 56 */
/*!****************************************************!*\
  !*** ./src/gis/businessLayers/dcServicePolygon.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @file 服务Polygon
	 */

	var ol = __webpack_require__(/*! ol */ 4);
	var maps = __webpack_require__(/*! maps/map */ 8);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var ajax = __webpack_require__(/*! utils/ajax */ 14);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);
	var event = __webpack_require__(/*! maps/event */ 11);

	var addLayer = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId;
	    var _map = hashMap.get(paramObj.mapId);
	    var _zoom = _map.getView().getZoom();

	    if (!hashMap.containsKey(_layerId)) {
	        var _layer = new ol.layer.Image({
	            source: new ol.source.ImageWMS({
	                params: {
	                    VERSION: '1.1.1'
	                },
	                wrapX: false
	            })
	        });
	        var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.POLYGON;
	        _layer.setZIndex(_ZIndex);
	        _layer.set('type', constant.CUSTOMTYPE.LAYERTILETYPE);
	        _layer.set('businessType', 'DPOLYGON');
	        _layer.set('isVectorType',false);
	        _layer.set('params.label', paramObj.label);
	        _layer.set('layerId', _layerId);
	        _layer.set('map', _map);
	        _layer.set('layer_id', paramObj.layerId);
	        _layer.set('multiple', paramObj.multiple);
	        _layer.set('clickId', 'business_Dservice_polygon_event_id');
	        if (paramObj.minShowLevel != undefined) {
	            _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	        }

	        if (paramObj.maxShowLevel != undefined) {
	            _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	        }

	        hashMap.put(_layerId, _layer);
	        _map.addLayer(_layer);
	    }
	    
	    event.addClickCallback(paramObj.mapId,'business_Dservice_polygon_event_id',function(object){
	        if(object.layer && object.layer.get('businessType') ==='DPOLYGON' ){
	            var mapObj = mapBox.getMapObj(paramObj.mapId);
	            var transportDataToInnerLayer = object.transportDataToInnerLayer;
	            if (transportDataToInnerLayer) {
	                if (!!transportDataToInnerLayer && transportDataToInnerLayer.length > 0) {
	                    highlight(object.layer, 'click', transportDataToInnerLayer[0]);
	                }
	            }
	            else {
	                highlights.removeHighlight({
	                    mapId: paramObj.mapId,
	                    layerId: paramObj.layerId,
	                    hTypes: ['click']
	                });
	            }
	        }
	    }, paramObj.layerId)
	};

	var setLayerData = function (paramObj) {
	    var layer = layers.getLayer(paramObj);
	    if (layer) {
	        if (paramObj.label) {
	            layer.set('params.label', paramObj.label);
	        }
	        layer.set('params.imgToken', paramObj.imgToken);
	        layer.set('imgToken', paramObj.imgToken);
	        layer.set('params.imgTokenLabel', paramObj.imgTokenLabel);
	        layer.set('paramObj',paramObj);
	        var imgToken = (paramObj.isShowLabel ? paramObj.imgTokenLabel : paramObj.imgToken);
	        var FCName = imgToken != undefined ?  imgToken.slice(0, imgToken.indexOf(':')) : undefined;
	        var source = new ol.source.ImageWMS({
	            url: constant.GisRootUrl + '/common/mapRender/export',
	            params: {
	                imgToken: imgToken,
	                VERSION: '1.1.1',
	                FCName:FCName
	            },
	            wrapX: false
	        });
	        layer.setSource(source);
	    }

	};

	var highlight = function (layerObj, highlightType, param) {
	    var olMap = layerObj.get('map');
	    var mapId = olMap.getTarget();
	    var layerId = layerObj.get('layer_id');
	    var layerType = layerObj.get('businessType');

	    highlights.removeHighlight({
	        mapId: mapId,
	        layerId: layerId,
	        hTypes: ['click']
	    });

	    if (highlightType === constant.HTYPE.CLICK) {
	        _clickHighlight(mapId, layerId, layerType, highlightType, param);
	    }
	    else if (highlightType === constant.HTYPE.VECTOR) {
	        _vectorHighlight(mapId, layerId, layerType, highlightType, param, layerObj);
	    }
	};

	function _clickHighlight(mapId, layerId, layerType, highlightType, params) {
	    var points = params.geometry;
	    points = utils.transformMultArray(points);
	    var _width = params.strokeWidth !== undefined ? params.strokeWidth : 1;
	    var feature = new ol.Feature({
	        geometry: new ol.geom.Polygon([points]),
	        mapId: mapId,
	        layerId: layerId,
	        layerType: layerType,
	        hType: highlightType
	    });

	    var style = new ol.style.Style({
	        stroke: new ol.style.Stroke({
	            width: _width,
	            color: params.strokeColor || 'black'
	        })
	    });

	    feature.setStyle(style);
	    var layerObj = highlights.getHLayer({
	        mapId: mapId,
	        layerId: layerId
	    });
	    layerObj.getSource().addFeature(feature);
	}

	function _vectorHighlight(mapId, layerId, layerType, highlightType, param, layerObj) {
	    var imgToken = layerObj.get('imgToken');
	    var Fcname = imgToken != undefined ?  imgToken.slice(0, imgToken.indexOf(':')) : undefined;
	    var _width = param.strokeWidth !== undefined ? param.strokeWidth : 1;
	    ajax.postJSON({
	        url: constant.GisRootUrl + '/common/mapRender/query?FCName='+Fcname,
	        data: JSON.stringify({
	            idValue: param.geoIds,
	            imgToken: imgToken
	        }),
	        success: function(result) {
	        		if(!result) {
	        			return;
	        		}
	        		result = JSON.parse(result);
	        		if(result.status.code !== 1 || !result.data || !result.data.length) {
	        			return;
	        		}

	        		var features = result.data.map(function(pointData) {
	        			var points = pointData.geometry;
	                    points = utils.transformMultArray(points);
	        			var feature = new ol.Feature({
	        				geometry: new ol.geom.Polygon([points]),
	        				mapId: mapId,
	        				layerId: layerId,
	        				layerType: layerType,
	        				hType: highlightType
	        			});

	        			var style = new ol.style.Style({
	        				stroke: new ol.style.Stroke({
	        					width: _width,
	        					color: param.strokeColor || '#9900FF'
	        				})
	        			});

	        			feature.setStyle(style);
	        			return feature;
	        		});

	        		var layerObj = highlights.getHLayer({
	        			mapId: mapId,
	        			layerId: layerId
	        		});
	        		layerObj.getSource().addFeatures(features);
	        	},
	        failure: function(result) {
	        		console.log(result);

	        	}

	       
	    });
	}

	var getClickData = function (mapObj, layerObj, evt, callback) {
		if(!layerObj.getVisible()){
			callback([]);
			return;
		}
		
	    var extent = maps.getExtent(mapObj.getTarget());
	    var imgToken = layerObj.get('imgToken');
	    var FCName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
	    var layerParamObj = layerObj.get('paramObj');
	    var paramObj = {
	        geometry: JSON.stringify({x: evt.coordinate[0], y: evt.coordinate[1]}),
	        tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  0.1,
	        mapExtent: extent,
	        imgToken: imgToken,
	        FCName:FCName
	    };
	    ajax.get({
	        url: constant.GisRootUrl + '/common/mapRender/identify',
	        data: utils.getParameterString(paramObj),
	        success: function (result) {
	            if (!result) {
	                return;
	            }
	            var responseText = JSON.parse(result);
	            var status = responseText.status;
	            if (status.code === 1) { //请求成功，可能有数据，可能没数据
	                if (responseText.data && responseText.data.length > 0) {
	                    var datas = responseText.data.map(function (data) {
	                        var oneData = {
	                            mapId: mapObj.getTarget(),
	                            layerId: layerObj.get('layer_id'),
	                            layerType: layerObj.get('businessType'),
	                            label: layerObj.get('params.label'),
	                            lonLat: data.centerPoint,
	                            geometry: data.geometry,
	                            extentInfo: data.extentInfo,
	                            geoId: data.id,
	                            geoName: data.name
	                        };

	                        return oneData;
	                    });

	                    if (callback && typeof callback === 'function') {
	                        callback(datas);
	                    }
	                }
	                else {
	                    callback([]);
	                }
	            }
	            else {
	                callback([]);
	            }
	        },
	        failure: function(result) {
	        	console.log(result);
	        	callback([]);

	        }
	    });
	};

	function getQueryData(param) {
	    var callback = param.callback;
	    ajax.postJSON({
	        url: constant.GisRootUrl + '/custom/queryfeature?FCName='+param.FCName,
	        data: JSON.stringify(param),
	        success: function (result) {
	            if (!result) {
	                return;
	            }
	            var responseText = JSON.parse(result);
	            var status = responseText.status;
	            if (status.code === 1) { //请求成功，可能有数据，可能没数据
	                callback(responseText);
	            }
	            else {
	                callback([]);
	            }
	        },
	        failure: function(result) {
	        	callback([]);
	        	console.log(result);

	        }
	    });
	}

	function setShowLabel(param) {
	    var layer = layers.getLayer(param);
	    if (!layer) {
	        return;
	    }
	    var imgToken;
	    if (param.isShowLabel) {
	        imgToken = layer.get('params.imgTokenLabel');
	    }
	    else {
	        imgToken = layer.get('params.imgToken');
	    }
	    var updateParams = {
	        VERSION: '1.1.1',
	        imgToken: imgToken
	    };
	    layer.getSource().updateParams(updateParams);
	}

	module.exports = {
	    addLayer: addLayer,
	    setLayerData: setLayerData,
	    getClickData: getClickData,
	    highlight: highlight,
	    setShowLabel: setShowLabel,
	    getQueryData:getQueryData
	};

/***/ },
/* 57 */
/*!**************************************************!*\
  !*** ./src/gis/businessLayers/dcServicePoint.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @file 服务Point
	 */

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var maps = __webpack_require__(/*! maps/map */ 8);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var ajax = __webpack_require__(/*! utils/ajax */ 14);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);
	var event = __webpack_require__(/*! maps/event */ 11);

	var addLayer = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId;
	    var _map = mapBox.getMapObj(paramObj.mapId);

	    if (!hashMap.containsKey(_layerId)) {
	        var _layer = new ol.layer.Image({
	            source: new ol.source.ImageWMS({
	                params: {
	                    VERSION: '1.1.1'
	                },
	                wrapX: false
	            })
	        });
	         var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.MARKER;
	        _layer.setZIndex(_ZIndex);
	        _layer.set('type', constant.CUSTOMTYPE.LAYERTILETYPE);
	        _layer.set('isVectorType',false);
	        _layer.set('businessType','DPOINT');
	        _layer.set('dw',paramObj.dw);
	        _layer.set('params.label', paramObj.label);
	        _layer.set('layerId', _layerId);
	        _layer.set('map', _map);
	        _layer.set('layer_id', paramObj.layerId);
	        _layer.set('clickId', 'business_Dservice_point_event_id');

	        if (!!paramObj.multiple) {
	            _layer.set('multiple', paramObj.multiple);
	        }
	        if (paramObj.minShowLevel != undefined) {
	            _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	        }

	        if (paramObj.maxShowLevel != undefined) {
	            _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));
	        }

	        hashMap.put(_layerId, _layer);
	        _map.addLayer(_layer);
	    }

	    event.addClickCallback(paramObj.mapId, 'business_Dservice_point_event_id', function (responseObj) {
	        if (responseObj.layer && responseObj.layer.get('businessType') === 'DPOINT') {
	            var mapObj = mapBox.getMapObj(paramObj.mapId);

	            var transportDataToInnerLayer = responseObj.transportDataToInnerLayer;
	            if (transportDataToInnerLayer) {
	                highlight(responseObj.layer, 'click', transportDataToInnerLayer[0]);
	            }
	            else {
	                highlights.removeHighlight({
	                    mapId: paramObj.mapId,
	                    layerId: paramObj.layerId,
	                    hTypes: ['click']
	                });
	            }
	        }
	    }, paramObj.layerId)
	};

	var setLayerData = function (paramObj) {
	    var layer = layers.getLayer(paramObj);
	    if (paramObj.label) {
	        layer.set('params.label', paramObj.label);
	    }
	    var _url =null;
	    if(layer.get('dw')!==undefined){//不走中间件
	    	_url =constant.GisRootUrl + '/mapRender/export';
	    }else{//走中间件
	    	_url =constant.GisRootUrl + '/common/mapRender/export';
	    }
	    layer.set('imgToken', paramObj.imgToken);
	    layer.set('paramObj',paramObj);
	    
	    layer.set('params.imgTokenLabel',paramObj.imgTokenLabel);
	    layer.set('params.imgToken',paramObj.imgToken);
	    var imgToken = (paramObj.showLabel ? paramObj.imgTokenLabel : paramObj.imgToken);
	    var FCName = imgToken != undefined ?  imgToken.slice(0, imgToken.indexOf(':')) : undefined;
	    var updateParams = {
	        VERSION: '1.1.1',
	        imgToken: imgToken,
	        FCName:FCName
	    };

	    if (layer) {
	        layer.getSource().setUrl(_url);
	        layer.getSource().updateParams(updateParams);
	    }
	};

	var highlight = function (layerObj, highlightType, param) {
	    var olMap = layerObj.get('map');
	    var mapId = olMap.getTarget();
	    var layerId = layerObj.get('layer_id');
	    var layerType = layerObj.get('businessType');

	    highlights.removeHighlight({
	        mapId: mapId,
	        layerId: layerId,
	        hTypes: ['click']
	    });

	    if (highlightType === constant.HTYPE.CLICK) {
	        _clickHighlight(mapId, layerId, layerType, highlightType, param);
	    }
	    else if (highlightType === constant.HTYPE.VECTOR) {
	        _vectorHighlight(mapId, layerId, layerType, highlightType, param, layerObj);
	    }
	};

	function _clickHighlight(mapId, layerId, layerType, highlightType, params) {
	    var points = params.geometry;
	    points = utils.gcjTransform(points);
	    var _width = params.strokeWidth !== undefined ? param.strokeWidth : 1;
	    var feature = new ol.Feature({
	        geometry: new ol.geom.Point(points),
	        mapId: mapId,
	        layerId: layerId,
	        layerType: layerType,
	        hType: highlightType
	    });
	    var style = new ol.style.Style({
	        image: new ol.style.Circle({
	            radius: params.radius || 5,
	            fill: new ol.style.Fill({
	                color: params.fillColor || 'black'
	            }),
	            stroke: new ol.style.Stroke({
	                color: params.strokeColor || 'black',
	                width: _width
	            })
	        })
	    });
	    feature.setStyle(style);
	    var layerObj = highlights.getHLayer({
	        mapId: mapId,
	        layerId: layerId
	    });
	    layerObj.getSource().addFeature(feature);
	}
	function _vectorHighlight(mapId, layerId, layerType, highlightType, param, layerObj) {
	    var imgToken = layerObj.get('imgToken');
	    var Fcname = imgToken != undefined ?  imgToken.slice(0, imgToken.indexOf(':')) : undefined;
	    var _width = param.strokeWidth !== undefined ? param.strokeWidth : 1;
	    ajax.postJSON({
	        url: constant.GisRootUrl + '/common/mapRender/query?FCName='+Fcname,
	        data: JSON.stringify({
	            idValue: param.geoIds,
	            imgToken: imgToken
	        }),
	        success: function (result) {
	            if (!result) {
	                return;
	            }
	            result = JSON.parse(result);
	            if (result.status.code !== 1 || !result.data || !result.data.length) {
	                return;
	            }

	            var features = result.data.map(function (pointData) {
	                var points = pointData.geometry;
	                points[0] = utils.gcjTransform(points[0]);
	                var feature = new ol.Feature({
	                    geometry: new ol.geom.Point(points[0]),
	                    mapId: mapId,
	                    layerId: layerId,
	                    layerType: layerType,
	                    hType: highlightType
	                });

	                var style = new ol.style.Style({
	                    image: new ol.style.Circle({
	                        radius: param.radius || 5,
	                        fill: new ol.style.Fill({
	                            color: param.fillColor || 'black'
	                        }),
	                        stroke: new ol.style.Stroke({
	                            color: param.strokeColor || 'black',
	                            width: _width
	                        })
	                    })
	                });

	                feature.setStyle(style);
	                return feature;
	            });

	            var layerObj = highlights.getHLayer({
	                mapId: mapId,
	                layerId: layerId
	            });
	            layerObj.getSource().addFeatures(features);
	        },
	        failure: function(result) {
	        	console.log(result);
	        }
	    });
	}
	function getQueryData(param) {
	    var callback = param.callback;
	    ajax.postJSON({
	        url: constant.GisRootUrl + '/custom/queryfeature?FCName='+param.FCName,
	        data: JSON.stringify(param),
	        success: function (result) {
	            if (!result) {
	                return;
	            }
	            var responseText = JSON.parse(result);
	            var status = responseText.status;
	            if (status.code === 1) { //请求成功，可能有数据，可能没数据
	                callback(responseText);
	            }
	            else {
	                callback([]);
	            }
	        },
	        failure: function(result) {
	        	callback([]);
	        }
	    });
	}

	function setShowLabel(param) {
	    var layer = layers.getLayer(param);
	    if (!layer) {
	        return;
	    }
	    var imgToken;
	    if (param.showLabel) {
	        imgToken = layer.get('params.imgTokenLabel');
	    }
	    else {
	        imgToken = layer.get('params.imgToken');
	    }
	    var updateParams = {
	        VERSION: '1.1.1',
	        imgToken: imgToken
	    };
	    layer.set('state.showLabel', !!param.showLabel);
	    layer.getSource().updateParams(updateParams);
	}

	var getClickData = function (mapObj, layerObj, evt, callback) {
		if(!layerObj.getVisible()){
			callback([]);
			return;
		}

	    var extent = maps.getExtent(mapObj.getTarget());
	    var imgToken = layerObj.get('imgToken');
	    var FCName = imgToken != undefined ?  imgToken.slice(0, imgToken.indexOf(':')) : undefined;
	    var layerParamObj = layerObj.get('paramObj');
	    var paramObj = {
	        geometry: JSON.stringify({x: evt.coordinate[0], y: evt.coordinate[1]}),
	        tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  10,
	        mapExtent: extent,
	        imgToken: imgToken,
	        FCName:FCName
	    };
	    ajax.get({
	        url: constant.GisRootUrl + '/common/mapRender/identify',
	        data: utils.getParameterString(paramObj),
	        success: function (result) {
	            if (!result) {
	                return;
	            }
	            var responseText = JSON.parse(result);
	            var status = responseText.status;
	            var data = responseText.data && responseText.data.length > 0 && responseText.data[0];
	            if (status.code === 1) { //请求成功，可能有数据，可能没数据
	                if (data) {
	                    if (callback && typeof callback === 'function') {
	                        callback([
	                            {
	                                mapId: mapObj.getTarget(),
	                                layerId: layerObj.get('layer_id'),
	                                layerType: layerObj.get('businessType'),
	                                geoId: data.id,
	                                geoName: data.name,
	                                lonLat: data.centerPoint,
	                                geometry: data.geometry,
	                                extentInfo: data.extentInfo
	                            }
	                        ]);
	                    }
	                }
	                else {
	                    callback([]);
	                }
	            }
	            else {
	                callback([]);
	            }
	        },
	        failure: function(result) {
	        	callback([]);
	        }
	    });
	};

	module.exports = {
	    addLayer: addLayer,
	    setLayerData: setLayerData,
	    getClickData: getClickData,
	    highlight: highlight,
	    getQueryData:getQueryData,
	    setShowLabel:setShowLabel
	};

/***/ },
/* 58 */
/*!*************************************************!*\
  !*** ./src/gis/businessLayers/dcServiceLine.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 服务Point
	 */
	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var maps = __webpack_require__(/*! maps/map */ 8);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var ajax = __webpack_require__(/*! utils/ajax */ 14);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);
	var event = __webpack_require__(/*! maps/event */ 11);

	var addLayer = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId;
	    var _map = mapBox.getMapObj(paramObj.mapId);
	    var _layer = null;
	    if (!hashMap.containsKey(_layerId)) {
	        _layer = new ol.layer.Image({
	            source: new ol.source.ImageWMS({
	                params: {
	                    VERSION: '1.1.1'
	                },
	                wrapX: false
	            })
	        });
	        var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.LINE;
	        _layer.setZIndex(_ZIndex);
	        _layer.set('type', constant.CUSTOMTYPE.LAYERTILETYPE);
	        _layer.set('isVectorType',false);
	        _layer.set('businessType', 'DLINE');
	        _layer.set('params.label', paramObj.label);
	        _layer.set('layerId', _layerId);
	        _layer.set('map', _map);
	        _layer.set('layer_id', paramObj.layerId);

	        if (!!paramObj.multiple) {
	            _layer.set('multiple', paramObj.multiple);
	        }

	        hashMap.put(_layerId, _layer);
	        _map.addLayer(_layer);
	    }
	    else {
	        _layer = hashMap.get(_layerId);
	    }
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	    }
	    _layer.set('clickId', 'business_Dservice_line_event_id');
	    event.addClickCallback(paramObj.mapId, 'business_Dservice_line_event_id', function (object) {
	        if (object.layer && object.layer.get('businessType') === 'DLINE') {
	            var mapObj = mapBox.getMapObj(paramObj.mapId);
	            
	            var transportDataToInnerLayer = object.transportDataToInnerLayer;
	            if (transportDataToInnerLayer) {
	                if (!!transportDataToInnerLayer && transportDataToInnerLayer.length > 0) {
	                    highlight(object.layer, 'click', transportDataToInnerLayer[0]);
	                }
	            }
	            else {
	                highlights.removeHighlight({
	                    mapId: paramObj.mapId,
	                    layerId: paramObj.layerId,
	                    hTypes: ['click']
	                });
	            }
	        }
	    }, paramObj.layerId)
	};

	var setLayerData = function (paramObj) {
	    var layer = layers.getLayer(paramObj);
	    if (paramObj.label) {
	        layer.set('params.label', paramObj.label);
	    }
	    layer.set('params.imgToken', paramObj.imgToken);
	    layer.set('params.imgTokenLabel',paramObj.imgTokenLabel);
	    
	    layer.set('imgToken', paramObj.imgToken);
	    layer.set('paramObj',paramObj);
	    
	    var imgToken = (paramObj.showLabel ? paramObj.imgTokenLabel : paramObj.imgToken);
	    var FCName = imgToken != undefined ?  imgToken.slice(0, imgToken.indexOf(':')) : undefined;
	    var updateParams = {
	        VERSION: '1.1.1',
	        imgToken: imgToken,
	        FCName:FCName
	    };
	    if (layer) {
	        layer.getSource().setUrl(constant.GisRootUrl + '/common/mapRender/export');
	        layer.getSource().updateParams(updateParams);
	    }
	};

	var highlight = function (layerObj, highlightType, param) {
	    var olMap = layerObj.get('map');
	    var mapId = olMap.getTarget();
	    var layerId = layerObj.get('layer_id');
	    var layerType = layerObj.get('businessType');

	    highlights.removeHighlight({
	        mapId: mapId,
	        layerId: layerId,
	        hTypes: ['click']
	    });

	    if (highlightType === constant.HTYPE.CLICK) {
	        _clickHighlight(mapId, layerId, layerType, highlightType, param);
	    }
	    else if (highlightType === constant.HTYPE.VECTOR) {
	        _vectorHighlight(mapId, layerId, layerType, highlightType, param, layerObj);
	    }
	};

	function _clickHighlight(mapId, layerId, layerType, highlightType, params) {
	    var points = params.geometry;
	    points = utils.transformMultArray(points);
	    var _width = params.strokeWidth !== undefined ? params.strokeWidth : 1;
	    var feature = new ol.Feature({
	        geometry: new ol.geom.LineString(points),
	        mapId: mapId,
	        layerId: layerId,
	        layerType: layerType,
	        hType: highlightType
	    });

	    var style = new ol.style.Style({
	        stroke: new ol.style.Stroke({
	            width: _width,
	            color: params.strokeColor || 'black'
	        })
	    });

	    feature.setStyle(style);
	    var layerObj = highlights.getHLayer({
	        mapId: mapId,
	        layerId: layerId
	    });
	    layerObj.getSource().addFeature(feature);
	}

	function _vectorHighlight(mapId, layerId, layerType, highlightType, param, layerObj) {
	    var imgToken = layerObj.get('imgToken');
	    var Fcname = imgToken != undefined ?  imgToken.slice(0, imgToken.indexOf(':')) : undefined;
	    var _width = param.strokeWidth !== undefined ? param.strokeWidth : 1;
	    ajax.postJSON({
	        url: constant.GisRootUrl + '/common/mapRender/query?FCName='+Fcname,
	        data: JSON.stringify({
	            idValue: param.geoIds,
	            imgToken: imgToken
	        }),
	        success: function (result) {
	            if (!result) {
	                return;
	            }
	            result = JSON.parse(result);
	            if (result.status.code !== 1 || !result.data || !result.data.length) {
	                return;
	            }

	            var features = result.data.map(function (pointData) {
	                var points = pointData.geometry;
	                points = utils.transformMultArray(points);
	                var feature = new ol.Feature({
	                    geometry: new ol.geom.LineString(points),
	                    mapId: mapId,
	                    layerId: layerId,
	                    layerType: layerType,
	                    hType: highlightType
	                });

	                var style = new ol.style.Style({
	                    stroke: new ol.style.Stroke({
	                        width: _width,
	                        color: param.strokeColor || '#9900FF'
	                    })
	                });

	                feature.setStyle(style);
	                return feature;
	            });

	            var layerObj = highlights.getHLayer({
	                mapId: mapId,
	                layerId: layerId
	            });
	            layerObj.getSource().addFeatures(features);
	        },
	        failure: function(result) {
	        	console.log(result);
	        }
	    });
	}
	function getQueryData(param) {
	    var callback = param.callback;
	    ajax.postJSON({
	        url: constant.GisRootUrl + '/custom/queryfeature?FCName='+param.Fcname,
	        data: JSON.stringify(param),
	        success: function (result) {
	            if (!result) {
	                return;
	            }
	            var responseText = JSON.parse(result);
	            var status = responseText.status;
	            if (status.code === 1) { //请求成功，可能有数据，可能没数据
	                if (callback && typeof callback === 'function') {
	                    callback(responseText);
	                }
	            }
	            else {
	                callback([]);
	            }
	        },
	        failure: function(result) {
	        	callback([]);
	        	console.log(result);
	        }
	    });
	}

	function setShowLabel(param) {
		var layer = layers.getLayer(param);
		if(!layer) {
			return;
		}
		var imgToken;
		if(param.showLabel) {
			imgToken = layer.get('params.imgTokenLabel');
		} else {
			imgToken = layer.get('params.imgToken');
		}
		var updateParams = {
			VERSION: '1.1.1',
			imgToken: imgToken
		};
		layer.set('state.showLabel', !!param.showLabel);
		layer.getSource().updateParams(updateParams);
	}

	var getClickData = function (mapObj, layerObj, evt, callback) {
		if(!layerObj.getVisible()) {
			callback([]);
			return;
		}
	    var extent = maps.getExtent(mapObj.getTarget());
	    var imgToken = layerObj.get('imgToken');
	    var FCName = imgToken != undefined ?  imgToken.slice(0, imgToken.indexOf(':')) : undefined;
	    var layerParamObj = layerObj.get('paramObj');
	    var paramObj = {
	        geometry: JSON.stringify({x: evt.coordinate[0], y: evt.coordinate[1]}),
	        tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  1,
	        mapExtent: extent,
	        imgToken: imgToken,
	        FCName: FCName
	    };
	    ajax.get({
	        url: constant.GisRootUrl + '/common/mapRender/identify',
	        data: utils.getParameterString(paramObj),
	        success: function (result) {
	            if (!result) {
	                return;
	            }
	            var responseText = JSON.parse(result);
	            var status = responseText.status;
	            var data = responseText.data && responseText.data.length > 0 && responseText.data[0];
	            if (status.code === 1) { //请求成功，可能有数据，可能没数据
	                if (data) {
	                    if (callback && typeof callback === 'function') {
	                        callback(
	                            [
	                                {
	                                    mapId: mapObj.getTarget(),
	                                    layerId: layerObj.get('layer_id'),
	                                    layerType: layerObj.get('businessType'),
	                                    geoId: data.id,
	                                    geoName: data.name,
	                                    lonLat: data.centerPoint,
	                                    geometry: data.geometry,
	                                    extentInfo: data.extentInfo
	                                }
	                            ]
	                        );
	                    }
	                }
	                else {
	                    callback([]);
	                }
	            }
	            else {
	                callback([]);
	            }
	        },
	        failure: function(result) {
	        	console.error(result);
	        	callback([]);

	        }
	    });
	};

	module.exports = {
	    addLayer: addLayer,
	    setLayerData: setLayerData,
	    getClickData: getClickData,
	    highlight: highlight,
	    getQueryData:getQueryData,
	    setShowLabel:setShowLabel
	};

/***/ },
/* 59 */
/*!*********************************************!*\
  !*** ./src/gis/layers/bubbleCircleLabel.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var algorithm = __webpack_require__(/*! framework/algorithm */ 48);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);

	var addBubble = function(paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId,
	        _layer = null;
	    if (hashMap.containsKey(_layerId)) {
	        _layer = hashMap.get(_layerId);
	    } else {
	        baseLayer.createLayer(paramObj);
	        _layer = hashMap.get(_layerId);
	    }
	    if (!!paramObj.multiple) {
	        _layer.set('multiple', paramObj.multiple);
	    }

	    _layer.set('businessType', 'BUBBLE_CIRCLE_LABEL');
	    _layer.set('layer_id', paramObj.layerId);
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }
	    _layer.set('isRadiuChange', paramObj.isRadiuChange || true);
	    _layer.set('datas', paramObj.datas);
	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));
	    }
	    _layer.set('isNotTip', paramObj.isNotTip === undefined ? false : paramObj.isNotTip);
	    if (!!paramObj.isHighlight) {
	        fusiongis.Events.addClickCallback(paramObj.mapId, 'bubble-circle-label-click-event', function(obj) {
	            if (obj.layer && obj.layer.get('businessType') === 'BUBBLE_CIRCLE_LABEL' &&
	                obj.feature && obj.feature.get('vectorType') === 'BUBBLE_CIRCLE_LABEL') {
	                highlights.removeHighlight({
	                    mapId: paramObj.mapId,
	                    layerId: paramObj.layerId,
	                    hTypes: ['click']
	                });
	                var feature = obj.feature;
	                highlight(obj.layer, 'click', {mapId: paramObj.mapId, layerId: paramObj.layerId, feature: feature});
	            }
	        }, paramObj.layerId)
	    }
	    var _source = _layer.getSource();
	    paramObj.source = _source;
	    if(paramObj.zindex !== undefined){
	        _layer.setZIndex(paramObj.zindex);
	    }

	    _setLayerData(paramObj);
	}
	var highlight = function(olLayer, hlType, paramObj) {
	    if (olLayer) {
	        var olMap = olLayer.get('map');
	        var mapId = olMap.getTarget();
	        var layerId = olLayer.get('layer_id');
	        var layerType = olLayer.get('businessType');
	        var olZindex = olLayer.getZIndex();
	        highlights.removeHighlight({
	            mapId: mapId,
	            layerId: layerId,
	            hTypes: [hlType]
	        });
	        var hLayer = highlights.getHLayer({
	            mapId: mapId,
	            layerId: layerId
	        });
	        var hLayerId = hLayer.get('layerId');

	        if (olLayer.hasOwnProperty('mouseoverCallback')
	            && typeof olLayer.mouseoverCallback === 'function'
	            && !(hLayer.hasOwnProperty('mouseoverCallback'))) {
	            registerHlayerMouseHover({
	                layerId: hLayerId,
	                mapId: paramObj.mapId,
	                callbackfunc: olLayer.mouseoverCallback
	            })
	        }
	        if (hlType === constant.HTYPE.CLICK) {
	            if (paramObj.feature) {
	                var geoId = paramObj.feature.getId();
	                var feature = paramObj.feature;
	                var highLight = paramObj.feature.get('select');
	                var tempFeature = feature.clone();
	                var data = feature.get('data');
	                var dealData = feature.get('dealData');
	                var highLightData = feature.get('select');
	                var tipCoordinates = paramObj.feature.get('tipCoordinates');
	                var _feature = _selfDrawLineRingCircle('highlight', {
	                    highLightData: highLightData,
	                    dealData: dealData,
	                    data: data,
	                    mapId: mapId,
	                    getId: geoId,
	                    hType: hlType,
	                    hLayer: hLayer,
	                    tipCoordinates: tipCoordinates
	                });
	                data['hType'] = hlType;
	                hLayer.set('data', data);
	                hLayer.set('tipCoordinates', tipCoordinates);
	                hLayer.set('dealData', dealData);
	                hLayer.set('select', highLightData);
	                hLayer.getSource().addFeature(_feature);
	                hLayer.setZIndex(olZindex + 1);
	            }
	        } else if (hlType === constant.HTYPE.VECTOR) {
	            var featureDatas = [];
	            if (paramObj.geoIds !== undefined && paramObj.geoIds.length > 0) {
	                var features = paramObj.geoIds.map(function(geoId) {
	                    var feature = olLayer.getSource().getFeatureById(geoId);
	                    var highLightData = feature.get('select');
	                    var tempFeature = feature.clone();
	                    var data = feature.get('data');
	                    var dealData = feature.get('dealData');
	                    featureDatas.push({
	                        data: data,
	                        dealData: dealData,
	                        highLightData: highLightData,
	                        hlType: hlType,
	                        tipCoordinates: feature.get('tipCoordinates')
	                    });
	                    var _feature = _selfDrawLineRingCircle('highlight', {
	                        highLightData: highLightData,
	                        dealData: dealData,
	                        data: data,
	                        mapId: mapId,
	                        geoId: geoId,
	                        hType: hlType,
	                        hLayer: hLayer,
	                        tipCoordinates: feature.get('tipCoordinates')
	                    });
	                    return _feature;

	                })
	                hLayer.set('data', featureDatas);
	                hLayer.getSource().addFeatures(features);
	                hLayer.setZIndex(olZindex + 1);
	            }

	        }
	    }
	}
	var _setLayerData = function(paramObj) {
	    var _data = paramObj.datas;
	    var _layerIdentify = paramObj.layerId + '_' + paramObj.mapId;
	    var _layer = hashMap.get(_layerIdentify);
	    var _source = _layer.getSource();
	    var _mapObj = mapBox.getMapObj(paramObj.mapId);
	    var _angle = 360, _azimuth = 0, pointRadius = 0;
	    var tipAzimth = paramObj.tipAzimth, tipAngle = 0;
	    _layer.set('tipAzimth', paramObj.tipAzimth);
	    _layer.set('isDis', paramObj.isDis);
	    if (utils.isValid(_data) || _data.length > 0) {
	        var _features = [];
	        _data.forEach(function(_dataItem, index) {
	            var _coordinate = utils.gcjTransform(_dataItem.coordinate);
	            var _radius = _dataItem.radius ? _dataItem.radius : 40;
	            var _coordinates = [], _lon = _coordinate[0], _lat = _coordinate[1];
	            var pixel = _mapObj.getPixelFromCoordinate(ol.proj.fromLonLat(_coordinate));
	            var _pixelList = algorithm.createSector(pixel[0], pixel[1], _radius, _azimuth, _angle);
	            var _pixelList2 = getPiexlCoordintesByAzimth(pixel, _radius, tipAzimth);
	            var tipCoordinates = ol.proj.toLonLat(_mapObj.getCoordinateFromPixel(_pixelList2));
	            for (var k = 0; k < _pixelList.length; k++) {
	                _coordinates.push(_mapObj.getCoordinateFromPixel(_pixelList[k]))
	            }

	            var _linearRing = new ol.geom.LinearRing(_coordinates);
	            var ring = _linearRing.getCoordinates();
	            var _polygon = null;
	            _polygon = new ol.geom.GeometryCollection();
	            ring.splice(0, 2);
	            ring.splice(ring.length - 1, 2);
	            _polygon.setGeometries([new ol.geom.Circle(ol.proj.fromLonLat([_lon, _lat]), pointRadius), new ol.geom.Polygon([ring])]);
	            var _multiple = 1000;
	            var _feature = new ol.Feature({
	                geometry: _polygon,
	                data: _dataItem,
	                businessType: 'BUBBLE_CIRCLE_LABEL'
	            });
	            var multiplierNum = _dataItem.radius / 50;
	            var aeraFontSize = multiplierNum * 15 + 'px';
	            var typeFontSize = multiplierNum * 10 + 'px';
	            var percentFontSize = multiplierNum * 25 + 'px';
	            var areaMultiplier, typeMultiplier;
	            if (multiplierNum >= 1) {
	                areaMultiplier = 4;
	                typeMultiplier = 8
	            } else if (multiplierNum >= 0.5 && multiplierNum < 1) {
	                areaMultiplier = 3;
	                typeMultiplier = 4;

	            } else {
	                areaMultiplier = 2;
	                typeMultiplier = 3;
	            }
	            if (!!paramObj.isDis) {
	                var labelArea = _dataItem.label.labelArea;
	                var labelType = _dataItem.label.labelType;
	                var labelPercent = _dataItem.label.labelPercent;
	            } else {
	                var labelArea = _dataItem.label.labelArea.toString().length > areaMultiplier ?
	                    _dataItem.label.labelArea.slice(0, areaMultiplier - 1) + '...' : _dataItem.label.labelArea;
	                var labelType = _dataItem.label.labelType.toString().length > typeMultiplier ?
	                    _dataItem.label.labelType.slice(0, typeMultiplier - 1) + '...' : _dataItem.label.labelType;
	                var labelPercent = _dataItem.label.labelPercent;
	            }
	            _feature.setId(_dataItem.id);
	            _feature.set('defaultRadiu', _radius);
	            _feature.set('data', _dataItem);
	            _feature.set('layer', _layer);
	            _feature.set('tipCoordinates', tipCoordinates);
	            _feature.set('vectorType', 'BUBBLE_CIRCLE_LABEL');
	            var _style = new ol.style.Style({
	                fill: new ol.style.Fill({
	                    color: _dataItem.fillColor || 'blue'
	                }),
	                stroke: new ol.style.Stroke({
	                    color: _dataItem.strokeColor || 'white',
	                    width: _dataItem.strokeWidth || 3,
	                    lineDash: _dataItem.lineDash || undefined
	                }),
	                text: new ol.style.Text({
	                    text: labelArea,
	                    fill: new ol.style.Fill({
	                        color: _dataItem.labelColor || 'white',
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color: !!paramObj.isDis ? 'rgba(0,0,0,0.6)' : !!_dataItem.labelStrokeColor
	                            ? _dataItem.labelStrokeColor : 'transparent',
	                        width: !!paramObj.isDis ? 3 : !!_dataItem.labelStrokeWidth
	                            ? _dataItem.labelStrokeWidth : 0
	                    }),
	                    font: _dataItem.label.areaFont || aeraFontSize + ' lighter Arail',
	                    offsetY: _dataItem.label.areaOffsetY || -30 * multiplierNum
	                })
	            });
	            var _labelTypeStyle = new ol.style.Style({
	                text: new ol.style.Text({
	                    text: labelType,
	                    fill: new ol.style.Fill({
	                        color: _dataItem.labelColor || 'white',
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color: !!paramObj.isDis ? 'rgba(0,0,0,0.6)' : !!_dataItem.labelStrokeColor
	                            ? _dataItem.labelStrokeColor : 'transparent',
	                        width: !!paramObj.isDis ? 3 : !!_dataItem.labelStrokeWidth
	                            ? _dataItem.labelStrokeWidth : 0
	                    }),
	                    font: _dataItem.label.typeFont || typeFontSize + ' lighter Arail',
	                    offsetY: _dataItem.label.typeOffsetY || -5 * multiplierNum
	                }),

	            });
	            var _labelPercentStyle = new ol.style.Style({
	                text: new ol.style.Text({
	                    text: labelPercent,
	                    fill: new ol.style.Fill({
	                        color: _dataItem.labelColor || 'white',
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color: !!paramObj.isDis ? 'rgba(0,0,0,0.6)' : !!_dataItem.labelStrokeColor
	                            ? _dataItem.labelStrokeColor : 'transparent',
	                        width: !!paramObj.isDis ? 3 : !!_dataItem.labelStrokeWidth
	                            ? _dataItem.labelStrokeWidth : 0
	                    }),
	                    font: _dataItem.label.percentFont || percentFontSize + ' lighter Arail',
	                    offsetY: _dataItem.label.percentOffsetY || 25 * multiplierNum
	                })
	            })
	            var _styleAll = [_style, _labelTypeStyle, _labelPercentStyle];
	            _style.setZIndex(index);
	            _labelTypeStyle.setZIndex(index);
	            _labelPercentStyle.setZIndex(index);
	            _feature.setStyle(_styleAll);
	            var dealData = {
	                labelArea: labelArea,
	                labelType: labelType,
	                labelPercent: labelPercent,
	                multiplierNum: multiplierNum,
	                aeraFontSize: aeraFontSize,
	                percentFontSize: percentFontSize,
	                typeFontSize: typeFontSize
	            }
	            var defaultHighlight = {
	                strokeColor: _dataItem.strokeColor || 'black',
	                labelColor: _dataItem.labelColor || 'white',
	                lineDash: _dataItem.lineDash || undefined,
	                fillColor: _dataItem.fillColor || 'blue'
	            };
	            _feature.set('dealData', dealData);
	            _feature.set('select', _dataItem.highlight || defaultHighlight);
	            _features.push(_feature);
	        })
	        _source.addFeatures(_features);
	    }
	};

	var _clearBubble = function(paramObj) {
	    var layerObj = fusiongis.BaseLayer.getLayer(paramObj);
	    if (!!layerObj && !!layerObj.getSource()) {
	        layerObj.getSource().clear();
	    }
	}
	var zoomChangeHightlight = function(paramObj) {
	    var mapObj = mapBox.getMapObj(paramObj.mapId);
	    var layers = mapObj.getLayers().getArray();
	    var Hlayer, features = [];
	    layers && layers.forEach(function(layer) {
	        if (layer.get('layerId') && layer.get('layerId') === paramObj.layerId) {
	            Hlayer = layer;
	        }
	    });
	    if (Hlayer !== undefined) {
	        Hlayer.getSource().clear();
	        var data = Hlayer.get('data');
	        if (data === undefined) {
	            return;
	        }
	        if (data instanceof Array && data.length > 0) {
	            features = data.map(function(_data) {
	                var _feature = _selfDrawLineRingCircle('highlight', {
	                    mapId: paramObj.mapId,
	                    geoId: _data.data.id,
	                    highLightData: _data.highLightData,
	                    dealData: _data.dealData,
	                    data: _data.data,
	                    hType: _data.hlType,
	                    hLayer: Hlayer,
	                    tipCoordinates: _data.tipCoordinates
	                });
	                return _feature;
	            })
	        } else {
	            var _feature = _selfDrawLineRingCircle(Hlayer, {
	                mapId: paramObj.mapId,
	                geoId: data.id,
	                hType: data.hType,
	                tipCoordinates: Hlayer.get('tipCoordinates')
	            });
	            features.push(_feature);
	        }
	        Hlayer.getSource().addFeatures(features);
	    }
	}
	var _selfDrawLineRingCircle = function(Hlayer, paramObj) {
	    var data, highLightData, dealData, geoId, hLayer;
	    var mapObj = mapBox.getMapObj(paramObj.mapId);
	    var tipCoordinates = paramObj.tipCoordinates;
	    if (Hlayer !== undefined && Hlayer !== 'highlight') {
	        data = Hlayer.get('data');
	        highLightData = Hlayer.get('select');
	        dealData = Hlayer.get('dealData');
	        geoId = paramObj.geoId;
	        hLayer = Hlayer;
	    } else {
	        data = paramObj.data;
	        highLightData = paramObj.highLightData;
	        dealData = paramObj.dealData;
	        geoId = paramObj.geoId;
	        hLayer = paramObj.hLayer;
	    }
	    if (data !== undefined && highLightData !== undefined && dealData !== undefined) {
	        var _angle = 360, _azimuth = 0, pointRadius = 0;
	        var _radius = data.radius ? data.radius : 40;
	        var _coordinates = [], _lon = data.coordinate[0], _lat = data.coordinate[1];
	        var pixel = mapObj.getPixelFromCoordinate(ol.proj.fromLonLat(data.coordinate));
	        var _pixelList = algorithm.createSector(pixel[0], pixel[1], _radius, _azimuth, _angle);
	        for (var k = 0; k < _pixelList.length; k++) {
	            _coordinates.push(mapObj.getCoordinateFromPixel(_pixelList[k]))
	        }
	        var _linearRing = new ol.geom.LinearRing(_coordinates);
	        var ring = _linearRing.getCoordinates();
	        var _polygon = null;
	        _polygon = new ol.geom.GeometryCollection();
	        ring.splice(0, 2);
	        ring.splice(ring.length - 1, 2);
	        _polygon.setGeometries([new ol.geom.Circle(ol.proj.fromLonLat([_lon, _lat]), pointRadius), new ol.geom.Polygon([ring])]);
	        var _multiple = 1000;
	        var _feature = new ol.Feature({
	            geometry: _polygon,
	            data: data,
	            businessType: 'BUBBLE_CIRCLE_LABEL'
	        });
	        var lineDash = highLightData.lineDash === undefined ? data.lineDash :
	            highlight.lineDash === 'solid' ? undefined : highlight.lineDash;
	        var _areaStyle = new ol.style.Style({
	            fill: new ol.style.Fill({
	                color: highLightData.fillColor || data.fillColor
	            }),
	            stroke: new ol.style.Stroke({
	                color: highLightData.strokeColor || 'black',
	                width: data.strokeWidth || 3,
	                lineDash: lineDash || undefined
	            }),
	            text: new ol.style.Text({
	                text: dealData.labelArea,
	                fill: new ol.style.Fill({
	                    color: highLightData.labelColor || 'white',
	                }),
	                font: data.label.areaFont || dealData.aeraFontSize + ' lighter Arail',
	                offsetY: data.label.areaOffsetY || -30 * dealData.multiplierNum
	            })
	        });
	        var _labelTypeStyle = new ol.style.Style({
	            text: new ol.style.Text({
	                text: dealData.labelType,
	                fill: new ol.style.Fill({
	                    color: highLightData.labelColor || 'white',
	                }),
	                font: data.label.typeFont || dealData.typeFontSize + ' lighter Arail',
	                offsetY: data.label.typeOffsetY || -5 * dealData.multiplierNum
	            }),

	        });
	        var _labelPercentStyle = new ol.style.Style({
	            text: new ol.style.Text({
	                text: dealData.labelPercent,
	                fill: new ol.style.Fill({
	                    color: highLightData.labelColor || 'white',
	                }),
	                font: data.label.percentFont || dealData.percentFontSize + ' lighter Arail',
	                offsetY: data.label.percentOffsetY || 25 * dealData.multiplierNum
	            })
	        })
	        var _style = [_areaStyle, _labelTypeStyle, _labelPercentStyle];
	        _feature.setStyle(_style);
	        _feature.set('hType', paramObj.hType);
	        _feature.setId(geoId);
	        _feature.set('layer', hLayer);
	        _feature.set('mapId', paramObj.mapId);
	        _feature.set('highlightFeature', true);
	        _feature.set('tipCoordinates', tipCoordinates);
	        return _feature;
	    }
	}
	var removeBubbleLayer = function(paramObj) {
	    baseLayer.removeLayer(paramObj);
	    var mapObj = mapBox.getMapObj(paramObj.mapId);
	    var layers = mapObj.getLayers().getArray();
	    var highlightLayerIds = paramObj.layerIds.map(function(layerId) {
	        return layerId + '&&&highlight';
	    });
	    highlightLayerIds.forEach(function(hLayerId) {
	        layers.forEach(function(layer) {
	            if (layer.get('layer_id') === hLayerId) {
	                mapObj.removeLayer(layer);
	            }
	        })
	    })
	}
	var registerHlayerMouseHover = function(paramObj) {
	    var hLayer;
	    var mapObj = mapBox.getMapObj(paramObj.mapId);
	    var layers = mapObj.getLayers().getArray();
	    layers.forEach(function(layer) {
	        if (layer.get('layerId') === paramObj.layerId) {
	            hLayer = layer;
	        }
	    })
	    if (paramObj.hasOwnProperty('callbackfunc') && hLayer) {
	        hLayer.mouseoverCallback = paramObj.callbackfunc;
	    }
	}
	var getPiexlCoordintesByAzimth = function(piexl, radius, azimuth) {
	    var piexlX_, piexlY_;
	    if (azimuth < 90) {
	        piexlX_ = piexl[0] + radius * Math.cos(azimuth);
	        piexlY_ = Math.sqrt(radius * radius - (piexlX_ - piexl[0]) * (piexlX_ - piexl[0])) + piexl[1];
	    } else if (azimuth === 90) {
	        piexlX_ = piexl[0];
	        piexlY_ = piexl[1] + radius;
	    } else if (azimuth > 90 && azimuth <= 180) {
	        piexlX_ = piexl[0] - radius * Math.cos(180 - azimuth);
	        piexlY_ = Math.sqrt(radius * radius - (piexlX_ - piexl[0]) * (piexlX_ - piexl[0])) + piexl[1];
	    } else if (azimuth > 180 && azimuth < 270) {
	        piexlX_ = piexl[0] - radius * Math.cos(azimuth - 180);
	        piexlY_ = Math.sqrt(radius * radius - (piexlX_ - piexl[0]) * (piexlX_ - piexl[0])) + piexl[1];
	    } else if (azimuth === 270) {
	        piexlX_ = piexl[0];
	        piexlY_ = piexl[1] - radius;
	    } else {
	        piexlX_ = piexl[0] + radius * Math.cos(360 - azimuth);
	        piexlY_ = Math.sqrt(radius * radius - (piexlX_ - piexl[0]) * (piexlX_ - piexl[0])) + piexl[1];
	    }
	    return [piexlX_, piexlY_];
	}
	module.exports = {
	    addBubble: addBubble,
	    addLayer: addBubble,
	    setLayerData: _setLayerData,
	    clear: _clearBubble,
	    highlight: highlight,
	    zoomChangeHightlight: zoomChangeHightlight,
	    removeLayer: removeBubbleLayer
	};


/***/ },
/* 60 */
/*!*************************************!*\
  !*** ./src/gis/layers/fontStyle.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var algorithm = __webpack_require__(/*! framework/algorithm */ 48);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);


	var _addIconLayer = function(paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId,
	        _layer = null;
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId,
	        _layer = null;
	    if (hashMap.containsKey(_layerId)) {
	        _layer = hashMap.get(_layerId);
	    } else {
	        baseLayer.createLayer(paramObj);
	        _layer = hashMap.get(_layerId);
	    }
	    if (!!paramObj.multiple) {
	        _layer.set('multiple', paramObj.multiple);
	    }
	    _layer.set('businessType', 'ICON_FONT_STYLE');
	    _layer.set('layer_id', paramObj.layerId);
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }
	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));
	    }
	    _layer.set('datas', paramObj.datas);

	    var _source = _layer.getSource();
	    paramObj.source = _source;
	    if (!!paramObj.isHighlight) {
	        fusiongis.Events.addClickCallback(paramObj.mapId, 'font-style-click-event', function(obj) {
	            if (obj.layer && obj.layer.get('businessType') === 'ICON_FONT_STYLE' &&
	                obj.feature && obj.feature.get('vectorType') === 'ICON_FONT_STYLE') {
	                highlights.removeHighlight({
	                    mapId: paramObj.mapId,
	                    layerId: paramObj.layerId,
	                    hTypes: ['click']
	                });
	                var feature = obj.feature;
	                highlight(obj.layer, 'click', {mapId: paramObj.mapId, layerId: paramObj.layerId, feature: feature});
	            }
	        }, paramObj.layerId)
	    }
	    if(paramObj.zindex !== undefined){
	        _layer.setZIndex(paramObj.zindex);
	    }
	    _setLayerData(paramObj);
	}
	var highlight = function(olLayer, hlType, paramObj) {
	    if (olLayer) {
	        var olMap = olLayer.get('map');
	        var mapId = olMap.getTarget();
	        var layerId = olLayer.get('layer_id');
	        var layerType = olLayer.get('businessType');
	        highlights.removeHighlight({
	            mapId: mapId,
	            layerId: layerId,
	            hType: [hlType]
	        });
	        var hLayer = highlights.getHLayer({
	            mapId: mapId,
	            layerId: layerId
	        });
	        if (hlType === constant.HTYPE.CLICK) {
	            if (paramObj.feature) {
	                var geoId = paramObj.feature.getId();
	                var feature = paramObj.feature;
	                var highlight = paramObj.feature.get('select');
	                var templateFeature = feature.clone();
	                var data = feature.get('data').labelFontStyle;
	                var _finalStyle = [];
	                data.forEach(function(textStyle,index) {
	                    var _style = new ol.style.Style({
	                        text: new ol.style.Text({
	                            text: textStyle.label || '',
	                            fill: new ol.style.Fill({
	                                color: highlight.fillColor || '#757171'
	                            }),
	                            stroke: new ol.style.Stroke({
	                                color: highlight.strokeColor || null,
	                                width: highlight.strokeWidth || 0,
	                                lineDash: textStyle.lineDash || undefined
	                            }),
	                            font: textStyle.font || '10px sans-seri',
	                            textAlign: textStyle.textAlign || 'start',
	                            textBaseline: textStyle.textBaseline || 'alphabetic',
	                            offsetY: textStyle.OffsetY || 20 * index,
	                            offsetX: textStyle.OffsetX || 0
	                        })
	                    });
	                    _finalStyle.push(_style);
	                })
	                templateFeature.setStyle(_finalStyle);
	                templateFeature.set('hType', 'click');
	                templateFeature.setId(geoId);
	                templateFeature.set('mapId', paramObj.mapId);
	                templateFeature.set('highlightFeature', true);
	            }
	            hLayer.getSource().addFeature(templateFeature);
	        } else if (hType === constant.HTYPE.VECTOR) {
	            var features = param.geoIds.map(function(geoId) {
	                var feature = olLayer.getSource().getFeatureById(geoId);
	                var highlight = feature.get('select');
	                var tempFeature = feature.clone();
	                var data = feature.get('data');
	                var tempFeature = feature.clone();
	                var _finalStyle = [];
	                data.forEach(function(textStyle,index) {
	                    var _style = new ol.style.Style({
	                        text: new ol.style.Text({
	                            text: textStyle.label || '',
	                            fill: new ol.style.Fill({
	                                color: highlight.fillColor || '#757171'
	                            }),
	                            stroke: new ol.style.Stroke({
	                                color: highlight.strokeColor || null,
	                                width: highlight.strokeWidth || 0,
	                                lineDash: textStyle.lineDash || undefined
	                            }),
	                            font: textStyle.font || '10px sans-seri',
	                            textAlign: textStyle.textAlign || 'start',
	                            textBaseline: textStyle.textBaseline || 'alphabetic',
	                            offsetY: textStyle.OffsetY || 20 * index,
	                            offsetX: textStyle.OffsetX || 0
	                        })
	                    });
	                    _finalStyle.push(_style);
	                })
	                tempFeature.setStyle(_style);
	                tempFeature.setId(geoId);
	                tempFeature.set('mapId', mapId);
	                tempFeature.set('layerId', layerId);
	                tempFeature.set('layerType', layerType);
	                tempFeature.set('hType', hlType);
	                tempFeature.set('highlightFeature', true);
	                return tempFeature;
	            })
	            hLayer.getSource().addFeature(features);
	        }
	    }
	}
	var _setLayerData = function(paramObj) {
	    var _mapObj = mapBox.getMapObj(paramObj.mapId),
	        _data = paramObj.datas,
	        _layerIdentify = paramObj.layerId + '_' + paramObj.mapId,
	        _layer = hashMap.get(_layerIdentify),
	        _source = _layer.getSource();
	    if (utils.isValid(_data) && _data.length > 0) {
	        var iconFeatures = [];
	        _data.forEach(function(_dataItem) {
	        	
	        	var _lastDataItem =utils.extend({},_dataItem);
	        	var _transFormCoord =utils.gcjTransform(_lastDataItem.coordinate);
	        	
	            var _coordinateNumber = _transFormCoord;
	            var _coordinate = ol.proj.fromLonLat(
	                [Number(_coordinateNumber[0]), Number(_coordinateNumber[1])]);
	            var _feature = new ol.Feature({
	                geometry: new ol.geom.Point(_coordinate)
	            })
	            var _textStyle = _dataItem.labelFontStyle;
	            var _styleFinal = [];
	            if (_textStyle instanceof Array) {
	                _textStyle.forEach(function(textStyle, index) {
	                    var _style = new ol.style.Style({
	                        text: new ol.style.Text({
	                            text: textStyle.label || '',
	                            fill: new ol.style.Fill({
	                                color: textStyle.fillColor || '#757171'
	                            }),
	                            stroke: new ol.style.Stroke({
	                                color: textStyle.strokeColor || null,
	                                width: textStyle.strokeWidth || 0,
	                                lineDash: textStyle.lineDash || undefined
	                            }),
	                            font: textStyle.font || '10px sans-seri',
	                            textAlign: textStyle.textAlign || 'start',
	                            textBaseline: textStyle.textBaseline || 'alphabetic',
	                            offsetY: textStyle.OffsetY || 20 * index,
	                            offsetX: textStyle.OffsetX || 0
	                        })
	                    });
	                    _styleFinal.push(_style);

	                });
	                var defalutHighlight = {
	                    fillColor :  _textStyle[0].fillColor || '#757171',
	                    strokeColor :_textStyle[0].strokeColor || null,
	                    strokeWidth :_textStyle[0].strokeWidth || 0
	                }
	                _feature.setStyle(_styleFinal);
	                _feature.set('select',_dataItem.highlight ? _dataItem.highlight : defalutHighlight);
	                _feature.setId(_dataItem.id);
	                _feature.set('data', _dataItem);
	                _feature.set('vectorType', 'ICON_FONT_STYLE');
	                _feature.set('layer', _layer);
	            }
	            iconFeatures.push(_feature);
	        })
	        _source.addFeatures(iconFeatures);
	    }
	}


	module.exports = {
	    addFontLayer : _addIconLayer,
	    addLayer: _addIconLayer,
	    setLayerData : _setLayerData
	}

/***/ },
/* 61 */
/*!**********************************************!*\
  !*** ./src/gis/businessLayers/multiPoint.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var event = __webpack_require__(/*! maps/event */ 11);

	var addLayer = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId,
	        _layer = null;
	    var _mapObj = mapBox.getMapObj(paramObj.mapId);
	    var _isShow = paramObj.isShow != undefined ? paramObj.isShow : true;
	    var _label = paramObj.label ? paramObj.label : paramObj.layerId;
	    if (hashMap.containsKey(_layerId)) {
	        _layer = hashMap.get(_layerId);
	    }
	    else {
	        _layer = new ol.layer.Vector({
	            source: new ol.source.Vector({
	                wrapX: false
	            })
	        });

	        ///自定义属性，方便后面通过类型判断对象
	        _layer.set('type', constant.CUSTOMTYPE.LAYERTYPE);
	        _layer.set('map', _mapObj);
	        _layer.set('layerId', paramObj.layerId);
	        _layer.set('layer_id', paramObj.layerId);
	        _layer.set('businessType', constant.BUSINESSTYPE.MULTIPOINT);
	        _layer.set('params.label', _label);
	        _layer.set('isVectorType',true);
	        _layer.set('state.showLabel', !!paramObj.showLabel);
	        var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.LANDMARKER;
	        _layer.setZIndex(_ZIndex);
	        _layer.set('isShow', _isShow);
	        if (!!paramObj.multiple) {
	            _layer.set('multiple', paramObj.multiple);
	        }
	        if (paramObj.minShowLevel != undefined) {
	            _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	        }

	        if (paramObj.maxShowLevel != undefined) {
	            _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	        }
	        hashMap.put(_layerId, _layer);
	        _mapObj.addLayer(_layer);
	    }

	};

	var setLayerData = function (paramObj) {
	    var _features = [];
	    var _datas = paramObj.datas;
	    var layer = layers.getLayer(paramObj);
	    layer.set('paramObj',paramObj);
	    if (paramObj.label) {
	        layer.set('params.label', paramObj.label);
	    }
	    if (utils.isValid(_datas) || _datas.length > 0) {

	        layer.set('state.showLabel', !!paramObj.showLabel);
	        _datas.forEach(function (pointDataObj) {
	            var _coordinate = (function() {
	            	return pointDataObj.points.map(function(item, index) {
	            		return ol.proj.fromLonLat(item.coordinate)
	            	});
	            }());
	            
	            var _feature = new ol.Feature({
	                geometry: new ol.geom.MultiPoint(_coordinate),
	                data: pointDataObj.points,
	                pointDataObj: pointDataObj,
	                layerId: paramObj.layerId,
	                mapId: paramObj.mapId,
	                businessType: constant.BUSINESSTYPE.MULTIPOINT,
	                vectorType: constant.BUSINESSTYPE.MULTIPOINT,
	                layer: layer,
	                id: pointDataObj.id
	            });
	            
	            var _style = new ol.style.Style({
	            	image: new ol.style.Circle({
	                    radius: pointDataObj.radius,
	                    stroke: new ol.style.Stroke({
	                        width: pointDataObj.strokeWidth != undefined ? pointDataObj.strokeWidth : 2,
	                        color: pointDataObj.strokeColor != undefined ? pointDataObj.strokeColor : 'black'
	                    }),
	                    fill: new ol.style.Fill({
	                        color: pointDataObj.fillColor != undefined ? pointDataObj.fillColor : 'red'
	                    })
	                })
	            });
	            _feature.setStyle(_style);
	            _feature.set('select', pointDataObj.highlight);
	            
	            _features.push(_feature);

	        });
	        layer.getSource().addFeatures(_features);
	    }

	};

	function highlight(olLayer, hType, param) {
		hType = constant.HTYPE.VECTOR;
	    if (olLayer) {
	        var olMap = olLayer.get('map');
	        var mapId = olMap.getTarget();
	        var layerId = olLayer.get('layer_id');
	        var layerType = olLayer.get('businessType');
	        highlights.removeHighlight({
	            mapId: mapId,
	            layerId: layerId
	        });

	        var hLayer = highlights.getHLayer({
	            mapId: mapId,
	            layerId: layerId
	        });
	        
	        var bigFeature = param.feature;
	        var _targetFeatures = [];
	        if (bigFeature == undefined) {
	        	var features = olLayer.getSource().getFeatures();
	        	features.forEach(function(featureItem, index) {
	    			featureItem.set('targetPoint', []);
	        		if (param.geoIds instanceof Array && param.geoIds.length > 0) {
	        				param.geoIds.forEach(function(pointId, index) {
	        					featureItem.get('data').forEach(function(item, index) {
				        			if (item.id == pointId) {
			        					featureItem.get('targetPoint').push(item);
			        					_targetFeatures.push(featureItem);
			        				}
				        		});
	        				})
	        			}
	        	});
	        	
	        	
	        	if (_targetFeatures.length > 0) {
	        		_targetFeatures.forEach(function(_targetFeature, i) {
	        			var highlightStyle = _targetFeature.get('select');
				        var pointDataObj = _targetFeature.get('pointDataObj');
				        var _targetPoint = _targetFeature.get('targetPoint');
				
				        _targetPoint.forEach(function(pp) {
				        	var _tempFeature = new ol.Feature({
					        	geometry: new ol.geom.Point(ol.proj.fromLonLat(pp.coordinate))
					        });
					         var _style = new ol.style.Style({
					            image: new ol.style.Circle({
					                radius: pointDataObj.radius,
					                fill: new ol.style.Fill({
					                    color: highlightStyle.fillColor
					                }),
					                stroke: new ol.style.Stroke({
					                    color: highlightStyle.strokeColor,
					                    width: highlightStyle.strokeWidth
					                })
					            })
					        });
					
					        _tempFeature.setStyle(_style);
					        hLayer.getSource().addFeature(_tempFeature);
				        });
	        		})
	        	}
	        }
	        else {
	        	var highlightStyle = bigFeature.get('select');
		        var pointDataObj = bigFeature.get('pointDataObj');
		
		        var _tempFeature = new ol.Feature({
		        	geometry: new ol.geom.Point(ol.proj.fromLonLat(bigFeature.get('coordinate')))
		        });
		        var _style = new ol.style.Style({
		            image: new ol.style.Circle({
		                radius: pointDataObj.radius,
		                fill: new ol.style.Fill({
		                    color: highlightStyle.fillColor
		                }),
		                stroke: new ol.style.Stroke({
		                    color: highlightStyle.strokeColor,
		                    width: highlightStyle.strokeWidth
		                })
		            })
		        });
		
		        _tempFeature.setStyle(_style);
		        hLayer.getSource().addFeature(_tempFeature);
	        }
	        

	    }
	}

	var getTargetClkPoint = function(multiPointInFeature, clkCoordinate) {
		var closestData;
		var minSquaredDistance = Infinity;

		var i, ii;
		for(i = 0, ii = multiPointInFeature.length; i < ii; i += 1) {
			var pointInFeature = multiPointInFeature[i];
			var p3857 = ol.proj.fromLonLat([Number(pointInFeature.coordinate[0]), Number(pointInFeature.coordinate[1])]);
	//		var squaredDistance = ol.math.squaredDistance(
	//			Number(clkCoordinate[0]), Number(clkCoordinate[1]), Number(p3857[0]), Number(p3857[1]));
				
			var squaredDistance = new ol.geom.LineString([
				[Number(clkCoordinate[0]), Number(clkCoordinate[1])],
				[Number(p3857[0]), Number(p3857[1])]
			
			]).getLength();
			if(squaredDistance < minSquaredDistance) {
				minSquaredDistance = squaredDistance;
				closestData = pointInFeature;
			}
		}
		return closestData;
	};

	module.exports = {
	    addLayer: addLayer,
	    setLayerData: setLayerData,
	    highlight: highlight,
	    getTargetClkPoint: getTargetClkPoint
	};


/***/ },
/* 62 */
/*!************************************!*\
  !*** ./src/gis/utils/eventTool.js ***!
  \************************************/
/***/ function(module, exports) {

	function _isEmptyObj(obj) {
	    for (var item in obj) {
	        return false;
	    }
	    return true;
	}

	function _each(ary, callback) {
	    for (var i = 0, len = ary.length; i < len;) {
	        callback(i, ary[i]) ? i = 0 : i++;
	    }
	}

	function _remove(el, type) {
	    var handler = el.listeners[type]['_handler_'];
	    el.removeEventListener ?
	        el.removeEventListener(type, handler, false) :
	        el.detachEvent('on' + type, handler);
	    delete el.listeners[type];
	    if (_isEmptyObj(el.listeners)) {
	        delete el.listeners;
	    }
	}

	// 添加事件
	function add(el, type, fn) {
	    el.listeners = el.listeners || {};
	    var listeners = el.listeners[type] = el.listeners[type] || [];
	    listeners.push(fn);
	    if (!listeners['_handler_']) {
	        listeners['_handler_'] = function (e) {
	            var evt = e || window.event;
	            for (var i = 0, fn; fn = listeners[i++];) {
	                fn.call(el, evt);
	            }
	        };
	        el.addEventListener ?
	            el.addEventListener(type, listeners['_handler_'], false) :
	            el.attachEvent('on' + type, listeners['_handler_']);
	    }
	}

	// 删除事件
	function remove(el, type, fn) {
	    if (!el.listeners) return;
	    var listeners = el.listeners && el.listeners[type];
	    if (listeners) {
	        _each(listeners, function (i, f) {
	            if (f == fn) {
	                return listeners.splice(i, 1);
	            }
	        });
	        if (listeners.length == 0) {
	            _remove(el, type);
	        }
	    }
	}

	//主动触发事件
	function dispatch(el, type) {
	    try {
	        if (el.dispatchEvent) {
	            var evt = document.createEvent('Event');
	            evt.initEvent(type, true, true);
	            el.dispatchEvent(evt);
	        }
	        else if (el.fireEvent) {
	            el.fireEvent('on' + type);
	        }
	    }
	    catch (e) {
	        console.error(e.getMessage());
	    }
	}

	module.exports = {
	    add: add,
	    remove: remove,
	    dispatch: dispatch
	};

/***/ },
/* 63 */
/*!*************************************!*\
  !*** ./src/gis/utils/mouseHover.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var ajax = __webpack_require__(/*! utils/ajax */ 14);
	var utils = __webpack_require__(/*! utils/util */ 1);

	var transformLonLat = olUtil.transformLonLat;

	function MouseHoverHeartBeat() {
		var self = this;
		var _lastPixel;
		var _lastTime;
		var _lastHoverPixel;
		var _mapObj;
		var _target;
		var _pixel;

		setInterval(function() {
			self.mouseHoverPublisher(_mapObj, _pixel, _target);
		}, 500);

		this.beat = function(mapObj, pixel, target) {
			_mapObj = mapObj;
			_pixel = pixel;
			_target = target;
		};

		this.mouseHoverPublisher = function(mapObj, pixel, target) {
			if(!mapObj || !pixel || !target) {
				return;
			}
			
			var mapExtent = mapObj.getView().calculateExtent(mapObj.getSize())
			var coordinateAtPix = mapObj.getCoordinateFromPixel(pixel);
			if (!ol.extent.containsCoordinate(mapExtent, coordinateAtPix)) {
				return;
			}

			if(!_lastTime || !_lastPixel) {
				_lastTime = new Date();
				_lastPixel = pixel;
				return;
			}

			var time = new Date() - _lastTime;
			if(_lastPixel[0] == pixel[0] && _lastPixel[1] == pixel[1]) {
				if(time <= 2000) {
					return;
				}
				if(_lastHoverPixel && _lastHoverPixel[0] == pixel[0] && _lastHoverPixel[1] == pixel[1]) {
					return;
				}

				self.mouseHoverHandle(mapObj, pixel, target);
				_lastHoverPixel = pixel;
			} else {
				_lastTime = new Date();
			}

			_lastPixel = pixel;
		};

		this.mouseHoverHandle = function(mapObj, pixel, target) {
			var e = {
				coordinate: mapObj.getCoordinateFromPixel(pixel)
			};

			hashMap.keys.filter(function(key) {
				return !!key && key.indexOf(mapObj.getTarget()) ===
					(key.length - mapObj.getTarget().length);
			}).forEach(function(key) {
				var _value = hashMap.get(key);
				if(!!_value && _value instanceof ol.layer.Layer) {
					var _layer = _value;
					if(_layer.hasOwnProperty('mouseoverCallback') &&
						typeof _layer.mouseoverCallback === 'function') {
						if(_layer.get('businessType') === constant.BUSINESSTYPE.GRID) {
							_getGridInfo(mapObj, _layer, e, undefined, function(obj) {
								if(obj == undefined) {
									return;
								}
								mouseHoverCallback(target, _layer, e, obj);
							})
						} else if(_layer.get('businessType') === 'DCELL') {
							_getdCellInfo(mapObj, _layer, e, undefined, function(obj) {
								if(obj && obj.length > 0) {
									obj = obj[0];
									if(obj == undefined) {
										return;
									}
									mouseHoverCallback(target, _layer, e, obj);
								}

							});
						} else if(_layer.get('businessType') === 'DPOINT' || _layer.get('businessType') === 'SITE') {
							getdSiteInfo(mapObj, _layer, e, undefined, function(obj) {
								if(obj && obj.length > 0) {
									obj = obj[0];
									if(obj == undefined) {
										return;
									}
									mouseHoverCallback(target, _layer, e, obj);
								}
							});
						} else if(_layer.get('businessType') === 'DLINE') {
							getdLineInfo(mapObj, _layer, e, undefined, function(obj) {
								obj = obj[0];
								if(obj == undefined) {
									return;
								}
								mouseHoverCallback(target, _layer, e, obj);
							});
						} else if(_layer.get('businessType') === 'DPOLYGON') {
							getdServicePolygonInfo(mapObj, _layer, e, undefined, function(obj) {
								obj = obj[0];
								if(obj == undefined) {
									return;
								}
								mouseHoverCallback(target, _layer, e, obj);
							});
						} else if(_layer.get('businessType') === constant.BUSINESSTYPE.SERVICEPOINT) {
							getServicePointInfo(mapObj, _layer, e, undefined, function(obj) {
								obj = obj[0];
								if(obj == undefined) {
									return;
								}
								mouseHoverCallback(target, _layer, e, obj);
							});
						} else if(_layer.get('businessType') === constant.BUSINESSTYPE.SERVICELINE) {
							getServiceLineInfo(mapObj, _layer, e, undefined, function(obj) {
								obj = obj[0];
								if(obj == undefined) {
									return;
								}
								mouseHoverCallback(target, _layer, e, obj);
							});
						} else if(_layer.get('businessType') === constant.BUSINESSTYPE.SERVICEPOLYGON) {
							getServicePolygonInfo(mapObj, _layer, e, undefined, function(obj) {
								obj = obj[0];
								if(obj == undefined) {
									return;
								}
								mouseHoverCallback(target, _layer, e, obj);
							});
						}
					}
				}
			});
		};

	}


	function _getGridInfo(mapObj, layerObj, evt, key, callback) {
		var extent = mapObj.getView().calculateExtent(mapObj.getSize());
		var layerParamObj = layerObj.get('paramObj');
		var coords = utils.gcjTransform3857(evt.coordinate);
		var paramObj = {
			geometry: {
				x: coords[0],
				y: coords[1]
			},
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance : 1,
			mapExtent: extent,
			imgToken: layerObj.get('imgToken')
		};
		ajax.postJSON({
			url: constant.GisRootUrl + '/gridManager/getGridInfo?cacheKey=' + layerObj.get('imgToken'),
			data: JSON.stringify(paramObj),
			success: function(result) {
				var responseText = JSON.parse(result);
				var status = responseText.status;
				var data = responseText.data && responseText.data.length > 0 && responseText.data[0];
				if(status.code === 1) {
					if(data) {
						callback({
							mapId: mapObj.getTarget(),
							layerId: layerObj.get('layer_id'),
							layerType: layerObj.get('businessType'),
							lonLat: data.originalCenterPoint,//data.centerPoint,
							geometry: data.geometry,
							geoId: data.id,
							data: data,
							key: key
						});
					}
				} else {
					callback({
						mapId: mapObj.getTarget(),
						layerId: layerObj.get('layer_id'),
						layerType: layerObj.get('businessType')
					});
				}
			},
			failure: function(result) {
				callback({
					mapId: mapObj.getTarget(),
					layerId: layerObj.get('layer_id'),
					layerType: layerObj.get('businessType')
				});
			}
		});
	}

	function _getdCellInfo(olMap, olLayer, evt, key, callback) {
		if(!olLayer.getVisible()) {
			callback(
				[{
					mapId: olMap.getTarget(),
					layerId: olLayer.get('layer_id'),
					layerType: olLayer.get('businessType')
				}]
			);
			return;
		}
		var mapExtent, imgToken, geometry, Fcname;

		if(!!evt.coordinate) {
			geometry = JSON.stringify({
				x: evt.coordinate[0],
				y: evt.coordinate[1]
			});
			mapExtent = olMap.getView().calculateExtent(olMap.getSize()).join(',');
			imgToken = olLayer.get('imgToken');
			Fcname = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
			var layerParamObj = olLayer.get('paramObj');
			var params = {
				geometry: geometry,
				tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance : 0.1,
				mapExtent: mapExtent,
				imgToken: imgToken,
				FCName: Fcname
			};

		}
		ajax.get({
			url: constant.GisRootUrl + '/common/mapRender/identify',
			data: utils.getParameterString(params),
			success: function(res) {
				if(!res) {
					callback(
						[{
							mapId: olMap.getTarget(),
							layerId: olLayer.get('layer_id'),
							layerType: olLayer.get('businessType')
						}]
					);
					return;
				}
				res = JSON.parse(res);
				if(!res || !res.data || !res.data.length) {
					callback(
						[{
							mapId: olMap.getTarget(),
							layerId: olLayer.get('layer_id'),
							layerType: olLayer.get('businessType')
						}]
					);
					return;
				}

				var result = utils.sortBy(res.data, function(j) {
					if(j.extentInfo.isDirect === '0') {
						j.extentInfo.radius = j.extentInfo.radius * 2;
					}
					return Number(j.extentInfo.radius);
				});
				var minRadius = result[0].extentInfo.radius;
				result = result.filter(function(item) {
					return item.extentInfo.radius === minRadius;
				});
				result.forEach(function(r) {
					if(r.extentInfo.isDirect === '0') {
						r.extentInfo.radius = r.extentInfo.radius / 2;
					}
				});
				var backJson = result.map(function(item) {
					return {
						mapId: olMap.getTarget(),
						layerId: olLayer.get('layer_id'),
						layerType: olLayer.get('businessType'),
						label: olLayer.get('params.label'),
						lonLat: item.centerPoint,
						geometry: item.geometry,
						extentInfo: item.extentInfo,
						geoId: item.id,
						geoName: item.name,
						key: key
					};
				});
				callback(backJson);
			},
			failure: function(res) {
				callback(
					[{
						mapId: olMap.getTarget(),
						layerId: olLayer.get('layer_id'),
						layerType: olLayer.get('businessType')
					}]
				);
			}
		});
	}

	function getdSiteInfo(olMap, olLayer, evt, key, callback) {
		if(!olLayer.getVisible()) {
			callback({
				mapId: olMap.getTarget(),
				layerId: olLayer.get('layer_id'),
				layerType: olLayer.get('businessType')
			});
			return;
		}
		var mapExtent, imgToken, geometry, dw, _url;
		imgToken = olLayer.get('imgToken');
		//判断悬浮事件的identify请求
		dw = olLayer.get('dw'); //通过取dw的属性判断是否走中间件
		if(dw != undefined) {
			_url = constant.GisRootUrl + '/mapRender/identify';
		} else {
			_url = constant.GisRootUrl + '/common/mapRender/identify';
		}
		geometry = JSON.stringify({
			x: evt.coordinate[0],
			y: evt.coordinate[1]
		});
		mapExtent = olMap.getView().calculateExtent(olMap.getSize()).join(',');
		var fcName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		var layerParamObj = olLayer.get('paramObj');
		var params = {
			geometry: geometry,
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance : 10,
			mapExtent: mapExtent,
			imgToken: imgToken,
			FCName: fcName
		};
		ajax.get({
			url: _url,
			data: utils.getParameterString(params),
			success: function(res) {
				if(!res) {
					callback({
						mapId: olMap.getTarget(),
						layerId: olLayer.get('layer_id'),
						layerType: olLayer.get('businessType')
					});
					return;
				}
				res = JSON.parse(res);
				if(!res || !res.data || !res.data.length) {
					callback({
						mapId: olMap.getTarget(),
						layerId: olLayer.get('layer_id'),
						layerType: olLayer.get('businessType')
					});
					return;
				}

				var result = res.data;
				var backJSON = result.map(function(item) {
					return {
						mapId: olMap.getTarget(),
						layerId: olLayer.get('layer_id'),
						layerType: olLayer.get('businessType'),
						label: olLayer.get('params.label'),
						lonLat: item.centerPoint,
						geometry: item.geometry,
						geoId: item.id,
						geoName: item.name,
						key: key
					};
				});

				callback(backJSON);
			},
			failure: function(res) {
				callback({
					mapId: olMap.getTarget(),
					layerId: olLayer.get('layer_id'),
					layerType: olLayer.get('businessType')
				});
			}
		});
	}

	function getdLineInfo(olMap, olLayer, evt, key, callback) {
		if(!olLayer.getVisible()) {
			callback({
				mapId: olMap.getTarget(),
				layerId: olLayer.get('layer_id'),
				layerType: olLayer.get('businessType')
			});
			return;
		}
		var mapExtent, imgToken, geometry, Fcname;
		imgToken = olLayer.get('imgToken');
		geometry = JSON.stringify({
			x: evt.coordinate[0],
			y: evt.coordinate[1]
		});
		mapExtent = olMap.getView().calculateExtent(olMap.getSize()).join(',');
		Fcname = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		var layerParamObj = olLayer.get('paramObj');
		var params = {
			geometry: geometry,
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance : 1,
			mapExtent: mapExtent,
			imgToken: imgToken,
			FCName: Fcname
		};
		ajax.get({
			url: constant.GisRootUrl + '/common/mapRender/identify',
			data: utils.getParameterString(params),
			success: function(res) {
				if(!res) {
					callback([]);
					return;
				}
				res = JSON.parse(res);
				if(!res || !res.data || !res.data.length) {
					callback([]);
					return;
				}

				var result = res.data;
				var backJSON = result.map(function(item) {
					return {
						mapId: olMap.getTarget(),
						layerId: olLayer.get('layer_id'),
						layerType: olLayer.get('businessType'),
						label: olLayer.get('params.label'),
						lonLat: item.centerPoint,
						geometry: item.geometry,
						geoId: item.id,
						geoName: item.name,
						key: key
					};
				});

				callback(backJSON);
			},
			failure: function(res) {
				callback({
					mapId: olMap.getTarget(),
					layerId: olLayer.get('layer_id'),
					layerType: olLayer.get('businessType')
				});
			}
		});
	}

	function getdServicePolygonInfo(mapObj, layerObj, evt, key, callback) {
		if(!layerObj.getVisible()) {
			callback({
				mapId: mapObj.getTarget(),
				layerId: layerObj.get('layer_id'),
				layerType: layerObj.get('businessType')
			});
			return;
		}

		var extent = mapObj.getView().calculateExtent(mapObj.getSize());
		var imgToken = layerObj.get('imgToken');
		var fcName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		var layerParamObj = layerObj.get('paramObj');
		var paramObj = {
			geometry: JSON.stringify({
				x: evt.coordinate[0],
				y: evt.coordinate[1]
			}),
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance : 0.1,
			mapExtent: extent,
			imgToken: imgToken,
			FCName: fcName
		};

		ajax.get({
			url: constant.GisRootUrl + '/common/mapRender/identify',
			data: utils.getParameterString(paramObj),
			success: function(result) {
				if(!result) {
					return;
				}
				var responseText = JSON.parse(result);
				var status = responseText.status;
				if(status.code === 1) { //请求成功，可能有数据，可能没数据
					if(responseText.data && responseText.data.length > 0) {
						var datas = responseText.data.map(function(data) {
							var oneData = {
								mapId: mapObj.getTarget(),
								layerId: layerObj.get('layer_id'),
								layerType: layerObj.get('businessType'),
								label: layerObj.get('params.label'),
								lonLat: data.centerPoint,
								geometry: data.geometry,
								extentInfo: data.extentInfo,
								geoId: data.id,
								geoName: data.name,
								key: key
							};

							return oneData;
						});

						if(callback && typeof callback === 'function') {
							callback(datas);
						}
					}
				}
			},
			failure: function(result) {
				callback({
					mapId: mapObj.getTarget(),
					layerId: layerObj.get('layer_id'),
					layerType: layerObj.get('businessType')
				});
			}
		});
	};

	function getServicePolygonInfo(mapObj, layerObj, evt, key, callback) {
		if(!layerObj.getVisible()) {
			callback([{
				mapId: mapObj.getTarget(),
				layerId: layerObj.get('layer_id'),
				layerType: layerObj.get('businessType')
			}]);
			return;
		}

		var extent = mapObj.getView().calculateExtent(mapObj.getSize());
		var imgToken = layerObj.get('imgToken');
		var fcName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		var layerParamObj = layerObj.get('paramObj');
		var coords = utils.gcjTransform3857(evt.coordinate);
		var paramObj = {
			geometry: JSON.stringify({
				x: coords[0],
				y: coords[1]
			}),
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance : 0.1,
			mapExtent: extent,
			imgToken: imgToken,
			FCName: fcName
		};
		ajax.get({
			url: constant.GisRootUrl + '/mapRender/identify',
			data: utils.getParameterString(paramObj),
			success: function(result) {
				if(!result) {
					return;
				}
				var responseText = JSON.parse(result);
				var status = responseText.status;
				if(status.code === 1) { //请求成功，可能有数据，可能没数据
					if(responseText.data && responseText.data.length > 0) {
						var datas = responseText.data.map(function(data) {
							var oneData = {
								mapId: mapObj.getTarget(),
								layerId: layerObj.get('layer_id'),
								layerType: layerObj.get('businessType'),
								label: layerObj.get('params.label'),
								lonLat: data.centerPoint,
								geometry: data.geometry,
								extentInfo: data.extentInfo,
								geoId: data.id,
								geoName: data.name,
								key: key
							};

							return oneData;
						});

						if(callback && typeof callback === 'function') {
							callback(datas);
						}
					}
				}
			},
			failure: function(result) {
				callback(
					[{
						mapId: mapObj.getTarget(),
						layerId: layerObj.get('layer_id'),
						layerType: layerObj.get('businessType')
					}]
				);
			}
		});
	};

	function getServicePointInfo(mapObj, layerObj, evt, key, callback) {
		if(!layerObj.getVisible()) {
			callback([{
				mapId: mapObj.getTarget(),
				layerId: layerObj.get('layer_id'),
				layerType: layerObj.get('businessType')
			}]);
			return;
		}

		var extent = mapObj.getView().calculateExtent(mapObj.getSize());
		var imgToken = layerObj.get('imgToken');
		var fcName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		var layerParamObj = layerObj.get('paramObj');
		var coords = utils.gcjTransform3857(evt.coordinate);
		var paramObj = {
			geometry: JSON.stringify({
				x: coords[0],
				y:coords[1]
			}),
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance : utils.getCurTolerance(mapObj,layerObj),
			mapExtent: extent,
			imgToken: imgToken,
			FCName: fcName
		};
		ajax.get({
			url: constant.GisRootUrl + '/mapRender/identify',
			data: utils.getParameterString(paramObj),
			success: function(result) {
				if(!result) {
					return;
				}
				var responseText = JSON.parse(result);
				var status = responseText.status;
				if(status.code === 1) { //请求成功，可能有数据，可能没数据
					if(responseText.data && responseText.data.length > 0) {
						var datas = responseText.data.map(function(data) {
							var oneData = {
								mapId: mapObj.getTarget(),
								layerId: layerObj.get('layer_id'),
								layerType: layerObj.get('businessType'),
								label: layerObj.get('params.label'),
								lonLat: data.centerPoint,
								geometry: data.geometry,
								extentInfo: data.extentInfo,
								geoId: data.id,
								geoName: data.name,
								key: key
							};

							return oneData;
						});

						if(callback && typeof callback === 'function') {
							callback(datas);
						}
					}
				}
			},
			failure: function(result) {
				callback([{
					mapId: mapObj.getTarget(),
					layerId: layerObj.get('layer_id'),
					layerType: layerObj.get('businessType')
				}]);
			}
		});
	};

	function getServiceLineInfo(mapObj, layerObj, evt, key, callback) {
		if(!layerObj.getVisible()) {
			callback([{
				mapId: mapObj.getTarget(),
				layerId: layerObj.get('layer_id'),
				layerType: layerObj.get('businessType')
			}]);
			return;
		}

		var extent = mapObj.getView().calculateExtent(mapObj.getSize());
		var imgToken = layerObj.get('imgToken');
		var fcName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
		var layerParamObj = layerObj.get('paramObj');
		var coords = utils.gcjTransform3857(evt.coordinate);
		var paramObj = {
			geometry: JSON.stringify({
				x: coords[0],
				y: coords[1]
			}),
			tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance : utils.getCurTolerance(mapObj,layerObj),
			mapExtent: extent,
			imgToken: imgToken,
			FCName: fcName
		};
		ajax.get({
			url: constant.GisRootUrl + '/mapRender/identify',
			data: utils.getParameterString(paramObj),
			success: function(result) {
				if(!result) {
					return;
				}
				var responseText = JSON.parse(result);
				var status = responseText.status;
				if(status.code === 1) { //请求成功，可能有数据，可能没数据
					if(responseText.data && responseText.data.length > 0) {
						var datas = responseText.data.map(function(data) {
							var oneData = {
								mapId: mapObj.getTarget(),
								layerId: layerObj.get('layer_id'),
								layerType: layerObj.get('businessType'),
								label: layerObj.get('params.label'),
								lonLat: data.centerPoint,
								geometry: data.geometry,
								extentInfo: data.extentInfo,
								geoId: data.id,
								geoName: data.name,
								key: key
							};

							return oneData;
						});

						if(callback && typeof callback === 'function') {
							callback(datas);
						}
					}
				}
			},
			failure: function(result) {
				callback([{
					mapId: mapObj.getTarget(),
					layerId: layerObj.get('layer_id'),
					layerType: layerObj.get('businessType')
				}]);
			}
		});
	};

	var isServiceLayer = function(mapObj) {
		var isServiceLayerFlag = false;
		hashMap.keys.filter(function(key) {
			return !!key && key.indexOf(mapObj.getTarget()) === (key.length - mapObj.getTarget().length);
		}).forEach(function(key) {
			var _value = hashMap.get(key);
			if(!!_value && _value instanceof ol.layer.Layer) {
				var _layer = _value;
				if(_layer.hasOwnProperty('mouseoverCallback') &&
					typeof _layer.mouseoverCallback === 'function') {
					var _businessType = _layer.get('businessType');
					if(_businessType === constant.BUSINESSTYPE.GRID ||
						_businessType === constant.BUSINESSTYPE.DCELL ||
						_businessType === constant.BUSINESSTYPE.DPOINT ||
						_businessType === constant.BUSINESSTYPE.SITE ||
						_businessType === constant.BUSINESSTYPE.DLINE ||
						_businessType === constant.BUSINESSTYPE.DPOLYGON ||
						_businessType === constant.BUSINESSTYPE.SERVICEPOINT ||
						_businessType === constant.BUSINESSTYPE.SERVICELINE ||
						_businessType === constant.BUSINESSTYPE.SERVICEPOLYGON) {
						isServiceLayerFlag = true;
					}
				}
			}
		});
		return isServiceLayerFlag;
	}

	function mouseHoverCallback(target, _layer, e, obj) {
		_layer.mouseoverCallback({
			e: e,
			layer: _layer,
			featureCenter: obj.lonLat,
			data: obj.data,
			geoId: obj.geoId,
			lonLat: obj.lonLat,
			points: transformLonLat(undefined, {
				layerType: _layer && _layer.get('businessType'),
				geometry: obj.geometry
			}),
			businessType: _layer && _layer.get('businessType'),
			layerType: _layer && _layer.get('businessType'),
			mapId: target,
			target: target,
			layerId: !!_layer && _layer.get('layer_id'),
			featureId: obj.geoId
		});
	}

	module.exports = {
		mouseHoverHeartBeat: MouseHoverHeartBeat,
		isServiceLayer: isServiceLayer
	};

/***/ },
/* 64 */
/*!******************************************!*\
  !*** ./src/gis/businessLayers/legend.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	/*
	 * 图例
	 */
	var ol = __webpack_require__(/*! ol */ 4);
	var domUtil = __webpack_require__(/*! utils/domUtil */ 10);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var util = __webpack_require__(/*! utils/util */ 1);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);

	var legClass = 'vGisWeb_legend_box';
	var map = new Map();
	map.set('refreshLayerManager_key', []);

	/**
	 * 图例开关
	 * @param paramObj
	 */
	var _legendSwitch = function (paramObj) {
	    var _mapId = paramObj.mapId;
	    var _targetElement = hashMap.get(_mapId).getTargetElement();
	    var _legSwitchId = 'vGisWeb_legend_switch' + '_' + _mapId;
	    var _legContentId = legClass + '_' + _mapId;
	    var _legNode = _targetElement.querySelector('#' + _legContentId);
	    var _legSwitchNode = document.querySelector('#' + _legSwitchId);

	    if (!!!_legSwitchNode) {
	        //图例开关
	        _legSwitchNode = domUtil.createDom({
	            tagName: 'div',
	            attributes: {
	                class: 'vGisWeb_legend_switch',
	                id: _legSwitchId,
	                title: fusiongis.I18n.prop('toolbar.legendSwitch')
	            }
	        });
	        _targetElement.appendChild(_legSwitchNode);
	    }

	    if (!!!_legNode) {
	        _legNode = domUtil.createDom({
	            tagName: 'div',
	            attributes: {
	                class: legClass,
	                id: _legContentId
	            }
	        });
	        _targetElement.appendChild(_legNode);
	    }

	    _legSwitchNode.onclick = function () {
	        _legNode = _targetElement.querySelector('#' + _legContentId);
	        if (!!_legNode && !!_legNode.style) {
	            var _display = _legNode.style.display;
	            if ('block' === _display) {
	                _legNode.style.display = '';
	            }
	            else if (!!!_display) {
	                _legNode.style.display = 'block';
	            }
	        }
	    };
	};

	/**
	 *
	 * @param paramObj
	 * {
	 *    mapId:''
	 *    layerId:''
	 *    legendInfo:''
	 *    businessType:''
	 *    titleImgPath:''
	 *    imgToken:''
	 * }
	 */
	var createLegend = function (paramObj) {
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId;
	    var _legendInfo = paramObj.legendInfo;
	    var _businessType = paramObj.businessType;
	    var _label =paramObj.label;
	    var _titleImgPath = paramObj.titleImgPath || constant.GisResourceURL + 'legend/';
	    var _legendImgPath = paramObj.legendImgPath || constant.GisResourceURL + 'marker/';
	    var _byPercent = _legendInfo && _legendInfo.byPercent;
	    var _imgToken = paramObj.imgToken || undefined;
	    var _legendName = (function() {
	        return util.htmlDecode(_legendInfo && _legendInfo.legendName);
	    }());
	    var _legendType = _legendInfo && _legendInfo.legendType;
	    var _legendList = _legendInfo && _legendInfo.legendList;
	    var _renderStyle = _legendInfo && _legendInfo.renderStyle;
	    var _businessLegClass = 'business_' + _legendType;
	    var _businessLegId = 'business_' + _layerId;
	    var _oneLineClass = 'oneLine';
	    var _oneLineId = _oneLineClass + '_' + _mapId;
	    var _legendSetting = hashMap.get(_mapId).get('paramObj').legendSetting;

	    var _targetElement = !!hashMap.get(_mapId) && hashMap.get(_mapId).getTargetElement();
	    if (!_targetElement) {
	        return;
	    }

	    (function () {
	        var _layerObj = layers.getLayer({
	            mapId: _mapId,
	            layerId: _layerId
	        });

	        var _layName = _label + '(' + _legendName + ')';
	        if (_layerObj) {
	            _layerObj.set('mineLayerName', _layName);
	            _layerObj.set('mineLayerImgToken', _imgToken);
	            _layerObj.set('mineLegendID', _businessLegId);
	            _layerObj.set('mineLegendName', util.htmlDecode(_layerObj.get('legendName')));
	            if (map.get('refreshLayerManager_key').length < 10) {
	                var layer = new ol.layer.Vector();
	                layer.set('layer_id', 'auto_increase_reduce');
	                mapBox.getMapObj(_mapId).addLayer(layer);
	                map.get('refreshLayerManager_key').push(layer);
	            }
	            else {
	               var _layers = map.get('refreshLayerManager_key');
	                if (!!_layers && _layers.length >= 0) {
	                    _layers.forEach(function(v, i) {
	                        mapBox.getMapObj(_mapId).removeLayer(v);
	                        map.get('refreshLayerManager_key').splice(i, 1);
	                    });
	                }
	            }

	        }
	    }());

	    var _legBox = _targetElement.querySelector('#' + legClass + '_' + _mapId);
	    if (!!!_legBox) {
	        _legendSwitch(paramObj);
	        _legBox = _targetElement.querySelector('#' + legClass + '_' + _mapId);
	    }

	    //业务图层对应的图例模块
	    var _businessLegNode = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            class: _businessLegClass + ' ' + _businessLegId
	        }
	    });
	    if (!!_targetElement.querySelector('.' + _businessLegId)) {
	        _legBox.removeChild(_targetElement.querySelector('.' + _businessLegId));
	    }
	    _legBox.appendChild(_businessLegNode);

	    //指标中一条记录
	    if (_legendInfo && _legendList && _legendList.length > 0) {
	        _businessLegNode.appendChild((function () {
	            var _legendTitle = domUtil.createDom({
	                tagName: 'div',
	                attributes: {
	                    class: 'legendTitle'
	                }
	            });

	            //图例标题前面的图标，可以认为是LOGO，比如grid.png
	            _legendTitle.appendChild((function () {
	                var _titleLeft = domUtil.createDom({
	                    tagName: 'div',
	                    attributes: {
	                        class: 'legendTitleLeft'
	                    }
	                });
	                _titleLeft.style.background = 'url(' + _titleImgPath + _businessType.toLowerCase() + '.png)';
	                _titleLeft.style.backgroundPosition = '3px 7px';
	                _titleLeft.style.backgroundRepeat = 'no-repeat';
	                return _titleLeft;
	            }()));

	            //标题显示信息
	            _legendTitle.appendChild((function () {
	                return  domUtil.createDom({
	                    tagName: 'div',
	                    attributes: {
	                        class: 'legendTitleRight',
	                        title: _legendName
	                    },
	                    text: _legendName.length > 20 ? _legendName.substring(0, 20) + '...'
	                        : _legendName
	                });
	            }()));
	            if (_legendSetting) {
	                //添加图例修改按钮
	                _legendTitle.appendChild((function () {
	                    return domUtil.createDom({
	                        tagName: 'input',
	                        attributes: {
	                            type: 'button',
	                            class: 'setting-button',
	                            value: '设置图例',
	                            title: '设置图例'
	                        },
	                        text: _legendName.length > 20 ? _legendName.substring(0, 20) + '...'
	                            : _legendName
	                    });
	                }()));
	            }
	            return _legendTitle;
	        }()));

	        _legendList.forEach(function (legend) {
	            var _legendValue = legend.value;
	            var _label = legend.label;
	            var _style = legend.style;
	            var _fillColor = legend.fillColor;
	            var _borderColor = legend.borderColor;
	            var _borderWidth = legend.borderWidth;
	            var _percent = legend.percent;
	            var _count = legend.count;
	            var _range = legend.range;//求得占比后的value区间
	            var _isContainsMin = legend.containsMin;
	            var _isContainsMax = legend.containsMax;

	            //one record
	            var _oneLine = domUtil.createDom({
	                tagName: 'div',
	                attributes: {
	                    class: _oneLineClass,
	                    id: _oneLineId
	                }
	            });
	            _businessLegNode.appendChild(_oneLine);
	            if (_legendSetting) {
	                //添加复选框
	                _oneLine.appendChild((function () {
	                    var checkDiv = domUtil.createDom({
	                        tagName: 'div',
	                        attributes: {
	                            value: _legendValue + '',
	                            class: 'isCheckBox',
	                            // type: 'checkbox',
	                            // checked: 'checked',
	                            checkDiv: 'checkDiv',
	                            style: 'vertical-align: middle;margin-right: 5px;float: left;'
	                        }
	                    });
	                    domUtil.on(checkDiv, 'click', addCheckDivEvent);
	                    return checkDiv;
	                }()));
	            }
	            //显示颜色值
	            _oneLine.appendChild((function () {
	                if (_style.indexOf(',') !== -1) {
	                    if (_legendType === 'singleColor' || _legendType === 'rangeColor') {
	                        if (_renderStyle === 'Border') {
	                            var style_ = !!!_borderColor ? _style : _borderColor;
	                            if (style_.split(',').length == 3) {
	                                _style = 'rgb(' + style_ + ')';
	                            }
	                            else if (style_.split(',').length == 4) {
	                                _style = 'rgba(' + style_ + ')';
	                            }
	                            return  domUtil.createDom({
	                                tagName: 'div',
	                                attributes: {
	                                    style: 'border: 1px solid ' + _style
	                                }
	                            });
	                        }
	                        else if (_renderStyle === 'Fill') {
	                            var style_ = !!!_fillColor ? _style : _fillColor;
	                            if (style_.split(',').length == 3) {
	                                _style = 'rgb(' + style_ + ')';
	                            }
	                            else if (style_.split(',').length == 4) {
	                                _style = 'rgba(' + style_ + ')';
	                            }
	                            return  domUtil.createDom({
	                                tagName: 'div',
	                                attributes: {
	                                    style: 'background: ' + _style
	                                }
	                            });
	                        }
	                    }
	                }
	                else {
	                    if (_legendType === 'singleSymbol' || _legendType === 'rangeSymbol') {
	                        var imageName = _style;
	                        return  domUtil.createDom({
	                            tagName: 'div',
	                            attributes: {
	                                style: 'background-image: url("' + _legendImgPath + imageName +
	                                    '.png");' +
	                                    'background-size: 18px; background-repeat: no-repeat; background-position: 0px 2px;'
	                            }
	                        });
	                    }
	                }
	            }()));

	            //根据不同的图例类型，显示不同的图例样式
	            _oneLine.appendChild((function () {
	                var _leftBrackets = '';
	                var _rightBrackets = '';

	                if (_isContainsMin === true) {
	                    _leftBrackets = '[';
	                }
	                else {
	                    _leftBrackets = '(';
	                }

	                if (_isContainsMax === true) {
	                    _rightBrackets = ']';
	                }
	                else {
	                    _rightBrackets = ')';
	                }

	                var _text = (function () {
	                    if (_legendType === 'singleColor') {
	                        return [
	                            _leftBrackets,
	                            _legendValue,
	                            _rightBrackets,
	                            ' ',
	                            _label
	                        ].join('');
	                    }
	                    else if (_legendType === 'rangeColor') {
	                        if (!!_byPercent) {
	                            if (!!!_range) {
	                                return [
	                                        _leftBrackets + _legendValue[0] + '%,' + _legendValue[1] + '%' + _rightBrackets,
	                                    ' ',
	                                    _label
	                                ].join('');
	                            }
	                            else {
	                                return [
	                                        _leftBrackets + _legendValue[0] + '%,' + _legendValue[1] + '%' + _rightBrackets,
	                                    ' ',
	                                    _leftBrackets,
	                                    _range,
	                                    _rightBrackets,
	                                    ' ',
	                                    _label
	                                ].join('');
	                            }

	                        }
	                        else {
	                            if (!!!_legendValue[0]) {
	                                _legendValue[0] = '-' + '&#8734;';
	                            }
	                            if (!!!_legendValue[1]) {
	                                _legendValue[1] = '+' + '&#8734;';
	                            }
	                            if (!!!_percent) {
	                                return [
	                                    _leftBrackets,
	                                    _legendValue,
	                                    _rightBrackets,
	                                    ' ',
	                                    _label
	                                ].join('');
	                            }
	                            else {
	                                return [
	                                    _leftBrackets,
	                                    _legendValue,
	                                    _rightBrackets,
	                                    ' (',
	                                    _count,
	                                    ',',
	                                    _percent,
	                                    '%)',
	                                    ' ',
	                                    _label
	                                ].join('');
	                            }
	                        }
	                    }
	                    else if (_legendType === 'singleSymbol') {
	                        return [
	                            _leftBrackets,
	                            _legendValue,
	                            _rightBrackets,
	                            ' ',
	                            _label
	                        ].join('');
	                    }
	                    else if (_legendType === 'rangeSymbol') {
	                        if (!!!_legendValue[0]) {
	                            _legendValue[0] = '-' + '&#8734;';
	                        }
	                        if (!!!_legendValue[1]) {
	                            _legendValue[1] = '+' + '&#8734;';
	                        }
	                        if (!!!_percent) {
	                            return [
	                                _leftBrackets,
	                                _legendValue,
	                                _rightBrackets,
	                                ' ',
	                                _label
	                            ].join('');
	                        }
	                        else {
	                            return [
	                                _leftBrackets,
	                                _legendValue,
	                                _rightBrackets,
	                                ' (',
	                                _percent,
	                                '%)',
	                                ' ',
	                                _label
	                            ].join('');
	                        }
	                    }
	                }());

	                return domUtil.createDom({
	                    tagName: 'div',
	                    attributes: {
	                        title: util.htmlDecode(_text)
	                    },
	                    text: _text
	                });
	            }()));
	        });
	    }
	    if (_legendSetting) {
	        setTimeout(function () {
	            addLegendEventLisener();
	            addModifyEventLisener('.' + _businessLegId + ' .legendTitle', _businessLegId);
	        }, 0);
	    }
	};

	/**
	 * 图例修改按钮监听的事件
	 */
	var addModifyEventLisener = function (selector, _businessLegId) {
	    $(selector).find('input').off('click');
	    $(selector).find('input').on('click', function () {
	        var parentNode = $(selector).parent();
	        var legendBox = parentNode && parentNode.parent()[0];
	        var className = parentNode.attr('class').substring(parentNode.attr('class').indexOf(' ') + 1);
	        var currMapId = legendBox && legendBox.id && legendBox.id.replace(legClass + '_', '');
	        var currLayerId = _businessLegId.replace('business_', '');
	        var layerInfo = layers.getLayer({
	            mapId: currMapId,
	            layerId: currLayerId
	        });
	        requestParam = layerInfo && layerInfo.get('paramObj');
	        if (!!!layerInfo || !!!requestParam) {
	            return;
	        }
	        businessType = layerInfo && layerInfo.get('businessType');
	        var legendInfoObj = requestParam.legendInfo || layerInfo.get('legendInfo');
	        var _legendType = legendInfoObj && legendInfoObj.legendType;
	        var _renderStyle = legendInfoObj && legendInfoObj.renderStyle;
	        var legendTypeBoxId = currMapId + '_' + currLayerId + '_' + _legendType + '_legengSettingBox';
	        var setkey = dataHandler.businessTypeMapping(businessType) + '_' + _legendType + '_' + _renderStyle;
	        if (!serviceLegendInfo[setkey] && requestParam && requestParam.legendInfo) {
	            serviceLegendInfo[setkey] = legendInfoObj;
	        }
	        requestParam.legendInfo = serviceLegendInfo[setkey];
	        layerInfo.set('legendInfo', serviceLegendInfo[setkey]);
	        //创建图例管理设置窗口
	        var allSettingPanel = document.querySelectorAll('.removeAllSettingPanel')[0];
	        if (allSettingPanel) {
	            allSettingPanel.parentNode.removeChild(allSettingPanel);
	        }
	        var settingPanel = domHandler.createSettingPanel(requestParam || {}, legendTypeBoxId);
	        var settingPanelW = parseInt(settingPanel.style.width);
	        var settingPanelH = parseInt(settingPanel.style.height);
	        var bodyWidth = parseInt(document.body.offsetWidth);
	        var bodyHeigth= parseInt(document.body.offsetHeight);
	        var _left = (bodyWidth - settingPanelW) / 2;
	        var _top = (bodyHeigth - settingPanelH) / 2;
	        settingPanel.style.left = _left + 'px';
	        settingPanel.style.top = _top + 'px';
	        document.body.appendChild(settingPanel);
	        setTimeout(function () {
	            var checkedList = $('#' + currMapId + ' .' + className + ' input[type="checkbox"]');
	            var legendList = serviceLegendInfo[setkey] && serviceLegendInfo[setkey].legendList;
	            var _legendSelect = legendService.getLegendList(checkedList, legendList, _legendType, _renderStyle);
	            var backFillInfo = {
	                legendTypeBoxId: legendTypeBoxId,
	                mapId: currMapId,
	                layerId: currLayerId,
	                legendType: _legendType,
	                legendList: legendList,
	                legendInfo: serviceLegendInfo[setkey]
	            };
	            backFillDataService.backFillData(backFillInfo);
	            util.dragBox([legendTypeBoxId]);
	        }, 0);
	    });
	};
	module.exports = {
	    createLegend: createLegend
	};


/***/ },
/* 65 */
/*!**********************************************!*\
  !*** ./src/gis/layers/setVectorLayerData.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var utils = __webpack_require__(/*! utils/util */ 1);
	/**
	 * 为点线面设置数据
	 * @param paramObj
	 * 参考:{
	 *      mapId:地图Id
	 *      layerId:图层Id
	 *      layerType:'POINT'|'LINE'|POLYGON,
	 *      layerData:点数据，需要根据不同的图层类型数据类型不同
	 * }
	 */

	var setVectorLayerData = function (paramObj) {

	    /**
	     * 根据点信息生成feature
	     * @param pointData
	     *  参考:[{
	     *   strokeWidth:1,
	     *   strokeColor:[255,0,0,255],
	     *   fillColor:[120,120,120,120],
	     *   radius:5,
	     *   data:[[x,y],[x,y]]
	     *  }]
	     * @returns {Array}
	     */
	    var setPointData = function (pointData) {

	        var featureList = [], feature, points = [];

	        pointData.forEach(function (item) {
	            //适配高德地图火星坐标系
	            var _coordinates = utils.transformMultArray(item.data);
	            feature = new ol.Feature({
	                geometry: new ol.geom.MultiPoint(_coordinates).transform(constant.PROJ.EPSG_4326,
	                    constant.PROJ.EPSG_3857)
	            });

	            feature.setStyle(new ol.style.Style({
	                image: new ol.style.Circle({
	                    fill: new ol.style.Fill({
	                        color: item.fillColor
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color: item.strokeColor,
	                        width: item.strokeWidth
	                    }),
	                    radius: item.radius
	                })
	            }));
	            featureList.push(feature);
	        });
	        return featureList;
	    };

	    /**
	     * 根据线数据生成多条线
	     * @param lineData
	     *参考：
	     * [{
	     *   strokeWidth:2,
	     *   strokeColor:[255,0,0,255],
	     *   lineType:'',
	     *   showArrow:false,
	     *   data:[[[x,y],[x,y]],[[x,y],[x,y]]]
	     *}]
	     * @returns {Array}
	     */
	    var setLineData = function (lineData) {

	        var featureList = [], feature, points = [];
	        lineData.forEach(function (item) {
	            //适配高德地图火星坐标系
	            var _coordinates = utils.transformMultArray(item.data);
	            feature = new ol.Feature({
	                geometry: new ol.geom.MultiLineString(_coordinates).transform(constant.PROJ.EPSG_4326,
	                    constant.PROJ.EPSG_3857)
	            });
	            feature.setStyle(
	                new ol.style.Style({
	                    stroke: new ol.style.Stroke({
	                        color: item.strokeColor,
	                        width: item.strokeWidth
	                    })
	                })
	            );
	            featureList.push(feature);
	        });

	        return featureList;
	    };
	    /**
	     * 根据数据生成多个面
	     * @param polygonData
	     * 参考:[{
	     *  strokeWidth:2,
	     *  strokeColor:[255,0,0,255],
	     *  fillColor:[120,120,120,255]
	     *  data:[[[x,y],[x,y],[x,y]],[[x,y],[x,y],[x,y]]]
	     * }]
	     * @returns {Array}
	     */
	    var setPolygonData = function (polygonData) {
	        var featureList = [], feature, points = [];
	        polygonData.forEach(function (item) {
	            //适配高德地图火星坐标系
	            var _coordinates = utils.transformMultArray(item.data);
	            feature = new ol.Feature({
	                geometry: new ol.geom.MultiPolygon([_coordinates]).transform(constant.PROJ.EPSG_4326,
	                    constant.PROJ.EPSG_3857)
	            });
	            feature.setStyle(
	                new ol.style.Style({
	                    stroke: new ol.style.Stroke({
	                        color: item.strokeColor,
	                        width: item.strokeWidth
	                    }),
	                    fill: new ol.style.Fill({
	                        color: item.fillColor
	                    })
	                })
	            );
	            featureList.push(feature);
	        });

	        return featureList;
	    };

	    var layerObj = layers.getLayer({
	        layerId: paramObj.layerId,
	        mapId: paramObj.mapId
	    });

	    if (!layerObj) {
	        baseLayer.createLayer({
	            layerId: paramObj.layerId,
	            mapId: paramObj.mapId
	        });

	        layerObj = layers.getLayer({
	            layerId: paramObj.layerId,
	            mapId: paramObj.mapId
	        });
	    }
	    if (paramObj.zindex !== undefined) {
	        layerObj.setZIndex(paramObj.zindex);
	    }
	    switch (paramObj.layerType) {
	        case constant.LAYERTYPE.POINT:
	            layerObj.getSource().addFeatures(
	                setPointData(paramObj.layerData)
	            );
	            break;
	        case constant.LAYERTYPE.LINE:
	            layerObj.getSource().addFeatures(
	                setLineData(paramObj.layerData)
	            );

	            break;
	        case constant.LAYERTYPE.POLYGON:
	            layerObj.getSource().addFeatures(
	                setPolygonData(paramObj.layerData)
	            );
	            break;
	        default :
	            return;
	    }
	};

	module.exports = {
	    setVectorLayerData: setVectorLayerData
	};

/***/ },
/* 66 */
/*!***************************************!*\
  !*** ./src/gis/layers/adminRegion.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 行政区域。
	 */
	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var utils = __webpack_require__(/*! utils/util */ 1);

	var addLayer = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId;
	    var _layer = null;

	    if (hashMap.containsKey(_layerId)) {
	        _layer = hashMap.get(_layerId);
	    }
	    else {
	        baseLayer.createLayer(paramObj);
	        _layer = hashMap.get(_layerId);
	    }

	    if (!!paramObj.multiple) {
	        _layer.set('multiple', paramObj.multiple);
	    }
	    _layer.set('businessType', constant.BUSINESSTYPE.ADMIN_REGION);
	    
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	    }
	    if(paramObj.zindex !== undefined){
	        _layer.setZIndex(paramObj.zindex);
	    }

	    setLayerData(paramObj);
	};

	/**
	 *
	 * @param paramObj
	 *      paramObj = {
	 *          datas: [
	 *              {
	 *                  id: ##,
	 *                  coordinates: [[x, y],[x, y],...],
	 *                  fillColor: ##,
	 *                  strokeColor: ##,
	 *                  strokeWidth: ##,
	 *                  label: ##
	 *              },
	 *              ...
	 *          ]
	 *
	 *      }
	 */
	var setLayerData = function (paramObj) {
	    var _features = [];
	    var _datas = paramObj.datas;
	    if (utils.isValid(_datas) || _datas.length > 0) {
	        _datas.forEach(function (adminRegionData) {
	            var _coordinates = adminRegionData.coordinates;
	            _coordinates = utils.multigcjTransform(_coordinates);

	            var _geoPolygon = new ol.geom.Polygon([_coordinates]);
	            var _labelPoint = ol.extent.getCenter(_geoPolygon.getExtent());
	            var _feature = new ol.Feature({
	                geometry: _geoPolygon.transform('EPSG:4326', 'EPSG:3857'),
	                labelPoint: ol.proj.fromLonLat(_labelPoint),
	                businessType: constant.BUSINESSTYPE.ADMIN_REGION,
	                data: adminRegionData
	            });
	            _feature.setId(adminRegionData.id);

	            var _style = new ol.style.Style({
	                fill: new ol.style.Fill({
	                    color: adminRegionData.fillColor || null
	                }),
	                stroke: new ol.style.Stroke({
	                    color: adminRegionData.strokeColor || null,
	                    width: adminRegionData.strokeWidth || 1
	                }),
	                text: new ol.style.Text({
	                    text: adminRegionData.label ? adminRegionData.label : '',
	                    fill: new ol.style.Fill({
	                        color: adminRegionData.labelFillColor || 'black'
	                    }),
	                    font: 'normal 14px Arial',
	                    stroke: new ol.style.Stroke({
	                        color: '#ffffff',
	                        width: 3
	                    })
	                })
	            });

	            _feature.setStyle(_style);
	            _features.push(_feature);
	        });
	        var _layerObj = hashMap.get(paramObj.layerId + '_' + paramObj.mapId);
	        if (_layerObj != undefined) {
	            _layerObj.getSource().addFeatures(_features);
	        }
	    }

	};

	module.exports = {
	    addFeature: addLayer,
	    addLayer: addLayer,
	    setLayerData: setLayerData
	};

/***/ },
/* 67 */
/*!****************************************!*\
  !*** ./src/gis/layers/bubbleCircle.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var constant = __webpack_require__(/*! framework/constant */ 2);

	var addBubble = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId;
	    var _layer = null;

	    if (hashMap.containsKey(_layerId)) {
	        _layer = hashMap.get(_layerId);
	    }
	    else {
	        baseLayer.createLayer(paramObj);
	        _layer = hashMap.get(_layerId);
	    }

	    if (!!paramObj.multiple) {
	        _layer.set('multiple', paramObj.multiple);
	    }

	    _layer.set('businessType', constant.BUSINESSTYPE.BUBBLE_CIRCLE);
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	    }

	    var _source = _layer.getSource();
	    paramObj.source = _source;
	    if(paramObj.zindex !== undefined){
	        _layer.setZIndex(paramObj.zindex);
	    }

	    _setLayerData(paramObj);
	};

	var _setLayerData = function (paramObj) {
	    var _data = paramObj.datas;
	    var _layerIdentify = paramObj.layerId + '_' + paramObj.mapId;
	    var _layer = hashMap.get(_layerIdentify);
	    var _source = _layer.getSource();

	    if (utils.isValid(_data) || _data.length > 0) {
	        var _features = [];
	        _data.forEach(function (oneRecord) {
	            var _coordinate = utils.gcjTransform(oneRecord.coordinate);
	            _coordinate = ol.proj.fromLonLat(_coordinate);

	            ///保持用户输入的数据统一性
	            var _multiple = 1000;
	            var _radius = oneRecord.radius ? oneRecord.radius * _multiple : 10000;
	            var _feature = new ol.Feature({
	                geometry: new ol.geom.Circle(_coordinate, _radius),
	                data: oneRecord,
	                businessType: constant.BUSINESSTYPE.BUBBLE_CIRCLE
	            });
	            _feature.setId(oneRecord.id);

	            var _style = new ol.style.Style({
	                fill: new ol.style.Fill({
	                    color: oneRecord.fillColor || '#319FD3'
	                }),
	                stroke: new ol.style.Stroke({
	                    color: oneRecord.strokeColor || '#ff0',
	                    width: oneRecord.strokeWidth || 1
	                })
	            });

	            _feature.setStyle(_style);

	            _features.push(_feature);

	        });

	        _source.addFeatures(_features);
	    }

	};

	module.exports = {
	    addBubble: addBubble,
	    addLayer: addBubble,
	    setLayerData:_setLayerData
	};

/***/ },
/* 68 */
/*!**********************************!*\
  !*** ./src/gis/layers/bubble.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var constant = __webpack_require__(/*! framework/constant */ 2);

	var addBubble = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId,
	        _layer = null;

	    if (hashMap.containsKey(_layerId)) {
	        _layer = hashMap.get(_layerId);
	    }
	    else {
	        baseLayer.createLayer(paramObj);
	        _layer = hashMap.get(_layerId);
	    }

	    if (!!paramObj.multiple) {
	        _layer.set('multiple', paramObj.multiple);
	    }

	    _layer.set('businessType', constant.BUSINESSTYPE.BUBBLE);
	    var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.SITE;
	    _layer.setZIndex(_ZIndex);
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	    }

	    var _source = _layer.getSource();
	    paramObj.source = _source;
	    _setLayerData(paramObj);
	};

	var _setLayerData = function (paramObj) {
	    var _features = [],
	        _datas = paramObj.datas;

	    if (utils.isValid(_datas) || _datas.length > 0) {
	        _datas.forEach(function (item, index, datas) {
	            var _coordinate = utils.gcjTransform(item.coordinate);
	            _coordinate = ol.proj.fromLonLat(_coordinate);
	            var _feature = new ol.Feature({
	                geometry: new ol.geom.Point(_coordinate),
	                data: item,
	                businessType: constant.BUSINESSTYPE.BUBBLE
	            });
	            _feature.setId(item.id);
	            _feature.set('id', item.id);

	            var _defaultStyle = new ol.style.Style({
	                image: new ol.style.Circle({
	                    radius: item.radius ? item.radius : 5,
	                    fill: new ol.style.Fill({
	                        color: item.fillColor || 'red'
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color: item.strokeColor || '#319FD3',
	                        width: item.strokeWidth || 1
	                    })
	                })
	            });
	            _feature.setStyle(_defaultStyle);

	            _feature.set('defaultStyle', _defaultStyle);

	            _features.push(_feature);

	        });

	        paramObj.source.addFeatures(_features);
	    }
	};

	module.exports = {
	    addBubble: addBubble,
	    addLayer: addBubble,
	    setLayerData : _setLayerData,
	    clear: function (param) {
	        if (!!hashMap.get(param.layerId + '_' + param.mapId)) {
	            if (!!hashMap.get(param.layerId + '_' + param.mapId).getSource()) {
	                hashMap.get(param.layerId + '_' + param.mapId).getSource().clear();
	            }
	        }
	    }
	};


/***/ },
/* 69 */
/*!******************************************!*\
  !*** ./src/gis/layers/gradientCircle.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var constant = __webpack_require__(/*! framework/constant */ 2);

	var addGradientCircle = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId,
	        _layer = null;

	    if (hashMap.containsKey(_layerId)) {
	        _layer = hashMap.get(_layerId);
	    }
	    else {
	        baseLayer.createLayer(paramObj);
	        _layer = hashMap.get(_layerId);
	    }

	    if (!!paramObj.multiple) {
	        _layer.set('multiple', paramObj.multiple);
	    }
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	    }


	    var _source = _layer.getSource();
	    paramObj.source = _source;
	    if(paramObj.zindex !== undefined){
	        _layer.setZIndex(paramObj.zindex);
	    }
	    _setLayerData(paramObj);
	};

	var _setLayerData = function (paramObj) {
	    var _features = [],
	        _datas = paramObj.datas;

	    if (_datas && _datas.length > 0) {
	        for (var i = 0; i < _datas.length; i++) {
	        	var _lastCoordinate =utils.extend({},_datas[i]);
	        	//�ߵµ�ͼת���ɻ������
	        	var _transFromCoord =utils.gcjTransform(_lastCoordinate.coordinate);
	            var _coordinate = ol.proj.fromLonLat(_transFromCoord);
	            
	            var _radius = _datas[i].radius;
	            for (var j = 0; j < _radius.length; j++) {
	                var geom = new ol.geom.Circle(_coordinate, _radius[j]);
	                var style = new ol.style.Style({
	                    fill: new ol.style.Fill({
	                        color: _datas[i].fillColor[j] || 'red'
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color: _datas[i].strokeColor[j] || '#319FD3',
	                        width: _datas[i].strokeWidth[j] || 1
	                    })
	                });
	                var _feature = new ol.Feature({
	                    geometry: geom,
	                    data: _datas[i],
	                    type: 'gradientCircle'
	                });
	                _feature.setStyle(style);
	                if (j === 0) {
	                    _feature.setId(_datas[i].id);
	                }
	                else {
	                    _feature.setId(_datas[i].id + "_" + j);
	                }
	                _features.push(_feature);
	            }
	        }
	        paramObj.source.addFeatures(_features);
	    }
	};

	function removeGradientCircle(paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId;

	    if (hashMap.containsKey(_layerId)) {
	        var _layer = hashMap.get(_layerId);
	        _layer.getSource().clear();
	    }
	}
	module.exports = {
	    addGradientCircle: addGradientCircle,
	    addLayer: addGradientCircle,
	    setLayerData: _setLayerData,
	    removeGradientCircle: removeGradientCircle
	};


/***/ },
/* 70 */
/*!*******************************************************!*\
  !*** ./src/gis/layers/echartsLayer/addChartsOnMap.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var PieChart = __webpack_require__(/*! layers/echartsLayer/pieChart */ 71);
	var ColumnChart = __webpack_require__(/*! layers/echartsLayer/addColumnChart */ 72);
	var LineChart = __webpack_require__(/*! layers/echartsLayer/lineChart */ 73);
	var utils = __webpack_require__(/*! utils/util */ 1);

	function addCharts(paramObj) {
		var mapObj = hashMap.get(paramObj.mapId);
		var myChart = null;
		var chartOption = null;

		var overLayer = null;
		var _data = paramObj.data;

		for (var key in _data) {
			if (key === 'bar') { //柱状图
				_data[key].forEach(function (obj) {
					var point = obj.position;
					if (obj.isLonLat) {
						point = utils.gcjTransform(point);
						point = ol.proj.fromLonLat(point);
					}
					var art = ColumnChart.addColumnChart(obj);
					overLayer = new ol.Overlay({
						position: point,
						positioning: 'center-center',
						element: art,
						stopEvent: false
					});
					mapObj.addOverlay(overLayer);
				})
			} else if (key === 'pie') { //饼图
				//走饼图的逻辑
				for (var i = 0; i < _data[key].length; i++) {
					var point = _data[key][i].position;
					if (_data[key][i].isLonLat) {
						point = utils.gcjTransform(point);
						point = ol.proj.fromLonLat(point);
					}
					var domDiv = PieChart.createPie(_data[key][i]);
					overLayer = new ol.Overlay({
						position: point,
						positioning: 'center-center',
						element: domDiv,
						stopEvent: false
					});
					mapObj.addOverlay(overLayer);

					//为饼图注册鼠标单击事件
					//fusiongis.ChartsEvent.chartsClickEvent(echarts.init(domDiv));
				}
			} else if (key === 'line') {
				//折线图
				_data[key].forEach(function (obj) {
					var point = obj.position;
					if (obj.isLonLat) {
						point = utils.gcjTransform(point);
						point = ol.proj.fromLonLat(point);
					}
					var domDiv = LineChart.createStroke(obj);
					overLayer = new ol.Overlay({
						position: point,
						positioning: 'center-center',
						element: domDiv,
						stopEvent: false
					});
					mapObj.addOverlay(overLayer);
				})
			}

		}

	};

	module.exports = {
		//添加chart
		addCharts: addCharts
	};

/***/ },
/* 71 */
/*!*************************************************!*\
  !*** ./src/gis/layers/echartsLayer/pieChart.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);

	var createPie = function (obj) {
		var chartConfig = obj.config;
		var mainDiv = document.createElement('div');
		//width和height根据用户传入的饼图的外半径计算overyLayer的大小
		var radius = obj.outerRadius;

		mainDiv.style.width = radius * 3 + 200 + 'px';//不让用户传
		mainDiv.style.height = radius * 3 + 200 + 'px';//不让用户传
		mainDiv.style.borderRadius = 10 + 'px';//不让用户传

		var myChart = echarts.init(mainDiv);
		var option = getEchartPieOption(obj);

		myChart.setOption(option);
		if (_.isFunction(chartConfig.eventFun)) {
			myChart.on(chartConfig.eventType || 'click', chartConfig.eventFun);
		}
		return mainDiv;
	};

	//封装echarts图形需要的数据
	var getEchartPieOption = function (obj) {
		var _seriesData = [];
		var _name = obj.roseType == 'radius' ? '半径模式' : '面积模式';
		var pieOption = null;

		var _innerRadius = obj.innerRadius !== undefined ? obj.innerRadius : 0;
		var _outerRadius = obj.outerRadius !== undefined ? obj.outerRadius : 50;

		if (obj.seriesData.length) {
			_seriesData = obj.seriesData.sort(function (a, b) {
				return a.value - b.value;
			});
		}
		var getItemColor = function (_seriesData) {
			var colorArr = [];
			_.each(_seriesData, function (item) {
				if (item.color) {
					colorArr.push(item.color);
				} else {
					colorArr.push('#c23531');
				}
			});
			return colorArr;
		}
		pieOption = {
			tooltip: {
				trigger: 'item',
				formatter: "{a} <br/>{b} : {c} ({d}%)"
			},
			color: getItemColor(_seriesData),
			calculable: true,
			series: [{
				name: _name, //系列名称
				type: 'pie',
				radius: [_innerRadius, _outerRadius], //内半径和外半径，外半径需要算
				center: ['50%', '50%'],
				itemStyle: { //图形样式
					normal: { //图形在默认状态下的样式
						// color: obj.color !== undefined ? obj.color : '#c23531',
						borderColor: obj.borderColor !== undefined ? obj.borderColor : '#000', //图形的描边颜色
						borderWidth: obj.borderWidth !== undefined ? obj.borderWidth : '0', //描边宽度,0为无描边宽度
						borderType: obj.borderType !== undefined ? obj.borderType : 'solid', //柱条的描边类型'solid', 'dashed', 'dotted'

						shadowColor: obj.shadowColor !== undefined ? obj.shadowColor : 'rgba(0, 0, 0, 0.5)', //图形阴影的颜色
						shadowOffsetX: '0', //阴影水平的偏移距离
						shadowOffsetY: '0',
						shadowBlur: obj.shadowBlur !== undefined ? obj.shadowBlur : 100, //图形阴影的模糊大小,
						opacity: obj.opacity !== undefined ? obj.opacity : 1 //为0时不绘制此图形
					}
				},

				animationType: 'scale',//两种类型'expansion'和'scale'圆弧展开的效果和缩放效果
				animationEasing: 'elasticOut',
				data: _seriesData
			}]
		};

		/*饼图图形文本标签*/
		var _label = { //拥有normal和emphasis两个状态
			normal: {
				show: obj.isShowLabel !== undefined ? obj.isShowLabel : false, //是否显示label标签写成动态的
				position: 'outside', //有四种'outside','inside','inner','center' 写成动态的
				textStyle: {
					color: obj.labelColor !== undefined ? obj.labelColor : 'rgba(0, 0, 0, 1)', //文字的颜色
					fontStyle: obj.fontStyle !== undefined ? obj.fontStyle : 'normal', //文字的字体风格 字体风格一般有'normal','italic','oblique'
					fontWeight: obj.fontWeight !== undefined ? obj.fontWeight : 'normal', //字体粗细有四种
					fontFamily: obj.fontFamily !== undefined ? obj.fontFamily : 'sans-serif', //字体系列
					fontSize: obj.fontSize !== undefined ? obj.fontSize : 12
				},
				formatter: '{b}: {d}'
			},

			emphasis: {
				show: obj.isShowLabelEmphasis !== undefined ? obj.isShowLabelEmphasis : true, //动态的
				textStyle: {
					color: obj.emphasisColor !== undefined ? obj.emphasisColor : 'rgba(0, 0, 0, 1)', //文字的颜色
					fontStyle: obj.emphasisfontStyle !== undefined ? obj.emphasisfontStyle : 'normal', //文字的字体风格 字体风格一般有'normal','italic','oblique'
					fontWeight: obj.emphasisfontWeight !== undefined ? obj.emphasisfontWeight : 'normal', //字体粗细有四种
					fontFamily: obj.emphasisfontFamily !== undefined ? obj.emphasisfontFamily : 'sans-serif', //字体系列
					fontSize: obj.emphasisfontSize !== undefined ? obj.emphasisfontSize : 12
				},
			}
		};

		/*标签的视觉引导线样式*/
		var _lableLine = {
			normal: { //普通状态下的视觉引导线样式
				show: obj.isShowlableLine ? obj.isShowlableLine : false, //动态的
				length: 10, //视觉引导线第一段的长度
				length2: 20, //第二段的长度
				smooth: 0.2, //平滑程度
				lineStyle: {
					//支持纯色、渐变色、文理填充
					color: obj.lineColor ? obj.lineColor : 'rgba(255, 255, 255, 0.3)',
					width: obj.strokeWidth ? obj.strokeWidth : 1,
					type: obj.lineType ? obj.lineType : 'solid' //线的类型有三种'solid','dashed','dotted'
				}
			},
			emphasis: { //高亮状态下视觉引导线样式
				show: obj.isShowLabelLineEmphasis ? obj.isShowLabelLineEmphasis : true
			}

		};

		/*创建饼图支持的三种类型南丁格尔,标准饼图,环形饼图*/

		if (obj.trueType === 'rose_pie') {
			if (!!obj.roseType) {
				pieOption.series[0].roseType = obj.roseType; //根据半径大小区分数据的大小
			}
			if (obj.roseType === 'radius') {
				pieOption.series[0].label = _label;
				pieOption.series[0].lableLine = _lableLine;
			}
		} else if (obj.trueType === 'ring_pie') { //环形饼图
			pieOption.series[0].label = _label;
			pieOption.series[0].lableLine = _lableLine;

			pieOption.series[0].label.normal.position = 'center';
			pieOption.series[0].avoidLabelOverlap = false;

		} else if (obj.trueType === 'circle_pie') { //标准饼图

		}
		return pieOption;
	};

	module.exports = {
		//添加chart
		createPie: createPie
	};

/***/ },
/* 72 */
/*!*******************************************************!*\
  !*** ./src/gis/layers/echartsLayer/addColumnChart.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 为点线面设置数据
	 * @param param
	 参数 paramObj = {
	            mapId: 'mapId-1',地图ID
	            data: {
	                bar: [{
	                    config: {
	                        isShowTooltip:true, //是否显示提示框
	                        isShowLabel:true, //是否显示label
	                        chartHeight:'80%', //chart图占容器高
	                        chartWidth:'80%', //chart图占容器宽
	                        gridLeft:'3%', // chart图左偏移
	                        gridRight:'4%', // chart图右偏移
	                        gridBottom:'3%', // chart图下偏移
	                        gridTop:'10%', // chart图上偏移
	                        isCalculable:true,
	                        color:['#369858', '#569814'], //颜色
	                        axisPointer:'shadow', //鼠标悬浮时阴影还是直线
	                        eventType:'click', //事件类型
	                        eventFun:function(){},//回调函数
	                        isShowLegend:true, //是否显示图例
	                        labelColor:'#333' //label颜色
	                    },
	                    xAxisData: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun', 'aaa'],
	                    Data:[{
	                        data:[10, 52, 200, 334, 390, 330, 220, 500],
	                        name:'直接选择',
	                        color:'',
	                        type:'bar'
	                    }],
	                    isLonLat: true, //经纬度此参数必须传
	                    position: [130.78, 27.97],
	                    width: '150px',
	                    height: '150px'
	                }]
	            }
	        };
	   调用： fusiongis.columnChart.addColumnChart(paramObj);
	 */
	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);

	var addColumnChart = function (param) {
	    var chartObj = null;
	    var chartOption = null;
	    var createDiv = null;
	    var overLayer = null;

	    //生成柱状图
	    var createBar = function (barParam) {
	        createDiv = document.createElement('div');
	        createDiv.style.width = barParam.width;
	        createDiv.style.height = barParam.height;
	        createDiv.style.borderRadius = 10 + 'px';//不让用户传
	        var chartConfig = barParam.config;
	        chartObj = echarts.init(createDiv);
	        chartOption = {
	            backgroundColor: chartConfig.backgroundColor || 'rgba(255, 255, 255, 0.7)',
	            calculable: chartConfig.isCalculable || false,
	            color: chartConfig.color || ['#369858', '#569814'],
	            chartType: 'bar',
	            tooltip: {
	                show: chartConfig.isShowTooltip || false,
	                trigger: 'axis',
	                axisPointer: {            // 坐标轴指示器，坐标轴触发有效
	                    type: chartConfig.axisPointer || 'shadow'        // 默认为直线，可选为：'line' | 'shadow'
	                }
	            },
	            grid: [{
	                width: chartConfig.chartWidth || '80%',
	                height: chartConfig.chartHeight || '80%',
	                left: chartConfig.gridLeft || '3%',
	                right: chartConfig.gridRight || '4%',
	                bottom: chartConfig.gridBottom || '3%',
	                top: chartConfig.gridTop || '2%',
	                containLabel: chartConfig.isContainLabel || true
	            }],
	            xAxis: [
	                {
	                    type: 'category',
	                    rotate: -45,
	                    data: barParam.xAxisData
	                }
	            ],
	            yAxis: [
	                {
	                    type: 'value'
	                }
	            ],
	            series: _.map(barParam.Data, function (item) {
	                return {
	                    name: item.name || '',
	                    itemStyle: {
	                        normal: {
	                            color: item.color || '#379CF8'
	                        }
	                    },
	                    type: item.type || 'bar',
	                    data: item.data,
	                    barWidth: chartConfig.barWidth || null,
	                    label: {
	                        normal: {
	                            show: chartConfig.isShowLabel || false,
	                            position: 'top',
	                            formatter: function () {
	                                return this.y;
	                            }
	                        },
	                        emphasis: {
	                            position: 'top',
	                            formatter: function () {
	                                return this.y;
	                            },
	                            textStyle: {
	                                color: chartConfig.labelColor || '#333'
	                            }
	                        }
	                    },
	                }
	            })
	        };
	        chartObj.setOption(chartOption);
	        if (_.isFunction(chartConfig.eventFun)) {
	            chartObj.on(chartConfig.eventType || 'click', chartConfig.eventFun);
	        }
	        return createDiv;
	    };
	    return createBar(param);
	};

	module.exports = {
	    //添加chart
	    addColumnChart: addColumnChart
	};

/***/ },
/* 73 */
/*!**************************************************!*\
  !*** ./src/gis/layers/echartsLayer/lineChart.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);

	var createStroke = function (strokeParam) {
	    createDiv = document.createElement('div');
	    var chartConfig = strokeParam.config;
	    createDiv.style.width = strokeParam.width;
	    createDiv.style.height = strokeParam.height;
	    createDiv.style.borderRadius = 10 + 'px';
	    chartObj = echarts.init(createDiv);
	    chartOption = {
	        backgroundColor: chartConfig.backgroundColor || 'rgba(255, 255, 255, 0.7)',
	        calculable: true,
	        tooltip: {
	            show: chartConfig.isShowTooltip || false,
	            trigger: 'axis',
	            axisPointer: {            // 坐标轴指示器，坐标轴触发有效
	                type: chartConfig.axisPointer || 'shadow'        // 默认为直线，可选为：'line' | 'shadow'
	            }
	        },
	        grid: [{
	            width: chartConfig.chartWidth || '80%',
	            height: chartConfig.chartHeight || '80%',
	            left: chartConfig.gridLeft || '3%',
	            right: chartConfig.gridRight || '4%',
	            bottom: chartConfig.gridBottom || '3%',
	            top: chartConfig.gridTop || '2%',
	            containLabel: chartConfig.isContainLabel || true
	        }],
	        xAxis: [{
	            type: 'category',
	            data: strokeParam.xAxisData
	        }],
	        yAxis: [{
	            type: 'value'
	        }],
	        series: _.map(strokeParam.Data, function (item) {
	            return {
	                name: item.name || '',
	                itemStyle: {
	                    normal: {
	                        color: item.color || '#379CF8'
	                    }
	                },
	                type: item.type || 'line',
	                symbol: item.symbol || 'emptyCircle',
	                symbolSize: item.symbolSize || 4,
	                data: item.data,
	                label: {
	                    normal: {
	                        show: chartConfig.isShowLabel || false,
	                        position: 'top',
	                        formatter: function () {
	                            return this.y;
	                        }
	                    },
	                    emphasis: {
	                        position: 'top',
	                        formatter: function () {
	                            return this.y;
	                        },
	                        textStyle: {
	                            color: chartConfig.labelColor || '#333'
	                        }
	                    }
	                },
	            }
	        }),
	        color: strokeParam.color
	    };
	    chartObj.setOption(chartOption);
	    if (_.isFunction(chartConfig.eventFun)) {
	        chartObj.on(chartConfig.eventType || 'click', chartConfig.eventFun);
	    }
	    return createDiv;
	};

	module.exports = {
	    //添加chart
	    createStroke: createStroke
	};

/***/ },
/* 74 */
/*!*******************************************!*\
  !*** ./src/gis/layers/bezierCurveLine.js ***!
  \*******************************************/
/***/ function(module, exports) {

	var addPolygonBezier = function (paramObj, callback) {
	    var arrayLength = paramObj.coordinates.length;
	    //是否传入的polygon是两个点
	    if (arrayLength === 2) {//三阶贝塞尔曲线
	        //计算控制点
	        var curveCoordinates = [];
	        var _startPoint = paramObj.coordinates[0];
	        var _endPoint = paramObj.coordinates[1];

	        var firstRadius = paramObj.radius[0];//第一个控制点半径
	        var secondRadius = paramObj.radius[1];//第二个控制点半径
	        var firstazimuth = paramObj.azimuth[0];//第一个控制点角度
	        var secondazimuth = paramObj.azimuth[1];//第二个控制点角度

	        var trans3857FirstCoords = ol.proj.fromLonLat(_startPoint);
	        var trans3857EndCoords = ol.proj.fromLonLat(_endPoint);

	        var rotatedazimuth1 = Math.PI / 2 - (firstazimuth) / 180 * Math.PI;
	        var rotatedazimuth2 = Math.PI / 2 - (secondazimuth) / 180 * Math.PI;

	        var firstControlCoordsX = trans3857FirstCoords[0] + firstRadius * Math.cos(rotatedazimuth1);
	        var firstControlCoordsY = trans3857FirstCoords[1] + firstRadius * Math.sin(rotatedazimuth1);
	        var secondControlCoordsX = trans3857EndCoords[0] + secondRadius * Math.cos(rotatedazimuth2);
	        var secondControlCoordsY = trans3857EndCoords[1] + secondRadius * Math.sin(rotatedazimuth2);

	        //将四个点转换为3857
	        var _3857StartPoint = ol.proj.fromLonLat(_startPoint);
	        var _3857EndPoint = ol.proj.fromLonLat(_endPoint);
	        var _3857FirstControl = [firstControlCoordsX, firstControlCoordsY];
	        var _3857SecondControl = [secondControlCoordsX, secondControlCoordsY];

	        var cp = [
	            new Point2D(_3857StartPoint[0], _3857StartPoint[1]),
	            new Point2D(_3857FirstControl[0], _3857FirstControl[1]),
	            new Point2D(_3857SecondControl[0], _3857SecondControl[1]),
	            new Point2D(_3857EndPoint[0], _3857EndPoint[1])
	        ];
	        var numberOfPoints = paramObj.numberOfPoints;
	        var curve = [];
	        //得到贝塞尔曲线的点
	        ComputeBezier(cp, numberOfPoints, curve);
	        if (curve.length > 0) {
	            for (var i = 0; i < curve.length; i++) {
	                curveCoordinates.push(ol.proj.toLonLat([curve[i].x, curve[i].y]));
	            }
	        }
	        var bezierParamObj = {
	            mapId: paramObj.mapId,
	            layerId: paramObj.layerId,
	            isBezier:paramObj.isBezier,
	            lineGeoId: paramObj.lineGeoId,
	            fillColor: paramObj.fillColor ? paramObj.fillColor : '##208089',
	            strokeColor: paramObj.strokeColor ? paramObj.strokeColor : '##208089',
	            strokeWidth: paramObj.strokeWidth ? paramObj.strokeWidth : 3,
	            coordinates: curveCoordinates
	        };
	        fusiongis.LineStraight.addLine(bezierParamObj,callback);

	/*        if (callback) {
	            callback(curveCoordinates);
	        } else {
	            return curveCoordinates;
	        }*/
	    }
	};

	function PointOnCubicBezier(cp, t) {
	    var ax, bx, cx;
	    var ay, by, cy;
	    var tSquared, tCubed;
	    var result = new Point2D;
	    /*计算多项式系数*/
	    cx = 3.0 * (cp[1].x - cp[0].x);
	    bx = 3.0 * (cp[2].x - cp[1].x) - cx;
	    ax = cp[3].x - cp[0].x - cx - bx;

	    cy = 3.0 * (cp[1].y - cp[0].y);
	    by = 3.0 * (cp[2].y - cp[1].y) - cy;
	    ay = cp[3].y - cp[0].y - cy - by;
	    /*计算位于参数值的曲线点*/
	    tSquared = t * t;
	    tCubed = tSquared * t;
	    result.x = (ax * tCubed) + (bx * tSquared) + (cx * t) + cp[0].x;
	    result.y = (ay * tCubed) + (by * tSquared) + (cy * t) + cp[0].y;
	    return result;
	}

	function Point2D(x, y) {
	    this.x = x || 0.0;
	    this.y = y || 0.0;
	}
	/*
	 ComputeBezier以控制点cp所产生的曲线点，填入Point2D结果的阵列。
	 */
	function ComputeBezier(cp, numberOfPoints, curve) {
	    var dt, i;
	    dt = 1.0 / ( numberOfPoints - 1 );
	    for (i = 0; i < numberOfPoints; i++)
	        curve[i] = PointOnCubicBezier(cp, i * dt);
	}

	module.exports = {
	    addCurve: addPolygonBezier
	};

/***/ },
/* 75 */
/*!************************************!*\
  !*** ./src/gis/layers/figTense.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var utils = __webpack_require__(/*! utils/util */ 1);

	/**
	 * @describe 时态图。
	 * @param paramObj {Object}
	 * @param paramObj.mapId {string} 地图唯一标识
	 * @param paramObj.layerId {string} 图层唯一标识
	 *
	 */
	var createLayer = function (paramObj) {
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId;
	    var _layerIdentify = _layerId + '_' + _mapId;
	    var _mapObj = hashMap.get(_mapId);
	    var _layer = null;

	    if (!!!hashMap.get(_layerIdentify)) {
	        _layer = new ol.layer.Image({
	            opacity: paramObj.opacity || 0.7
	        });

	        _layer.set('layerId', _layerId);
	        _layer.set('mapId', _mapId);
	        _mapObj.addLayer(_layer);
	        hashMap.put(_layerIdentify, _layer);
	    }
	    else {
	        _layer = hashMap.get(_layerIdentify);
	    }

	    if (!!paramObj.multiple) {
	        _layer.set('multiple', paramObj.multiple);
	    }
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	    }
	    if(paramObj.zindex !== undefined){
	        _layer.setZIndex(paramObj.zindex);
	    }

	    return _layer;
	};

	/**
	 * @describe 设置时态图层数据。
	 * @param paramObj {Object}
	 * @param paramObj.mapId {string} 地图唯一标识
	 * @param paramObj.layerId {string} 图层唯一标识
	 *
	 * @param paramObj.parentTaskId {string} 父任务唯一标识
	 * @param paramObj.subTaskId {string} 子任务唯一标识
	 *
	 * @param paramObj.imgUrl {string} 静态图显示的位置
	 * @param paramObj.projection {string} 静态图层渲染的投影坐标
	 * @param paramObj.imageExtent {Array<minX, minY, maxX, maxY>} 静态图显示的位置
	 *
	 * @param isStaticImg {boolean=} 是否加载静态图
	 */
	var setLayerData = function (paramObj, isStaticImg) {
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId;
	    var _layerIdentify = _layerId + '_' + _mapId;
	    var _layer = hashMap.get(_layerIdentify);
	    var _mapSize = !!hashMap.get(_mapId) && hashMap.get(_mapId).getSize();
	    var _source = null;

	    if (!!isStaticImg) {
	        _source = new ol.source.ImageStatic({
	            url: paramObj.imgUrl,
	            projection: paramObj.projection || constant.PROJ.EPSG_4326,
	            imageExtent: paramObj.imageExtent
	        })
	    }
	    else {
	        var url = constant.GisRootUrl;

	        if (paramObj.previewType === 'vector') {
	            url = url + '/temporalmap/vector/getImage';
	        }
	        else {
	            url = url + '/temporalmap/grid/getImage';
	        }

	        _source = new ol.source.ImageWMS({
	                params: {
	                    parentTaskId: paramObj.parentTaskId,
	                    subTaskId: paramObj.subTaskId,
	                    VERSION: '1.1.1',
	                    WIDTH: _mapSize[0],
	                    HEIGHT: _mapSize[1]
	                },
	                extent: !!hashMap.get(_mapId) && hashMap.get(_mapId).getExtent(_mapId) || [-180, -85, 180, 85],
	                url: url,
	                wrapX: false
	            }
	        );
	    }

	    !!_layer && _layer.setSource(_source);

	};

	module.exports = {
	    createLayer: createLayer,
	    addLayer: createLayer,
	    setLayerData: setLayerData
	};

/***/ },
/* 76 */
/*!***************************************!*\
  !*** ./src/gis/layers/gridDensity.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 栅格密度
	 */
	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var utils = __webpack_require__(/*! utils/util */ 1);

	var map = null;
	var gridWidth = 50;
	var gridHeight = 50;
	var ctx = null;
	var coordinates = [];

	var drawRect = function (x, y, val) {
	    ctx.lineWidth = 1;
	    if (val > 0) {
	        ctx.strokeStyle = 'rgba(0,0,255,0.8)';

	    }
	    else {
	        ctx.strokeStyle = 'rgba(0,0,255,0.1)';
	    }
	    ctx.strokeRect(x - gridWidth / 2, y - gridHeight / 2, gridWidth, gridHeight);
	};

	var drawText = function (x, y, val) {
	    if (val > 0) {
	        //只有汇聚情况下，才进行标签显示
	        ctx.textAlign = 'center';
	        ctx.textBaseline = 'middle';
	        ctx.font = "15px Arial";
	        ctx.fillStyle = 'white';
	        ctx.fillText(val, x, y);
	    }
	};

	function calculateGrids(numOfLevel, numOfVertical, imageExtent) {
	    var _gridW_3857 = (imageExtent[2] - imageExtent[0]) / numOfLevel;
	    var _gridH_3857 = (-imageExtent[3] + imageExtent[1]) / numOfVertical;
	    var _widthOfHalfGrid = _gridW_3857 / 2;
	    var _heightOfHalfGrid = _gridH_3857 / 2;

	    for (var i = 0; i < numOfLevel; i++) {
	        for (var j = 0; j < numOfVertical; j++) {
	            var x = imageExtent[0] + _gridW_3857 * i;
	            var y = imageExtent[3] + _gridH_3857 * j;
	            var count = 0;

	            coordinates.forEach(function (coordinate) {
	            	var lastCoordinate =coordinate.slice(0);
	            	//转换成火星坐标
	            	var tansFormCoordinate =utils.gcjTransform(lastCoordinate);
	                var _coordinate = ol.proj.fromLonLat(tansFormCoordinate);
	                if (_coordinate[0] >= x - _widthOfHalfGrid &&
	                    _coordinate[0] < x + _widthOfHalfGrid &&
	                    _coordinate[1] <= y - _heightOfHalfGrid &&
	                    _coordinate[1] > y + _heightOfHalfGrid) {
	                    count += 1;
	                }
	            });

	            var _currentX = gridWidth * i;
	            var _currentY = gridHeight * j;

	            drawRect(_currentX, _currentY, count);

	            drawText(_currentX, _currentY, count);
	        }
	    }
	}

	var _canvasFunction = function (imageExtent, imageResolution, devicePixelRatio, imageSize, imageProjection) {
	    if (!this.canvas) {
	        this.canvas = document.createElement('canvas');
	    }

	    var canvasWidth = imageSize[0];
	    var canvasHeight = imageSize[1];
	    this.canvas.setAttribute('width', canvasWidth);
	    this.canvas.setAttribute('height', canvasHeight);
	    ctx = this.canvas.getContext('2d');

	    var numOfLevel = canvasWidth / gridWidth;
	    var numOfVertical = canvasHeight / gridHeight;
	    calculateGrids(numOfLevel, numOfVertical, imageExtent);
	    return this.canvas;
	};

	/**
	 * 添加栅格密度
	 * @param paramObj
	 */
	var addGridDensity = function (paramObj) {
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId + '_' + _mapId;
	    coordinates = paramObj.datas;
	    var globalMap = mapBox.getMapObj(_mapId);

	    if (!utils.isValid(hashMap.get(_layerId))) {
	        var _layer = new ol.layer.Image({
	            source: new ol.source.ImageCanvas({
	                canvasFunction: _canvasFunction,
	                projection: globalMap.get('paramObj').proj
	            })
	        });

	        _layer.set('type', constant.CUSTOMTYPE.LAYERIMGTYPE);
	        _layer.set('isVectorType',false);
	        _layer.set('map', globalMap);
	        _layer.set('layerId', _layerId);
	        _layer.set('layer_id', paramObj.layerId);
	        if (paramObj.minShowLevel != undefined) {
	            _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	        }

	        if (paramObj.maxShowLevel != undefined) {
	            _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	        }

	        globalMap.addLayer(_layer);
	        if(paramObj.zindex !== undefined){
	            _layer.setZIndex(paramObj.zindex);
	        }

	        hashMap.put(_layerId, _layer);
	    }
	};

	module.exports = {
	    addGridDensity: addGridDensity
	};

/***/ },
/* 77 */
/*!***********************************!*\
  !*** ./src/gis/layers/heatMap.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var maps = __webpack_require__(/*! maps/map */ 8);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var utils = __webpack_require__(/*! utils/util */ 1);

	var createLayer = function (paramObj) {
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId + '_' + _mapId;
	    var _mapObj = mapBox.getMapObj(_mapId);
	    var _label = !!!paramObj.label ? paramObj.layerId : paramObj.label;
	    var _zoom = _mapObj.getView().getZoom();
	    var _gradient = paramObj.gradient ? paramObj.gradient : [
	        '#FF3030', '#FF4500', '#FF7F50', '#FF8C00', '#FFA54F', '#FFB90F', '#436EEE', '#5CACEE',
	        '#54FF9F'
	    ];
	    _gradient.reverse();

	    if (!utils.isValid(hashMap.get(_layerId))) {
	        var radius = paramObj.radius ? paramObj.radius : 8;
	        var blur = paramObj.blur ? paramObj.blur : 15;
	        var shadow = (radius + blur) * 10;
	        var _layer = new ol.layer.Heatmap({
	            gradient: _gradient,
	            radius: paramObj.radius ? paramObj.radius : 30,
	            blur: paramObj.blur ? paramObj.blur : 50,
	            shadow: shadow,
	            source: new ol.source.Vector({
	                wrapX: false
	            })
	        });
	        _layer.set('type', constant.CUSTOMTYPE.LAYERHEATTYPE);
	        _layer.set('map', _mapObj);
	        _layer.set('layerId', _layerId);
	        _layer.set('businessType', constant.BUSINESSTYPE.HEAT_MAP);
	        _layer.set('params.label', _label);
	        _layer.set('layer_id', paramObj.layerId);

	        if (!!paramObj.multiple) {
	            _layer.set('multiple', paramObj.multiple);
	        }
	        if (paramObj.minShowLevel != undefined) {
	            _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	        }

	        if (paramObj.maxShowLevel != undefined) {
	            _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	        }
	        if(paramObj.zindex !== undefined){
	            _layer.setZIndex(paramObj.zindex);
	        }

	        _mapObj.addLayer(_layer);

	        hashMap.put(_layerId, _layer);
	    }
	    return _layer;
	};

	/**
	 * 添加热力图
	 * @param paramObj
	 *
	 * {
	 *      mapId: {String},
	 *      layerId: {String},
	 *      gradient：{Array<String>}, e.g ['#00f', '#0ff', '#0f0', '#ff0', '#f00']
	 *      radius:{number},
	 *      blur:{number},
	 *      shadow: {number},
	 *      data: {Array<Array<number>>} e.g [[x, y], [x, y]]
	 * }
	 */
	var addHeatMap = function (paramObj) {
	    var _layer = createLayer(paramObj),
	        _features = [],
	        _weights = [],
	        _maxWeight = 0; //获取最大的权重
	    paramObj.datas.forEach(function (data) {
	        _weights.push(data.weight);
	    });
	    utils.sortDesc(_weights);
	    _maxWeight = _weights[0];

	    paramObj.datas.forEach(function (data) {
	    	var _coordinate =utils.gcjTransform(data.coordinate);
	        var _geoPoint = new ol.geom.Point(ol.proj.fromLonLat(_coordinate));
	        var _feature = new ol.Feature({
	            geometry: _geoPoint,
	            data: data,
	            weight: data.weight / _maxWeight
	        });
	        _feature.setId(data.id);
	        _features.push(_feature);
	    });

	    _layer.getSource().addFeatures(_features);

	};

	var setLayerData = function (paramObj) {
	    var _layer = layers.getLayer(paramObj),
	        _features = [],
	        _weights = [],
	        _maxWeight = 0; //获取最大的权重
	    paramObj.datas.forEach(function (data) {
	        _weights.push(data.weight);
	    });
	    utils.sortDesc(_weights);
	    _maxWeight = _weights[0];

	    paramObj.datas.forEach(function (data) {
	    	var _coordinate =utils.gcjTransform(data.coordinate);
	        var _geoPoint = new ol.geom.Point(ol.proj.fromLonLat(_coordinate));
	        var _feature = new ol.Feature({
	            geometry: _geoPoint,
	            data: data,
	            weight: data.weight / _maxWeight
	        });
	        _feature.setId(data.id);
	        _features.push(_feature);
	    });

	    _layer.getSource().addFeatures(_features);
	};

	module.exports = {
	    addHeatMap: addHeatMap,
	    addLayer: createLayer,
	    setLayerData: setLayerData
	};

/***/ },
/* 78 */
/*!********************************!*\
  !*** ./src/gis/layers/icon.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 网元或者异常事件业务可以通过此类进行适配
	 */
	var ol = __webpack_require__(/*! ol */ 4);
	var maps = __webpack_require__(/*! maps/map */ 8);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var layers = __webpack_require__(/*! layers/layers */ 41);

	var imgPath = constant.GisResourceURL + 'marker/';

	var addIcon = function (paramObj) {
	    var _layerIdentify = paramObj.layerId + '_' + paramObj.mapId;
	    var _label = paramObj.label != undefined ? paramObj.label : paramObj.layerId;
	    var _layer = null;

	    if (hashMap.containsKey(_layerIdentify)) {
	        _layer = hashMap.get(_layerIdentify);
	    }
	    else {
	        baseLayer.createLayer(paramObj);
	        _layer = hashMap.get(_layerIdentify);

	    }

	    if (!!paramObj.multiple) {
	        _layer.set('multiple', paramObj.multiple);
	    }
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	    }
	    _layer.set('type', 'ICON');
	    _layer.set('isImgType',true);
	    _layer.set('layerId', _layerIdentify);
	    _layer.set('layer_id', paramObj.layerId);
	    _layer.set('businessType', 'ICON');
	    _layer.set('params.label', _label);
	    _layer.set('legendName', paramObj.legendName);
	    if(paramObj.zindex !== undefined){
	        _layer.setZIndex(paramObj.zindex);
	    }
	    setLayerData(paramObj);

	};

	var setLayerData = function (paramObj) {
	    var mapObj = maps.getMapObj(paramObj.mapId);
	    var layer = layers.getLayer(paramObj);
	    var _features = [];
	    var _datas = paramObj.datas;
	    var _currentExtent = mapObj.getView().calculateExtent(mapObj.getSize());

	    if (!!paramObj.imgPath) {
	        imgPath = paramObj.imgPath;
	    }

	    if (!!_datas) {
	        _datas.forEach(function (iconData) {
	            var _imgUrl = null;
	            var _selectImgUrl = null;
	            //高德地图转换成火星坐标
	            var _coordinate = utils.gcjTransform(iconData.coordinate);


	            var coordinate_ = ol.proj.fromLonLat(_coordinate);
	            var _point = new ol.geom.Point(coordinate_);
	            var _feature = new ol.Feature({
	                geometry: _point,
	                businessType: constant.BUSINESSTYPE.ICON,
	                data: iconData
	            });
	            if (iconData.imageName) {
	                _imgUrl = imgPath + iconData.imageName;
	            }
	            else {
	                _imgUrl = constant.GisResourceURL + 'marker/ne_default.png';
	            }

	            var _rotation = 0;
	            if (!!!iconData.rotation) {
	                _rotation = 0;
	            }
	            else {
	                _rotation = iconData.rotation;
	            }
	            var _style = new ol.style.Style({
	                image: new ol.style.Icon({
	                    src: _imgUrl,
	                    rotation: _rotation,
	                    opacity: iconData.opacity || 1
	                }),
	                text: new ol.style.Text({
	                    text: iconData.label != undefined ? iconData.label : '',
	                    fill: new ol.style.Fill({
	                    	color: iconData.labelFillColor != undefined ? iconData.labelFillColor : 'black'
	                    })
	                })
	            });
	            _feature.setId(iconData.id);
	            _feature.setStyle(_style);
	            _feature.set('data', iconData);
	            _feature.set('vectorType', constant.BUSINESSTYPE.ICON);
	            _feature.set('layer',layer);
	            _features.push(_feature);
	        });
	        layer.getSource().addFeatures(_features);
	        layer.set('legendName', paramObj.legendName);
	    }
	};

	module.exports = {
	    addIcon: addIcon,
	    addLayer: addIcon,
	    setLayerData: setLayerData
	};

/***/ },
/* 79 */
/*!**************************************!*\
  !*** ./src/gis/layers/icon2Label.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var utils = __webpack_require__(/*! utils/util */ 1);

	var glbSource = null;
	var mapObj = null;

	var addLayer = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId;
	    mapObj = mapBox.getMapObj(paramObj.mapId);
	    var _layer = null;
	    if (hashMap.containsKey(_layerId)) {
	        _layer = hashMap.get(_layerId);
	    }
	    else {
	        baseLayer.createLayer(paramObj);
	        _layer = hashMap.get(_layerId);
	    }

	    if (!!paramObj.multiple) {
	        _layer.set('multiple', paramObj.multiple);
	    }
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	    }
	    _layer.set('isVectorType',true);
	    if(paramObj.zindex !== undefined){
	        _layer.setZIndex(paramObj.zindex);
	    }

	    glbSource = _layer.getSource();
	};

	var setLayerData = function (paramObj) {
	    var mapId = paramObj.mapId;
	    var layerId = paramObj.layerId;
	    var _layer = hashMap.get(layerId + '_' + mapId);
	    if(!_layer){
	        console.log("layer can not find " + layerId);
	        return
	    }
	    glbSource = _layer.getSource();
	    var _features = [];
	    var _datas = paramObj.datas;
	    var _view = mapObj.getView();
	    var _currentExtent = _view.calculateExtent(mapObj.getSize());
	    if (utils.isValid(_datas) || _datas.length > 0) {
	        _datas.forEach(function (data) {
	            var _coordinate = utils.gcjTransform(data.coordinate);


	            var coordinate3857 = ol.proj.fromLonLat(_coordinate);
	            var _point = new ol.geom.Point(coordinate3857);
	            var _feature = new ol.Feature({
	                geometry: _point
	            });
	            var _featureId = data.id;
	            _feature.setId(_featureId);

	            var _shadowFeature = _feature.clone();
	            var _shadowFeatureId = _featureId + '_shadow';
	            _shadowFeature.setId(_shadowFeatureId);

	            var _relationFeature = _feature.clone();
	            var _linkFeatureId = _featureId + '_relation_featureId';
	            _relationFeature.setId(_linkFeatureId);

	            var _style = new ol.style.Style({
	                image: new ol.style.Circle({
	                    radius: 6,
	                    stroke: new ol.style.Stroke({
	                        color: '#1E90FF',
	                        width: 3
	                    }),
	                    fill: new ol.style.Fill({
	                        color: 'white'
	                    })
	                }),
	                text: new ol.style.Text({
	                    text: data.pointLabel,
	                    font: 'normal 14px Arial',
	                    offsetY: data.pointLabelY || 20
	                })
	            });
	            _feature.setStyle(_style);

	            var _shadowStyle = new ol.style.Style({
	                image: new ol.style.Circle({
	                    radius: 10,
	                    stroke: new ol.style.Stroke({
	                        color: '#87CEEB',
	                        width: 5
	                    }),
	                    fill: new ol.style.Fill({
	                        color: 'rgba(0,0,0,0)'
	                    })
	                })
	            });
	            _shadowFeature.setStyle(_shadowStyle);

	            var _relationStyle = new ol.style.Style({
	                image: new ol.style.Icon({
	                    src: data.imgUrl,
	                    opacity: .7,
	                    scale: data.scale || 1,
	                    anchor: [0.47, 0.7]
	                }),
	                text: new ol.style.Text({
	                    text: data.iconLabel,
	                    font: 'normal 14px Arial',
	                    offsetY: data.iconLabelY || 25
	                })
	            });
	            _relationFeature.setStyle(_relationStyle);

	            _features.push(_feature, _shadowFeature, _relationFeature);
	        });
	        glbSource.addFeatures(_features);
	    }
	};

	module.exports = {
	    addLayer: addLayer,
	    setLayerData: setLayerData
	};


/***/ },
/* 80 */
/*!***********************************!*\
  !*** ./src/gis/layers/infoPop.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var utils = __webpack_require__(/*! utils/util */ 1);

	function addInfoPop(params) {
	    var olMap = mapBox.getMapObj(params.mapId);
	    var sourceLayer = layers.getLayer({
	        mapId: params.mapId,
	        layerId: params.sourceLayerId
	    });
	    if (!sourceLayer) {
	        throw new Error('source layer does not exist!');
	    }
	    var infoLayer = addLayer(params, olMap);
	    //将infoLayer添加为sourceLayer的效果图层
	    layers.addEffectLayer({
	        mapId: params.mapId,
	        layer: sourceLayer,
	        effectLayer: infoLayer
	    });
	    setLayerData(params, olMap, infoLayer);
	    var drag = getInteraction(params, olMap);

	    drag.onDrag = function (evt, feature) {
	        var shape = feature;
	        var line = shape.get('line');
	        var origin = line.getGeometry().getCoordinates()[0];
	        var _origin = utils.gcjTransform3857(origin);
	        var floatCoord = shape.getGeometry().getCoordinates();
	        var _floatCoord = utils.gcjTransform3857(floatCoord);
	        var coordinates = getLineCoordinates(_origin, _floatCoord);
	        line.getGeometry().setCoordinates(coordinates);
	    };
	}

	function addLayer(params, olMap) {
	    var layerId = 'infoPop\u9999' + params.sourceLayerId;
	    var layer = olUtil.getLayer({
	        mapId: params.mapId,
	        layerId: layerId
	    });
	    if (layer) {
	        return layer;
	    }
	    layer = new ol.layer.Vector({
	        map: olMap,
	        layerId: layerId,
	        source: new ol.source.Vector({
	            warpX: false
	        })
	    });
	    var _ZIndex = params.zindex !== undefined ? params.zindex : constant.Z_INDEX.INFOPOP;
	    layer.setZIndex(_ZIndex);
	    olMap.addLayer(layer);
	    return layer;
	}

	function setLayerData(params, olMap, layer) {
	    var features = [];
	    params.data.forEach(function (pointData) {
	        var position = pointData.position ? pointData.position : 'left';
	        var distance = pointData.distance ? pointData.distance : 150;
	        var origin = ol.proj.fromLonLat(util.gcjTransform(pointData.lonLat));
	        var originPixel = olMap.getPixelFromCoordinate(origin);

	        var floatPixel = originPixel.slice(0);
	        switch (position) {
	            case 'left':
	                floatPixel[0] = floatPixel[0] - distance;
	                break;
	            case 'right':
	                floatPixel[0] = floatPixel[0] + distance;
	                break;
	            case 'up':
	                floatPixel[1] = floatPixel[1] + distance;
	                break;
	            case 'down':
	                floatPixel[1] = floatPixel[1] - distance;
	                break;
	        }
	        var floatCoord = olMap.getCoordinateFromPixel(floatPixel);

	        var shape = makeShape(params, pointData, floatCoord);
	        var line = makeLine(params, pointData, origin, floatCoord);
	        shape.set('line', line);
	        features.push(shape);
	        features.push(line);
	    });
	    layer.getSource().addFeatures(features);
	}

	function makeShape(params, pointData, floatCoord) {
	    var _floatCoord = util.gcjTransform3857(floatCoord);
	    var shape = new ol.Feature(
	        new ol.geom.Point(_floatCoord)
	    );

	    var fontSize = pointData.fontSize ? pointData.fontSize : '16px';
	    var fontFamily = pointData.fontFamily ? pointData.fontFamily : 'serif';
	    var font = fontSize + ' ' + fontFamily;

	    var outLineRadius = pointData.radius ? pointData.radius : 39;
	    outLineRadius += pointData.strokeWidth ? pointData.strokeWidth : 4;
	    shape.setStyle([
	        new ol.style.Style({
	            image: new ol.style.Circle({
	                radius: outLineRadius,
	                fill: new ol.style.Fill({
	                    color: pointData.fillColor || '#FF8870'
	                })
	            })
	        }),
	        new ol.style.Style({
	            image: new ol.style.Circle({
	                radius: pointData.radius || 35,
	                fill: new ol.style.Fill({
	                    color: pointData.fillColor || '#FF8870'
	                }),
	                stroke: new ol.style.Stroke({
	                    color: pointData.strokeColor || '#FFFFFF',
	                    width: pointData.strokeWidth || 4
	                })
	            }),
	            text: new ol.style.Text({
	                font: font,
	                text: pointData.content,
	                fill: new ol.style.Fill({
	                    color: pointData.fontColor || '#000000'
	                })
	            })
	        })
	    ]);
	    shape.set('data', pointData);
	    shape.set('sourceLayerId', params.sourceLayerId);
	    shape.set('type', 'infoPop_shape');
	    shape.setId(pointData.id);
	    return shape;
	}

	function makeLine(params, pointData, origin, floatCoord) {
	    var _floatCoord = util.gcjTransform3857(floatCoord);
	    var coordinates = getLineCoordinates(origin, _floatCoord);
	    var lineFeature = new ol.Feature(
	        new ol.geom.LineString(coordinates)
	    );
	    lineFeature.setStyle(new ol.style.Style({
	        stroke: new ol.style.Stroke({
	            color: pointData.lineColor || '#0099ff',
	            width: pointData.lineWidth || 2
	        })
	    }));
	    lineFeature.set('data', pointData);
	    lineFeature.set('sourceLayerId', params.sourceLayerId);
	    lineFeature.set('type', 'infoPop_line');
	    lineFeature.setId('line\u9999' + pointData.id);
	    return lineFeature;
	}

	function getLineCoordinates(source, target) {
	    var coordinates = [source, target];
	    if (source[0] !== target[1] && source[1] !== target[1]) {
	        coordinates.splice(1, 0, [source[0], target[1]]);
	    }
	    return coordinates;
	}

	function getInteraction(params, olMap) {
	    var drag = olUtil.getIntactByName(params.mapId, 'infoPopDrag');
	    if (drag) {
	        return drag;
	    }
	    drag = new Drag();
	    drag.set('mapId', params.mapId);
	    drag.set('name', 'infoPopDrag');
	    olMap.addInteraction(drag);
	    return drag;

	}

	/**
	 * @constructor
	 * @extends {ol.interaction.Pointer}
	 */
	function Drag() {

	    ol.interaction.Pointer.call(this, {
	        handleDownEvent: Drag.prototype.handleDownEvent,
	        handleDragEvent: Drag.prototype.handleDragEvent,
	        handleMoveEvent: Drag.prototype.handleMoveEvent,
	        handleUpEvent: Drag.prototype.handleUpEvent
	    });

	    /**
	     * @type {ol.Pixel}
	     * @private
	     */
	    this.coordinate_ = null;

	    /**
	     * @type {string|undefined}
	     * @private
	     */
	    this.cursor_ = 'pointer';

	    /**
	     * @type {ol.Feature}
	     * @private
	     */
	    this.feature_ = null;

	    /**
	     * @type {string|undefined}
	     * @private
	     */
	    this.previousCursor_ = undefined;

	    /**
	     * on drag handle
	     * @type {null}
	     */
	    this.onDrag = null;

	}

	ol.inherits(Drag, ol.interaction.Pointer);

	/**
	 * @param {ol.MapBrowserEvent} evt Map browser event.
	 * @return {boolean} `true` to start the drag sequence.
	 */
	Drag.prototype.handleDownEvent = function (evt) {
	    var map = evt.map;

	    var feature = map.forEachFeatureAtPixel(evt.pixel,
	        function (feature) {
	            if (feature.get('type') === 'infoPop_shape') {
	                return feature;
	            }
	        });

	    if (feature) {
	        this.coordinate_ = evt.coordinate;
	        this.feature_ = feature;
	    }

	    return !!feature;
	};

	/**
	 * @param {ol.MapBrowserEvent} evt Map browser event.
	 */
	Drag.prototype.handleDragEvent = function (evt) {
	    var deltaX = evt.coordinate[0] - this.coordinate_[0];
	    var deltaY = evt.coordinate[1] - this.coordinate_[1];

	    var geometry = /** @type {ol.geom.SimpleGeometry} */
	        (this.feature_.getGeometry());
	    geometry.translate(deltaX, deltaY);

	    this.coordinate_[0] = evt.coordinate[0];
	    this.coordinate_[1] = evt.coordinate[1];
	    if (this.onDrag) {
	        this.onDrag(evt, this.feature_);
	    }
	};

	/**
	 * @param {ol.MapBrowserEvent} evt Event.
	 */
	Drag.prototype.handleMoveEvent = function (evt) {
	    if (this.cursor_) {
	        var map = evt.map;
	        var feature = map.forEachFeatureAtPixel(evt.pixel,
	            function (feature) {
	                if (feature.get('type') === 'infoPop_shape') {
	                    return feature;
	                }
	            });
	        var element = evt.map.getTargetElement();
	        if (feature) {
	            if (element.style.cursor !== this.cursor_) {
	                this.previousCursor_ = element.style.cursor;
	                element.style.cursor = this.cursor_;
	            }
	        }
	        else if (this.previousCursor_ !== undefined) {
	            element.style.cursor = this.previousCursor_;
	            this.previousCursor_ = undefined;
	        }
	    }
	};

	/**
	 * @return {boolean} `false` to stop the drag sequence.
	 */
	Drag.prototype.handleUpEvent = function () {
	    this.coordinate_ = null;
	    this.feature_ = null;
	    return false;
	};

	module.exports = {
	    addInfoPop: addInfoPop
	};

/***/ },
/* 81 */
/*!***************************************!*\
  !*** ./src/gis/layers/imageFilter.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	var utils = __webpack_require__(/*! utils/util */ 1);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var googleMap = __webpack_require__(/*! maps/googleMap */ 24);

	function setImageFilter(paramsObj) {
	    var filterType = paramsObj.filterType;
	    var mapId = paramsObj.mapId;
	    var layerId = paramsObj.layerId;
	    var rateR = paramsObj.rateR;
	    var rateG = paramsObj.rateG;
	    var rateB = paramsObj.rateB;
	    var isCustom = paramsObj.isCustom;
	    var layerRenderEnd = paramsObj.layerRenderEnd;

	    var layer = olUtil.getLayer({
	        mapId: mapId,
	        layer_id: layerId
	    });

	    if (!layer || !filterType) {
	        return;
	    }

	    var filterHandle = layer.get('imageFilter.handle');
	    if (filterHandle) {
	        layer.unByKey(filterHandle);
	    }
	    filterHandle = layer.on('postcompose', function (event) {
	        if (!!imageFilters[filterType]) {
	            imageFilters[filterType](event.context, rateR, rateG, rateB, isCustom);
	        }
	        if (!!layerRenderEnd && typeof layerRenderEnd === 'function') {
	            layerRenderEnd(event.context);
	        }
	    });

	    layer.set('imageFilter.handle', filterHandle);
	    layer.set('imageFilter.type', filterType);

	    if (!!paramsObj.multiple) {
	        layer.set('multiple', paramsObj.multiple);
	    }

	    if (paramsObj.layerId !== constant.MAPPROPERTY.BASE_LAYER_ID) {
	        return;
	    }

	    var olMap = mapBox.getMapObj(paramsObj.mapId);
	    var params = olMap.get('paramObj');
	    if (params.mapType === constant.MAPTYPE.GOOGLE_MAP) {
	        googleMap.setImageFilter(paramsObj);
	    }
	}

	function removeImageFilter(paramsObj) {
	    var layer = olUtil.getLayer({
	        mapId: paramsObj.mapId,
	        layer_id: paramsObj.layerId
	    });
	    if (!layer) {
	        return;
	    }

	    var filterHandle = layer.get('imageFilter.handle');
	    if (filterHandle) {
	        layer.unByKey(filterHandle);
	        layer.unset('imageFilter.handle');
	        layer.unset('imageFilter.type');
	    }

	    if (paramsObj.layerId !== constant.MAPPROPERTY.BASE_LAYER_ID) {
	        return;
	    }

	    var olMap = mapBox.getMapObj(paramsObj.mapId);
	    var params = olMap.get('paramObj');
	    if (params.mapType === constant.MAPTYPE.GOOGLE_MAP) {
	        googleMap.removeImageFilter(paramsObj);
	    }
	}

	function getImageFilter(paramsObj) {
	    var layer = olUtil.getLayer({
	        mapId: paramsObj.mapId,
	        layer_id: paramsObj.layerId
	    });
	    if (!layer) {
	        return;
	    }

	    return layer.get('imageFilter.type');
	}

	var imageFilters = {
	    gray: grayFilter,
	    blue: blueFilter,
	    pink: pinkFilter,
	    teal: tealFilter,
	    green: greenFilter,
	    yellow: yellowFilter,
	    black: blackFilter,
	    g20: g20Filter
	};

	/**
	 * 设置地图
	 * @param context
	 */
	function grayFilter(context, undefined, undefined, undefined, isCustom) {
	    if (!isCustom) {
	        var canvas = context.canvas;
	        var width = canvas.width;
	        var height = canvas.height;

	        var imageData = context.getImageData(0, 0, width, height);
	        var pix = imageData.data;
	        for (var i = 0, n = pix.length; i < n; i += 4) {
	            pix[i + 0] = pix[i + 1] = pix[i + 2] = (3 * pix[i + 0] + 4 * pix[i + 1] + pix[i + 2]) / 8;
	        }
	        context.putImageData(imageData, 0, 0);
	    }
	}

	/**
	 * 设置地图
	 * @param context
	 */
	function blueFilter(context, rateR, rateG, rageB, isCustom) {
	    if (!isCustom) {
	        var canvas = context.canvas;
	        var width = canvas.width;
	        var height = canvas.height;

	        var _rateR = 0.01;
	        var _rateG = 0.01;
	        var _rageB = 0.7;
	        if (!!rateR) {
	            _rateR = rateR;
	        }
	        if (rateR === 0) {
	            _rateR = rateR;
	        }

	        if (!!rateG) {
	            _rateG = rateG;
	        }
	        if (rateG === 0) {
	            _rateG = rateG;
	        }

	        if (!!rageB) {
	            _rageB = rageB;
	        }
	        if (rageB === 0) {
	            _rageB = rageB;
	        }

	        var imageData = context.getImageData(0, 0, width, height);
	        var pix = imageData.data;
	        for (var i = 0, n = pix.length; i < n; i += 4) {
	            var r = pix[i + 0];
	            var g = pix[i + 1];
	            var b = pix[i + 2];
	            // CIE luminance for the RGB
	            var v = _rateR * r + _rateG * g + _rageB * b;
	            pix[i + 0] = 255 - v; // Red
	            pix[i + 1] = 255 - v; // Green
	            pix[i + 2] = v; // Blue
	            pix[i + 3] = 255; // Alpha
	        }
	        context.putImageData(imageData, 0, 0);
	    }
	}

	/**
	 * 设置地图
	 * @param context
	 */
	function pinkFilter(context, rateR, rateG, rageB, isCustom) {
	    if (!isCustom) {
	        var canvas = context.canvas;
	        var width = canvas.width;
	        var height = canvas.height;

	        var _rateR = 0.02;
	        var _rateG = 0.215;
	        var _rageB = 0.545;
	        if (!!rateR) {
	            _rateR = rateR;
	        }
	        if (rateR === 0) {
	            _rateR = rateR;
	        }

	        if (!!rateG) {
	            _rateG = rateG;
	        }
	        if (rateG === 0) {
	            _rateG = rateG;
	        }

	        if (!!rageB) {
	            _rageB = rageB;
	        }
	        if (rageB === 0) {
	            _rageB = rageB;
	        }

	        var imageData = context.getImageData(0, 0, width, height);
	        var pix = imageData.data;
	        for (var i = 0, n = pix.length; i < n; i += 4) {
	            var r = pix[i + 0];
	            var g = pix[i + 1];
	            var b = pix[i + 2];
	            // CIE luminance for the RGB
	            var v = _rateR * r + _rateG * g + _rageB * b;
	            pix[i + 0] = v; // Red
	            pix[i + 1] = 255 - v; // Green
	            pix[i + 2] = v; // Blue
	            pix[i + 3] = 255; // Alpha
	        }
	        context.putImageData(imageData, 0, 0);
	    }
	}

	/**
	 * 设置地图
	 * @param context
	 */
	function tealFilter(context, rateR, rateG, rageB, isCustom) {
	    if (!isCustom) {
	        var canvas = context.canvas;
	        var width = canvas.width;
	        var height = canvas.height;

	        var _rateR = 0.02;
	        var _rateG = 0.215;
	        var _rageB = 0.545;
	        if (!!rateR) {
	            _rateR = rateR;
	        }
	        if (rateR === 0) {
	            _rateR = rateR;
	        }

	        if (!!rateG) {
	            _rateG = rateG;
	        }
	        if (rateG === 0) {
	            _rateG = rateG;
	        }

	        if (!!rageB) {
	            _rageB = rageB;
	        }
	        if (rageB === 0) {
	            _rageB = rageB;
	        }

	        var imageData = context.getImageData(0, 0, width, height);
	        var pix = imageData.data;
	        for (var i = 0, n = pix.length; i < n; i += 4) {
	            var r = pix[i + 0];
	            var g = pix[i + 1];
	            var b = pix[i + 2];
	            // CIE luminance for the RGB
	            var v = _rateR * r + _rateG * g + _rageB * b;
	            pix[i + 0] = 255 - v; // Red
	            pix[i + 1] = v; // Green
	            pix[i + 2] = v; // Blue
	            pix[i + 3] = 255; // Alpha
	        }
	        context.putImageData(imageData, 0, 0);
	    }
	}

	/**
	 * 设置地图
	 * @param context
	 */
	function greenFilter(context, rateR, rateG, rageB, isCustom) {
	    if (!isCustom) {
	        var canvas = context.canvas;
	        var width = canvas.width;
	        var height = canvas.height;

	        var _rateR = 0.02;
	        var _rateG = 0.215;
	        var _rageB = 0.545;
	        if (!!rateR) {
	            _rateR = rateR;
	        }
	        if (rateR === 0) {
	            _rateR = rateR;
	        }

	        if (!!rateG) {
	            _rateG = rateG;
	        }
	        if (rateG === 0) {
	            _rateG = rateG;
	        }

	        if (!!rageB) {
	            _rageB = rageB;
	        }
	        if (rageB === 0) {
	            _rageB = rageB;
	        }

	        var imageData = context.getImageData(0, 0, width, height);
	        var pix = imageData.data;
	        for (var i = 0, n = pix.length; i < n; i += 4) {
	            var r = pix[i + 0];
	            var g = pix[i + 1];
	            var b = pix[i + 2];
	            // CIE luminance for the RGB
	            var v = _rateR * r + _rateG * g + _rageB * b;
	            pix[i + 0] = 255 - v; // Red
	            pix[i + 1] = v; // Green
	            pix[i + 2] = 255 - v; // Blue
	            pix[i + 3] = 255; // Alpha
	        }
	        context.putImageData(imageData, 0, 0);
	    }
	}

	/**
	 * 设置地图
	 * @param context
	 */
	function yellowFilter(context, rateR, rateG, rageB, isCustom) {
	    if (!isCustom) {
	        var canvas = context.canvas;
	        var width = canvas.width;
	        var height = canvas.height;

	        var _rateR = 0.02;
	        var _rateG = 0.215;
	        var _rageB = 0.545;
	        if (!!rateR) {
	            _rateR = rateR;
	        }
	        if (rateR === 0) {
	            _rateR = rateR;
	        }

	        if (!!rateG) {
	            _rateG = rateG;
	        }
	        if (rateG === 0) {
	            _rateG = rateG;
	        }

	        if (!!rageB) {
	            _rageB = rageB;
	        }
	        if (rageB === 0) {
	            _rageB = rageB;
	        }

	        var imageData = context.getImageData(0, 0, width, height);
	        var pix = imageData.data;
	        for (var i = 0, n = pix.length; i < n; i += 4) {
	            var r = pix[i + 0];
	            var g = pix[i + 1];
	            var b = pix[i + 2];
	            // CIE luminance for the RGB
	            var v = _rateR * r + _rateG * g + _rageB * b;
	            pix[i + 0] = v; // Red
	            pix[i + 1] = v; // Green
	            pix[i + 2] = 255 - v; // Blue
	            pix[i + 3] = 255; // Alpha
	        }
	        context.putImageData(imageData, 0, 0);
	    }
	}

	/**
	 * 设置地图
	 * @param context
	 */
	function blackFilter(context, rateR, rateG, rageB, isCustom) {
	    if (!isCustom) {
	        var _rateR = 0.02;
	        var _rateG = 0.215;
	        var _rageB = 0.545;
	        if (!!rateR) {
	            _rateR = rateR;
	        }
	        if (rateR === 0) {
	            _rateR = rateR;
	        }

	        if (!!rateG) {
	            _rateG = rateG;
	        }
	        if (rateG === 0) {
	            _rateG = rateG;
	        }

	        if (!!rageB) {
	            _rageB = rageB;
	        }
	        if (rageB === 0) {
	            _rageB = rageB;
	        }
	        var canvas = context.canvas;
	        var width = canvas.width;
	        var height = canvas.height;

	        var imageData = context.getImageData(0, 0, width, height);
	        var pix = imageData.data;
	        for (var i = 0, n = pix.length; i < n; i += 4) {
	            var r = pix[i + 0];
	            var g = pix[i + 1];
	            var b = pix[i + 2];
	            // CIE luminance for the RGB
	            var v = _rateR * r + _rateG * g + _rageB * b;
	            pix[i + 0] = 255 - v/* - 80*/; // Red
	            pix[i + 1] = 255 - v/* + 40*/; // Green
	            pix[i + 2] = 255 - v/* + 180*/; // Blue
	            pix[i + 3] = 255; // Alpha
	        }
	        context.putImageData(imageData, 0, 0);
	    }

	}

	var isPrintedLog = false;
	function g20Filter(context, rateR, rateG, rageB, isCustom) {
	    if (!isCustom) {
	        var canvas = context.canvas;
	        var width = canvas.width;
	        var height = canvas.height;

	        var imageData = context.getImageData(0, 0, width, height);
	        var pix = imageData.data;
	        for (var i = 0, n = pix.length; i < n; i += 4) {
	            var r = pix[i + 0];
	            var g = pix[i + 1];
	            var b = pix[i + 2];
	            // CIE luminance for the RGB
	            var v = (255 - r) + (255 - g) + (255 - b);
	            pix[i + 0] = v / 3; // Red
	            pix[i + 1] = v / 3; // Green
	            pix[i + 2] = 120; // Blue
	            pix[i + 3] = 255; // Alpha
	        }
	        context.putImageData(imageData, 0, 0);
	    }

	    var html = '自定滤镜算法参考如下:\n' +
	        '/***************************************************************************\n' +
	        '*  var canvas = context.canvas;\n' +
	        '*  var width = canvas.width;\n' +
	        '*  var height = canvas.height;\n' +
	        '*  var imageData = context.getImageData(0, 0, width, height);\n' +
	        '*  var pix = imageData.data;\n' +
	        '*  for (var i = 0, n = pix.length; i < n; i += 4) {\n' +
	        '*      var r = pix[i + 0];\n' +
	        '*      var g = pix[i + 1];\n' +
	        '*      var b = pix[i + 2];\n' +
	        '*      var v = (255 - r) + (255 - g) + (255 - b);\n' +
	        '*      pix[i + 0] = v / 3; // Red\n' +
	        '*      pix[i + 1] = v / 3; // Green\n' +
	        '*      pix[i + 2] = 120; // Blue\n' +
	        '*      pix[i + 3] = 255; // Alpha\n' +
	        '*  }\n' +
	        '*  context.putImageData(imageData, 0, 0);\n' +
	        '***************************************************************************/';
	    if (isPrintedLog === false) {
	        console.log('%c ' + html, 'color:blue;font-size:14px;');
	    }
	    isPrintedLog = true;
	}

	module.exports = {
	    setImageFilter: setImageFilter,
	    removeImageFilter: removeImageFilter,
	    getImageFilter: getImageFilter
	};

/***/ },
/* 82 */
/*!********************************!*\
  !*** ./src/gis/layers/line.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 连线
	 */
	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var promise = __webpack_require__(/*! utils/promise */ 83);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var bLayer = __webpack_require__(/*! businessLayers/bLayer */ 40);
	var events = __webpack_require__(/*! maps/event */ 11);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var highlights =__webpack_require__(/*! layers/highlight */ 43);

	/**
	 *
	 * @param paramObj
	 * mapId: {},
	 * sourceLayerId:
	 * targetLayerId:
	 * sourceLayerType:
	 * targetLayerType:
	 *
	 * @returns {ol.layer.Layer|undefined|*}
	 */
	function getLineLayer(paramObj) {
	    var olMap = mapBox.getMapObj(paramObj.mapId);
	    var _lineLayerId = paramObj.sourceLayerId + '-' + paramObj.targetLayerId;
	    var lineLayer = olUtil.getLayer({
	        mapId: paramObj.mapId,
	        layerId: _lineLayerId
	    });
	    if (!lineLayer) {
	        lineLayer = new ol.layer.Vector({
	            source: new ol.source.Vector({
	                wrapX: false
	            })
	        });
	        lineLayer.set('mapId', paramObj.mapId);
	        var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.VECTORLINE;
	        lineLayer.setZIndex(_ZIndex);//图层顺序
	        lineLayer.set('layerId', _lineLayerId);
	        //新添加的属性
	        lineLayer.set('layer_id', _lineLayerId);//最后再测

	        lineLayer.set('sourceLayerId', paramObj.sourceLayerId);
	        lineLayer.set('sourceLayerType', paramObj.sourceLayerType);
	        lineLayer.set('targetLayerId', paramObj.targetLayerId);
	        lineLayer.set('targetLayerType', paramObj.targetLayerType);

	        lineLayer.set('businessType', constant.BUSINESSTYPE.LINE);

	        olMap.addLayer(lineLayer);
	    }
	    if (paramObj.minShowLevel != undefined) {
	        lineLayer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        lineLayer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));
	    }
	    return lineLayer;
	}

	function drawLine(paramObj) {
	    //判断业务图层是否存在，不存在不连线
	    var sourceLayer = layers.getLayer({
	        mapId: paramObj.mapId,
	        layerId: paramObj.sourceLayerId
	    });
	    var targetLayer = layers.getLayer({
	        mapId: paramObj.mapId,
	        layerId: paramObj.targetLayerId
	    });
	    if (!sourceLayer || !targetLayer) {
	        return;
	    }
	    var lineLayer = getLineLayer(paramObj);
	    layers.addEffectLayer({
	        layer: sourceLayer,
	        effectLayer: lineLayer
	    });

	    layers.addEffectLayer({
	        layer: targetLayer,
	        effectLayer: lineLayer
	    });

	    paramObj.datas.forEach(function(lineData) {
	        drawSingleLine(paramObj, lineLayer, lineData);
	    });

	    //增加缩放事件监听
	    var _layerId = paramObj.sourceLayerId + '-' + paramObj.targetLayerId;

	    var setNewCoordinate = function(paramObj) {
	        var olMap = mapBox.getMapObj(paramObj.mapId);
	        var layers = olMap.getLayers().getArray();

	        var lineLayer = utils.find(layers, function(layerObj) {
	            if (layerObj && layerObj.get('layerId') === _layerId) {
	                return layerObj;
	            }
	        });
	        if(!!!lineLayer) {
	        	return;
	        }

	        if(!!!lineLayer.getSource()) {
	        	return;
	        }

	        var hLineLayer = highlights.getHLayer({
	        	mapId: paramObj.mapId,
	        	layerId: lineLayer.get('layer_id')
	        });

	        var highLineFeatures = null;

	        if(hLineLayer) {
	        	highLineFeatures = hLineLayer.getSource().getFeatures();
	        }

	        var lineFeatures = lineLayer.getSource().getFeatures();

	        var setRightLonlat = function(lineFeature, arrowFeature) {
	        	var lineGeom = lineFeature.getGeometry();
	        	var arrowGeom = arrowFeature.getGeometry();
	        	var lineLngLat = lineFeature.get('coordinates'); //连线的坐标
	            var mapId = lineFeature.get('mapId');
	        	var realLngLat = calculateLngLat(lineLngLat[0], lineLngLat[1], mapId);

	        	lineGeom.setCoordinates([lineLngLat[0], realLngLat]);
	        	arrowGeom.setCoordinates(realLngLat);
	        };

	        !!lineFeatures && lineFeatures.forEach(function(featureItem) {
	       			var arrow = featureItem.get('arrow');
	       			//判断这个feature是否有箭头
	       			if(arrow) {
	       				setTimeout(function() {
	       					setRightLonlat(featureItem, arrow);
	       				}, 500);
	       			}
	       	});

	        		//处理高亮的连线和箭头
	        !!highLineFeatures && highLineFeatures.forEach(function(highLineFea) {
	        	var highRowFea = highLineFea.get('arrow');
	        	if(highRowFea) {
	        		setTimeout(function() {
	        			setRightLonlat(highLineFea, highRowFea);
	        		}, 500);
	        	}
	        });



	    };
	    events.onZoomChange({
	        mapId: paramObj.mapId,
	        id: _layerId,
	        callbackfunc: setNewCoordinate
	    });
	}

	function drawSingleLine(paramObj, lineLayer, lineData) {
	    /*  if (paramObj.targetLayerType === 'POLYGON') {// POLYGON是源图层不应该是目标图层
	          return;
	      }*/
	    var lineLayerFeatures = [];
	    getTargetPoint(lineData, paramObj).then(function(targetPoint) {
	        if (targetPoint instanceof Array && targetPoint.length > 0) {
	            targetPoint.forEach(function(point, index) {
	                var _targetPoint = utils.gcjTransform(point.centerPoint);  //point.extentInfo.circleCenter SEP数据，Dis数据结构未知
	                if (!!_targetPoint) {
	                    getSourcePoint(lineData, paramObj, _targetPoint).then(function(sourcePoint) {
	                        var featureGeoIds = {
	                            lineId: !!lineData && !!lineData.geoId ? lineData.geoId
	                                + '_line_' + index : 'line_' + index,
	                            arrowId: !!lineData && !!lineData.geoId ? lineData.geoId
	                                + '_arrow_' + index : 'arrow_' + index
	                        }
	                        var _sourcePoint = utils.gcjTransform(sourcePoint);
	                        var features = getLineFeatures(_sourcePoint, _targetPoint, lineData, paramObj, featureGeoIds);
	                        lineLayerFeatures = lineLayerFeatures.concat(features);
	                        //lineLayer.getSource().addFeatures(features);
	                    });
	                }
	            })
	        }
	        lineLayer.getSource().clear();
	        lineLayer.getSource().addFeatures(lineLayerFeatures);
	    });

	}

	function getSourcePoint(lineData, paramObj, targetPoint) {
	    var deferred = promise.defer();
	    if (lineData.sourceLngLat) {
	        var point = [Number(lineData.sourceLngLat[0]), Number(lineData.sourceLngLat[1])];
	        deferred.resolve(point);
	        return deferred.promise;
	    }
	    if (lineData.sourceGeoId||paramObj.coordinates) {
	        var handler = bLayer.getBsHandler(paramObj.sourceLayerType);//获取图层类型
	        var params = {
	            mapId: paramObj.mapId,
	            layerId: paramObj.sourceLayerId,
	            layerType: paramObj.sourceLayerType,
	            geoId: lineData.sourceGeoId,
	            targetPoint: targetPoint,
	            coordinates: paramObj.coordinates
	        };
	        if (!handler) {
	            return;
	        }
	        handler.getLineLonLat(params, function(lonlat) {
	            if (lonlat) {
	                deferred.resolve(lonlat);
	            }
	            else {
	                deferred.reject(lonlat);
	            }
	        });
	        return deferred.promise;
	    }
	}

	function getTargetPoint(lineData, paramObj) {
	    var deferred = promise.defer();
	    if (lineData.targetLngLat) {
	        var point = [
	            Number(lineData.targetLngLat[0]),
	            Number(lineData.targetLngLat[1])
	        ];
	        var _point = utils.gcjTransform(point);
	        deferred.resolve(_point);
	        return deferred.promise;
	    }
	    if (lineData.targetGeoId) {
	        var handler = bLayer.getBsHandler(constant.BUSINESSTYPE.CELL);//获取图层类型
	        var params = {
	            mapId: paramObj.mapId,
	            layerId: paramObj.targetLayerId,
	            layerType: paramObj.targetLayerType,
	            geoId: lineData.targetGeoId
	        };
	        if (!handler) {
	            return;
	        }
	        handler.getLineLonLat(params, function(lonlat) {
	            if (lonlat) {
	                deferred.resolve(lonlat);
	            }
	            else {
	                deferred.reject(lonlat);
	            }
	        });
	        return deferred.promise;
	    }

	}

	function getLineFeatures(sourcePoint, targetPoint, lineData, paramObj, geoId) {
	    var _sourcePoint = ol.proj.fromLonLat(sourcePoint);
	    var _targetPoint = ol.proj.fromLonLat(targetPoint);
	    var lineFeatures = [], lineDash;
	    if (paramObj.lineType) {
	        lineDash = paramObj.lineType[0] === 1 ? [0] : [paramObj.lineType[0]];//虚线OR实线
	    }
	    else {
	        lineDash = [0];
	    }
	    var feature = new ol.Feature({
	        geometry: new ol.geom.LineString([_sourcePoint, _targetPoint]),
	        businessType: constant.BUSINESSTYPE.LINE,
	        mapId: paramObj.mapId
	    });
	    var _style = new ol.style.Style({
	        fill: new ol.style.Fill({
	            color: lineData.fillColor ? lineData.fillColor : '#000'
	        }),
	        stroke: new ol.style.Stroke({
	            color: lineData.strokeColor ? lineData.strokeColor : '#000',
	            width: lineData.strokeWidth ? lineData.strokeWidth : 1,
	            lineDash: lineDash
	        })
	    });

	    feature.setStyle(_style);
	    feature.setId(geoId.lineId);
	    feature.set('mapId',paramObj.mapId);
	    feature.set('sourceGeoId', lineData.sourceGeoId);//源对象ID
	    feature.set('targetGeoId', lineData.targetGeoId);//目标对象ID
	    feature.set('coordinates', [_sourcePoint, _targetPoint]);//连线坐标
	    lineFeatures.push(feature);

	    if (paramObj.isArrow) {
	        var arrowFeature = getLineArrow(lineData, sourcePoint, targetPoint, paramObj.mapId, feature, geoId.arrowId);
	        arrowFeature.set('mapId',paramObj.mapId);
	        feature.set('arrow', arrowFeature);
	        lineFeatures.push(arrowFeature);
	    }
	    return lineFeatures;

	}

	//计算箭头位置
	function calculateLngLat(sourcePoint, targetPoint, mapId) {
	    var olMap = mapBox.getMapObj(mapId);
	    var startPixel = olMap.getPixelFromCoordinate(sourcePoint);
	    var endPixel = olMap.getPixelFromCoordinate(targetPoint);
	    var xStart = startPixel[0];
	    var yStart = startPixel[1];
	    var xEnd = endPixel[0];
	    var yEnd = endPixel[1];
	    var awayFromTop = 7;

	    var increaseX = (xEnd - xStart >= 0) ? -1 : 1;
	    var increaseY = (yEnd - yStart >= 0) ? -1 : 1;
	    var angle = Math.atan2(yEnd - yStart, xEnd - xStart);
	    var xCenter = xEnd + increaseX * awayFromTop * Math.abs(Math.cos(angle));
	    var yCenter = yEnd + increaseY * awayFromTop * Math.abs(Math.sin(angle));

	    return olMap.getCoordinateFromPixel([xCenter, yCenter]);
	}

	function calculateRotation(sourcePoint, targetPoint) {
	    var dx = targetPoint[0] - sourcePoint[0];
	    var dy = targetPoint[1] - sourcePoint[1];
	    return -Math.atan2(dy, dx) + Math.PI / 2;
	}

	//箭头方案1 ： ol.styel.Icon
	function getLineArrow(param, sourcePoint, targetPoint, mapId, feature, geoId) {
	    var rotation = calculateRotation(sourcePoint, targetPoint);//计算箭头角度
	    var realLngLat = calculateLngLat(ol.proj.fromLonLat(sourcePoint), ol.proj.fromLonLat(targetPoint), mapId);//修改箭头位置往后移
	    feature.getGeometry().setCoordinates([ol.proj.fromLonLat(sourcePoint), realLngLat]);//带箭头的连线需要缩短
	    var arrow = new ol.Feature({
	        geometry: new ol.geom.Point(realLngLat)
	    });
	    arrow.setStyle(new ol.style.Style({
	        image: new ol.style.RegularShape({
	            fill: new ol.style.Fill({
	                color: param.strokeColor || '#000000'
	            }),
	            stroke: new ol.style.Stroke({
	                color: param.strokeColor || '#000000',
	                width: param.strokeWidth || 1
	            }),
	            points: 3,
	            radius: 8,
	            rotation: rotation,
	            angle: 0
	        })
	    }));
	    arrow.setId(geoId);
	    arrow.set('coordinates', realLngLat);
	    return arrow;
	}

	function removeLine(paramObj) {
	    var lineLayerId = paramObj.sourceLayerId + '-' + paramObj.targetLayerId;
	    var lineLayer = olUtil.getLayer({mapId: paramObj.mapId, layerId: lineLayerId});
	    if (lineLayer) {
	        lineLayer.getSource().clear();
	    }
	}

	module.exports = {
	    drawLine: drawLine,
	    removeLine: removeLine
	};

/***/ },
/* 83 */
/*!**********************************!*\
  !*** ./src/gis/utils/promise.js ***!
  \**********************************/
/***/ function(module, exports) {

	"use strict";
	var PROMISE_STATE = {};
	PROMISE_STATE.RESOLVED = 'resolved';
	PROMISE_STATE.REJECTED = 'rejected';
	PROMISE_STATE.WAITING = 'waiting';

	function Promise() {
	    this.state_ = PROMISE_STATE.WAITING;
	    this.callbacks = {};
	    this.results = {};
	    this.done = false;
	}

	Promise.prototype.resolve = function (result) {
	    if (this.done) {
	        return;
	    }
	    this.done = true;
	    this.state_ = PROMISE_STATE.RESOLVED;
	    this.results.resolved = result;
	    this.next_();
	};
	Promise.prototype.reject = function (result) {
	    if (this.done) {
	        return;
	    }
	    this.done = true;
	    this.state_ = PROMISE_STATE.REJECTED;
	    this.results.rejected = result;
	    this.next_();
	};
	Promise.prototype.then = function (fullfillFunc, failedFunc) {
	    if (fullfillFunc) {
	        this.callbacks.onResovled = fullfillFunc;
	    }
	    if (failedFunc) {
	        this.callbacks.onRejected = failedFunc;
	    }
	    if (!this.nextPromise) {
	        this.nextPromise = new Promise();
	    }
	    this.next_();
	    return this.nextPromise;
	};
	Promise.prototype.next_ = function () {
	    if (!this.nextPromise) {
	        this.nextPromise = new Promise();
	    }
	    if (this.state_ === PROMISE_STATE.RESOLVED && this.callbacks.onResovled) {
	        this.callbacks.onResovled(this.results.resolved, this.nextPromise);
	    }
	    if (this.state_ === PROMISE_STATE.REJECTED && this.callbacks.onRejected) {
	        this.callbacks.onRejected(this.results.rejected, this.nextPromise);
	    }
	};
	Promise.prototype.each = function (list, callback) {
	    var self = this;
	    var completeCount = 0;
	    var ll = list.length;
	    var results = new Array(ll);
	    var fullfillResults = [];
	    var failedResults = [];

	    function iterator(v, k, eachPromise) {
	        eachPromise.then(function (result) {
	            completeCount++;
	            results[k] = result;
	            fullfillResults.push(result);
	            if (completeCount === ll) {
	                self.resolve(fullfillResults);
	            }
	        }, function (result) {
	            completeCount++;
	            results[k] = result;
	            failedResults.push(result);
	            if (completeCount === ll) {
	                self.resolve(fullfillResults);
	            }
	        });
	        callback(v, k, eachPromise);
	    }

	    if (ll === 0) {
	        self.resolve(fullfillResults);
	    }
	    else {
	        for (var i = 0; i < ll; i++) {
	            var eachPromise = new Promise();
	            iterator(list[i], i, eachPromise);
	        }
	    }

	    return this;
	};

	function defer() {
	    var promise = new Promise();
	    return {
	        promise: promise,
	        resolve: function (result) {
	            promise.resolve(result);
	        },
	        reject: function (result) {
	            promise.reject(result);
	        },
	        each: function (list, callback) {
	            return promise.each(list, callback);
	        }
	    };
	}

	module.exports = {
	    defer: defer
	};

/***/ },
/* 84 */
/*!****************************************!*\
  !*** ./src/gis/layers/layerManager.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	var domUtil = __webpack_require__(/*! utils/domUtil */ 10);
	var eventTool = __webpack_require__(/*! utils/eventTool */ 62);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var utils = __webpack_require__(/*! utils/util */ 1);

	/**
	 * 图层管理器
	 * @param paramObj
	 */
	function layerManager(paramObj) {
	    this.gisLayerMgrId = 'gis_layer_manager_id_';
	    this.mapId = paramObj.mapId;
	    this.isShow = paramObj.isShow;
	    var _attributes = paramObj.attributes || {};

	    var _layerMgrModuleId = this.gisLayerMgrId + this.mapId; ///图层管理器唯一ID
	    _attributes.id = _layerMgrModuleId;
	    if (!_attributes.hasOwnProperty('class')) {
	        _attributes['class'] = 'gis_layer_manager';
	    }

	    var _layerMgrBox = domUtil.createDom({
	        tagName: 'div',
	        attributes: _attributes
	    });
	    ///创建新图层管理器之前，删除之前已有的节点
	    if (domUtil.getDom(_layerMgrModuleId)) {
	        domUtil.getDom(this.mapId).removeChild(domUtil.getDom(_layerMgrModuleId));
	    }
	    domUtil.getDom(this.mapId).appendChild(_layerMgrBox);

	    ///图层管理器开关
	    var _layerSwitchDiv = _createLayerSwitch(this.mapId, _layerMgrModuleId);
	    _layerMgrBox.appendChild(_layerSwitchDiv);

	    ///图层管理器图层列表
	    var _layerMgrContent = _createLayerMgrList(_layerMgrBox, this.mapId);
	    _layerMgrBox.appendChild(_layerMgrContent);

	    if (!this.isShow) {
	        var layerMgrBoxParentNode = domUtil.getDom(this.gisLayerMgrId + this.mapId);
	        domUtil.getDom(this.mapId).removeChild(layerMgrBoxParentNode);
	    }
	}

	/**
	 * 构造图层管理器开关
	 * @param mapId
	 * @param _layerMgrModuleId
	 * @returns {*|!Element}
	 * @private
	 */
	function _createLayerSwitch(mapId, _layerMgrModuleId) {
	    var _layerSwitchDiv = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            class: 'switcher'
	        },
	        text: '+'
	    });

	    ///图层管理器隐藏展开
	    var _isShow = function () {
	        var _layerMgrBox = domUtil.getDom(_layerMgrModuleId);
	        if (!_layerMgrBox) {
	            return;
	        }

	        if (_layerSwitchDiv.innerText === '+') {
	            ///展开图层管理器之前，更新图层信息
	            var _layerMgrContent = _createLayerMgrList(_layerMgrBox, mapId);

	            _layerMgrBox.appendChild(_layerMgrContent);

	            _layerMgrBox.lastChild.style.display = 'block';
	            _layerSwitchDiv.innerText = '-';
	        }
	        else {
	            _layerMgrBox.lastChild.style.display = 'none';
	            _layerSwitchDiv.innerText = '+';
	        }
	    };
	    eventTool.add(_layerSwitchDiv, 'click', _isShow);

	    return _layerSwitchDiv;
	}

	/**
	 * 构造构建图层列表
	 * @returns {*|!HTMLElement}
	 * @private
	 */
	function _createLayerMgrList(_layerMgrBox, mapId) {
	    var _layerList;
	    if (document.querySelector('.gis_layer_manager > .layer_list')) {
	        _layerList = document.querySelector('.gis_layer_manager > .layer_list');
	        _layerMgrBox.removeChild(_layerList);
	    }

	    _layerList = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            class: 'layer_list'
	        }
	    });

	    if (!hashMap.isEmpty()) {
	        hashMap.keys.forEach(function (layerId) {
	            if (layerId && utils.endsWith(layerId, '_' + mapId)) {
	                var _layerItem = domUtil.createDom({
	                    tagName: 'div',
	                    attributes: {
	                        class: 'layer'
	                    }
	                });
	                _layerList.appendChild(_layerItem);

	                /**************************************************checkbox*************************************************/
	                var _controller = domUtil.createDom({
	                    tagName: 'div',
	                    attributes: {
	                        class: 'controller'
	                    }
	                });

	                var _checkbox = domUtil.createDom({
	                    tagName: 'input',
	                    attributes: {
	                        type: 'checkbox',
	                        class: 'checkbox',
	                        name: 'layer_name',
	                        checked: true
	                    }
	                });
	                _controller.appendChild(_checkbox);
	                _layerItem.appendChild(_controller);
	                /**************************************************checkbox*************************************************/


	                ///图层名称 or 图层ID
	                var _underLineIndex = layerId.lastIndexOf('_');
	                var _layerName = layerId.substring(0, _underLineIndex);

	                /**************************************************layer name*************************************************/
	                var _layerId = domUtil.createDom({
	                    tagName: 'div',
	                    attributes: {
	                        class: 'layer_name',
	                        title: _layerName
	                    },
	                    text: _layerName.length > 25 ? _layerName.substring(0, 25) : _layerName
	                });
	                _layerItem.appendChild(_layerId);
	                /**************************************************layer name*************************************************/

	                /**************************************************调整图层垂直高度按钮*************************************************/
	                var btnBox = domUtil.createDom({
	                    tagName: 'div',
	                    attributes: {
	                        class: 'z_index_btn_box'
	                    }
	                });

	                var btnUp = domUtil.createDom({
	                    tagName: 'div',
	                    attributes: {
	                        class: 'btn'
	                    }
	                });

	                var btnDown = domUtil.createDom({
	                    tagName: 'div',
	                    attributes: {
	                        class: 'btn'
	                    }
	                });

	                btnBox.appendChild(btnUp);
	                btnBox.appendChild(btnDown);
	                _layerItem.appendChild(btnBox);
	                /**************************************************调整图层垂直高度按钮*************************************************/


	                ///图层隐藏显示
	                var _isShowLayer = function (e) {
	                    if (e.target.checked) {
	                        baseLayer.setVisible({
	                            mapId: mapId,
	                            layerIds: [_layerName],
	                            isShow: true
	                        });
	                    }
	                    else {
	                        baseLayer.setVisible({
	                            mapId: mapId,
	                            layerIds: [_layerName],
	                            isShow: false
	                        });
	                    }
	                };
	                eventTool.add(_checkbox, 'click', _isShowLayer);

	                var defaultZIndex = 0;
	                var mapObj = mapBox.getMapObj(mapId);
	                var num = mapObj.getLayers().getLength();

	                var setLayerZIndex = function (zIndex) {
	                    baseLayer.setLayerZIndex({
	                        mapId: mapId,
	                        layerId: layerId.substring(0, layerId.lastIndexOf('_')),
	                        zIndex: zIndex
	                    });
	                };

	                eventTool.add(btnUp, 'click', function () {
	                    if (defaultZIndex !== num) {
	                        defaultZIndex = defaultZIndex + 1;
	                    }
	                    setLayerZIndex(defaultZIndex);
	                });

	                eventTool.add(btnDown, 'click', function () {
	                    defaultZIndex = defaultZIndex - 1;
	                    setLayerZIndex(defaultZIndex);
	                });
	            }
	        });
	    }

	    return _layerList;
	}

	module.exports = {
	    layerManager: layerManager
	};



/***/ },
/* 85 */
/*!***************************************!*\
  !*** ./src/gis/layers/legendRange.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var util = __webpack_require__(/*! utils/util */ 1);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var maps = __webpack_require__(/*! maps/map */ 8);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var domUtil = __webpack_require__(/*! utils/domUtil */ 10);

	var _globalSource = null;
	var _globalFeatures = [];

	var addFeature = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId;
	    var _layer = null;

	    if (hashMap.containsKey(_layerId)) {
	        _layer = hashMap.get(_layerId);
	    }
	    else {
	        baseLayer.createLayer(paramObj);
	        _layer = hashMap.get(_layerId);
	    }
	    _globalSource = _layer.getSource();

	    setLayerData(paramObj);
	};

	var setLayerData = function (paramObj) {
	    var _features = [];
	    var _datas = paramObj.datas;
	    var _currentExtent = maps.getExtent(paramObj.mapId);

	    if (util.isValid(_datas) || _datas.length > 0) {
	        _datas.forEach(function (data) {
	            var _coordinate = ol.proj.fromLonLat(util.gcjTransform(data.coordinate));

	//          if (!ol.extent.containsCoordinate(_currentExtent, _coordinate)) {
	//              return;
	//          }

	            var _point = new ol.geom.Point(_coordinate);
	            var _feature = new ol.Feature({
	                geometry: _point,
	                businessType: constant.BUSINESSTYPE.LEGEND_RANGE,
	                data: data
	            });
	            _feature.setId(data.id);
	            _feature.set('legendVal', data.legendVal);

	            var _style = new ol.style.Style({
	                image: new ol.style.Circle({
	                    radius: data.radius ? data.radius : 5,
	                    fill: new ol.style.Fill({
	                        color: data.fillColor ? data.fillColor : 'red'
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color: data.strokeColor ? data.strokeColor : '#319FD3',
	                        width: data.strokeWidth ? data.strokeWidth : 1
	                    })
	                })
	            });
	            _feature.setStyle(_style);
	            _feature.set('foreverStyle', _style);
	            _feature.set('radius', data.radius ? data.radius : 5);
	            _feature.set('strokeWidth', data.strokeWidth ? data.strokeWidth : 1);

	            _features.push(_feature);

	        });
	        _globalSource.addFeatures(_features);
	        _globalFeatures = _features;
	    }

	    createLegend(paramObj);
	};

	/**
	 * 构造图例
	 * @param legendData
	 *
	 * legendData = [{
	 *   color: ##
	 *   text: ##
	 *   val: ##
	 * }]
	 */
	var createLegend = function (paramObj) {
	    var _legendData = paramObj.legendData;
	    var _mapId = paramObj.mapId;
	    var util = domUtil;

	    ///图例顶层box
	    var _legendBox = null;
	    var _legendContainer = util.getDom(_mapId).getElementsByClassName('layer_legend_container_for_one_map');
	    ///如果当前地图对象的DIV中，图例节点存在的话，就获取此节点使用，如果不存在，就创建一个节点，并将创建的节点追加到当前地图的DIV节点中
	    if (_legendContainer && _legendContainer.length > 0) {
	        _legendBox = _legendContainer[0];
	    }
	    else {
	        _legendBox = util.createDom({
	            tagName: 'div',
	            attributes: {
	                class: 'layer_legend_container_for_one_map'
	            }
	        });
	        util.getDom(_mapId).appendChild(_legendBox);
	    }

	    ///create one legend box
	    var _oneLegendBox = util.createDom({
	        tagName: 'div',
	        attributes: {
	            class: 'one_legend_range__box_one_layer'
	        }
	    });
	    if (!document.querySelector('.layer_legend_container_for_one_map').hasChildNodes('measure-close-legend')) {
	        var _closeButton = util.createDom({
	            tagName: 'div',
	            attributes: {
	                id: 'closeEvent',
	                class: 'measure-close-legend'
	            }
	        });
	        _legendBox.insertBefore(_closeButton, _legendBox.childNodes[0]);
	        //为_closeButton注册关闭事件
	        _closeButton.onclick = function () {
	            _legendBox.style.display = 'none';
	            util.getDom(_mapId).removeChild(_legendBox);
	        };
	    }
	    if (_legendBox.querySelector('.one_legend_range__box_one_layer')) {
	        _legendBox.removeChild(_legendBox.querySelector('.one_legend_range__box_one_layer'));
	    }
	    _legendBox.appendChild(_oneLegendBox);

	    _legendData.forEach(function (legend) {
	        var _oneLegendLine = util.createDom({
	            tagName: 'div',
	            attributes: {
	                class: 'one_legend_line'
	            }
	        });
	        _oneLegendLine.style.cursor = 'pointer';
	        _oneLegendLine.id = legend.val;
	        _oneLegendBox.appendChild(_oneLegendLine);

	        _oneLegendLine.onclick = function () {
	            var _legend = _oneLegendLine.getAttribute('id').split(','); ///指标值
	            _globalFeatures.forEach(function (feature) {
	                var _featureLegend = feature.get('legendVal');
	                if (parseFloat(_legend[0]) <= _featureLegend &&
	                    _featureLegend < parseFloat(_legend[1])) {
	                    if (feature.get('opacity') === 0) {
	                        feature.set('opacity', 1);
	                        feature.setStyle(feature.get('foreverStyle'));

	                        _oneLegendLine.style.borderLeftWidth = 0 + 'px';

	                        _oneLegendLine.childNodes[0].style.backgroundColor = _oneLegendLine.childNodes[0].id;
	                    }
	                    else {
	                        feature.set('opacity', 0);

	                        var _style = new ol.style.Style({
	                            image: new ol.style.Circle({
	                                radius: feature.get('radius'),
	                                fill: new ol.style.Fill({
	                                    color: 'gray'
	                                }),
	                                stroke: new ol.style.Stroke({
	                                    color: 'gray',
	                                    width: feature.get('strokeWidth')
	                                })
	                            })
	                        });
	                        feature.setStyle(_style);

	                        _oneLegendLine.style.borderLeftWidth = 2 + 'px';
	                        _oneLegendLine.style.borderLeftStyle = 'solid';
	                        _oneLegendLine.style.borderLeftColor = '#00BFFF';

	                        _oneLegendLine.childNodes[0].style.backgroundColor = 'gray';
	                    }
	                }
	            });
	        };

	        var _colorNode = util.createDom({
	            tagName: 'div'
	        });
	        _colorNode.style.width = 8 + 'px';
	        _colorNode.style.height = 8 + 'px';
	        _colorNode.style.marginTop = 9 + 'px';
	        _colorNode.style.marginLeft = 10 + 'px';
	        _colorNode.style.marginRight = 10 + 'px';
	        _colorNode.style.backgroundColor = legend.color;
	        _colorNode.style.borderRadius = 100 + 'px';
	        _colorNode.style.webkitBorderRadius = 100 + 'px';
	        _colorNode.style.mozBorderRadius = 100 + 'px';
	        _colorNode.id = legend.color;
	        _oneLegendLine.appendChild(_colorNode);

	        var _titleNode = util.createDom({
	            tagName: 'div'
	        });
	        _titleNode.innerHTML = legend.title ? legend.title : legend.text;
	        _oneLegendLine.appendChild(_titleNode);
	    });
	};

	module.exports = {
	    addFeature: addFeature,
	    setLayerData: setLayerData,
	    createLegend: createLegend
	};

/***/ },
/* 86 */
/*!****************************************!*\
  !*** ./src/gis/layers/legendSlider.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var maps = __webpack_require__(/*! maps/map */ 8);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var domUtil = __webpack_require__(/*! utils/domUtil */ 10);

	var _globalSource = null;
	var _globalFeatures = [];

	var addFeature = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId;
	    var _layer = null;

	    if (hashMap.containsKey(_layerId)) {
	        _layer = hashMap.get(_layerId);
	    }
	    else {
	        baseLayer.createLayer(paramObj);
	        _layer = hashMap.get(_layerId);
	    }
	    _globalSource = _layer.getSource();

	    setLayerData(paramObj);
	};

	/**
	 *
	 * @param paramObj
	 *
	 * paramObj = {
	 *   legendData: [{
	 *       color: ##
	 *       text: ##
	 *       val: ##
	 *   }...],
	 *   datas: [
	 *    {
	 *        coordinate: [x, y],
	 *        fillColor: ##,
	 *        strokeColor: ##,
	 *        strokeWidth: ##,
	 *        radius: ##,
	 *        legendVal: ##
	 *    }
	 *   ]
	 *
	 * }
	 */
	var setLayerData = function (paramObj) {
	    var _features = [];
	    var _datas = paramObj.datas;
	    var _currentExtent = maps.getExtent(paramObj.mapId);

	    if (utils.isValid(_datas) || _datas.length > 0) {
	        _datas.forEach(function (data) {
	            var _coordinate = ol.proj.fromLonLat(utils.gcjTransform(data.coordinate));

	//          if (!ol.extent.containsCoordinate(_currentExtent, _coordinate)) {
	//              return;
	//          }

	            var _point = new ol.geom.Point(_coordinate);
	            var _feature = new ol.Feature({
	                geometry: _point,
	                businessType: constant.BUSINESSTYPE.LEGEND_SLIDER,
	                data: data
	            });
	            _feature.setId(data.id);
	            _feature.set('legendVal', data.legendVal);

	            var _style = new ol.style.Style({
	                image: new ol.style.Circle({
	                    radius: data.radius ? data.radius : 5,
	                    fill: new ol.style.Fill({
	                        color: data.fillColor ? data.fillColor : 'red'
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color: data.strokeColor ? data.strokeColor : '#319FD3',
	                        width: data.strokeWidth ? data.strokeWidth : 1
	                    })
	                })
	            });
	            _feature.setStyle(_style);
	            _feature.set('foreverStyle', _style);
	            _feature.set('radius', data.radius ? data.radius : 5);
	            _feature.set('strokeWidth', data.strokeWidth ? data.strokeWidth : 1);

	            _features.push(_feature);

	        });
	        _globalSource.addFeatures(_features);
	        _globalFeatures = _features;
	    }

	    createLegendSlider(paramObj);
	};

	/**
	 * 构造图例
	 * @param legendData
	 *
	 * legendData = [{
	  *   color: ##
	  *   text: ##
	  *   val: ##
	  * }]
	 */
	var createLegendSlider = function (paramObj) {
	    var _legendData = paramObj.legendData;
	    var _mapId = paramObj.mapId;
	    var util = domUtil;
	    var _browerTyep = utils.getBrowserType();

	    ///图例顶层box
	    var _legendBox = null;
	    var _legendContainer = util.getDom(_mapId).getElementsByClassName('layer_legend_container_for_one_map');
	    if (_legendContainer && _legendContainer.length > 0) {
	        ///如果当前地图对象的DIV中，图例节点存在的话，就获取此节点使用
	        _legendBox = _legendContainer[0];
	    }
	    else {
	        ///如果不存在，就创建一个节点，并将创建的节点追加到当前地图的DIV节点中
	        _legendBox = util.createDom({
	            tagName: 'div',
	            attributes: {
	                class: 'layer_legend_container_for_one_map'
	            }
	        });
	        util.getDom(_mapId).insertBefore(_legendBox, util.getDom(_mapId).childNodes[0]);
	    }

	    ///滑动图例模块
	    var _oneLegendBox = util.createDom({
	        tagName: 'div',
	        attributes: {
	            class: 'one_legend_box_one_layer_slider'
	        }
	    });
	    if (!document.querySelector('.layer_legend_container_for_one_map').hasChildNodes('measure-close-legend')) {
	        var _closeButton = util.createDom({
	            tagName: 'div',
	            attributes: {
	                id: 'closeEvent',
	                class: 'measure-close-legend'
	            }
	        });
	        _legendBox.insertBefore(_closeButton, _legendBox.childNodes[0]);
	        _closeButton.onclick = function () {
	            _legendBox.style.display = 'none';
	            util.getDom(_mapId).removeChild(_legendBox);
	        };
	    }

	    if (_legendBox.querySelector('.one_legend_box_one_layer_slider')) {
	        _legendBox.removeChild(_legendBox.querySelector('.one_legend_box_one_layer_slider'));
	    }
	    _legendBox.appendChild(_oneLegendBox);

	    ///下面创建三个div，来布局div.left、div.color、div.right
	    /*******************************Left***********************************************************************/
	    var _sliderDivLeftClass = '';
	    var _sliderDivRightClass = '';
	    if (_browerTyep.webkit) {
	        ///chrome
	        _sliderDivLeftClass = 'slider_left_chrome';
	        _sliderDivRightClass = 'slider_right_chrome';
	    }
	    else if (_browerTyep.mozilla) {
	        ///firefox
	        _sliderDivLeftClass = 'slider_left_Firefox';
	        _sliderDivRightClass = 'slider_right_Firefox';
	    }
	    else if (_browerTyep.msie) {
	        ///IE
	        _sliderDivLeftClass = 'slider_left_MsIE';
	        _sliderDivRightClass = 'slider_right_MsIE';
	    }
	    var _sliderDivLeft = util.createDom({
	        tagName: 'div',
	        attributes: {
	            class: _sliderDivLeftClass
	        }
	    });
	    _oneLegendBox.appendChild(_sliderDivLeft);

	    var _sliderInputLeft = util.createDom({
	        tagName: 'input',
	        attributes: {
	            type: 'range',
	            step: 1,
	            min: 1,
	            max: paramObj.legendData.length,
	            value: 1,
	            zIndex: 2
	        }
	    });
	    _sliderInputLeft.title = 1;
	    _sliderDivLeft.appendChild(_sliderInputLeft);

	    /**
	     * 修饰区间指标状态
	     * @private
	     */
	    var _decBetweenFeature = function (paramObj) {
	        var _inputLeftVal = paramObj.inputLeftVal;
	        var _inputRightVal = paramObj.inputRightVal;
	        _globalFeatures.forEach(function (feature) {
	            var _featureLegend = feature.get('legendVal');
	            if (_inputLeftVal <= _featureLegend && _featureLegend <= _inputRightVal) {
	                feature.setStyle(feature.get('foreverStyle'));
	            }
	            else {
	                var _style = new ol.style.Style({
	                    image: new ol.style.Circle({
	                        radius: feature.get('radius'),
	                        fill: new ol.style.Fill({
	                            color: 'gray'
	                        }),
	                        stroke: new ol.style.Stroke({
	                            color: 'gray',
	                            width: feature.get('strokeWidth')
	                        })
	                    })
	                });
	                feature.setStyle(_style);
	            }
	        });
	    };

	    /**
	     * 单点指标
	     * @param currentVal {Integer} 某一点的指标值
	     * @private
	     */
	    var _decorationFeature = function (currentVal) {
	        _globalFeatures.forEach(function (feature) {
	            if (feature.get('legendVal') === currentVal) {
	                feature.setStyle(feature.get('foreverStyle'));
	            }
	            else if (feature.get('legendVal') !== currentVal) {
	                var _style = new ol.style.Style({
	                    image: new ol.style.Circle({
	                        radius: feature.get('radius'),
	                        fill: new ol.style.Fill({
	                            color: 'gray'
	                        }),
	                        stroke: new ol.style.Stroke({
	                            color: 'gray',
	                            width: feature.get('strokeWidth')
	                        })
	                    })
	                });
	                feature.setStyle(_style);
	            }
	        });
	    };

	    /**
	     * 装饰color div background color
	     * @param paramObj
	     * @private
	     */
	    var _decorationColorDivBack = function (paramObj) {
	        var _sliderInputColor = paramObj.sliderInputColor;
	        if (_sliderInputColor.children) {
	            for (var i = 0, len = _sliderInputColor.children.length; i < len; i++) {
	                var _colorDiv = _sliderInputColor.children[i];
	                _colorDiv.style.backgroundColor = _colorDiv.title;
	                if (i === paramObj.legendVal - 1) {
	                    continue;
	                }
	                _colorDiv.style.backgroundColor = 'gray';
	            }
	        }
	    };

	    var _decorationBetweenColorDivBack = function (paramObj) {
	        var _sliderInputColor = paramObj.sliderInputColor;
	        if (_sliderInputColor.children) {
	            for (var i = 0, len = _sliderInputColor.children.length; i < len; i++) {
	                var _colorDiv = _sliderInputColor.children[i];
	                _colorDiv.style.backgroundColor = _colorDiv.title;
	                if (i >= paramObj.legendVal[0] - 1 && i <= paramObj.legendVal[1] - 1) {
	                    continue;
	                }
	                _colorDiv.style.backgroundColor = 'gray';
	            }
	        }
	    };

	    _sliderInputLeft.onchange = function () {
	        var _inputLeftVal = parseFloat(this.value);
	        var _inputRightVal = parseFloat(_sliderInputRight.value);
	        this.title = _inputLeftVal;

	        if (_inputLeftVal >= _inputRightVal) {
	            //当右边值小于左边值时，需要进行单点指标显示
	            _sliderInputRight.value = _inputLeftVal;
	            _inputRightVal = _inputLeftVal;

	            _decorationFeature(_inputLeftVal);

	            //装饰color div背景色
	            _decorationColorDivBack({
	                sliderInputColor: _sliderInputColor,
	                legendVal: _inputLeftVal
	            });
	        }
	        else if (_inputLeftVal < _inputRightVal) {
	            //区间指标场景
	            _decBetweenFeature({
	                inputLeftVal: _inputLeftVal,
	                inputRightVal: _inputRightVal
	            });

	            _decorationBetweenColorDivBack({
	                sliderInputColor: _sliderInputColor,
	                legendVal: [_inputLeftVal, _inputRightVal]
	            });
	        }

	        util.getDom('.legend_label_div_class')[0].innerHTML = _inputLeftVal + ' ~ ' +
	            _inputRightVal;
	    };
	    /********************************Left**********************************************************************/

	    /********************************Color**********************************************************************/
	    var _sliderInputColor = util.createDom({
	        tagName: 'div',
	        attributes: {
	            class: 'slider_color'
	        }
	    });
	    _oneLegendBox.appendChild(_sliderInputColor);
	    paramObj.legendData.forEach(function (legend) {
	        var _colorDiv = util.createDom({
	            tagName: 'div',
	            attributes: {
	                title: legend.color
	            }
	        });

	        var _divH = (255 / paramObj.legendData.length);
	        _colorDiv.style.backgroundColor = legend.color;
	        _colorDiv.style.height = _divH + 'px';
	        _colorDiv.style.width = 100 + '%';
	        _sliderInputColor.appendChild(_colorDiv);
	    });
	    /********************************Color**********************************************************************/

	    /*******************************************Right***********************************************************/
	    var _sliderDivRight = util.createDom({
	        tagName: 'div',
	        attributes: {
	            class: _sliderDivRightClass
	        }
	    });
	    _oneLegendBox.appendChild(_sliderDivRight);

	    var _sliderInputRight = util.createDom({
	        tagName: 'input',
	        attributes: {
	            type: 'range',
	            step: 1,
	            min: 1,
	            max: paramObj.legendData.length,
	            value: paramObj.legendData.length,
	            zIndex: 2
	        }
	    });
	    _sliderInputRight.title = paramObj.legendData.length;
	    _sliderDivRight.appendChild(_sliderInputRight);

	    _sliderInputRight.onchange = function () {
	        var _inputRightVal = parseFloat(this.value);
	        var _inputLeftVal = parseFloat(_sliderInputLeft.value);
	        this.title = _inputRightVal;

	        if (_inputRightVal <= _inputLeftVal) {
	            _sliderInputLeft.value = _inputRightVal;
	            _inputLeftVal = _inputRightVal;

	            _decorationFeature(_inputRightVal);

	            _decorationColorDivBack({
	                sliderInputColor: _sliderInputColor,
	                legendVal: _inputRightVal
	            });
	        }
	        else if (_inputRightVal > _inputLeftVal) {
	            _decBetweenFeature({
	                inputLeftVal: _inputLeftVal,
	                inputRightVal: _inputRightVal
	            });

	            _decorationBetweenColorDivBack({
	                sliderInputColor: _sliderInputColor,
	                legendVal: [_inputLeftVal, _inputRightVal]
	            });
	        }

	        util.getDom('.legend_label_div_class')[0].innerHTML = _inputLeftVal + ' ~ ' +
	            _inputRightVal;
	    };
	    /*******************************************Right***********************************************************/

	    /*******************************************Legend Label*****************************************************/
	    var _legendLabel = util.createDom({
	        tagName: 'div',
	        attributes: {
	            class: 'legend_label_div_class'
	        },
	        text: parseFloat(_sliderInputLeft.value) + ' ~ ' + parseFloat(_sliderInputRight.value)
	    });
	    _oneLegendBox.appendChild(_legendLabel);

	    var _legendLabelLow = util.createDom({
	        tagName: 'div',
	        attributes: {
	            class: 'legend_label_low_div_class'
	        },
	        text: 'Low'
	    });
	    _oneLegendBox.appendChild(_legendLabelLow);

	    var _legendLabelHigh = util.createDom({
	        tagName: 'div',
	        attributes: {
	            class: 'legend_label_high_div_class'
	        },
	        text: 'High'
	    });
	    _oneLegendBox.appendChild(_legendLabelHigh);

	    /*******************************************Legend Label*****************************************************/
	};

	module.exports = {
	    addFeature: addFeature,
	    setLayerData: setLayerData
	};

/***/ },
/* 87 */
/*!****************************************!*\
  !*** ./src/gis/layers/pointCluster.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var point = __webpack_require__(/*! businessLayers/point */ 42);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);

	var map = new Map();
	map.set('refreshLayerManager_key', []);

	var addLayer = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId;
	    var _layer = null;
	    var _clusterStyle = paramObj.clusterStyle || {};
	    var strokeColor = _clusterStyle.strokeColor || '#aaaaaa';
	    var fillColor = _clusterStyle.fillColor || '#3399cc';
	    var strokeWidth = _clusterStyle.strokeWidth !== undefined ? _clusterStyle.strokeWidth: 1;
	    if(strokeWidth === 0){
	        strokeColor = fillColor;
	    }
	    var fontColor = _clusterStyle.fontColor ||'#ffffff';
	    var _radius = _clusterStyle.radius || 20;
	    var distance = _clusterStyle.distance || 50;
	    var isShow = paramObj.isShow != undefined ? paramObj.isShow : true;
	    var _label = paramObj.label?paramObj.label:paramObj.layerId;
	    if(strokeWidth < 0){
	        console.warn('strokeWidth 必须大于等于0');
	        return;
	    }
	    if(_radius <= 0){
	        console.warn('radius 必须大于0');
	        return;
	    }
	    if(distance <= 0){
	        console.warn('distance 必须大于0');
	        return;
	    }
	    if(paramObj.isClusterVariableSize === undefined){
	        paramObj.isClusterVariableSize = false;
	    }

	    paramObj.distance = distance;
	    var _clusterStyleFunc = function (feature, resolution) {
	        var _features = feature.get('features');
	        var _size = _features.length;
	        if (_size > 1) {
	            var radius = 0;
	            if(paramObj.isClusterVariableSize){
	                radius = _radius+_size;
	            }else{
	                radius = _radius;
	            }
	            return [
	                new ol.style.Style({
	                    image: new ol.style.Circle({
	                        radius: radius,
	                        fill: new ol.style.Fill({
	                            color: fillColor
	                        }),
	                        stroke: new ol.style.Stroke({
	                            color: strokeColor,
	                            width: strokeWidth
	                        })
	                    }),
	                    text: new ol.style.Text({
	                        text: _size.toString(),
	                        fill: new ol.style.Fill({
	                            color: fontColor
	                        })
	                    })
	                })
	            ];
	        }else{
	            var pro = _features[0].get('property');
	            return [
	                new ol.style.Style({
	                    image: new ol.style.Circle({
	                        radius: pro.radius,
	                        fill: new ol.style.Fill({
	                            color: pro.fillColor
	                        }),
	                        stroke: new ol.style.Stroke({
	                            color: pro.strokeColor,
	                            width: pro.strokeWidth
	                        })
	                    }),
	                    text: new ol.style.Text({
	                        // text: _size.toString(),
	                        fill: new ol.style.Fill({
	                            color: fontColor
	                        })
	                    })
	                })
	            ];
	        }
	    };
	    if (hashMap.containsKey(_layerId)) {
	        _layer = hashMap.get(_layerId);
	    }
	    else {
	        baseLayer.createLayer(paramObj);
	        _layer = hashMap.get(_layerId);
	    }
	    var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.SITE;
	    _layer.setZIndex(_ZIndex);
	    _layer.setStyle(_clusterStyleFunc);
	    _layer.set('type', constant.CUSTOMTYPE.LAYERIMGTYPE);
	    _layer.set('businessType', 'POINTCLUSTER');
	    _layer.set('params.label', _label);
	    _layer.set('isVectorType',true);
	    _layer.set('state.showLabel', !!paramObj.showLabel);
	    _layer.set('layerId', paramObj.layerId);
	    _layer.set('layer_id', paramObj.layerId);
	    _layer.set('legendName', paramObj.legendName);
	    _layer.set('isShow', isShow);
	    _layer.set('mapId', paramObj.mapId);
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	    }

	    if (!!paramObj.isHightlight) {
	        fusiongis.Events.addClickCallback(paramObj.mapId, 'point-cluster-click-event', function(obj) {
	            if (obj.layer && obj.layer.get('businessType') === 'POINTCLUSTER' && obj.feature
	                && obj.feature.get('businessType') === constant.BUSINESSTYPE.POINTER_CLUSTER) {
	                highlights.removeHighlight({
	                    mapId: paramObj.mapId,
	                    layerId: paramObj.layerId,
	                    hTypes: ['click']
	                });
	                var HLayer = highlights.getHLayer({mapId:paramObj.mapId,layerId:paramObj.layerId});
	                if(!!HLayer && !HLayer.getVisible()){
	                    HLayer.setVisible(true);
	                }
	                var _feature = obj.feature;
	                point.highlight(obj.layer, 'click', {mapId: paramObj.mapId, layerId: paramObj.layerId, feature: _feature});
	                var _mapObj = mapBox.getMapObj(obj.mapId);
	                _mapObj && _mapObj.on('moveend', function(e) {
	                    var mapId = e.map.getTarget();
	                    var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	                    var highlights = __webpack_require__(/*! layers/highlight */ 43);
	                    var bLayer = __webpack_require__(/*! businessLayers/bLayer */ 40);
	                    var targetLayerId = '';
	                    var featureId, sourceLayer;
	                    hashMap.keys.forEach(function(layerId) {
	                        var _layer = hashMap.get(layerId);
	                        if (!!_layer) {
	                            var _bussinessType = _layer.get('businessType');
	                            var _targetLayerId = _layer.get('mapId');
	                            if (!!_targetLayerId && _targetLayerId === mapId
	                                && _bussinessType === 'POINTCLUSTER') {
	                                targetLayerId = _layer.get('layerId');
	                                sourceLayer = _layer;
	                            }
	                        }
	                    })
	                    var HLayer = highlights.getHLayer({
	                        mapId : mapId,
	                        layerId : targetLayerId
	                    });
	                    var features = HLayer.getSource().getFeatures();
	                    if (features instanceof Array && features.length > 0) {
	                        featureId = features[0].get('$index');
	                    }
	                    var sourceFeatures = sourceLayer.getSource().getFeatures();
	                    var isClusterFlag = false;
	                    if (sourceFeatures instanceof Array && sourceFeatures.length > 0) {
	                        sourceFeatures.forEach(function(feature) {
	                            var _features = feature.get('features');
	                            if (_features instanceof Array && _features.length > 1) {
	                                _features.forEach(function(featureItem) {
	                                    var _featureId = featureItem.get('$index');
	                                    if (_featureId === featureId) {
	                                        isClusterFlag = true;
	                                    }
	                                })
	                            }
	                        })
	                    }
	                    HLayer.setVisible(!isClusterFlag);

	                })
	            }
	        }, paramObj.layerId)
	    }
	};

	var setLayerData = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId;
	    var _data = paramObj.datas;
	    var _layer = hashMap.get(_layerId);
	    var _source = null;
	    var isCluster = paramObj.isCluster === undefined? true:paramObj.isCluster;
	    if(_layer){
	        _layer.set('legendName', paramObj.legendName);
	        if (paramObj.label) {
	            _layer.set('params.label', paramObj.label);
	        }
	        _source = isCluster === true ? _layer.getSource().getSource() : _layer.getSource();
	    }
	    if(paramObj.isCluster) {
			_layer.set('isCluster', paramObj.isCluster);
		}

	    if (utils.isValid(_data) || _data.length > 0) {
	        var _features = [];
	        _data.forEach(function(oneRecord, index) {
	            var _coordinate = ol.proj.fromLonLat(utils.gcjTransform(oneRecord.coordinate));
	            var _feature = new ol.Feature({
	                geometry: new ol.geom.Point(_coordinate),
	                property: {
	                    fillColor: oneRecord.fillColor,
	                    strokeColor: oneRecord.strokeColor,
	                    strokeWidth: oneRecord.strokeWidth,
	                    radius: oneRecord.radius || 5
	                },
	                data: oneRecord,
	                businessType: constant.BUSINESSTYPE.POINTER_CLUSTER
	            });
	            _feature.setId(oneRecord.id);
	            _feature.set('id', oneRecord.id);
	            _feature.set('data', oneRecord);
	            _feature.set('vectorType', constant.BUSINESSTYPE.POINTER_CLUSTER);
	            _feature.set('layer', _layer);
	            _feature.set('$index', '$' + index);
	            var hightlightStyle = {
	                radius: oneRecord.radius || 5,
	                fillColor: oneRecord.highlight !== undefined ?
	                    oneRecord.highlight.fillColor !== undefined ?
	                        oneRecord.highlight.fillColor :
	                        oneRecord.fillColor : oneRecord.fillColor,
	                strokeColor: oneRecord.highlight !== undefined ?
	                    oneRecord.highlight.strokeColor !== undefined ?
	                        oneRecord.highlight.strokeColor : 'black' : 'black',
	                strokeWidth: oneRecord.highlight !== undefined ?
	                    oneRecord.highlight.strokeWidth !== undefined ?
	                        oneRecord.highlight.strokeWidth : 1 : 1,
	            }
	            _feature.set('select', hightlightStyle);
	            _features.push(_feature);

	        });
	        if(_source){
	            _source.addFeatures(_features);
	        }
	    }


	    if (map.get('refreshLayerManager_key').length < 10) {
	        var layer = new ol.layer.Vector();
	        mapBox.getMapObj(paramObj.mapId).addLayer(layer);
	        map.get('refreshLayerManager_key').push(layer);
	    }
	    else {
	        var _layers = map.get('refreshLayerManager_key');
	        if (!!_layers && _layers.length > 0) {
	            _layers.forEach(function(v, i) {
	                mapBox.getMapObj(paramObj.mapId).removeLayer(v);
	                map.get('refreshLayerManager_key').splice(i, 1);
	            });
	        }
	    }
	};

	module.exports = {
	    addLayer: addLayer,
	    setLayerData:setLayerData
	};


/***/ },
/* 88 */
/*!*********************************!*\
  !*** ./src/gis/layers/radar.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var util = __webpack_require__(/*! utils/util */ 1);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var math = __webpack_require__(/*! framework/algorithm */ 48);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);

	var _createLayer = function (paramObj) {
	    var _layer = null;
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId;
	    var _mapObj = mapBox.getMapObj(_mapId);
	    var paramForGet = {
	        mapId: _mapId,
	        layerId: _layerId
	    };
	    if (!olUtil.getLayer(paramForGet)) {
	        _layer = new ol.layer.Vector();
	        _layer.set('type', constant.CUSTOMTYPE.LAYERIMGTYPE);
	        _layer.set('map', _mapObj);
	        _layer.set('layerId', _layerId);

	        _mapObj.addLayer(_layer);
	    }
	    else {
	        _layer = olUtil.getLayer(paramForGet);
	    }
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	    }
	    if(paramObj.zindex !== undefined){
	        _layer.setZIndex(paramObj.zindex);
	    }
	    return _layer;
	};

	/**
	 * 绘制雷达图，
	 * @param paramObj
	 * paramObj = {
	 * mapId:{String} 地图唯一标识
	 * datas: [
	 *   {
	 *       coordinate: {Array<x, y>} 坐标
	 *       angel:{int} 夹角
	 *       azimuth:{int}方位角
	 *       radius:{int} 半径
	 *       fillColor:{String} 填充色,当前没有添加默认填充色和边线颜色，必须有此参数
	 *       strokeColor:{String} 边线颜色
	 *       opacity:{float}透明度
	 *    },
	 *         ……
	 *]
	 * */
	function arrChange(arr) {//数组翻转函数
	    var arrLength = arr.length;
	    var newArr = [];
	    for (var i = arrLength - 1; i >= 0; i--) {
	        newArr.push(arr[i]);
	    }
	    return newArr;
	}

	function sourceAddFeature(data) {//source构建函数
	    var features = [];
	    var concatArr = [data[0].coordinate];
	    for (var i = 0; i < data.length; i++) {
	        var coordinate =util.gcjTransform(data[i].coordinate);
	        var angel = data[i].angel;
	        var azimuth = data[i].azimuth;
	        var radius = data[i].radius;
	        var fillColor = data[i].fillColor;
	        var strokeColor = data[i].strokeColor;
	        var alpha = data[i].opacity;

	        //构造polygon数据
	        var dateArr = math.createSector(coordinate[0], coordinate[1], radius, azimuth, angel);
	        var dateArrWithoutCenterPoint = dateArr.slice(0, dateArr.length - 2);
	        var finalConcatArr = arrChange(concatArr);
	        var polygonPointArr = dateArrWithoutCenterPoint.concat(finalConcatArr);
	        concatArr = dateArrWithoutCenterPoint;

	        //坐标系转换
	        var coordinates3857 = [];
	        polygonPointArr.forEach(function (coordinate) {
	            var newCoordinate = ol.proj.transform(coordinate, constant.PROJ.EPSG_4326, constant.PROJ.EPSG_3857);
	            coordinates3857.push(newCoordinate);
	        });

	        var polygon = new ol.geom.Polygon([coordinates3857]);
	        var feature = new ol.Feature({
	            geometry: polygon
	        });
	        //设置样式
	        var colorStr = fillColor.substring(0, fillColor.length - 1);
	        var ColorWithAlpha = "rgba" + colorStr + "," + alpha + ")";
	        var stroke = "rgb" + strokeColor;
	        var style = new ol.style.Style({
	            fill: new ol.style.Fill({
	                color: ColorWithAlpha
	            }),
	            stroke: new ol.style.Stroke({
	                color: stroke,
	                width: 1
	            })
	        });
	        feature.setStyle(style);
	        features.push(feature);
	    }
	    return features;
	}

	var addRadar = function (paramObj) {
	    var mapId = paramObj.mapId;
	    var datas = paramObj.datas;
	    var layerId = "radarLayer_" + mapId;//layerId并未作为参数传入，自己构造layerId
	    //若地图不存在则不进行下一步操作
	    var mapMain = mapBox.getMapObj(mapId);
	    if (mapMain == null) {
	        return;
	    }
	    //添加layer
	    var radarLayer = _createLayer(paramObj);
	    if (radarLayer.getSource() == null) {
	        var vectorSource = new ol.source.Vector({
	            wrapX: false
	        });
	        radarLayer.setSource(vectorSource);
	    }
	    sourceAddFeature(datas).forEach(function (feature) {
	        radarLayer.getSource().addFeature(feature);
	    });

	};
	module.exports = {
	    addRadar: addRadar
	}

/***/ },
/* 89 */
/*!********************************************!*\
  !*** ./src/gis/layers/renderShadowArea.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var util = __webpack_require__(/*! utils/util */ 1);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);

	var _createLayer = function (paramObj) {
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId + '_' + _mapId;
	    var _mapObj = mapBox.getMapObj(_mapId);
	    var _layer = null;
	    if (!util.isValid(hashMap.get(_layerId))) {
	        _layer = new ol.layer.Vector({
	            source: new ol.source.Vector({
	                wrapX: false
	            })
	        });
	        _layer.set('type', constant.CUSTOMTYPE.LAYERTYPE);
	        _layer.set('map', _mapObj);
	        _layer.set('layerId', _layerId);

	        _mapObj.addLayer(_layer);

	        hashMap.put(_layerId, _layer);
	    }
	    else {
	        _layer = hashMap.get(_layerId);
	    }

	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	    }
	    if(paramObj.zindex !== undefined){
	        _layer.setZIndex(paramObj.zindex);
	    }
	    return _layer;
	};

	/**
	 * 绘制镂空多边形，
	 * @param paramObj
	 * paramObj = {
	 *    mapId:       {String}              地图唯一标识
	 *   layerId:      {String}              图层唯一标识
	 *    geoId:       { String | int }      元素唯一标识
	 *   coordinates:  {Array<Array<x, y>>}  坐标
	 *    shadowColor: {String}              遮盖层填充颜色 "(255,255,255)"
	 *   shadowOpacity:{float}               遮盖层透明色
	 *}
	 * */
	var renderShadowArea = function (paramObj) {
	    var shadowLayer = _createLayer(paramObj);
	    var mapId = paramObj.mapId;
	    var layerId = paramObj.layerId;
	    var geoId = paramObj.geoId;
	    var shadowColor = paramObj.shadowColor;
	    var shadowOpacity = paramObj.shadowOpacity;
	    var coordinates = paramObj.coordinates;//传输4326格式，底图3857格式

	    if (paramObj.geoId) {
	        var param = {
	            layerId: layerId,
	            mapId: mapId,
	            featureId: geoId
	        };
	        var geoPolygonFeature = baseLayer.getFeatureById(param);
	        coordinates = geoPolygonFeature.getGeometry().getCoordinates();

	    }

	    //通过mapId获取地图
	    var mapMain = mapBox.getMapObj(mapId);
	    if (mapMain == null) {
	        return;//若地图不存在则不进行下一步操作
	    }

	    var vectorSource = new ol.source.Vector({
	    	wrapX: false    	
	    });

	    //构建背景大polygon的四个顶点
	    var northEast = ol.proj.fromLonLat([180, 89.99]);
	    var southEast = ol.proj.fromLonLat([180, -89.99]);
	    var southWest = ol.proj.fromLonLat([-180, -89.99]);
	    var northWest = ol.proj.fromLonLat([-180, 89.99]);

	    var bgPoints = [northEast, southEast, southWest, northWest];

	    //镂空区域坐标系转换
	    var coordinates3857 = [];
	    if (paramObj.geoId) {
	        coordinates3857 = coordinates;
	    }
	    else {
	        coordinates.forEach(function (coordinate) {
	            //适配高德地图火星坐标系
	            coordinate = utils.gcjTransform(coordinate);
	            var newCoordinate = ol.proj.transform(coordinate, constant.PROJ.EPSG_4326, constant.PROJ.EPSG_3857);
	            coordinates3857.push(newCoordinate);
	        });
	    }
	    coordinates3857.push(coordinates3857[0]);//关键代码，不重新加一遍第一个点会出现错误

	    var polygon = new ol.geom.LinearRing(coordinates3857);
	    var bgPolygon = new ol.geom.Polygon([bgPoints]);
	    var featureExtent = new ol.Feature({
	        geometry: bgPolygon,
	        type: 'bgPolygon',
	        geoId: geoId
	    });
	    featureExtent.setId(geoId);
	    vectorSource.addFeature(featureExtent);
	    bgPolygon.setCoordinates([bgPoints]);
	    bgPolygon.appendLinearRing(polygon);

	    var bgColor;
	    var bgAlpha;
	    if (shadowColor == null) {
	        bgColor = "(50,50,50)";
	    }
	    else {
	        bgColor = shadowColor;
	    }
	    if (shadowOpacity == null) {
	        bgAlpha = 0.3
	    }
	    else {
	        bgAlpha = shadowOpacity;
	    }
	    var colorStr = bgColor.substring(0, bgColor.length - 1);
	    var bgColorWithAlpha = "rgba" + colorStr + "," + bgAlpha + ")";
	    //设定背景大polygon颜色，透明度
	    var bgStyle = new ol.style.Style({
	        fill: new ol.style.Fill({
	            color: bgColorWithAlpha
	        }),
	        stroke: new ol.style.Stroke({
	            color: 'rgba(255,0,0,0)',
	            width: 1
	        })
	    });

	    //通过layerId获取图层



	    shadowLayer.setSource(vectorSource);
	    shadowLayer.setStyle(bgStyle);
	    mapMain.addLayer(shadowLayer);

	};

	module.exports = {
	    renderShadowArea: renderShadowArea
	};

/***/ },
/* 90 */
/*!*************************************!*\
  !*** ./src/gis/layers/trackShow.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);

	var intervalMap = new Map();
	var _paramObjs = new Map();

	var addTackShow = function (paramObj) {
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId + '_' + _mapId;
	    var _layer = null;

	    //将地图和定时器绑定，这样就可以对每个地图的定时器进行常用操作
	    intervalMap.set(_mapId, []);

	    _paramObjs.set(_mapId, []);

	    if (hashMap.containsKey(_layerId)) {
	        _layer = hashMap.get(_layerId);
	    }
	    else {
	        baseLayer.createLayer(paramObj);
	        _layer = hashMap.get(_layerId);
	    }
	    if (paramObj.zindex !== undefined) {
	        _layer.setZIndex(paramObj.zindex);
	    }
	    paramObj.source = _layer.getSource();

	    _addLine(paramObj);

	    _addDiscretePoints(paramObj);
	};

	/**
	 * 画线
	 * @param paramObj
	 *
	 * paramObj = {
	 *  datas: [
	 *      {
	 *          coordinates: [[x, y, timestamp], [x, y, timestamp], ...],
	 *          style: {
	 *              strokeColor: '',
	 *              fillColor: '',
	 *              strokeWidth: 5,
	 *              radius: 20,
	 *              lineStrokeColor: '',
	 *              lineStrokeWidth: 4
	 *          },
	 *          uniqueIdentify: 'unique identify'
	 *      }
	 *  ],
	 *  source: XXX
	 * }
	 * @private
	 */
	var _addLine = function (paramObj) {
	    var _data = paramObj.datas;
	    var _source = paramObj.source;

	    if (!utils.isValid(_data)) {
	        return;
	    }

	    for (var i = 0, len = _data.length; i < len; i++) {
	        var _coordinates = [];
	        //适配高德地图火星坐标系
	        var _lineCoordinateData = utils.transformMultArray(_data[i].coordinates);
	        var _style = _data[i].style;

	        for (var j = 0, _len = _lineCoordinateData.length; j < _len; j++) {
	            var _coordinate = ol.proj.fromLonLat([
	                _lineCoordinateData[j][0], _lineCoordinateData[j][1]
	            ]);
	            _coordinates.push(_coordinate);
	        }

	        ///一条一条画, 循环一次画一次
	        var _feature = new ol.Feature({
	            geometry: new ol.geom.LineString(_coordinates),
	            businessType: constant.BUSINESSTYPE.TRACK_SHOW_LINE
	        });

	        if (_style && _style.lineStrokeColor) {
	            var _lineStyle = new ol.style.Style({
	                stroke: new ol.style.Stroke({
	                    color: _style.lineStrokeColor,
	                    width: _style.lineStrokeWidth ? _style.lineStrokeWidth : 3
	                })
	            });

	            _feature.setStyle(_lineStyle);
	        }

	        _source.addFeature(_feature);

	        //获取线上最后；两个点
	        var _lastTwoPoint = _coordinates.filter(function (value, index, _finalPoints) {
	            return (index > (_finalPoints.length - 3));
	        });
	        var _dx = _lastTwoPoint[1][0] - _lastTwoPoint[0][0];
	        var _dy = _lastTwoPoint[1][1] - _lastTwoPoint[0][1];
	        var _rotation = -Math.atan2(_dy, _dx) + Math.PI / 2;
	        var _arrawStyle = new ol.style.Style({
	            image: new ol.style.RegularShape({
	                fill: new ol.style.Fill({
	                    color: _style ? _style.lineStrokeColor : 'blue'
	                }),
	                stroke: new ol.style.Stroke({
	                    color: _style ? _style.lineStrokeColor : 'blue',
	                    width: 1
	                }),
	                points: 3,
	                radius: 10,
	                rotation: _rotation,
	                angle: 0
	            })
	        });

	        var _arrawFeature = new ol.Feature({
	            geometry: new ol.geom.Point(_lastTwoPoint[1]),
	            businessType: constant.BUSINESSTYPE.TRACK_SHOW_LINE
	        });
	        _arrawFeature.setStyle(_arrawStyle);
	        _source.addFeature(_arrawFeature);
	    }

	};

	/**
	 * 根据时间在地图上添加离散点
	 * @param paramObj
	 *
	 * paramObj = {
	 *  datas: [
	 *      {
	 *          coordinates: [[x, y, timestamp], [x, y, timestamp], ...],
	 *          style: {
	 *              strokeColor: '',
	 *              fillColor: '',
	 *              strokeWidth: 5,
	 *              radius: 20
	 *          },
	 *          uniqueIdentify: 'unique identify'
	 *      }
	 *  ],
	 *  source: XXX
	 *  speedRate: XXX
	 *  isKeepTrack: true or false,
	 *  mapId: XXX,
	 *  layerId: XXX
	 * }
	 * @private
	 */
	var _addDiscretePoints = function (paramObj) {
	    _paramObjs.get(paramObj.mapId).push(paramObj);

	    var _data = paramObj.datas;
	    var _source = paramObj.source;
	    var _timeInterval = 0;

	    if (!!paramObj.speedRate) {
	        _timeInterval = paramObj.speedRate * 500;

	    }
	    else {
	        _timeInterval = 500;
	    }
	    var _isKeepTrack = paramObj.isKeepTrack;
	    var _mapId = paramObj.mapId;

	    if (!utils.isValid(_data)) {
	        return;
	    }

	    /**
	     *
	     * @param lineCoordinates {Array<Array<x, y>>} 组成线的经纬度集合
	     * @param style{Object} 样式
	     * @param lineUniqueIdentify {String} 线的唯一标识
	     * @private
	     */
	    var _addPoint = function (lineCoordinates, style, lineUniqueIdentify) {
	        var _hashMap = hashMap;
	        var _lineUniqueIdentify = _mapId + lineUniqueIdentify;
	        var _curPointIndex = _hashMap.get(_lineUniqueIdentify) || 0;
	        var _pointLength = lineCoordinates.length;
	        var _features = [];
	        var _sumTime = 0;

	        var _interval = setInterval(function () {
	            if (_curPointIndex < _pointLength) {
	                ///轨迹上一个点的数据信息、包括经纬度和时间戳
	                var _onePointObj = lineCoordinates[_curPointIndex];

	                var _timestamp = 1000;
	                if (!_onePointObj) {
	                    return;
	                }
	                if (_onePointObj.length > 2) {
	                    //使用点默认的时间戳
	                    _timestamp = _onePointObj[2];
	                }
	                //适配高德地图火星坐标系
	                var point = utils.gcjTransform([_onePointObj[0], _onePointObj[1]]);
	                var _coordinate = ol.proj.fromLonLat(point);
	                var _point = new ol.geom.Point(_coordinate);

	                _sumTime = _sumTime + 500;
	                //只有当点是点之间的时间戳到了才去打印点
	                if (_timestamp < _sumTime) {
	                    var _feature = new ol.Feature({
	                        geometry: _point,
	                        businessType: constant.BUSINESSTYPE.TRACK_SHOW
	                    });

	                    var _featureStyle = null;
	                    if (!!style) {
	                        ///如果轨迹有自己默认的样式，就使用默认样式
	                        _featureStyle = new ol.style.Style({
	                            image: new ol.style.Circle({
	                                fill: new ol.style.Fill({
	                                    color: style.fillColor || '#319FD3'
	                                }),
	                                radius: style.radius || 5,
	                                stroke: new ol.style.Stroke({
	                                    color: style.strokeColor || '#ff0',
	                                    width: style.strokeWidth || 1
	                                })
	                            })
	                        });
	                    }
	                    else {
	                        ///如果轨迹没有默认样式，就使用统一的样式
	                        _featureStyle = new ol.style.Style({
	                            image: new ol.style.Circle({
	                                fill: new ol.style.Fill({
	                                    color: paramObj.fillColor || '#319FD3'
	                                }),
	                                radius: paramObj.radius || 5,
	                                stroke: new ol.style.Stroke({
	                                    color: paramObj.strokeColor || '#ff0',
	                                    width: paramObj.strokeWidth || 1
	                                })
	                            })
	                        });
	                    }

	                    _feature.setStyle(_featureStyle);

	                    //画新点之前，先清除之前的点
	                    if (!_isKeepTrack) {
	                        _features.forEach(function (feature) {
	                            _source.removeFeature(feature);
	                        });
	                        _features = [];
	                    }

	                    _source.addFeature(_feature);
	                    _features.push(_feature);

	                    if (_curPointIndex === (_pointLength - 1)) {
	                        if (_isKeepTrack) {
	                            clearInterval(_interval);
	                        }
	                        else {
	                            _curPointIndex = -1;
	                        }
	                    }

	                    //记录每条线当前点的位置索引,在暂停后从新启动会用到,必须在++之前执行
	                    _hashMap.put(_lineUniqueIdentify, _curPointIndex);
	                    _sumTime = 0;
	                    _curPointIndex++;
	                }
	            }
	        }, _timeInterval);

	        // 每一条轨迹都是一个定时器
	        intervalMap && intervalMap.get(_mapId).push(_interval);

	    };

	    //循环中每一条线代表一条轨迹
	    for (var j = 0, length = _data.length; j < length; j++) {
	        var _lineDataObj = _data[j];
	        var _style = _lineDataObj.style || null;
	        _addPoint(_lineDataObj.coordinates, _style, _lineDataObj.uniqueIdentify);
	    }
	};

	/**
	 * 暂停
	 */
	var pause = function (mapId) {
	    intervalMap.size > 0 && intervalMap.get(mapId).length > 0 &&
	    intervalMap.get(mapId).forEach(function (interval) {
	        clearInterval(interval);
	    });
	};

	/**
	 * 从暂停的时间点重新开始
	 */
	var start = function (mapId) {
	    var _paramObj_ = _paramObjs.get(mapId);
	    var _paramObj = _paramObj_[_paramObj_.length - 1];
	    if (_paramObj) {
	        var _features = _paramObj.source.getFeatures();
	        if (!_paramObj.isKeepTrack) {
	            _features.forEach(function (feature) {
	                if (constant.BUSINESSTYPE.TRACK_SHOW === feature.get('businessType')) {
	                    _paramObj.source.removeFeature(feature);
	                }
	            });
	        }
	        _addDiscretePoints(_paramObj);
	    }

	};

	/**
	 * 从当前时间的前一个时间开始
	 */
	var pre = function (mapId) {
	    var _hashMap = hashMap;
	    _hashMap.keys.forEach(function (pointIndexKey) {
	        ///pointIndex 点的索引
	        if (pointIndexKey.startsWith(mapId)) {
	            _hashMap.put(pointIndexKey, (_hashMap.get(pointIndexKey) - 1));
	        }

	        return;
	    });

	    start(mapId);
	};

	/**
	 * 从当前时间的下一个时间点开始
	 */
	var next = function (mapId) {
	    var _hashMap = hashMap;
	    _hashMap.keys.forEach(function (pointIndexKey) {
	        ///pointIndex 点的索引
	        if (pointIndexKey.startsWith(mapId)) {
	            _hashMap.put(pointIndexKey, (_hashMap.get(pointIndexKey) + 1));
	        }

	        return;
	    });

	    start(mapId);
	};

	module.exports = {
	    addTackShow: addTackShow,
	    pause: pause,
	    start: start,
	    pre: pre,
	    next: next
	};



/***/ },
/* 91 */
/*!****************************************!*\
  !*** ./src/gis/layers/convergeCell.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var util = __webpack_require__(/*! utils/util */ 1);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);

	var _createLayer = function (paramObj) {
	    var _layer;
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId;
	    var _mapObj = mapBox.getMapObj(_mapId);
	 
	    var _layerIdentify = _layerId + '_' + _mapId;
	    if (hashMap.containsKey(_layerIdentify)) {
	        _layer = hashMap.get(_layerIdentify);
	    }
	    else {
	         _layer = new ol.layer.Image({
	            source: new ol.source.ImageCanvas({
	                canvasFunction: paramObj.canvasFunction,
	                projection: 'EPSG:3857'
	            })
	        });
	        _layer.set('type', constant.CUSTOMTYPE.LAYERIMGTYPE);
	        _layer.set('isVectorType',false);
	        _layer.set('map', _mapObj);
	        _layer.set('layerId', _layerIdentify);
	        _layer.set('layer_id', _layerId);

	        _mapObj.addLayer(_layer);
	    }
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	    }
	    if(paramObj.zindex !== undefined){
	        _layer.setZIndex(paramObj.zindex);
	    }
	   
	    return _layer;
	};

	var _removeLayer = function (paramObj) {
	    var _layer;
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId;
	    var _mapObj = mapBox.getMapObj(_mapId);
	    var _layerIdentify = _layerId + '_' + _mapId;
	    if (hashMap.containsKey(_layerIdentify)) {
	        _layer = layers.getLayer(_layerIdentify);
	        _layer.setSource(new ol.source.ImageCanvas({
	            canvasFunction: null,
	            projection: 'EPSG:3857'
	        }));
	        _mapObj.removeLayer(_layer);
	        _layer = null;
	    }

	};

	var convergeForCell = function (param) {
	    var mapObj = mapBox.getMapObj(param.mapId);
	    var radius = param.radius;
	    var coordinates = param.data;
	    var ctx;
	    //添加填充色
	    var colorArr = param.color;
	    var step = param.step;

	    var drawRect = function (x, y, val) {
	        var fillStyle;
	        for (var i = 0; i <= colorArr.length; i++) {
	            if (val > step * i && val <= step * (i + 1)) {
	                fillStyle = colorArr[i];
	            }
	        }
	        if (fillStyle === undefined) {
	            fillStyle = 'rgba(255,255,255,0)';
	        }
	        var para = Math.sqrt(3) / 2 * radius;
	        ctx.beginPath();
	        ctx.lineWidth = 1;
	        ctx.fillStyle = fillStyle;
	        ctx.moveTo(x, y - radius);
	        ctx.lineTo(x + para, y - radius / 2);
	        ctx.lineTo(x + para, y + radius / 2);
	        ctx.lineTo(x, y + radius);
	        ctx.lineTo(x - para, y + radius / 2);
	        ctx.lineTo(x - para, y - radius / 2);
	        ctx.fill();
	        ctx.closePath();
	    };

	    var drawText = function (x, y, val) {
	        if (val > 0) {
	            //只有汇聚情况下，才进行标签显示
	            ctx.textAlign = 'center';
	            ctx.textBaseline = 'middle';
	            ctx.font = "15px Arial";
	            ctx.fillStyle = 'white';
	            ctx.fillText(val, x, y);
	        }

	    };

	    function newImageExtentCal(LNum, VNum, W3857, H3857) {
	        var result1;
	        var result2;
	        var result = [];
	        var queue = Math.floor(Math.abs(VNum / H3857));
	        if (VNum >= 0) {
	            result1 = queue * Math.abs(H3857);
	        }
	        else {
	            result1 = -queue * Math.abs(H3857);
	        }
	        result.push(result1);
	        if (queue % 2 === 0) {
	            result2 = Math.ceil(Math.abs(LNum / W3857)) * Math.abs(W3857);
	        }
	        else {
	            result2 = Math.ceil(Math.abs(LNum / W3857) - 0.5) * Math.abs(W3857) + 0.5 * Math.abs(W3857);
	        }
	        if (LNum <= 0) {
	            result2 = -result2;
	        }
	        result.push(result2);
	        return result;
	    }

	    function calculateGrids(numOfLevel, numOfVertical, imageExtent) {
	        var x, y, _currenX, _cuurentY;
	        var paraTwo = Math.sqrt(3) * radius / 2;

	        var _gridW_3857 = (imageExtent[2] - imageExtent[0]) / numOfLevel;
	        var _gridH_3857 = (-imageExtent[3] + imageExtent[1]) / numOfVertical;
	        var radius_3857 = 2 * _gridH_3857 / 3;

	        var newImageExtent = newImageExtentCal(imageExtent[0], imageExtent[3], _gridW_3857, _gridH_3857);
	        var newImageExtent0 = newImageExtent[1];
	        var newImageExtent3 = newImageExtent[0];

	        var newX = (newImageExtent0 - imageExtent[0]) / _gridW_3857 * 2 * paraTwo;
	        var newY = (newImageExtent3 - imageExtent[3]) / _gridH_3857 * 1.5 * radius;

	        for (var i = 0; i < numOfVertical; i++) {
	            for (var j = 0; j < numOfLevel; j++) {
	                if (i % 2 === 0) {
	                    _currenX = newX + 2 * paraTwo * j;
	                    x = newImageExtent0 + _gridW_3857 * j;
	                }
	                else {
	                    _currenX = newX + paraTwo + 2 * paraTwo * j;
	                    x = newImageExtent0 + 0.5 * _gridW_3857 + _gridW_3857 * j;
	                }

	                _cuurentY = newY + 1.5 * radius * i;
	                y = newImageExtent3 + _gridH_3857 * i;
	                var count = 0;

	                coordinates.forEach(function (coordinate) {
	                	var _lastCoordinate =coordinate.slice(0);
	                	var _transFromCoords =util.gcjTransform(_lastCoordinate);
	                    var _coordinate = ol.proj.fromLonLat(_transFromCoords);
	                    var xInPolygon = _coordinate[0] - x;
	                    var yInPolygon = _coordinate[1] - y;

	                    if (Math.abs(yInPolygon) >= Math.abs(radius_3857) || Math.abs(xInPolygon) >= Math.abs(_gridW_3857) / 2) {

	                    }
	                    else {
	                        if (Math.abs(radius_3857) - Math.abs(yInPolygon) > Math.abs(xInPolygon) / Math.sqrt(3)) {
	                            count += 1;
	                        }
	                    }
	                });

	                drawRect(_currenX, _cuurentY, count);
	                drawText(_currenX, _cuurentY, count);
	            }
	        }
	    }

	    var render = function (canvasWidth, canvasHeight, imageExtent) {

	        var numOfLevel = canvasWidth / (Math.sqrt(3) * radius);
	        var numOfVertical = canvasHeight / (1.5 * radius);

	        calculateGrids(numOfLevel, numOfVertical, imageExtent);
	    };

	    var canvasFunction = function (imageExtent, imageResolution, devicePixelRatio, imageSize, imageProjection) {
	        if (!this.canvas) {
	            this.canvas = document.createElement('canvas');
	        }

	        var canvasWidth = imageSize[0];
	        var canvasHeight = imageSize[1];
	        this.canvas.setAttribute('width', canvasWidth);
	        this.canvas.setAttribute('height', canvasHeight);

	        ctx = this.canvas.getContext('2d');

	        render(canvasWidth, canvasHeight, imageExtent);
	        return this.canvas;
	    };

	    var createLayerParam = {
	        mapId: param.mapId,
	        canvasFunction: canvasFunction
	    };

	    _createLayer(createLayerParam);

	};

	module.exports = {
	    convergeForCell: convergeForCell,
	    removeConverge: _removeLayer
	}

/***/ },
/* 92 */
/*!****************************************!*\
  !*** ./src/gis/layers/convergeGrid.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var util = __webpack_require__(/*! utils/util */ 1);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);

	var _createLayer = function (paramObj) {
	    var _layer;
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId;
	    var _mapObj = mapBox.getMapObj(_mapId);
	    var _layerIdentify = _layerId + '_' + _mapId;
	    if (hashMap.containsKey(_layerIdentify)) {
	        _layer = hashMap.get(_layerIdentify);
	    }
	    else {
	         _layer = new ol.layer.Image({
	            source: new ol.source.ImageCanvas({
	                canvasFunction: paramObj.canvasFunction,
	                projection: 'EPSG:3857'
	            })
	        });
	        _layer.set('type', constant.CUSTOMTYPE.LAYERIMGTYPE);
	        _layer.set('isVectorType',false);
	        _layer.set('map', _mapObj);
	        _layer.set('layerId', _layerIdentify);
	        _layer.set('layer_id', _layerId);

	        _mapObj.addLayer(_layer);
	    }
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	    }
	    if(paramObj.zindex !== undefined){
	        _layer.setZIndex(paramObj.zindex);
	    }
	    return _layer;
	};

	var _removeLayer = function (paramObj) {
	    var _layer;
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId;
	    var _mapObj = mapBox.getMapObj(_mapId);
	    var _layerIdentify = _layerId + '_' + _mapId;
	    
	    if (hashMap.containsKey(_layerIdentify)) {
	        _layer = layers.getLayer(_layerIdentify);
	        _layer.setSource(new ol.source.ImageCanvas({
	            canvasFunction: null,
	            projection: 'EPSG:3857'
	        }));
	        _mapObj.removeLayer(_layer);
	        _layer = null;
	    }

	};

	var convergeForGrid = function (param) {
	    var mapObj = mapBox.getMapObj(param.mapId);
	    var rectWidth = param.width;
	    var rectHeight = param.height;
	    var coordinates = param.data;
	    var ctx;
	    //添加填充色
	    var colorArr = param.color;
	    var step = param.step;

	    var drawRect = function (x, y, val) {
	        var fillStyle;
	        ctx.strokeStyle = 'rgba(0,0,255,0.1)';
	        for (var i = 0; i <= colorArr.length; i++) {
	            if (val > step * i && val <= step * (i + 1)) {
	                fillStyle = colorArr[i];
	            }
	        }
	        if (fillStyle === undefined) {
	            fillStyle = 'rgba(255,255,255,0)';
	        }

	        ctx.beginPath();
	        ctx.fillStyle = fillStyle;
	        ctx.fillRect(x - rectWidth / 2, y - rectHeight / 2, rectWidth, rectHeight);
	        ctx.fill();
	        ctx.closePath();
	    };

	    var drawText = function (x, y, val) {
	        if (val > 0) {
	            ctx.textAlign = 'center';
	            ctx.textBaseline = 'middle';
	            ctx.font = "15px Arial";
	            ctx.fillStyle = 'white';
	            ctx.fillText(val, x, y);
	        }

	    };

	    function newImageExtentCal(firstNum, secNum) {
	        var result;
	        if (firstNum >= 0) {
	            result = Math.ceil(Math.abs(firstNum / secNum)) * Math.abs(secNum);
	        }
	        else {
	            result = -Math.ceil(Math.abs(firstNum / secNum)) * Math.abs(secNum);
	        }
	        return result;
	    }

	    function calculateGrids(cols, rows, imageExtent) {
	        var _gridW_3857 = (imageExtent[2] - imageExtent[0]) / cols;
	        var _gridH_3857 = (-imageExtent[3] + imageExtent[1]) / rows;
	        var _widthOfHalfGrid = _gridW_3857 / 2;
	        var _heightOfHalfGrid = _gridH_3857 / 2;

	        var newImageExtent0 = newImageExtentCal(imageExtent[0], _gridW_3857);
	        var newImageExtent3 = newImageExtentCal(imageExtent[3], _gridH_3857);

	        for (var i = 0; i < cols; i++) {
	            for (var j = 0; j < rows; j++) {
	                var x = newImageExtent0 + _gridW_3857 * i;
	                var y = newImageExtent3 + _gridH_3857 * j;
	                var count = 0;

	                coordinates.forEach(function (coordinate) {
	                	var _lastCoordinate =coordinate.slice(0);
	                	var transFormCoord =util.gcjTransform(_lastCoordinate);
	                    var _coordinate = ol.proj.fromLonLat(transFormCoord);
	                    if (_coordinate[0] >= x - _widthOfHalfGrid && _coordinate[0] < x + _widthOfHalfGrid
	                        && _coordinate[1] <= y - _heightOfHalfGrid && _coordinate[1] > y + _heightOfHalfGrid) {
	                        count += 1;
	                    }
	                });
	                var newX = (newImageExtent0 - imageExtent[0]) / _gridW_3857 * 50;
	                var newY = (newImageExtent3 - imageExtent[3]) / _gridH_3857 * 50;
	                var _currenX = newX + rectWidth * i;
	                var _cuurentY = newY + rectHeight * j;

	                drawRect(_currenX, _cuurentY, count);

	                drawText(_currenX, _cuurentY, count);
	            }
	        }
	    }

	    var render = function (canvasWidth, canvasHeight, imageExtent) {

	        var cols = canvasWidth / rectWidth;
	        var rows = canvasHeight / rectHeight;
	        calculateGrids(cols, rows, imageExtent);
	    };

	    var canvasFunction = function (imageExtent, imageResolution, devicePixelRatio, imageSize, imageProjection) {
	        if (!this.canvas) {
	            this.canvas = document.createElement('canvas');
	        }

	        var canvasWidth = imageSize[0];
	        var canvasHeight = imageSize[1];
	        this.canvas.setAttribute('width', canvasWidth);
	        this.canvas.setAttribute('height', canvasHeight);

	        ctx = this.canvas.getContext('2d');

	        render(canvasWidth, canvasHeight, imageExtent);
	        return this.canvas;
	    };

	    var createLayerParam = {
	        mapId: param.mapId,
	        canvasFunction: canvasFunction
	    };

	    _createLayer(createLayerParam);

	};

	module.exports = {
	    convergeForGrid: convergeForGrid,
	    removeConverge: _removeLayer
	}

/***/ },
/* 93 */
/*!***********************************************!*\
  !*** ./src/gis/businessLayers/siteAndCell.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var algorithm = __webpack_require__(/*! framework/algorithm */ 48);

	var _glbSource = null;
	function addSiteAndCell(paramObj) {

	    var _layerIdentify = paramObj.layerId + '_' + paramObj.mapId;
	    var _layer = null;
	    var _mapObj = hashMap.get(paramObj.mapId);
	    var _zoom = _mapObj.getView().getZoom();

	    if (hashMap.containsKey(_layerIdentify)) {
	        _layer = hashMap.get(_layerIdentify);
	    }
	    else {
	        baseLayer.createLayer(paramObj);
	        _layer = hashMap.get(_layerIdentify);
	    }

	    _layer.set('businessType', 'editLayer');
	    _layer.set('legendName', paramObj.legendName);
	    _layer.set('paramObj',paramObj);
	    if (paramObj.minShowLevel != undefined) {
			_layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
		}

		if (paramObj.maxShowLevel != undefined) {
			_layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
		}
	    _glbSource = _layer.getSource();
	    setLayerData(paramObj);
	}

	function getLayerSource(param) {
	    var source = null;
	    var _layerIdentify = param.layerId + '_' + param.mapId;
	    var _layer = hashMap.get(_layerIdentify);
	    _layer.set('legendName', param.legendName);
	    if (_layer) {
	        source = _layer.getSource();
	    }
	    return source
	}

	function BubbleSort(array) {
	    var length = array.length;
	    for (var i = length - 1; i > 0; i--) {
	        for (var j = 0; j < i; j++) {
	            if (array[j].radius > array[j + 1].radius) {
	                var temp = array[j];
	                array[j] = array[j + 1];
	                array[j + 1] = temp;
	            }
	        }
	    }
	    return array;
	}

	function setLayerData(paramObj) {
	    _glbSource = getLayerSource(paramObj);
	    var _datas = paramObj.datas;
	    if (utils.isValid(_datas) || _datas.length > 0) {
	        for (var i = 0; i < _datas.length; i++) {
	            var cellList = _datas[i].cellInfo;
	            _glbSource.addFeature(createSite(_datas[i]));
	            var cellData = {};
	            for (var j = 0; j < cellList.length; j++) {
	                if (cellData[cellList[j].azimuth.toString()]) {

	                    cellData[cellList[j].azimuth.toString()].push(cellList[j]);
	                } else {
	                    cellData[cellList[j].azimuth.toString()] = [];
	                    cellData[cellList[j].azimuth.toString()].push(cellList[j]);
	                }
	            }
	            for (var key in cellData) {
	                if (cellData[key].length > 1) {
	                    BubbleSort(cellData[key]);
	                }
	            }
	            for (var key in cellData) {
	                if (cellData[key].length > 0) {
	                    for (var v = cellData[key].length - 1; v >= 0; v--) {
	                        _glbSource.addFeature(createCell(cellData[key][v]));
	                    }
	                }
	            }
	        }
	    }
	}
	var handleDownEvent, handleMoveEvent, handleUpEvent = null;

	function moveFeature(params) {
	    var _mapObj = hashMap.get(params.mapId);
	    var _isOpen = params.isOpen;
	    var _type = params.type;
	    var draPan = _mapObj.getInteractions().item(2);
	    var isMove = false;
	    var callback = params.callback;
	    _glbSource = getLayerSource({mapId: params.mapId, layerId: params.layerId});
	    if (!!_isOpen) {
	        if (handleDownEvent && handleMoveEvent && handleUpEvent) {
	            return;
	        }
	        var _moveFeature = null;
	        handleDownEvent = _mapObj.on('pointerdown', function (e) {
	            var _featureList = [];
	            _mapObj.forEachFeatureAtPixel(e.pixel, function (feature) {
	                if (feature && feature.get('businessType') === 'siteAndCell') {
	                    draPan.setActive(false);
	                    isMove = true;
	                    _featureList.push(feature);
	                }
	            });
	            if (_featureList.length > 0) {
	                _moveFeature = _featureList[0];
	            }
	        });

	        handleMoveEvent = _mapObj.on('pointerdrag', function (e) {
	            if (isMove) {
	                if (_moveFeature.get('type') === 'site') {
	                    if (_type === 'translate') {
	                        _moveFeature.getGeometry().setCoordinates(e.coordinate);
	                        //解决点线分离
	                        var oldData = _moveFeature.get('data').coordinates;
	                        _moveFeature.get('data').coordinates = ol.proj.toLonLat(e.coordinate);
	                        _moveFeature.set('nowLatlon', e.coordinate);
	                        var cellList = _moveFeature.get('data').cellInfo;
	                        if (cellList && cellList.length > 0) {
	                            for (var i = 0; i < cellList.length; i++) {
	                                var moveObject = _glbSource.getFeatureById(cellList[i].cellId);
	                                if (cellList[i].coordinates[0] === oldData[0] && cellList[i].coordinates[1] === oldData[1]) {
	                                    if (moveObject) {
	                                        moveCell(e, moveObject);
	                                        siteAndCellLine(params.mapId, params.layerId, _moveFeature, moveObject);
	                                    }
	                                } else {
	                                    if (moveObject) {
	                                        siteAndCellLine(params.mapId, params.layerId, _moveFeature, moveObject);
	                                    }
	                                }

	                            }
	                        }

	                    }
	                }
	                else if (_moveFeature.get('type') === 'cell') {
	                    if (_type === 'translate') {
	                        var _site = _glbSource.getFeatureById(_moveFeature.get('data').belongSite);
	                        moveCell(e, _moveFeature);
	                        siteAndCellLine(params.mapId, params.layerId, _site, _moveFeature);
	                    }
	                    else {
	                        rotateCell(e, _moveFeature);
	                    }

	                }

	            }
	        });

	        handleUpEvent = _mapObj.on('pointerup', function () {
	            if (_moveFeature) {
	                draPan.setActive(true);
	                isMove = false;
	                _moveFeature = null;
	            }

	        })
	    }
	    else {
	        _mapObj.unByKey(handleDownEvent);
	        _mapObj.unByKey(handleMoveEvent);
	        _mapObj.unByKey(handleUpEvent);
	        handleDownEvent = null;
	        handleMoveEvent = null;
	        handleUpEvent = null;
	    }
	}

	function addSite(param, site) {
	    _glbSource = getLayerSource(param);
	    if (site) {
	        if (Array.isArray(site) && site.length > 0) {
	            var siteList = [];
	            for (var i = 0; i < site.length; i++) {
	                siteList.push(createSite(site[i]));
	            }
	            _glbSource.addFeatures(siteList);
	        }
	        else {
	            _glbSource.addFeature(createSite(site));
	        }
	    }

	}

	function createSite(param) {
	    //适配高德地图火星坐标系
	    var _coordinates = utils.gcjTransform(param.coordinates);
	    var _point = new ol.geom.Point(ol.proj.fromLonLat(_coordinates));
	    var pointFeature = new ol.Feature({
	        geometry: _point,
	        businessType: 'siteAndCell',
	        type: 'site',
	        data: param
	    });
	    pointFeature.setId(param.siteId);

	    var shapeStyle = new ol.style.Style({
	        image: new ol.style.Circle({
	            radius: param.radius ? param.radius : 5,
	            fill: new ol.style.Fill({
	                color: param.fillColor ? param.fillColor : 'red'
	            }),
	            stroke: new ol.style.Stroke({
	                color: param.strokeColor ? param.strokeColor : '#319FD3',
	                width: param.strokeWidth ? param.strokeWidth : 1
	            })
	        })
	    });
	    pointFeature.setStyle(shapeStyle);
	    return pointFeature;
	}

	function createCell(param) {
	    var _radius = param.radius;
	    var _azimuth = param.azimuth;
	    var _angle = param.angle;
	    var _cellType = param.cellType;//arrow",
	    //适配高德地图火星坐标系
	    var paramCoordinates = utils.gcjTransform(param.coordinates);
	    var _lonlat = ol.proj.fromLonLat([paramCoordinates[0], paramCoordinates[1]]);
	    var _coordinates = null;
	    var cellFeature;
	    //创建箭头小区
	    if (_cellType === 'arrow') {
	        _coordinates = algorithm.createArrow(_lonlat[0], _lonlat[1], _radius, _azimuth, _angle);
	        //创建扇瓣小区
	    }
	    else if (_cellType === 'sector') {
	        _coordinates = algorithm.createSector(_lonlat[0], _lonlat[1], _radius, _azimuth, _angle);

	    } else if (_cellType === 'triangle') {
	        _coordinates = algorithm.createTriangle(_lonlat[0], _lonlat[1], _radius, _azimuth, _angle);
	    }
	    var _linearRing = new ol.geom.LinearRing(_coordinates);
	    var ring = _linearRing.getCoordinates();
	    var _polygon = null;

	    if (_angle === 360) {
	        var pointRadius = param.pointRadius || 0;
	        _polygon = new ol.geom.GeometryCollection();
	        ring.splice(0, 2);
	        ring.splice(ring.length - 1, 2);
	        _polygon.setGeometries([new ol.geom.Circle(ol.proj.fromLonLat([paramCoordinates[0], paramCoordinates[1]]), pointRadius), new ol.geom.Polygon([ring])]);
	    } else {
	        _polygon = new ol.geom.Polygon([ring]);
	    }

	    cellFeature = new ol.Feature({
	        geometry: _polygon,
	        businessType: 'siteAndCell',
	        type: 'cell',
	        data: param
	    });
	    cellFeature.setId(param.cellId);

	    var _style = new ol.style.Style({
	        fill: new ol.style.Fill({
	            color: param.fillColor || '#836FFF'
	        }),
	        stroke: new ol.style.Stroke({
	            color: param.strokeColor || '#76EEC6',
	            width: param.strokeWidth || 2
	        })
	    });
	    cellFeature.setStyle(_style);
	    return cellFeature;
	}

	function addCell(param, cell) {
	    _glbSource = getLayerSource(param);
	    if (cell) {
	        var _site = null;
	        if (Array.isArray(cell) && cell.length > 0) {
	            var cellList = [];
	            for (var i = 0; i < cell.length; i++) {
	                cellList.push(createCell(cell[i]));
	                _site = _glbSource.getFeatureById(cellList[i].belongSite);
	                _site.get('data').cellInfo.push(cell[i]);
	            }
	            _glbSource.addFeatures(cellList);
	        }
	        else {
	            _site = _glbSource.getFeatureById(cell.belongSite);
	            var siteDate = _site.get('data').cellInfo;
	            var flag = true;
	            var cellData = [];
	            for (var i = 0; i < siteDate.length; i++) {
	                if (cell.azimuth === siteDate[i].azimuth) {
	                    flag = false;
	                    cellData.push(siteDate[i]);
	                }
	            }
	            if(flag){
	                _glbSource.addFeature(createCell(cell));
	                siteDate.push(cell);
	            }else{
	                for(var i=0;i<cellData.length;i++){
	                    var delfeature = _glbSource.getFeatureById(cellData[i].cellId);
	                    if(delfeature){
	                        _glbSource.removeFeature(delfeature);
	                    }
	                }
	                cellData.push(cell);
	                var sameCells = BubbleSort(cellData);
	                for(var i=sameCells.length-1;i>=0;i--){
	                    _glbSource.addFeature(createCell(sameCells[i]));
	                }
	                siteDate.push(cell);
	            }
	        }
	    }
	}

	function deleteSite(param, siteId) {
	    _glbSource = getLayerSource(param);
	    if (siteId) {
	        if (Array.isArray(siteId) && siteId.length > 0) {
	            for (var i = 0; i < siteId.length; i++) {
	                _glbSource.removeFeature(_glbSource.getFeatureById(siteId[i]));
	            }
	        }
	        else {
	            _glbSource.removeFeature(_glbSource.getFeatureById(siteId));
	        }
	    }
	}

	function deleteCellInfo(site, cellId) {
	    var cellList = site.get('data').cellInfo;
	    if (cellList && cellList.length > 0) {
	        for (var i = 0; i < cellList.length; i++) {
	            if (cellList[i].cellId === cellId) {
	                cellList.splice(i, 1);
	            }
	        }
	    }
	}

	function deleteCell(param, cellId) {
	    _glbSource = getLayerSource(param);
	    if (cellId) {
	        var _site, _deleteObj, deleteLine = null;
	        if (Array.isArray(cellId) && cellId.length > 0) {
	            for (var i = 0; i < cellId.length; i++) {
	                _deleteObj = _glbSource.getFeatureById(cellId[i]);
	                deleteLine = _glbSource.getFeatureById(cellId[i] + '_line');
	                if (_deleteObj) {
	                    _glbSource.removeFeature(_deleteObj);
	                    _site = _glbSource.getFeatureById(_deleteObj.get('data').belongSite);
	                    if (_site) {
	                        deleteCellInfo(_site, cellId[i]);
	                    }
	                }
	                if (deleteLine) {
	                    _glbSource.removeFeature(deleteLine);
	                }
	            }
	        }
	        else {
	            _deleteObj = _glbSource.getFeatureById(cellId);
	            deleteLine = _glbSource.getFeatureById(cellId + '_line');
	            if (_deleteObj) {
	                _glbSource.removeFeature(_deleteObj);
	                _site = _glbSource.getFeatureById(_deleteObj.get('data').belongSite);
	                if (_site) {
	                    deleteCellInfo(_site, cellId);
	                }
	            }
	            if (deleteLine) {
	                _glbSource.removeFeature(deleteLine);
	            }

	        }
	    }
	}

	function editSite(site, param) {
	    if (site && param) {
	        var cellData = site.get('data');
	        utils.mixin(cellData, param);
	        var _lonlat = ol.proj.fromLonLat(cellData.coordinates);
	        var shapeStyle = new ol.style.Style({
	            image: new ol.style.Circle({
	                radius: cellData.radius,
	                fill: new ol.style.Fill({
	                    color: cellData.fillColor
	                }),
	                stroke: new ol.style.Stroke({
	                    color: cellData.strokeColor,
	                    width: cellData.strokeWidth
	                })
	            })
	        });
	        site.setStyle(shapeStyle);
	        site.getGeometry().setCoordinates(_lonlat);
	        site.set('data', cellData);
	    }
	}

	function editCell(cell, param) {
	    _glbSource = getLayerSource(param);
	    if (cell && param) {
	        var cellData = cell.get('data');
	        utils.mixin(cellData, param);
	        var _radius = cellData.radius;
	        var _azimuth = cellData.azimuth;
	        var _angle = cellData.angle;
	        var _cellType = cellData.cellType;
	        var _lonlat = ol.proj.fromLonLat(utils.gcjTransform(cellData.coordinates));
	        var _coordinates = null;
	        //创建箭头小区
	        if (_cellType === 'arrow') {
	            _coordinates = algorithm.createArrow(_lonlat[0], _lonlat[1], _radius, _azimuth, _angle);
	            //创建扇瓣小区
	        }
	        else if (_cellType === 'sector') {
	            _coordinates = algorithm.createSector(_lonlat[0], _lonlat[1], _radius, _azimuth, _angle);
	        } else if (_cellType === 'triangle') {
	            _coordinates = algorithm.createTriangle(_lonlat[0], _lonlat[1], _radius, _azimuth, _angle);
	        }
	        var _style = new ol.style.Style({
	            fill: new ol.style.Fill({
	                color: cellData.fillColor || '#836FFF'
	            }),
	            stroke: new ol.style.Stroke({
	                color: cellData.strokeColor || '#76EEC6',
	                width: cellData.strokeWidth || 2
	            })
	        });
	        cell.getGeometry().setCoordinates([_coordinates]);
	        cell.setStyle(_style);
	        cell.set('data', cellData);

	        var _site = _glbSource.getFeatureById(cell.get('data').belongSite);
	        var siteDate = _site.get('data').cellInfo;
	        var flag = true;
	        var _cellData = [];
	        for (var i = 0; i < siteDate.length; i++) {
	            if (_azimuth === siteDate[i].azimuth) {
	                flag = false;
	                _cellData.push(siteDate[i]);
	            }
	        }
	        if(!flag){

	            for(var i=0;i<_cellData.length;i++){
	                var delfeature = _glbSource.getFeatureById(_cellData[i].cellId);
	                if(delfeature){
	                    _glbSource.removeFeature(delfeature);
	                }
	            }
	            var sameCells = BubbleSort(_cellData);
	            for(var i=sameCells.length-1;i>=0;i--){
	                _glbSource.addFeature(createCell(sameCells[i]));
	            }
	        }
	    }
	}

	function moveCell(e, cell) {
	    var _radius = cell.get('data').radius;
	    var cellCoordinates;
	    if (cell.get('data').cellType === 'sector') {
	        cellCoordinates = algorithm.createSector(e.coordinate[0], e.coordinate[1],
	            _radius, cell.get('data').azimuth, cell.get('data').angle);
	    } else if (cell.get('data').cellType === 'arrow') {
	        cellCoordinates = algorithm.createArrow(e.coordinate[0], e.coordinate[1],
	            _radius, cell.get('data').azimuth, cell.get('data').angle);
	    } else if (cell.get('data').cellType === 'triangle') {
	        cellCoordinates = algorithm.createTriangle(e.coordinate[0], e.coordinate[1],
	            _radius, cell.get('data').azimuth, cell.get('data').angle);
	    }
	    cell.getGeometry().setCoordinates([cellCoordinates]);
	    cell.get('data').coordinates = ol.proj.toLonLat(e.coordinate);
	    cell.set('nowLatlon', e.coordinate);
	}

	function rotateCell(e, cell) {
	    var _cell = cell.get('data');
	    var _lonlat = ol.proj.fromLonLat(utils.gcjTransform(_cell.coordinates));
	    var _azimuth = Math.atan((e.coordinate[0] - _lonlat[0]) / (e.coordinate[1] - _lonlat[1])) * 180 / Math.PI;
	    if (e.coordinate[1] - _lonlat[1] > 0) {
	        _azimuth += 360;
	    }
	    else {
	        _azimuth += 180;
	    }
	    if (_azimuth > 360) {
	        _azimuth -= 360;
	    }
	    var cellCoordinates;
	    if (cell.get('data').cellType === 'sector') {
	        cellCoordinates = algorithm.createSector(_lonlat[0], _lonlat[1],
	            _cell.radius, _azimuth, _cell.angle);

	    } else if (cell.get('data').cellType === 'arrow') {
	        cellCoordinates = algorithm.createArrow(_lonlat[0], _lonlat[1],
	            _cell.radius, _azimuth, _cell.angle);
	    } else if (cell.get('data').cellType === 'triangle') {
	        cellCoordinates = algorithm.createTriangle(_lonlat[0], _lonlat[1],
	            _cell.radius, _azimuth, _cell.angle);
	    }
	    cell.getGeometry().setCoordinates([cellCoordinates]);
	    cell.get('data').azimuth = _azimuth;
	}

	function deleteSiteByExtent(param, extent) {
	    _glbSource = getLayerSource(param);
	    var featureList = _glbSource.getFeaturesInExtent(extent);
	    if (featureList && featureList.length > 0) {
	        for (var i = 0; i < featureList.length; i++) {
	            if (featureList[i].get('type') === 'site') {
	                deleteSite(param, featureList[i].getId());
	                var cellList = featureList[i].get('data').cellInfo;
	                if (cellList && cellList.length > 0) {
	                    for (var k = 0; k < cellList.length; k++) {
	                        deleteCell(param, cellList[k].cellId);
	                    }
	                }
	            }
	            else if (featureList[i].get('type') === 'cell') {
	                deleteCell(param, featureList[i].getId());
	            }
	        }
	    }
	}

	var handleDownEvent_all, handleMoveEvent_all, handleUpEvent_all = null;

	function moveFeatures(params) {
	    var _mapObj = hashMap.get(params.mapId);
	    var _isOpen = params.isOpen;
	    var draPan = _mapObj.getInteractions().item(2);
	    var callbackFun = params.callback;
	    _glbSource = getLayerSource({mapId: params.mapId, layerId: params.layerId});
	    var isMove = false;
	    var _moveFeature;
	    if (!!_isOpen) {
	        if (handleDownEvent_all && handleMoveEvent_all && handleUpEvent_all) {
	            return;
	        }
	        var featureList = _glbSource.getFeaturesInExtent(params.extent);
	        var siteFeatures = [];
	        if (featureList && featureList.length > 0) {
	            for (var i = 0; i < featureList.length; i++) {
	                if (featureList[i].get('type') === 'site') {
	                    siteFeatures.push(featureList[i]);
	                }
	            }
	        }
	        var downPosition = null;
	        handleDownEvent_all = _mapObj.on('pointerdown', function (e) {
	            var _featureList = [];
	            _mapObj.forEachFeatureAtPixel(e.pixel, function (feature) {
	                if (feature && feature.get('businessType') === 'siteAndCell') {
	                    draPan.setActive(false);
	                    isMove = true;
	                    _featureList.push(feature);
	                }
	            });
	            if (_featureList.length > 0) {
	                _moveFeature = _featureList[0];
	            }
	            downPosition = e.coordinate;
	        });
	        handleMoveEvent_all = _mapObj.on('pointerdrag', function (e) {
	            if (isMove) {
	                if (_moveFeature) {
	                    var Dx = e.coordinate[0] - downPosition[0];
	                    var Dy = e.coordinate[1] - downPosition[1];
	                    for (var i = 0; i < featureList.length; i++) {
	                        if (featureList[i].get('type') === 'site') {
	                            //适配高德地图火星坐标系
	                            var adapterCoordinate = featureList[i].get('data').coordinates;
	                            var oldCoordinate = ol.proj.fromLonLat(utils.gcjTransform(adapterCoordinate));
	                            featureList[i].getGeometry().setCoordinates([oldCoordinate[0] + Dx, oldCoordinate[1] + Dy]);
	                            featureList[i].set('nowLatlon', [oldCoordinate[0] + Dx, oldCoordinate[1] + Dy]);
	                            var _cellList = featureList[i].get('data').cellInfo;
	                            for (var n = 0; n < _cellList.length; n++) {
	                                var _cell = _glbSource.getFeatureById(_cellList[n].cellId);
	                                siteAndCellLine_(params.mapId, params.layerId, featureList[i], _cell);
	                            }
	                        } else if (featureList[i].get('type') === 'cell') {
	                            var cellCoordinates;
	                            var cellData = featureList[i].get('data');
	                            var _cellCoordinate = ol.proj.fromLonLat(utils.gcjTransform(cellData.coordinates));
	                            if (cellData.cellType === 'sector') {
	                                cellCoordinates = algorithm.createSector(_cellCoordinate[0] + Dx, _cellCoordinate[1] + Dy,
	                                    cellData.radius, cellData.azimuth, cellData.angle);
	                            }
	                            else if (cellData.cellType === 'arrow') {
	                                cellCoordinates = algorithm.createArrow(_cellCoordinate[0] + Dx, _cellCoordinate[1] + Dy,
	                                    cellData.radius, cellData.azimuth, cellData.angle);
	                            } else if (cellData.cellType === 'triangle') {
	                                cellCoordinates = algorithm.createTriangle(_cellCoordinate[0] + Dx, _cellCoordinate[1] + Dy,
	                                    cellData.radius, cellData.azimuth, cellData.angle);
	                            }
	                            featureList[i].getGeometry().setCoordinates([cellCoordinates]);
	                            featureList[i].set('nowLatlon', [_cellCoordinate[0] + Dx, _cellCoordinate[1] + Dy]);
	                            var _site = _glbSource.getFeatureById(featureList[i].get('data').belongSite);
	                            siteAndCellLine_(params.mapId, params.layerId, _site, featureList[i]);
	                        } else if (featureList[i].get('type') === 'line') {
	//                            var lineCoordinate = featureList[i].get('data').coordinates;
	//                            featureList[i].getGeometry().setCoordinates([
	//                                [lineCoordinate[0][0] + Dx, lineCoordinate[0][1] + Dy],
	//                                [lineCoordinate[1][0] + Dx, lineCoordinate[1][1] + Dy]
	//                            ]);
	                        }

	                    }
	                }

	            }
	        });

	        handleUpEvent_all = _mapObj.on('pointerup', function (e) {
	            var _dx = e.coordinate[0] - downPosition[0];
	            var _dy = e.coordinate[1] - downPosition[1];
	            for (var i = 0; i < featureList.length; i++) {
	                if (featureList[i].get('type') === 'site') {
	                    var oldCoordinate = ol.proj.fromLonLat(featureList[i].get('data').coordinates);
	                    featureList[i].get('data').coordinates =
	                        ol.proj.toLonLat([oldCoordinate[0] + _dx, oldCoordinate[1] + _dy]);
	                } else if (featureList[i].get('type') === 'cell') {
	                    var cellData = featureList[i].get('data');
	                    var _cellCoordinate = ol.proj.fromLonLat(cellData.coordinates);
	                    cellData.coordinates = ol.proj.toLonLat([_cellCoordinate[0] + _dx, _cellCoordinate[1] + _dy]);
	                } else if (featureList[i].get('type') === 'line') {
	                    var lineData = featureList[i].get('data').coordinates;
	                    var newlineData = [
	                        [lineData[0][0] + _dx, lineData[0][1] + _dy],
	                        [lineData[1][0] + _dx, lineData[1][1] + _dy]
	                    ];
	                    featureList[i].get('data').coordinates = newlineData;
	                }
	            }
	            draPan.setActive(true);
	            isMove = false;
	            callbackFun();
	            _moveFeature = null;
	        })
	    }
	    else {
	        _mapObj.unByKey(handleDownEvent_all);
	        _mapObj.unByKey(handleMoveEvent_all);
	        _mapObj.unByKey(handleUpEvent_all);
	        handleDownEvent_all = null;
	        handleMoveEvent_all = null;
	        handleUpEvent_all = null;
	    }
	}

	function hightLight(params) {
	    removeHightLight({mapId: params.mapId, layerId: params.layerId});
	    var featureList = params.features;
	    var _style = params.style ? params.style : {};
	    _glbSource = getLayerSource({mapId: params.mapId, layerId: params.layerId});
	    var defindStyle = {
	        "strokeColor": "rgba(0,0,0,1)",
	        "strokeWidth": 2,
	        "fillColor": "rgba(255,255,0,0.8)",
	        radius: 5
	    };
	    utils.mixin(_style, defindStyle);
	    var cellStyle = new ol.style.Style({
	        fill: new ol.style.Fill({
	            color: _style.fillColor
	        }),
	        stroke: new ol.style.Stroke({
	            color: _style.strokeColor,
	            width: _style.strokeWidth
	        })
	    });
	    if (featureList && featureList.length > 0) {
	        for (var i = 0; i < featureList.length; i++) {
	            if (featureList[i].get('type') === 'site') {
	                var siteStyle = new ol.style.Style({
	                    image: new ol.style.Circle({
	                        radius: featureList[i].get('data').radius,
	                        fill: new ol.style.Fill({
	                            color: _style.fillColor
	                        }),
	                        stroke: new ol.style.Stroke({
	                            color: _style.strokeColor,
	                            width: _style.strokeWidth
	                        })
	                    })
	                });
	                featureList[i].setStyle(siteStyle);
	            }
	            else if (featureList[i].get('type') === 'cell') {
	                featureList[i].setStyle(cellStyle);
	            }
	        }

	    }
	    _glbSource.set('higthLight', featureList);

	}

	function removeHightLight(param) {
	    _glbSource = getLayerSource({mapId: param.mapId, layerId: param.layerId});
	    var featureList = _glbSource.get('higthLight');
	    if (featureList && featureList.length > 0) {
	        for (var i = 0; i < featureList.length; i++) {
	            if (featureList[i].get('type') === 'site') {
	                var siteStyle = new ol.style.Style({
	                    image: new ol.style.Circle({
	                        radius: featureList[i].get('data').radius,
	                        fill: new ol.style.Fill({
	                            color: featureList[i].get('data').fillColor
	                        }),
	                        stroke: new ol.style.Stroke({
	                            color: featureList[i].get('data').strokeColor,
	                            width: featureList[i].get('data').strokeWidth
	                        })
	                    })
	                });
	                featureList[i].setStyle(siteStyle);
	            }
	            else if (featureList[i].get('type') === 'cell') {
	                var cellStyle = new ol.style.Style({
	                    fill: new ol.style.Fill({
	                        color: featureList[i].get('data').fillColor
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color: featureList[i].get('data').strokeColor,
	                        width: featureList[i].get('data').strokeWidth
	                    })
	                });
	                featureList[i].setStyle(cellStyle);
	            }
	        }

	    }
	    _glbSource.set('higthLight', null);

	}

	function refreshLayer(param, callback) {
	    _glbSource = getLayerSource({mapId: param.mapId, layerId: param.layerId});
	    var featureList = _glbSource.getFeatures();
	    var callbackFun = callback;
	    var dataList = [];
	    for (var i = 0; i < featureList.length; i++) {
	        _glbSource.removeFeature(featureList[i]);
	        dataList.push(featureList[i].get('data'));
	    }
	    if (callbackFun && typeof callbackFun == 'function') {
	        callbackFun(dataList);
	    }
	}

	function siteAndCellLine_(mapId, layerId, site, cell) {
	    _glbSource = getLayerSource({mapId: mapId, layerId: layerId});
	    var lineObj = _glbSource.getFeatureById(cell.get('data').cellId + '_line');
	    var siteData = site.get('nowLatlon') ? site.get('nowLatlon') : ol.proj.fromLonLat(site.get('data').coordinates);
	    var cellData = cell.get('nowLatlon') ? cell.get('nowLatlon') : ol.proj.fromLonLat(cell.get('data').coordinates);
	    //适配高德地图火星坐标系
	    var adapterSiteCoordinate;
	    var adapterCellCoordinate;
	    if(site.get('nowLatlon')) {
	        adapterSiteCoordinate = site.get('nowLatlon');
	    } else {
	        var siteDateCoordinate = site.get('data').coordinates;
	        adapterSiteCoordinate = utils.gcjTransform(siteDateCoordinate);
	    }
	    if(cell.get('nowLatlon')) {
	        adapterCellCoordinate = cell.get('nowLatlon');
	    } else {
	        var cellDateCoordinate = cell.get('data').coordinates;
	        adapterCellCoordinate = utils.gcjTransform(cellDateCoordinate);
	    }
	    var lineGeom = new ol.geom.LineString([adapterSiteCoordinate, adapterCellCoordinate]);
	    if (lineObj) {
	        lineObj.setGeometry(lineGeom);
	        lineObj.get('data').coordinates = [siteData, cellData];
	    } else {
	        var lineStyle = new ol.style.Style({
	            fill: new ol.style.Fill({
	                color: [0, 0, 0, 0.8]
	            }),
	            stroke: new ol.style.Stroke({
	                color: [0, 0, 0, 0.8],
	                width: 2
	            })
	        });
	        var lineFeature = new ol.Feature({
	            geometry: lineGeom,
	            businessType: 'siteAndCell',
	            type: 'line',
	            data: {
	                coordinates: [siteData, cellData]
	            }
	        });
	        lineFeature.setId(cell.get('data').cellId + '_line');
	        lineFeature.setStyle(lineStyle);
	        _glbSource.addFeature(lineFeature);
	    }
	}

	function siteAndCellLine(mapId, layerId, site, cell) {
	    _glbSource = getLayerSource({mapId: mapId, layerId: layerId});
	    var lineObj = _glbSource.getFeatureById(cell.get('data').cellId + '_line');
	    var siteCoordinate = site.get('data').coordinates;
	    var cellCoordinate = cell.get('data').coordinates;
	    var siteData = ol.proj.fromLonLat(siteCoordinate);
	    var cellData = ol.proj.fromLonLat(cellCoordinate);
	    //适配高德火星坐标系
	    var deltaSiteCoordinate = ol.proj.fromLonLat(utils.gcjTransform(siteCoordinate));
	    var deltaCellCoordinate = ol.proj.fromLonLat(utils.gcjTransform(cellCoordinate));
	    var lineGeom = new ol.geom.LineString([deltaSiteCoordinate, deltaCellCoordinate]);
	    if (lineObj) {
	        lineObj.setGeometry(lineGeom);
	        lineObj.get('data').coordinates = [siteData, cellData];
	    } else {
	        var lineStyle = new ol.style.Style({
	            fill: new ol.style.Fill({
	                color: [0, 0, 0, 0.8]
	            }),
	            stroke: new ol.style.Stroke({
	                color: [0, 0, 0, 0.8],
	                width: 2
	            })
	        });
	        var lineFeature = new ol.Feature({
	            geometry: lineGeom,
	            businessType: 'siteAndCell',
	            type: 'line',
	            data: {
	                coordinates: [siteData, cellData]
	            }
	        });
	        lineFeature.setId(cell.get('data').cellId + '_line');
	        lineFeature.setStyle(lineStyle);
	        _glbSource.addFeature(lineFeature);
	    }
	}

	module.exports = {
	    addSiteAndCell: addSiteAndCell,
	    moveFeature: moveFeature,
	    moveFeatures: moveFeatures,
	    addSite: addSite,
	    addCell: addCell,
	    deleteSite: deleteSite,
	    deleteCell: deleteCell,
	    editCell: editCell,
	    editSite: editSite,
	    deleteSiteByExtent: deleteSiteByExtent,
	    removeHightLight: removeHightLight,
	    hightLight: hightLight,
	    refreshLayer: refreshLayer,
	    siteAndCellLine: siteAndCellLine
	};


/***/ },
/* 94 */
/*!*************************************************!*\
  !*** ./src/gis/businessLayers/vectorPolygon.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var event = __webpack_require__(/*! maps/event */ 11);

	function addLayer(paramObj) {
	    var _layerIdentify = paramObj.layerId + '_' + paramObj.mapId;
	    var _mapObj = mapBox.getMapObj(paramObj.mapId);
	    var _zoom = _mapObj.getView().getZoom();
	    var isShow = paramObj.isShow != undefined ? paramObj.isShow : true;
	    var _label = paramObj.label?paramObj.label:paramObj.layerId;
	    if (!hashMap.containsKey(_layerIdentify)) {
	        var _layer = new ol.layer.Vector({
	            source: new ol.source.Vector({
	                wrapX: false
	            })
	        });

	        ///自定义属性，方便后面通过类型判断对象
	        _layer.set('type', constant.CUSTOMTYPE.LAYERTYPE);
	        _layer.set('map', _mapObj);
	        _layer.set('layerId', _layerIdentify);
	        _layer.set('layer_id', paramObj.layerId);
	        _layer.set('params.label', _label);
	        _layer.set('isVectorType',true);
	        _layer.set('state.showLabel', !!paramObj.showLabel);
	        _layer.set('businessType', constant.BUSINESSTYPE.POLYGON);
	        var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.POLYGON;
	        _layer.setZIndex(_ZIndex);
	        _layer.set('multiple', paramObj.multiple);
	        _layer.set('legendName', paramObj.legendName);
	        _layer.set('clickId', 'business_vector_polygon_event_id');
	        _layer.set('isShow', isShow);
	        if (paramObj.minShowLevel != undefined) {
	            _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	        }

	        if (paramObj.maxShowLevel != undefined) {
	            _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	        }
	        hashMap.put(_layerIdentify, _layer);

	        _mapObj.addLayer(_layer);
	    }
	    event.addClickCallback(paramObj.mapId, 'business_vector_polygon_event_id', function (e) {
	        if (e.layer && e.layer.get('businessType') === constant.BUSINESSTYPE.POLYGON &&
	            e.feature && e.feature.get('businessType') === constant.BUSINESSTYPE.POLYGON) {
	            highlight(e.layer, 'click', {mapId: paramObj.mapId, layerId: paramObj.layerId, feature: e.feature});
	        } else {
	            highlights.removeHighlight({
	                mapId: paramObj.mapId,
	                layerId: paramObj.layerId,
	                hTypes: ['click']
	            });
	        }
	    }, paramObj.layerId)
	}

	/**
	 *
	 * @param paramObj
	 *   paramObj = {
	 *       datas: [
	 *           {
	 *               id: ##,
	 *               coordinates: [[x, y],[x, y],...],
	 *               fillColor: ##,
	 *               strokeColor: ##,
	 *               strokeWidth: ##,
	 *               label: ##
	 *           }
	 *       ]
	 *   }
	 */
	function setLayerData(paramObj) {
	    var _features = [];
	    var _datas = paramObj.datas;
	    var layer = layers.getLayer(paramObj);
	    layer.set('legendName', paramObj.legendName);
	    layer.set('paramObj',paramObj);
	    if (paramObj.label) {
	        layer.set('params.label', paramObj.label);
	    }
	    if (utils.isValid(_datas) || _datas.length > 0) {
	        layer.set('state.showLabel', true);
	        //ToDo: setLayerData应该清除source，这里需要和vGIS同时修改
	        var source = layer.getSource();
	        _datas.forEach(function (data) {
	            //适配高德地图火星坐标系
	            var _coordinates = utils.transformMultArray(data.coordinates);

	            var _geoPolygon = new ol.geom.Polygon([_coordinates]);
	            var _labelPoint = ol.extent.getCenter(_geoPolygon.getExtent());
	            var _feature = new ol.Feature({
	                geometry: _geoPolygon.transform(constant.PROJ.EPSG_4326, constant.PROJ.EPSG_3857),
	                labelPoint: ol.proj.fromLonLat(_labelPoint),
	                businessType: constant.BUSINESSTYPE.POLYGON,
	                data: data,
	                layerId: paramObj.layerId,
	                mapId: paramObj.mapId
	            });
	            _feature.setId(data.id);

	            var _style = new ol.style.Style({
	                fill: new ol.style.Fill({
	                    color: data.fillColor || 'rgba(0,0,0,0)'
	                }),
	                stroke: new ol.style.Stroke({
	                    color: data.strokeColor || '#000',
	                    width: data.strokeWidth ? data.strokeWidth: 0
	                }),
	                text: new ol.style.Text({
	                    text: data.label ? data.label : '',
	                    fill: new ol.style.Fill({
	                        color: data.labelFillColor || 'black'
	                    }),
	                    font: 'normal 14px Arial',
	                    stroke: new ol.style.Stroke({
	                        color: '#ffffff',
	                        width: 3
	                    })
	                })
	            });

	            var shapeStyle = new ol.style.Style({
	                fill: new ol.style.Fill({
	                    color: data.fillColor || 'rgba(0,0,0,0)'
	                }),
	                stroke: new ol.style.Stroke({
	                    color: data.strokeColor || '#000',
	                    width: data.strokeWidth ? data.strokeWidth: 0
	                })
	            });

	            _feature.setStyle(_style);
	            _feature.set('defaultStyle', _style);
	            _feature.set('shapeStyle', shapeStyle);
	            _feature.set('state.showLabel', true);
	            _features.push(_feature);
	        });

	        source.addFeatures(_features);
	    }

	}

	/**
	 * 给图层追加polygon，参数与setLayerData相同，不同之处在于此函数不清除图层中的数据
	 * @param paramObj
	 * paramObj = {
	 *       mapId:'string',
	 *       layerId:'string',
	 *       datas: [
	 *           {
	 *               id: ##,
	 *               coordinates: [[x, y],[x, y],...],
	 *               fillColor: ##,
	 *               strokeColor: ##,
	 *               strokeWidth: ##,
	 *               label: ##
	 *           }
	 *       ]
	 *   }
	 */
	function appendLayerData(paramObj) {
	    var _features = [];
	    var _datas = paramObj.datas;
	    var layer = layers.getLayer(paramObj);
	    if (paramObj.label) {
	        layer.set('params.label', paramObj.label);
	    }
	    if (utils.isValid(_datas) || _datas.length > 0) {
	        layer.set('state.showLabel', true);
	        var source = layer.getSource();
	        _datas.forEach(function (data) {
	            //适配高德地图火星坐标系
	            var _coordinates = utils.transformMultArray(data.coordinates);
	            var _strokeWidth = data.strokeWidth !== undefined ? data.strokeWidth : 0;
	            var _geoPolygon = new ol.geom.Polygon([_coordinates]);
	            var _labelPoint = ol.extent.getCenter(_geoPolygon.getExtent());
	            var defaultHighLight = {
	                fillColor: data.fillColor ? data.fillColor : 'rgba(255,0,255,0.3)',
	                strokeColor: 'black',
	                strokeWidth: _strokeWidth,
	                labelFillColor: data.labelFillColor || 'black',
	                labelStrokeColor: data.labelStrokeColor || '#ffffff'
	            };
	            var _feature = new ol.Feature({
	                geometry: _geoPolygon.transform(constant.PROJ.EPSG_4326, constant.PROJ.EPSG_3857),
	                labelPoint: ol.proj.fromLonLat(_labelPoint),
	                businessType: constant.BUSINESSTYPE.POLYGON,
	                data: data,
	                layerId: paramObj.layerId,
	                mapId: paramObj.mapId,
	                select: data.hightLight ? data.hightLight : defaultHighLight
	            });
	            _feature.setId(data.id);

	            var _style = new ol.style.Style({
	                fill: new ol.style.Fill({
	                    color: data.fillColor || 'rgba(0,0,0,0)'
	                }),
	                stroke: new ol.style.Stroke({
	                    color: data.strokeColor || '#000',
	                    width: data.strokeWidth ? data.strokeWidth: 0
	                }),
	                text: new ol.style.Text({
	                    text: data.label ? data.label : '',
	                    fill: new ol.style.Fill({
	                        color: data.labelFillColor || 'black'
	                    }),
	                    font: 'normal 14px Arial',
	                    stroke: new ol.style.Stroke({
	                        color: '#ffffff',
	                        width: 3
	                    })
	                })
	            });

	            var shapeStyle = new ol.style.Style({
	                fill: new ol.style.Fill({
	                    color: data.fillColor || 'rgba(0,0,0,0)'
	                }),
	                stroke: new ol.style.Stroke({
	                    color: data.strokeColor || '#000',
	                    width: data.strokeWidth ? data.strokeWidth: 0
	                })
	            });

	            _feature.setStyle(_style);
	            _feature.set('defaultStyle', _style);
	            _feature.set('shapeStyle', shapeStyle);
	            _feature.set('state.showLabel', true);
	            _features.push(_feature);
	        });
	        source.addFeatures(_features);
	    }

	}

	function highlight(olLayer, hType, params) {
	    var olMap = olLayer.get('map');
	    var mapId = olMap.getTarget();
	    var layerId = olLayer.get('layer_id');
	    var layerType = olLayer.get('businessType');
	    highlights.removeHighlight({
	        mapId: mapId,
	        layerId: layerId,
	        hTypes: ['click']
	    });
	    var hLayer = highlights.getHLayer({
	        mapId: mapId,
	        layerId: layerId
	    });
	    if (hType === constant.HTYPE.CLICK) {
	        if(params.feature){
	            var nFeature =params.feature;
	            var hightLight = params.feature.get('select');

	            nFeature = nFeature.clone();
	            var _style = new ol.style.Style({
	                fill: new ol.style.Fill({
	                    color: hightLight.fillColor
	                }),
	                stroke: new ol.style.Stroke({
	                    width: hightLight.strokeWidth,
	                    color: hightLight.strokeColor
	                })
	            });
	            nFeature.setStyle(_style);

	            nFeature.setId(params.geoId);
	            nFeature.set('mapId', mapId);
	            nFeature.set('layerId', layerId);
	            nFeature.set('layerType', layerType);
	            nFeature.set('hType', hType);
	            nFeature.set('layer',hLayer);

	            //数组copy
	            var _feature =nFeature;
	            _feature = utils.compact(_feature);
	            hLayer.getSource().addFeature(_feature);
	        }

	    }
	    else if (hType === constant.HTYPE.VECTOR) {
	        var features = params.geoIds.map(function (geoId) {
	            var f = olLayer.getSource().getFeatureById(geoId);
	            var hightLight = f.get('select');
	            if (!f) {
	                return;
	            }
	            f = f.clone();
	            var _style = new ol.style.Style({
	                fill: new ol.style.Fill({
	                    color: hightLight.fillColor
	                }),
	                stroke: new ol.style.Stroke({
	                    width: hightLight.strokeWidth,
	                    color: hightLight.strokeColor
	                })
	            });
	            f.setStyle(_style);
	            f.setId(params.geoId);
	            f.set('mapId', mapId);
	            f.set('layerId', layerId);
	            f.set('layerType', layerType);
	            f.set('hType', hType);
	            f.set('layer',hLayer);
	            return f;
	        });

	        features = utils.compact(features);
	        /*将feature加到高亮图层上*/
	        hLayer.getSource().addFeatures(features);
	    }
	}

	function getLineLonLat(param, callback) {
	    var olLayer = layers.getLayer({
	        mapId: param.mapId,
	        layerId: param.layerId
	    });
	    if (!olLayer && param.sourceLayerType !== 'POLYGON') {
	        callback();
	        return;
	    }
	    var geometry = olLayer.getSource().getFeatureById(param.geoId).getGeometry();
	    var points = geometry.getCoordinates()[0];
	    var temp = (points[0][0] - param.targetPoint[0]) * (points[0][0] - param.targetPoint[0]) +
	        (points[0][1] - param.targetPoint[1]) * (points[0][1] - param.targetPoint[1]);
	    var distance = 0, num;
	    points.forEach(function (point, i) {
	        distance = (point[0] - param.targetPoint[0]) * (point[0] - param.targetPoint[0]) +
	            (point[1] - param.targetPoint[1]) * (point[1] - param.targetPoint[1]);
	        if (temp > distance) {
	            temp = distance;
	            num = i;
	        }
	    });
	    callback(points[num]);
	}

	function setShowLabel(param) {
	    var layer = layers.getLayer(param);
	    if (!layer) {
	        return;
	    }
	    var showLabel = layer.get('state.showLabel');
	    var features = layer.getSource().getFeatures().slice(0);
	    features.forEach(function (f) {
	        if (param.showLabel && !showLabel) {
	            f.setStyle(f.get('defaultStyle'));
	        }
	        else if (!param.showLabel && showLabel) {
	            f.setStyle(f.get('shapeStyle'));
	        }
	    });
	    layer.set('state.showLabel', !!param.showLabel);
	}

	module.exports = {
	    addLayer: addLayer,
	    appendLayerData: appendLayerData,
	    setLayerData: setLayerData,
	    highlight: highlight,
	    getLineLonLat: getLineLonLat,
	    setShowLabel: setShowLabel
	};

/***/ },
/* 95 */
/*!******************************************!*\
  !*** ./src/gis/businessLayers/dcGrid.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var maps = __webpack_require__(/*! maps/map */ 8);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var ajax = __webpack_require__(/*! utils/ajax */ 14);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);
	var event = __webpack_require__(/*! maps/event */ 11);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var addLayer = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId;
	    var _map = hashMap.get(paramObj.mapId);
	    var _zoom = _map.getView().getZoom();
	    var _layer = null;

	    if (!hashMap.containsKey(_layerId)) {
	        _layer = new ol.layer.Tile({
	            source: new ol.source.TileWMS({
	                wrapX: false
	            })
	        });
	        var _imageLayer = new ol.layer.Image({
	            source: new ol.source.ImageWMS({
	                wrapX: false
	            })
	        });
	        _layer.set('imageLayer', _imageLayer);
	        var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.GRID;
	        _layer.setZIndex(_ZIndex);
	        _layer.set('type', constant.CUSTOMTYPE.LAYERTILETYPE);
	        _layer.set('isVectorType',false);
	        _layer.set('businessType', constant.BUSINESSTYPE.GRID);
	        _layer.set('params.label', paramObj.label);
	        _layer.set('layerId', _layerId);
	        _layer.set('map', _map);
	        _layer.set('layer_id', paramObj.layerId);

	        if (!!paramObj.multiple) {
	            _layer.set('multiple', paramObj.multiple);
	        }

	        hashMap.put(_layerId, _layer);
	        _map.addLayer(_layer);

	    }
	    else {
	        _layer = hashMap.get(_layerId);
	    }
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	    }

	    _layer.set('clickId', 'business_Dgrid_event_id');
	    event.addClickCallback(paramObj.mapId, 'business_Dgrid_event_id', function (object) {
	        var layer = baseLayer.getLayer({
	            mapId:paramObj.mapId,
	            layerId:paramObj.layerId
	        })
	        if (layer && layer.get('gridType') !== 8) {
	            var mapObj = mapBox.getMapObj(paramObj.mapId);
	            
	            var transportDataToInnerLayer = object.transportDataToInnerLayer;
	            if (transportDataToInnerLayer) {
	                if (!!transportDataToInnerLayer && transportDataToInnerLayer.length > 0) {
	                    highlight(layer, 'click', transportDataToInnerLayer[0]);
	                }
	            }
	            else {
	                highlights.removeHighlight({
	                    mapId: paramObj.mapId,
	                    layerId: paramObj.layerId,
	                    hTypes: ['click']
	                });
	            }
	        }
	    }, paramObj.layerId)
	};

	var setLayerData = function (paramObj) {
	    var _imgTokenParam = paramObj.imgTokenParam;
	    var _imgToken = paramObj.imgToken;
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId;
	    var _gridType = paramObj.gridType ? paramObj.gridType : undefined;
	    var _layers = paramObj.layers ? paramObj.layers : undefined;
	    var _isSolidGrid = paramObj.ISSOLIDGRID ? paramObj.ISSOLIDGRID : true;
	    var mapObj = mapBox.getMapObj(_mapId);
	    var layer = layers.getLayer({
	        mapId: _mapId,
	        layerId: _layerId
	    });

	    if (layer) {
	        var source;
	        if (paramObj.label) {
	            layer.set('label', paramObj.label);
	        }
	        if (_gridType === 8 || _isSolidGrid === false) {
	            source = new ol.source.ImageWMS({
	                url: constant.GisRootUrl + '/gridManager/export',
	                params: {
	                    GRIDTYPE: _gridType,
	                    LAYERS: _layers,
	                    IMGTOKEN: _imgToken,
	                    VERSION: '1.1.1',
	                    ISSOLIDGRID: _isSolidGrid,
	                    cacheKey :_imgToken
	                },
	                wrapX: false
	            });
	            mapObj.addLayer(layer.get('imageLayer'));
	            layer.get('imageLayer').setSource(source);
	            layer.set('imgToken', _imgToken);
	            layer.set('gridType', _gridType);
	            //栅格抽稀时，地图缩放需要从新下发请求，必须保存下发的条件
	            layer.set('imgTokenParam', _imgTokenParam);
	        }
	        else {
	            source = new ol.source.TileWMS({
	                url: constant.GisRootUrl + '/gridManager/export',
	                params: {
	                    GRIDTYPE: _gridType,
	                    LAYERS: _layers,
	                    IMGTOKEN: _imgToken,
	                    VERSION: '1.1.1',
	                    ISSOLIDGRID: _isSolidGrid,
	                    cacheKey :_imgToken
	                },
	                wrapX: false
	            });
	            mapObj.addLayer(layer);
	            layer.setSource(source);
	            layer.set('imgToken', _imgToken);
	            layer.set('gridType', _gridType);
	            //栅格抽稀时，地图缩放需要从新下发请求，必须保存下发的条件
	            layer.set('imgTokenParam', _imgTokenParam);
	        }
			layer.set('paramObj',paramObj);
	    }
	};

	var getClickData = function (mapObj, layerObj, evt, callback) {
	    var extent = maps.getExtent(mapObj.getTarget());
	    var layerParamObj = layerObj.get('paramObj');
	    var paramObj = {
	        geometry: {x: evt.coordinate[0], y: evt.coordinate[1]},
	        tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  1,
	        mapExtent: extent,
	        imgToken: layerObj.get('imgToken')
	    };
	    ajax.postJSON({
	        url: constant.GisRootUrl + '/gridManager/getGridInfo?cacheKey=' +layerObj.get('imgToken'),
	        data: JSON.stringify(paramObj),
	        success: function (result) {
	            var responseText = JSON.parse(result);
	            var status = responseText.status;
	            var data = responseText.data && responseText.data.length > 0 && responseText.data[0];
	            if (status.code === 1) { //请求成功，可能有数据，可能没数据
	                if (data) {
	                    if (callback && typeof callback === 'function') {
	                        callback([
	                            {
	                                mapId: mapObj.getTarget(),
	                                layerId: layerObj.get('layer_id'),
	                                layerType: layerObj.get('businessType'),
	                                label: layerObj.get('params.label'),
	                                lonLat: data.centerPoint,
	                                geometry: data.geometry,
	                                extentInfo: data.extentInfo,
	                                geoId: data.id,
	                                geoName: data.name
	                            }
	                        ]);
	                    }
	                }
	                else {
	                    callback([]);
	                }
	            }
	            else {
	                callback([]);
	            }
	        },
	        failure: function(result) {
	        	callback([]);
	        }
	    });
	};

	function highlight(layerObj, hType, params) {
	    var olMap = layerObj.get('map');
	    var mapId = olMap.getTarget();
	    var layerId = layerObj.get('layer_id');
	    var layerType = layerObj.get('businessType');

	    highlights.removeHighlight({
	        mapId: mapId,
	        layerId: layerId,
	        hTypes: ['click']
	    });

	    if (hType === constant.HTYPE.CLICK) {
	        _clickHighlight(mapId, layerId, layerType, hType, params);
	    }
	    else if (hType === constant.HTYPE.VECTOR) {
	        _vectorHighlight(mapId, layerId, layerType, hType, params, layerObj);
	    }
	}

	/**
	 * 点击高亮栅格
	 * @param mapId
	 * @param layerId
	 * @param layerType
	 * @param hType
	 * @param params
	 * @private
	 */
	function _clickHighlight(mapId, layerId, layerType, hType, params) {
	    var points = params.geometry;
	    var lonConstant = 50,
	        tempMaxLon,
	        tempMinLon,
	        _points = [];
	    tempMinLon = params.lonLat[0] - lonConstant / 2;
	    tempMaxLon = params.lonLat[0] + lonConstant / 2;
	    _points.push([tempMinLon, points[1]]);
	    _points.push([tempMaxLon, points[1]]);
	    _points.push([tempMaxLon, points[3]]);
	    _points.push([tempMinLon, points[3]]);
	    _points = utils.transformMultArray(_points);
	    var feature = new ol.Feature({
	        geometry: new ol.geom.Polygon([_points]),
	        mapId: mapId,
	        layerId: layerId,
	        layerType: layerType,
	        hType: hType
	    });

	    var style = new ol.style.Style({
	        stroke: new ol.style.Stroke({
	            width: 2,
	            color: 'black'
	        })
	    });

	    feature.setStyle(style);
	    var layerObj = highlights.getHLayer({
	        mapId: mapId,
	        layerId: layerId
	    });
	    layerObj.getSource().addFeature(feature);
	}

	/**
	 * 通过数据高亮栅格
	 * @param mapId
	 * @param layerId
	 * @param layerType
	 * @param hType
	 * @param pointData
	 * @param layerObj
	 * @private
	 */
	function _vectorHighlight(mapId, layerId, layerType, hType, pointData, layerObj) {
	    var points = [];
	    pointData.coordinates.forEach(function (coordinate) {
	        points.push({
	            x: coordinate[0],
	            y: coordinate[1]
	        });
	    });
	    ajax.postJSON({
	        url: constant.GisRootUrl + '/gridManager/queryGridInfo?cacheKey=' +layerObj.get('imgToken'),
	        data: JSON.stringify({
	            points: points,
	            imgToken: layerObj.get('imgToken')
	        }),
	        success: function (result) {
	            if (!result) {
	                return;
	            }
	            result = JSON.parse(result);
	            if (result.status.code !== 1 || !result.data || !result.data.length) {
	                return;
	            }

	            var features = result.data.map(function (pointData) {
	                var points = pointData.geometry;
	                var lonConstant = 50, tempMaxLon, tempMinLon, _points = [];
	                tempMinLon = pointData.centerPoint[0] - lonConstant / 2;
	                tempMaxLon = pointData.centerPoint[0] + lonConstant / 2;
	                _points.push([tempMinLon, points[1]]);
	                _points.push([tempMaxLon, points[1]]);
	                _points.push([tempMaxLon, points[3]]);
	                _points.push([tempMinLon, points[3]]);
	                _points = utils.transformMultArray(_points);
	                var feature = new ol.Feature({
	                    geometry: new ol.geom.Polygon([_points]),
	                    mapId: mapId,
	                    layerId: layerId,
	                    layerType: layerType,
	                    hType: hType
	                });

	                var style = new ol.style.Style({
	                    stroke: new ol.style.Stroke({
	                        width: 2,
	                        color: 'black'
	                    })
	                });

	                feature.setStyle(style);
	                return feature;
	            });

	            var layerObj = highlights.getHLayer({
	                mapId: mapId,
	                layerId: layerId
	            });
	            layerObj.getSource().addFeatures(features);
	        },
	        failure: function(result) {
				
	        }
	    });
	}

	module.exports = {
	    addLayer: addLayer,
	    setLayerData: setLayerData,
	    getClickData: getClickData,
	    highlight: highlight
	};

/***/ },
/* 96 */
/*!******************************************!*\
  !*** ./src/gis/businessLayers/dcCell.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 加载服务栅格。
	 * 1、下发查询条件，获取ImageToken;
	 * 2、下发查询条件，export服务栅格图片。
	 *
	 *
	 */
	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var ajax = __webpack_require__(/*! utils/ajax */ 14);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);
	var event = __webpack_require__(/*! maps/event */ 11);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	function addLayer(paramObj) {
	    var layerId = paramObj.layerId + '_' + paramObj.mapId;
	    var olMap = hashMap.get(paramObj.mapId);
	    var _zoom = olMap.getView().getZoom();
	    var olLayer = null;
	    if (!hashMap.containsKey(layerId)) {
	        olLayer = new ol.layer.Image({
	            source: new ol.source.ImageWMS({
	                params: {
	                    VERSION: '1.1.1'
	                },
	                wrapX: false
	            })
	        });
	        

	        if (!!paramObj.multiple) {
	            olLayer.set('multiple', paramObj.multiple);
	        }
	        var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex :constant.Z_INDEX.CELL;
	        olLayer.setZIndex(_ZIndex);
	        olLayer.set('type', constant.CUSTOMTYPE.LAYERIMGTYPE);
	        olLayer.set('isVectorType',false);
	        olLayer.set('businessType', 'DCELL');
	        olLayer.set('params.label', paramObj.label);
	        olLayer.set('state.showLabel', !!paramObj.showLabel);
	        olLayer.set('layerId', layerId);
	        olLayer.set('map', olMap);
	        olLayer.set('layer_id', paramObj.layerId);

	        hashMap.put(layerId, olLayer);
	        olMap.addLayer(olLayer);
	    }
	    else {
	        olLayer = hashMap.get(layerId);
	    }

	    
	    if (paramObj.minShowLevel != undefined) {
	        olLayer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        olLayer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	    }

	    olLayer.set('clickId', 'business_Dservice_cell_event_id');
	    event.addClickCallback(paramObj.mapId, 'business_Dservice_cell_event_id', function (e) {
	        if (e.layer && e.layer.get('businessType') === 'DCELL') {
	            var mapObj = mapBox.getMapObj(paramObj.mapId);
	            
	            
	            var transportDataToInnerLayer = e.transportDataToInnerLayer;
	            if (transportDataToInnerLayer) {
	                if (!!transportDataToInnerLayer && transportDataToInnerLayer.length > 0) {
	                    highlight(e.layer, 'click', transportDataToInnerLayer[0]);
	                }
	            }
	            else {
	                highlights.removeHighlight({
	                    mapId: paramObj.mapId,
	                    layerId: paramObj.layerId,
	                    hTypes: ['click']
	                });
	            }
	        }

	    }, paramObj.layerId)
	}

	/**
	 *
	 * @param paramObj = {
	 *      data: {
	 *          mapId: ''
	 *          layerId: ''
	 *          layerType: 'POLYGON'
	 *          isUserDefinedLegend: 1, 是否使用用户自定义的图例 0：是， 1：否
	 *          renderParam: {
	 *              legendInfo : {
	 *                  legendType : 'singleColor' //图例类型'singleColor' | 'rangeColor' | 'singleSymbol' | 'rangeSymbol'
	 *                  renderStyle: {String} //渲染的样式Border、Fill
	 *                  legendList : [
	 *                      {
	 *                          'label' : '较差' //单一值名称
	 *                          'value' : [string1, string2]//分段值
	 *                          'style' : '255,255,0' //RGB色值,,或者 符号文件的地址
	 *                          'count' : 1000, ///
	 *                          'percent' : 0.2 ///
	 *                      }
	 *                  ]
	 *               }
	 *          },
	 *          queryParam: {
	 *
	 *          },
	 *          geoParams: {
	 *
	 *          }
	 *      }
	 * }
	 */
	function setLayerData(paramObj) {
	    var layer = layers.getLayer(paramObj);
	    layer.set('params.imgToken', paramObj.imgToken);
	    layer.set('imgToken', paramObj.imgToken);
	    layer.set('imgTokenLabel', paramObj.imgTokenLabel);
	    layer.set('params.imgTokenLabel', paramObj.imgTokenLabel);
	    layer.set('paramObj',paramObj);
	    if (paramObj.label) {
	        layer.set('params.label', paramObj.label);
	    }
	    layer.set('state.showLabel', !!paramObj.showLabel);
	    var imgToken = (paramObj.showLabel ? paramObj.imgTokenLabel : paramObj.imgToken);
	    var Fcname = imgToken != undefined ?  imgToken.slice(0, imgToken.indexOf(':')) : undefined;
	    var updateParams = {
	        VERSION: '1.1.1',
	        imgToken: imgToken,
	        FCName:Fcname
	    };
	    if (layer) {
	        layer.getSource().setUrl(constant.GisRootUrl + '/common/mapRender/export');
	        layer.getSource().updateParams(updateParams);
	    }
	}

	function getClickData(olMap, olLayer, evt, callback) {
		if(!olLayer.getVisible()) {
			callback([]);
			return;
		}
		var cellPath, mapExtent, imgToken, geometry;
		if(!!evt.coordinate) {
			geometry = JSON.stringify({
				x: evt.coordinate[0],
				y: evt.coordinate[1]
			});
			mapExtent = olMap.getView().calculateExtent(olMap.getSize()).join(',');
			imgToken = olLayer.get('params.imgToken');
			var Fcname = imgToken.slice(0, imgToken.indexOf(':'));
			var layerParamObj = olLayer.get('paramObj');
			var params = {
				geometry: geometry,
				tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  0.1,
				mapExtent: mapExtent,
				imgToken: imgToken,
				FCName: Fcname
			};
			cellPath = constant.GisRootUrl + 'common/mapRender/identify';
		}
		ajax.get({
			url: cellPath,
			data: utils.getParameterString(params),
			success: function(res) {
				if(!res) {
					callback([]);
					return;
				}
				res = JSON.parse(res);
				if(!res || !res.data || !res.data.length) {
					callback([]);
					return;
				}

				var result = utils.sortBy(res.data, function(j) {
					if(j.extentInfo.isDirect === '0') {
						j.extentInfo.radius = j.extentInfo.radius * 2;
					}
					return Number(j.extentInfo.radius);
				});
				var minRadus = result[0].extentInfo.radius;
				result = result.filter(function(item) {
					return item.extentInfo.radius === minRadus;
				});
				result.forEach(function(r) {
					if(r.extentInfo.isDirect === '0') {
						r.extentInfo.radius = r.extentInfo.radius / 2;
					}
				});
				var backJson = result.map(function(item) {
					return {
						mapId: olMap.getTarget(),
						layerId: olLayer.get('layer_id'),
						layerType: olLayer.get('businessType'),
						label: olLayer.get('params.label'),
						lonLat: evt.coordinate,
						geometry: item.geometry,
						extentInfo: item.extentInfo,
						geoId: item.id,
						geoName: item.name
					};
				});
				callback(backJson);
			},
			failure: function(res) {
				callback([]);
			}
		});
	}

	function highlight(olLayer, hType, params, callback) {
		var olMap = olLayer.get('map');
		var mapId = olMap.getTarget();
		var layerId = olLayer.get('layer_id');
		var layerType = olLayer.get('businessType');
		var nFeature;

		highlights.removeHighlight({
			mapId: mapId,
			layerId: layerId,
			hTypes: ['click']
		});
		if(hType === constant.HTYPE.CLICK) {
			var points = JSON.parse(params.geometry);
			var _lineString = new ol.geom.LineString(points);
	        _lineString = utils.transformMultArray(_lineString.getCoordinates());
			nFeature = new ol.Feature({
	            geometry: new ol.geom.Polygon([_lineString]),
				mapId: mapId,
				layerId: layerId,
				layerType: layerType,
				hType: hType
			});

			var _style = new ol.style.Style({
				stroke: new ol.style.Stroke({
					width: 2,
					color: 'black'
				})
			});

			nFeature.setStyle(_style);
			var hLayer = highlights.getHLayer({
				mapId: mapId,
				layerId: layerId
			});
			hLayer.getSource().addFeature(nFeature);

		} else if(hType === constant.HTYPE.VECTOR) {
			queryGeometry(olLayer, params, function(result) {
				if(!result) {
					return;
				}
				var features = [];

				var _style = new ol.style.Style({
					stroke: new ol.style.Stroke({
						width: 2,
						color: 'black'
					})
				});
				result.map(function(r) {
	                var _coordinate = utils.transformMultArray(JSON.parse(r.geometry));
					nFeature = new ol.Feature({
	                    geometry: new ol.geom.Polygon([_coordinate]),
						mapId: mapId,
						layerId: layerId,
						layerType: layerType,
						hType: hType
					});
					nFeature.setStyle(_style);
					features.push(nFeature);
				});

	            var hLayer = highlights.getHLayer({
	                mapId: mapId,
	                layerId: layerId
	            });
	            hLayer.getSource().addFeatures(features);
	            if (callback) {
	                callback(result);
	            }
	        });
	    }
	}

	function queryGeometry(olLayer, params, callback) {
	    var imgToken = olLayer.get('params.imgToken');
	    var Fcname = imgToken != undefined ?  imgToken.slice(0, imgToken.indexOf(':')) : undefined;
	    var url = constant.GisRootUrl + '/common/mapRender/query?FCName='+Fcname;
	    ajax.postJSON({
	        url: url,
	        data: JSON.stringify({
	            idValue: params.geoIds,
	            imgToken: imgToken
	        }),
	        success: function (rs) {
	            var result = JSON.parse(rs);
	            if (!result || !result.data || !result.data.length) {
	                callback(null);
	            }
	            else {
	                callback(result.data);
	            }
	        },
	        failure: function(e) {
	        	callback(null);
	        }
	    });
	}

	//获取连线端点的位置（经纬度）
	function getLineLonLat(param, callback) {
	    var lineLngLat;
	    var olLayer = layers.getLayer({
	        mapId: param.mapId,
	        layerId: param.layerId
	    });
	    if (!olLayer) {
	        callback();
	        return;
	    }
	    queryGeometry(olLayer, {
	        geoIds: [param.geoId]
	    }, function (res) {
	        if (!res) {
	            return;
	        }
	        lineLngLat = res ; //res[0].extentInfo.circleCenter;
	        //lineLngLat = ol.proj.fromLonLat(lineLngLat);
	        callback(lineLngLat);
	    });
	}

	function setShowLabel(param) {
	    var layer = layers.getLayer(param);
	    if (!layer) {
	        return;
	    }
	    var imgToken;
	    if (param.showLabel) {
	        imgToken = layer.get('params.imgTokenLabel');
	    }
	    else {
	        imgToken = layer.get('params.imgToken');
	    }
	    var updateParams = {
	        VERSION: '1.1.1',
	        imgToken: imgToken
	    };
	    layer.set('state.showLabel', !!param.showLabel);
	    layer.getSource().updateParams(updateParams);
	}

	module.exports = {
	    addLayer: addLayer,
	    setLayerData: setLayerData,
	    getClickData: getClickData,
	    highlight: highlight,
	    getLineLonLat: getLineLonLat,
	    setShowLabel: setShowLabel
	};

/***/ },
/* 97 */
/*!******************************************!*\
  !*** ./src/gis/businessLayers/dcSite.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 加载服务栅格。
	 * 1、下发查询条件，获取ImageToken;
	 * 2、下发查询条件，export服务栅格图片。
	 *
	 *
	 */
	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var ajax = __webpack_require__(/*! utils/ajax */ 14);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);
	var event = __webpack_require__(/*! maps/event */ 11);

	function addLayer(paramObj) {
	    var layerId = paramObj.layerId + '_' + paramObj.mapId;
	    var olMap = mapBox.getMapObj(paramObj.mapId);
	    var _zoom = olMap.getView().getZoom();

	    if (!hashMap.containsKey(layerId)) {
	        var olLayer = new ol.layer.Image({
	            source: new ol.source.ImageWMS({
	                params: {
	                    VERSION: '1.1.1'
	                },
	                wrapX: false
	            })
	        });
	        

	        var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.SITE;
	        olLayer.setZIndex(_ZIndex);
	        olLayer.set('type', constant.CUSTOMTYPE.LAYERIMGTYPE);
	        olLayer.set('isVectorType',false);
	        olLayer.set('businessType', constant.BUSINESSTYPE.SITE);
	        olLayer.set('params.label', paramObj.label);
	        olLayer.set('state.showLabel', !!paramObj.showLabel);
	        olLayer.set('layerId', layerId);
	        olLayer.set('map', olMap);
	        olLayer.set('layer_id', paramObj.layerId);
	        olLayer.set('multiple', paramObj.multiple);
	        olLayer.set('clickId', 'business_Dservice_site_event_id');
	        if (paramObj.minShowLevel != undefined) {
	            _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	        }

	        if (paramObj.maxShowLevel != undefined) {
	            _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	        }
	        hashMap.put(layerId, olLayer);
	        olMap.addLayer(olLayer);
	    }
	    
	    event.addClickCallback(paramObj.mapId, 'business_Dservice_site_event_id', function (object) {
	        if (object.layer && object.layer.get('businessType') === constant.BUSINESSTYPE.SITE) {
	            var mapObj = mapBox.getMapObj(paramObj.mapId);
	            
	            var transportDataToInnerLayer = object.transportDataToInnerLayer;
	            if (transportDataToInnerLayer) {
	                if (!!transportDataToInnerLayer && transportDataToInnerLayer.length > 0) {
	                    highlight(object.layer, 'click', transportDataToInnerLayer[0]);
	                }
	            }
	            else {
	                highlights.removeHighlight({
	                    mapId: paramObj.mapId,
	                    layerId: paramObj.layerId,
	                    hTypes: ['click']
	                });
	            }
	        }
	    }, paramObj.layerId)
	}

	/**
	 *
	 * @param paramObj = {
	     *      data: {
	     *          mapId: ''
	     *          layerId: ''
	     *          layerType: 'POLYGON'
	     *          isUserDefinedLegend: 1, 是否使用用户自定义的图例 0：是， 1：否
	     *          renderParam: {
	     *              legendInfo : {
	     *                  legendType : 'singleColor' //图例类型'singleColor' | 'rangeColor' | 'singleSymbol' | 'rangeSymbol'
	     *                  renderStyle: {String} //渲染的样式Border、Fill
	     *                  legendList : [
	     *                      {
	     *                          'label' : '较差' //单一值名称
	     *                          'value' : [string1, string2]//分段值
	     *                          'style' : '255,255,0' //RGB色值,,或者 符号文件的地址
	     *                          'count' : 1000, ///
	     *                          'percent' : 0.2 ///
	     *                      }
	     *                  ]
	     *               }
	     *          },
	     *          queryParam: {
	     *
	     *          },
	     *          geoParams: {
	     *
	     *          }
	     *      }
	     * }
	 */
	function setLayerData(paramObj) {
	    var layer = layers.getLayer(paramObj);
	    layer.set('params.imgToken', paramObj.imgToken);
	    layer.set('params.imgTokenLabel', paramObj.imgTokenLabel);
	    layer.set('state.showLabel', !!paramObj.showLabel);
	    layer.set('paramObj',paramObj);
	    if (paramObj.label) {
	        layer.set('params.label', paramObj.label);
	    }
	    var imgToken = (paramObj.showLabel ? paramObj.imgTokenLabel : paramObj.imgToken);
	    var Fcname = imgToken.slice(0, imgToken.indexOf(':'));
	    var updateParams = {
	        VERSION: '1.1.1',
	        imgToken: imgToken,
	        Fcname: Fcname
	    };
	    if (layer) {
	        layer.getSource().setUrl(constant.GisRootUrl + '/common/mapRender/export');
	        layer.getSource().updateParams(updateParams);
	    }
	}

	function getClickData(olMap, olLayer, evt, callback) {
	    if (!olLayer.getVisible()) {
	        callback([]);
	        return;
	    }
	    var imgToken = olLayer.get('params.imgToken');
	    var Fcname = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
	    var sitePath = constant.GisRootUrl + '/common/mapRender/identify';
	    var geometry = JSON.stringify({x: evt.coordinate[0], y: evt.coordinate[1]});
	    var mapExtent = olMap.getView().calculateExtent(olMap.getSize()).join(',');
	    var layerParamObj = olLayer.get('paramObj');
	    var params = {
	        geometry: geometry,
	        tolerance: (layerParamObj != undefined && layerParamObj.tolerance != undefined) ? layerParamObj.tolerance :  1,
	        mapExtent: mapExtent,
	        imgToken: imgToken,
	        FCName: Fcname
	    };
	    ajax.get({
	    	url: sitePath,
	    	data: utils.getParameterString(params),
	    	success: function(res) {
	    		if(!res) {
	    			callback([]);
	    			return;
	    		}
	    		res = JSON.parse(res);
	    		if(!res || !res.data || !res.data.length) {
	    			callback([]);
	    			return;
	    		}

	    		var result = res.data;
	    		var backJSON = result.map(function(item) {
	    			return {
	    				mapId: olMap.getTarget(),
	    				layerId: olLayer.get('layer_id'),
	    				layerType: olLayer.get('businessType'),
	    				label: olLayer.get('params.label'),
	    				lonLat: evt.coordinate,
	    				geometry: item.geometry,
	    				geoId: item.id,
	    				geoName: item.name
	    			};
	    		});

	    		callback(backJSON);
	    	},
	    	failure: function(res) {
				callback([]);
	    	}
	    });
	}


	function highlight(olLayer, hType, params, callback) {
	    var olMap = olLayer.get('map');
	    var mapId = olMap.getTarget();
	    var layerId = olLayer.get('layer_id');
	    var layerType = olLayer.get('businessType');
	    var nFeature;

	    highlights.removeHighlight({
	        mapId: mapId,
	        layerId: layerId
	    });
	    if (hType === constant.HTYPE.CLICK) {
	        var points = params.geometry;
	        points = utils.gcjTransform(points);
	        nFeature = new ol.Feature({
	            geometry: new ol.geom.Point(points),
	            mapId: mapId,
	            layerId: layerId,
	            layerType: layerType,
	            hType: hType
	        });

	        var _style = new ol.style.Style({
	            image: new ol.style.Circle({
	                stroke: new ol.style.Stroke({
	                    width: 2,
	                    color: '#000'
	                }),
	                radius: 5
	            })
	        });

	        nFeature.setStyle(_style);
	        var hLayer = highlights.getHLayer({
	            mapId: mapId,
	            layerId: layerId
	        });
	        hLayer.getSource().addFeature(nFeature);

	    }
	    else if (hType === constant.HTYPE.VECTOR) {
	        queryGeometry(olLayer, params, function (result) {
	            var points;
	            if (!result) {
	                return;
	            }

	            points = result[0].geometry;
	            points = utils.gcjTransform(points);
	            nFeature = new ol.Feature({
	                geometry: new ol.geom.Point(points),
	                mapId: mapId,
	                layerId: layerId,
	                layerType: layerType,
	                hType: hType
	            });

	            var _style = new ol.style.Style({
	                image: new ol.style.Circle({
	                    stroke: new ol.style.Stroke({
	                        width: 2,
	                        color: '#000'
	                    }),
	                    radius: 5
	                })
	            });

	            nFeature.setStyle(_style);
	            var hLayer = highlights.getHLayer({
	                mapId: mapId,
	                layerId: layerId
	            });
	            hLayer.getSource().addFeature(nFeature);
	            if (callback) {
	                callback(result);
	            }
	        });
	    }
	}

	function queryGeometry(olLayer, params, callback) {
	    var imgToken = olLayer.get('params.imgToken');
	    var Fcname = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
	    var action = constant.GisRootUrl + '/common/mapRender/query?FCName='+Fcname;

	    ajax.postJSON({
	        url: action,
	        data: JSON.stringify({
	            id: params.geoIds,
	            imgToken: imgToken
	        }),
	        success: function (rs) {
	            var result = JSON.parse(rs);
	            if (!result || !result.data || !result.data.length) {
	                callback(null);
	            }
	            else {
	                callback(result.data);
	            }
	        },
	        failure: function(e) {
				callback(null);
	        }
	    });
	}

	//获取连线端点的位置（经纬度）
	function getLineLonLat(param) {
	    var lineLngLat;
	    var olLayer = layers.getLayer({
	        mapId: param.mapId,
	        layerId: param.sourceLayerId
	    });
	    if (!olLayer) {
	        return;
	    }
	    queryGeometry(olLayer, {
	        geoIds: param.layerId,
	        imgToken: olLayer.get('params.imgToken')
	    }, function (res) {
	        if (!res) {
	            return;
	        }
	        lineLngLat = res.extentInfo.circleCenter;
	    });
	    return lineLngLat;
	}

	function setShowLabel(param) {
	    var layer = layers.getLayer(param);
	    if (!layer) {
	        return;
	    }
	    var imgToken;
	    if (param.showLabel) {
	        imgToken = layer.get('params.imgTokenLabel');
	    }
	    else {
	        imgToken = layer.get('params.imgToken');
	    }
	    var updateParams = {
	        VERSION: '1.1.1',
	        imgToken: imgToken
	    };
	    layer.set('state.showLabel', !!param.showLabel);
	    layer.getSource().updateParams(updateParams);
	}

	module.exports = {
	    addLayer: addLayer,
	    setLayerData: setLayerData,
	    getClickData: getClickData,
	    highlight: highlight,
	    getLineLonLat: getLineLonLat,
	    setShowLabel: setShowLabel
	};

/***/ },
/* 98 */
/*!******************************************!*\
  !*** ./src/gis/businessLayers/render.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var constant = __webpack_require__(/*! framework/constant */ 2);

	var getImgToken = function (paramObj, callback) {
	    var callback = callback;
	    var url = '';
	    if (paramObj.dw != undefined) {
	    	url = fusiongis.Constant.GisRootUrl + '/mapRender/dw/getImgToken?FCName=' + paramObj.fcName;
	    }
	    else {
	    	url = fusiongis.Constant.GisRootUrl + '/common/mapRender/getImgToken?FCName=' + paramObj.fcName;
	    }

	    fusiongis.OriginalAjax.postJSON({
	        url: url,
	        data: JSON.stringify(paramObj.data),
	        success: function (result) {
	            if (!!result) {
	                var responseText = JSON.parse(result);
	                if (callback && typeof callback === 'function') {
	                    callback(responseText);
	                }
	            }
	            else {
	                if (callback && typeof callback === 'function') {
	                    callback(null);
	                }
	            }
	        },
	        failure: function(result) {
	        	if(callback && typeof callback === 'function') {
					callback(null);
				}
	        }
	    });
	};

	module.exports = {
	    render: getImgToken
	};


/***/ },
/* 99 */
/*!***********************************************!*\
  !*** ./src/gis/businessLayers/renderToken.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var constant = __webpack_require__(/*! framework/constant */ 2);

	var getImageToken = function (paramObj, callback) {
	    var callback = callback;
	    var _condition = {
	        commonParam: paramObj.commonParam,
	        renderParam: {
	            legendInfo: paramObj.commonParam.isUserDefinedLegend === 1 ? paramObj.legendInfo : {}
	        },
	        queryParam: paramObj.queryParam,
	        geoParams: paramObj.geoParams
	    };
	    fusiongis.OriginalAjax.postJSON({
	        url: fusiongis.Constant.GisRootUrl + '/gridManager/getImgToken?FCName=' + paramObj.fcName,
	        data: JSON.stringify(_condition),
	        success: function (result) {
	            if (!!result) {
	                var responseText = JSON.parse(result);
	                if (callback && typeof callback === 'function') {
	                    callback(responseText);
	                }
	            }
	        },
	        failure: function(result) {
	        	console.log(result);
				if(callback && typeof callback === 'function') {
					callback(null);
				}

	        }
	    });
	};
	module.exports = {
	    getImageToken: getImageToken
	};


/***/ },
/* 100 */
/*!*************************************!*\
  !*** ./src/gis/maps/gStreetView.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var map = __webpack_require__(/*! maps/map */ 8);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);

	/*
	 * @key
	 * */
	var loadGoogleAPI = function (key, language, callback) {
	    if (typeof (google) === 'undefined') {
	        var script = document.createElement('script');
	        var _protocol = 'http:';
	        if (location.protocol !== 'file:') {
	            _protocol = location.protocol;
	        }
	        var _language = language || 'en-US';//zh-CH
	        var _src = _protocol + '//maps.google.com/maps/api/js?v=3&language=' + _language + '&key=' + key;
	        if (!!document.querySelector('#google-api-load-yet')) {
	            script.setAttribute('src', 'http://www.huawei.com/Assets/CBG/js/Huawei.Personalization.CBG.js?ver=1');
	        }
	        else {
	            script.setAttribute('src', _src);
	            script.setAttribute('id', 'google-api-load-yet');
	        }

	        script.onload = function () {
	            callback(true);
	        };
	        script.onerror = function () {
	            callback(false);
	        };
	        document.body.appendChild(script);
	    }
	    else {
	        callback(true);
	    }
	};

	/*
	 * @lngLat
	 *      {lng:136.125621,lat:39.0145215}  经纬度
	 * return
	 *      返回街景id 不存在返回空
	 * */
	var isHaveStreetView = function (lngLat, radius, callback) {
	    var _panoService = new google.maps.StreetViewService();
	    _panoService.getPanorama(
	        {
	            location: lngLat,
	            radius: radius ? radius : 50
	        },
	        function (data, status) {
	            if (status === google.maps.StreetViewStatus.OK) {
	                callback(data.location.pano);
	            }
	            else {
	                return;
	            }
	        }
	    )
	};

	/*
	 * @mapId
	 *     mapId:'map1'  string|array  地图容器ID
	 * @param
	 *     radius: 50 number 坐标多大范围内的街景
	 *     isPanochanged：0/1 是否注册街景移动事件
	 *     style:
	 *     {
	 *          width://街景地图的宽度
	 *          height://街景地图的高度
	 *          ....
	 *     }
	 * */
	var _pano;//街景地图对象
	var svMap;//街景地图容器
	var gemo;//地图标记
	var clickEventKey;//singClick
	var svLayer;//标记图层
	var loadGoogleStreetView = function (mapId, param) {

	    if (!svMap) {
	        //创建街景容器
	        svMap = document.getElementById(mapId).cloneNode(false);
	        svMap.id = 'sv' + mapId;
	        document.body.appendChild(svMap);
	    }
	    addStreetViewLayer(mapId, function (res) {
	        isHaveStreetView(res.latLng, param.radius, function (pano) {
	            if (!!!_pano) {
	                changeDivStyle(mapId, 'open', param.style);//所点击的地方有街景 设置街景效果
	                map.refreshMaps([mapId]);
	                var defaultControl = {
	                    addressControlOptions: {
	                        position: google.maps.ControlPosition.BOTTOM_CENTER
	                    },
	                    linksControl: false,
	                    panControl: false,
	                    enableCloseButton: false,
	                    pano: pano
	                };
	                _pano = new google.maps.StreetViewPanorama(svMap, defaultControl);
	                if (param.isPanochanged === 1) {
	                    registerPanoChangeEvent(mapId);
	                }
	            }
	            else {
	                _pano.setPano(pano);
	            }
	        });
	    })
	};

	var changeDivStyle = function (mapId, type, style) {
	    var _customMap = document.getElementById(mapId);
	    var _googleMap = document.getElementById("$$customMap_" + mapId);
	    var _customMapWidth = !!_customMap ? _customMap.clientWidth : _googleMap.clientWidth;
	    var _customMapHeight = !!_customMap ? _customMap.clientHeight : _googleMap.clientHeight;

	    if (type === 'open') {
	        if (!!_googleMap) {
	            _googleMap.style.width = Math.ceil(_customMapWidth / 2) + "px";
	            _googleMap.style.padding = 0 + 'px';
	            _googleMap.style.margin = 0 + 'px';
	            _googleMap.style.position = 'absolute';
	            _googleMap.style.left = 0 + 'px';
	            _googleMap.style.top = 0 + 'px';
	            _googleMap.style.border = 0 + 'px';
	        }
	        else if (!!_customMap) {
	            _customMap.style.width = Math.ceil(_customMapWidth / 2) + "px";
	            _customMap.style.padding = 0 + 'px';
	            _customMap.style.margin = 0 + 'px';
	            _customMap.style.position = 'absolute';
	            _customMap.style.left = 0 + 'px';
	            _customMap.style.top = 0 + 'px';
	            _customMap.style.border = 0 + 'px';

	        }
	        svMap.style.width = Math.ceil(_customMapWidth / 2) + "px";
	        svMap.style.height = _customMapHeight + "px";
	        svMap.style.padding = 0 + 'px';
	        svMap.style.margin = 0 + 'px';
	        svMap.style.position = 'absolute';
	        svMap.style.right = 0 + 'px';
	        svMap.style.top = 0 + 'px';
	        svMap.style.border = 0 + 'px';
	    }
	    else {
	        if (svMap) {
	            document.body.removeChild(svMap);
	            _customMap.style.width = _customMapWidth + "px";
	            if (_googleMap) {
	                _googleMap.style.width = _customMapWidth + "px";
	            }
	            svMap = null;
	        }
	    }
	};

	var addStreetViewLayer = function (mapId, clickCallback) {

	    var mapObj = mapBox.getMapObj(mapId);
	    if (!svLayer) {
	        svLayer = new ol.layer.Vector({
	            layerName: 'street_view',
	            source: new ol.source.Vector({wrapX: false}),
	            opacity: 0.8,
	            style: new ol.style.Style({
	                fill: new ol.style.Fill({
	                    color: 'rgba(255, 255, 255, 0.2)'
	                }),
	                stroke: new ol.style.Stroke({
	                    color: '#ff0000',
	                    width: 2
	                }),
	                image: new ol.style.Circle({
	                    radius: 7,
	                    fill: new ol.style.Fill({
	                        color: '#ff0000'
	                    })
	                })
	            })
	        });
	        mapObj.addLayer(svLayer);
	    }

	    if (clickEventKey) {

	        if (gemo) {
	            svLayer.getSource().clear();
	        }
	        mapObj.unByKey(clickEventKey);
	        clickEventKey = null;
	    }
	    clickEventKey = mapObj.on('singleclick', function (evt) {
	        var coordinate = ol.proj.toLonLat(evt.coordinate);
	        if (gemo) {
	            svLayer.getSource().clear();
	        }
	        //放一个marker
	        gemo = new ol.Feature({
	            geometry: new ol.geom.Point(evt.coordinate),
	            name: 'street_view_marker'
	        });
	        gemo.setId('street_view_marker');
	        var source = new ol.source.Vector({
	            features: [gemo],
	            wrapX:false
	        });
	        svLayer.setSource(source);
	        clickCallback({
	            latLng: {
	                lat: coordinate[1],
	                lng: coordinate[0]
	            }
	        })
	    });
	    mapObj.set('clickEventKey', clickEventKey);
	};

	var registerPanoChangeEvent = function (mapId) {
	    google.maps.event.addListener(_pano, 'position_changed', function () {
	        var lngLat = _pano.getPosition();
	        moveSVMarker(mapId, {
	            lng: lngLat.lng(),
	            lat: lngLat.lat()
	        });//街景移动 移动地图标记
	        map.setMapCenter({
	            mapId: mapId,
	            coordinate: [lngLat.lng(), lngLat.lat()],
	            opt_projection: 'EPSG:3857'
	        });
	    });
	};

	var moveSVMarker = function moveSVMarker(mapId, paramObj) {
	    var mapObj = mapBox.getMapObj(mapId);
	    if (svLayer) {
	        var feature = svLayer.getSource().getFeatureById('street_view_marker');
	        var gemo = feature.getGeometry();
	        var coordinate = ol.proj.fromLonLat([paramObj.lng, paramObj.lat]);
	        gemo.setCoordinates(coordinate);
	    }
	};

	var closeGoogleStreetView = function (mapId) {
	    var mapObj = mapBox.getMapObj(mapId);
	    if (_pano) {
	        _pano = null;
	        changeDivStyle(mapId, 'close', undefined);
	        map.refreshMaps([mapId]);
	    }
	    if (svLayer) {
	        gemo = null;
	        mapObj.removeLayer(svLayer);
	        mapObj.unByKey(mapObj.get('clickEventKey'));
	        svLayer = null;
	        clickEventKey = null;
	    }
	};

	module.exports = {
	    loadGoogleAPI: loadGoogleAPI,
	    loadGoogleStreetView: loadGoogleStreetView,
	    closeGoogleStreetView: closeGoogleStreetView
	};

/***/ },
/* 101 */
/*!**********************************!*\
  !*** ./src/gis/tools/measure.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	var line = __webpack_require__(/*! tools/measureDistance */ 102);
	var area = __webpack_require__(/*! tools/measureArea */ 103);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);

	module.exports = {
	    measure: function (params) {
	        if (params.measureType === 'geoLine') {
	            if (params.isOpen) {
	                return line.measureLine(params);
	            }
	            else {
	                line.clearLastLine(params.mapId);
	            }
	        }
	        if (params.measureType === 'geoArea') {
	            area.measureArea(params);
	        }

	    },
	    isMeasuring: function isMeasuring(params) {
	        var map = mapBox.getMapObj(params.mapId);
	        if (!map) {
	            return false;
	        }
	        var measureType = params.measureType || 'geoLine';
	        return !!map.get('state.measure.' + measureType);
	    }
	};

/***/ },
/* 102 */
/*!******************************************!*\
  !*** ./src/gis/tools/measureDistance.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);

	var utils = __webpack_require__(/*! utils/util */ 1);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var domUtil = __webpack_require__(/*! utils/domUtil */ 10);
	var I18n = __webpack_require__(/*! utils/i18n */ 13);

	var wgs84Sphere = new ol.Sphere(6378137);
	var actCache = {};
	var ovCache = {}; 
	var uId = 1;
	var offset = [3, -1];
	var MEASURE_NAME = 'distanceMeasure';

	function measureLine(param) {
	    var _mapObj = mapBox.getMapObj(param.mapId);
	    if (_mapObj.get('state.drawing')) {
	        return;
	    }
	    var mapId = _mapObj.getTarget();
	    var actId = createActionId(param.mapId);
	    var features = new ol.Collection();
	    features.on('change:length', function (evt) {
	        var array = features.getArray();
	        var ac = actCache[mapId];
	        var cActId = ac[ac.length - 1];
	        for (var i = 0; i < array.length; i++) {
	            if (array[i].get('type')) {
	                continue;
	            }
	            array[i].set('type', cActId);
	            array[i].setStyle(getLineStyle(param));
	        }
	    });

	    var measureLayer = _mapObj.get('measureLine.Layer');
	    if (!measureLayer) {
	        measureLayer = new ol.layer.Vector({
	            source: new ol.source.Vector({
	                features: features,
	                wrapX: false
	            }),
	            style: new ol.style.Style({
	                stroke: new ol.style.Stroke({
	                    color: '#0099ff',
	                    width: 3
	                })
	            })
	        });
	        measureLayer.setMap(_mapObj);
	        measureLayer.set('layer_id', 'measure-line-layer-id');
	        _mapObj.set('measureLine.Layer', measureLayer);
	    }

	    initCache(param.mapId, actId);

	    addInteraction(param, _mapObj, measureLayer, actId);

	    fusiongis.Events.addClickCallback(mapId, 'measure-distance-click-event', function (obj) {
	        var evt = obj.e;
	        var shouldAddPoint = true;
	        if (param.clickCallback) {
	            //根据返回的真值决定是否要添加点，用于有时不充许点在地图外的情况
	            shouldAddPoint = param.clickCallback({
	                mapId: mapId,
	                coordinate: evt.coordinate
	            });
	        }

	        if (shouldAddPoint !== false) {
	            createMeasureTooltip(evt, _mapObj, actId);
	            addPoint(evt.coordinate, _mapObj, actId, param);
	        }
	    }, 'measure-line-layer-id');
	}

	function getLineStyle(param) {
	    return new ol.style.Style({
	        stroke: new ol.style.Stroke({
	            color: param.strokeColor || '#0099ff',
	            width: param.strokeWidth || 3
	        })
	    });
	}

	function addInteraction(param, _mapObj, layer, actId) {
	    var mapId = _mapObj.getTarget();
	    _mapObj.set('state.drawing', true);
	    _mapObj.set('state.measure.geoLine', true);
	    var draw = olUtil.getIntactByName(mapId, MEASURE_NAME);
	    if(!draw) {
	    	draw = new ol.interaction.Draw({
	    		clickTolerance: 0.00000000001, //单击移动范围
	    		snapTolerance: 0.00000001,
	    		source: layer.getSource(),
	    		type: 'LineString'
	    	});
	    	draw.set('name', MEASURE_NAME);
	    	_mapObj.addInteraction(draw);
	    }
	    else {
	        draw.setActive(true);
	    }

	    createHelpTooltip(_mapObj, actId);
	    var totalLength = null;
	    var drawStartHandler = draw.on('drawstart', function (evt) {
	        // set sketch
	        var sketch = evt.feature;
	        _mapObj.set('measureLine.drawLineSketch', sketch);
	        addStartPopup(evt.feature.getGeometry().getCoordinates()[0], _mapObj, actId);
	        var sketchChangeHandler = sketch.getGeometry().on('change', function (evt) {
	            moveHelpTooltip(evt, _mapObj, actId);
	            totalLength = formatLength(evt.target);
	        });
	        _mapObj.set('measureLine.sketchChange', sketchChangeHandler);
	    });

	    var drawEndHandler = draw.on('drawend', function (evt) {
	        fusiongis.Events.removeClickCallback(mapId, 'measure-distance-click-event');
	        var coordiantes = evt.feature.getGeometry().getCoordinates();
	        addCloseButton(coordiantes[coordiantes.length - 1], _mapObj, actId);
	        alterHelpTooltip(mapId, actId);
	        clearHandlers(mapId, draw);
	        if (totalLength === "0 m") {
	            clearMeasure(_mapObj, actId);
	            totalLength = null;
	        }
	        setTimeout(function () {
	            draw.setActive(false);
	            _mapObj.set('state.drawing', false);
	            _mapObj.set('state.measure.geoLine', false);
	            if (param.endCallback) {
	                param.endCallback(
	                    {
	                        mapId: mapId,
	                        coordinates: coordiantes
	                    }
	                );
	            }
	        }, 0);
	    });
	    _mapObj.set('measureLine.drawStart', drawStartHandler);
	    _mapObj.set('measureLine.drawEnd', drawEndHandler);
	}

	function addStartPopup(tooltipCoord, _mapObj, actId) {
	    var StartPopupElement = document.createElement('div');
	    StartPopupElement.className = 'measure-tooltip mile';
	    StartPopupElement.style.zIndex = olUtil.getPopupZIndex(_mapObj.getTarget());

	    StartPopupElement.innerHTML = I18n.prop('measure.message.start');
	    var StartPopup = new ol.Overlay({
	        element: StartPopupElement,
	        offset: offset
	    });
	    StartPopup.set('type', actId);
	    StartPopup.setPosition(tooltipCoord);
	    _mapObj.addOverlay(StartPopup);
	}

	function addPoint(tooltipCoord, _mapObj, actId, param) {
	    var draw = olUtil.getIntactByName(_mapObj.getTarget(), MEASURE_NAME);
	    if (!draw.getActive()) {
	        return;
	    }
	    var measurePointLayer = _mapObj.get('measureLine.PointLayer');
	    if (!measurePointLayer) {
	        measurePointLayer = new ol.layer.Vector({
	            source: new ol.source.Vector({
	                wrapX:false
	            }),
	            layerId: 'point'
	        });
	        _mapObj.set('measureLine.PointLayer', measurePointLayer);
	    }
	    measurePointLayer.setMap(_mapObj);
	    var point = new ol.Feature(new ol.geom.Point(tooltipCoord));
	    point.set('type', actId);
	    point.setStyle(getPointStyle(param));
	    measurePointLayer.getSource().addFeature(point);
	}

	function getPointStyle(param) {
	    return new ol.style.Style({
	        image: new ol.style.Circle({
	            radius: param.pointRadius || 4,
	            fill: new ol.style.Fill({
	                color: param.pointFillColor || '#ffffff'
	            }),
	            stroke: new ol.style.Stroke({
	                color: param.pointStrokeColor || '#0099ff',
	                width: param.pointStrokeWidth || 2
	            })
	        })
	    });
	}

	function addCloseButton(tooltipCoord, _mapObj, actId) {
	    var closeIconElement = document.createElement('div');
	    closeIconElement.className = 'measure-close';
	    closeIconElement.style.zIndex = olUtil.getPopupZIndex(_mapObj.getTarget());

	    var closeIcon = new ol.Overlay({
	        element: closeIconElement,
	        offset: offset
	    });
	    closeIcon.set('type', actId);
	    closeIcon.setPosition(tooltipCoord);
	    _mapObj.addOverlay(closeIcon);
	    domUtil.on(closeIconElement, 'click', function () {
	        clearMeasure(_mapObj, actId);
	    });
	}

	function clearMeasure(_mapObj, actId) {
	    clearOverlay(_mapObj, actId);
	    clearFeature(_mapObj, actId);
	    clearPoint(_mapObj, actId);
	}

	function clearFeature(_mapObj, actId) {
	    var layer = _mapObj.get('measureLine.Layer');
	    if (layer) {
	        olUtil.delFeatureByType(layer.getSource(), actId);
	    }
	}

	function clearOverlay(_mapObj, actId) {
	    var mapId = _mapObj.getTarget();
	    var overlays = _mapObj.getOverlays().getArray().slice(0);
	    overlays.forEach(function (ov) {
	        var ovType = ov.get('type');
	        if (ovType && ovType === actId) {
	            _mapObj.removeOverlay(ov);
	        }
	    });
	    if (actCache[mapId]) {
	        var index = actCache[mapId].indexOf(actId);
	        if (index > -1) {
	            actCache[mapId].splice(index, 1);
	        }
	    }
	    if (ovCache[mapId] && ovCache[mapId][actId]) {
	        ovCache[mapId][actId].splice(0);
	    }

	}

	/**
	 * 清除上次的测量
	 * @param mapId
	 */
	function clearLastLine(mapId) {
	    var drawer = olUtil.getIntactByName(mapId, MEASURE_NAME);
	    if (!drawer) {
	        return;
	    }
	    var actId = utils.last(actCache[mapId]);
	    var _mapObj = mapBox.getMapObj(mapId);
	    clearMeasure(_mapObj, actId);
	    clearHandlers(mapId, drawer);
	    if(_mapObj.get('state.drawing')){
	//      _mapObj.removeInteraction(drawer);
	        drawer.setActive(false);
	        _mapObj.set('state.drawing', false);
	        _mapObj.set('state.measure.geoLine', false);
	        _mapObj.set('measureLine.drawLineSketch',null);
	    }
	}

	/**
	 * 清空事件处理
	 * @param mapId
	 * @param drawer
	 */
	function clearHandlers(mapId, drawer) {
	    var _mapObj = mapBox.getMapObj(mapId);
	    ol.Observable.unByKey(_mapObj.get('measureLine.sketchChange'));
	    drawer.unByKey(_mapObj.get('measureLine.drawStart'));
	    drawer.unByKey(_mapObj.get('measureLine.drawEnd'));
	}

	function clearPoint(_mapObj, actId) {
	    var layer = _mapObj.get('measureLine.PointLayer');
	    if (layer) {
	        olUtil.delFeatureByType(layer.getSource(), actId);
	    }
	}

	function createHelpTooltip(_mapObj, actId) {
	    var helpTooltipElement = document.createElement('div');
	    helpTooltipElement.innerHTML = I18n.prop('measure.message.startHelper');
	    helpTooltipElement.className = 'measure-tooltip';

	    var helpTooltip = new ol.Overlay({
	        element: helpTooltipElement,
	        offset: offset,
	        positioning: 'center-left'
	    });
	    helpTooltip.set('type', actId);
	    helpTooltip.set('name', actId + '_helpTooltip');
	    _mapObj.addOverlay(helpTooltip);
	    helpTooltipElement.parentNode.style.zIndex = olUtil.getPopupZIndex(_mapObj.getTarget()) + 100;
	}

	/**
	 * 修改helptooltip的显示位置
	 * @param mapId
	 * @param actId
	 */
	function alterHelpTooltip(mapId, actId) {
	    var helpTooltip = olUtil.getOverlayByName(mapId, actId + '_helpTooltip');
	    var helpTooltipElement = helpTooltip.get('element');

	    helpTooltip.setOffset([-7, -30]);
	    var output = helpTooltipElement.innerHTML;

	    var index = output.indexOf('<br>');
	    output = output.slice(0, index);
	    helpTooltipElement.innerHTML = output;
	    helpTooltipElement.parentNode.style.zIndex = olUtil.getPopupZIndex(mapId);

	    var ovName = utils.last(ovCache[mapId][actId]);
	    if (ovName !== undefined) {
	        var lastMeasureTip = olUtil.getOverlayByName(mapId, ovName);
	        mapBox.getMapObj(mapId).removeOverlay(lastMeasureTip);
	    }
	}

	function moveHelpTooltip(evt, _mapObj, actId) {
	    var geom = evt.target;
	    var mapId = _mapObj.getTarget();
	    var output = formatLength(geom);
	    var tooltipCoord = geom.getLastCoordinate();
	    var helpTooltip = olUtil.getOverlayByName(mapId, actId + '_helpTooltip');
	    helpTooltip.get('element').innerHTML = (function(input) {
	    	var _output = I18n.prop('measure.message.total') + input;
		    _output = _output + '<br>' + I18n.prop('measure.message.helper');
		    return _output;
	    }(output))
	    helpTooltip.setPosition(tooltipCoord);
	}


	function createMeasureTooltip(evt, _mapObj, actId) {
	    var measureTooltipElement = document.createElement('div');
	    measureTooltipElement.className = 'measure-tooltip mile';
	    var sketch = _mapObj.get('measureLine.drawLineSketch');
	    if(sketch){
	        var geom = sketch.getGeometry();
	        var output = formatLength(geom);
	        if (output.slice(0, 1) === '0') {
	            return;
	        }
	        measureTooltipElement.innerHTML = output;
	        measureTooltipElement.style.zIndex = olUtil.getPopupZIndex(_mapObj.getTarget());
	        measureTooltipElement.setAttribute('actId', actId);
	        var measureTooltip = new ol.Overlay({
	            element: measureTooltipElement,
	            offset: offset,
	            positioning: 'bottom-center'
	        });
	        measureTooltip.set('type', actId);
	        measureTooltip.set('name', createOvName(_mapObj.getTarget(), actId));
	        measureTooltip.setPosition(evt.coordinate);
	        _mapObj.addOverlay(measureTooltip);
	    }
	}

	function formatLength(line) {
	    var length;
	    var coordinates = line.getCoordinates();
	    length = 0;
	    //flat distance
	//  for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
	//      var line = new ol.geom.LineString([coordinates[i],coordinates[i + 1]]);
	//      length += line.getLength();
	//  }
	    
	    //sphere distance
	    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
	        var c1 = ol.proj.toLonLat(coordinates[i]);
	        var c2 = ol.proj.toLonLat(coordinates[i + 1]);
	        length += wgs84Sphere.haversineDistance(c1, c2);
	    }
	    
	    

	    var output;
	    if (length > 1000) {
	        output = (Math.round(length / 1000 * 1000) / 1000) +
	            ' ' + 'km';
	    }
	    else {
	        output = (Math.round(length * 1000) / 1000) +
	            ' ' + 'm';
	    }
	    return output;
	}

	/**
	 * 初始化cache
	 * @param mapId
	 * @param actId
	 */
	function initCache(mapId, actId) {
	    if (!ovCache[mapId]) {
	        ovCache[mapId] = {};
	    }
	    if (!ovCache[mapId][actId]) {
	        ovCache[mapId][actId] = [];
	    }
	}

	/**
	 * 新的画线操作
	 * @returns {*}
	 */
	function createActionId(mapId) {
	    var actId = uniqueId('measure_act_');
	    if (!actCache[mapId]) {
	        actCache[mapId] = [];
	    }

	    actCache[mapId].push(actId);
	    return actId;
	}

	/**
	 * 创建ovName
	 * @param mapId
	 * @param actId
	 * @returns {*}
	 */
	function createOvName(mapId, actId) {
	    var ovName = uniqueId('measure_ov_');
	    ovCache[mapId][actId].push(ovName);
	    return ovName;
	}

	function uniqueId(str) {
	    var strId = str + uId;
	    uId = uId + 1;
	    return strId;
	}

	module.exports = {
	    measureLine: measureLine,
	    clearLastLine: clearLastLine
	};

/***/ },
/* 103 */
/*!**************************************!*\
  !*** ./src/gis/tools/measureArea.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);

	var utils = __webpack_require__(/*! utils/util */ 1);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var domUtil = __webpack_require__(/*! utils/domUtil */ 10);
	var I18n = __webpack_require__(/*! utils/i18n */ 13);

	var uId = 1;
	var actPool = {}, wgs84Sphere = new ol.Sphere(6378137);
	var iUtil = {
	    isNull: function (obj) {
	        return obj === null;
	    },
	    last: function (arr) {
	        if (!arr) {
	            return;
	        }
	        return arr[arr.length - 1];
	    },
	    uniqueId: function (str) {
	        var strId = str + uId;
	        uId = uId + 1;
	        return strId;
	    },

	    getSketchCoords: function (drawer) {
	        var sketchCoords;
	        for (var x in drawer) {
	            if (!drawer.hasOwnProperty(x)) {
	                continue;
	            }
	            var item = drawer[x];
	            if (utils.isArray(item) && item.length > 0 && utils.isArray(item[0])) {
	                sketchCoords = item;
	            }
	        }
	        return sketchCoords;
	    },
	    getSketchFeature: function (drawer) {
	        var sketchFeature;
	        for (var x in drawer) {
	            if (!drawer.hasOwnProperty(x)) {
	                continue;
	            }
	            var item = drawer[x];
	            if (item instanceof ol.Feature && item.getGeometry() &&
	                item.getGeometry() instanceof ol.geom.Polygon) {
	                sketchFeature = item;
	            }
	        }
	        return sketchFeature;
	    }
	};

	function setMeasuring(mapId, b) {
	    var olMap = getMap(mapId);
	    olMap.set('state.drawing', b);
	    olMap.set('state.measure.geoArea', b);
	}

	function isMeasuring(mapId) {
	    var olMap = getMap(mapId);
	    return olMap.get('state.drawing');
	}

	function getMap(mapId) {
	    return mapBox.getMapObj(mapId);
	}

	/**
	 * 新的画线操作
	 * @returns {*}
	 */
	function newActionId(mapId) {
	    var actId = iUtil.uniqueId('measureArea_act_');
	    if (!actPool[mapId]) {
	        actPool[mapId] = [];
	    }

	    actPool[mapId].push(actId);
	    return actId;
	}

	function _measureArea(params) {
	    var mapId = params.mapId;
	    var olMap = getMap(mapId);
	    if (!olMap) {
	        return;
	    }

	    if (isMeasuring(mapId)) {
	        return;
	    }
	    var actId = newActionId(mapId);

	    var measureLayer = getMeasureLayer(mapId);
	    var drawer = getDrawer(mapId, actId, measureLayer);
	    drawer.setActive(true);

	    var pmKey = olMap.on('pointermove', function (evt) {
	        pointerMoveHandler(mapId, evt, params);
	    });
	    olMap.set('KEYS.MEASURE_AREA_PMOVE', pmKey);

	    setMeasuring(mapId, true);
	    return actId;
	}

	function getDrawer(mapId, actId, measureLayer) {
	    var olMap = getMap(mapId);
	    if (!olMap) {
	        return;
	    }

	    createHelpTooltip(mapId, actId);
	    var drawer = olUtil.getIntactByName(mapId, 'areaMeasure');
	    if (!drawer) {

	        drawer = new ol.interaction.Draw({
	            type: 'Polygon'
	        });

	        drawer.set('name', 'areaMeasure');

	        drawer.on('drawend', function (evt) {
	            HandleDrawEnd(evt, mapId, drawer);
	            var coordinate = evt.feature.getGeometry().getCoordinates()[0];
	            coordinate.pop(coordinate[coordinate.length - 1]);
	            var lastCood = coordinate.slice(1);
	            var falg = false;
	            if (lastCood.length > 1) {
	                for (var i = 0; i < lastCood.length - 1; i++) {
	                    if (lastCood[i][0] !== lastCood[i + 1][0] || lastCood[i][1] !== lastCood[+1][1]) {
	                        falg = true;
	                    }
	                }
	            }

	            if (falg) {
	                getMeasureLayer(mapId).getSource().addFeature(evt.feature);
	            }

	        });

	        drawer.on('drawstart', function (evt) {
	            drawer.set('STATE.MEASURE.START', true);
	        });

	        olMap.addInteraction(drawer);
	    }

	    drawer.set('actId', actId);

	    return drawer;
	}

	/**
	 * 创建测矩图层
	 * @param mapId
	 * @returns {ol.layer.Vector}
	 */
	function getMeasureLayer(mapId) {
	    var layer = olUtil.getLayer({
	        mapId: mapId,
	        layerId: 'measureArea'
	    });
	    if (!layer) {
	        layer = new ol.layer.Vector({
	            layerId: 'measureArea',
	            source: new ol.source.Vector({
	                wrapX: false
	            }),
	            style: new ol.style.Style({
	                stroke: new ol.style.Stroke({
	                    color: '#0099ff',
	                    width: 3
	                })
	            })
	        });
	        getMap(mapId).addLayer(layer);
	    }
	    return layer;
	}

	/**
	 * 创建一个显示距离的tooltip
	 * @param mapId
	 * @param actId
	 */
	function createHelpTooltip(mapId, actId) {
	    var helpTooltipElement = document.createElement('div');
	    helpTooltipElement.className = 'measure-tooltip';
	    helpTooltipElement.innerHTML = I18n.prop('measure.message.startHelper');
	    var helpTooltip = new ol.Overlay({
	        element: helpTooltipElement,
	        offset: [120, 85],
	        positioning: 'bottom-center'
	    });
	    helpTooltip.set('type', actId);
	    helpTooltip.set('name', actId + '_helper');
	    getMap(mapId).addOverlay(helpTooltip);
	    helpTooltipElement.parentNode.style.zIndex = olUtil.getPopupZIndex(mapId);
	}

	/**
	 * 修改helptooltip的显示位置
	 * @param mapId
	 * @param actId
	 */
	function alterHelpTooltip(mapId, actId) {
	    var helpTooltip = olUtil.getOverlayByName(mapId, actId + '_helper');
	    var helpTooltipElement = helpTooltip.get('element');

	    helpTooltip.setOffset([-7, -10]);
	    var output = helpTooltipElement.innerHTML;

	    var index = output.indexOf('<br>');
	    output = output.slice(0, index);
	    helpTooltipElement.innerHTML = output;

	}

	/**
	 * 添加关闭按钮
	 * @param mapId
	 * @param actId
	 */
	function addCloseButton(mapId, actId) {
	    var drawer = olUtil.getIntactByName(mapId, 'areaMeasure');
	    var closeIconElement = document.createElement('div');
	    closeIconElement.className = 'measure-close';
	    domUtil.on(closeIconElement, 'click', function () {
	        clearMeasure(mapId, actId);
	    });

	    var closeIcon = new ol.Overlay({
	        element: closeIconElement,
	        offset: [15, 6],
	        positioning: 'bottom-center'
	    });
	    closeIcon.set('name', actId + '_close');
	    closeIcon.set('type', actId);
	    getMap(mapId).addOverlay(closeIcon);
	    var coords = iUtil.getSketchCoords(drawer);
	    var coordinate = coords[coords.length - 2];
	    closeIcon.setPosition(coordinate);
	}

	/**
	 * 指针移动监听函数
	 * @param mapId
	 * @param {ol.MapBrowserEvent} evt
	 */
	function pointerMoveHandler(mapId, evt, params) {

	    if (evt.dragging) {
	        return;
	    }

	    var drawer = olUtil.getIntactByName(mapId, 'areaMeasure');
	    if (!drawer) {
	        return;
	    }

	    var actId = iUtil.last(actPool[mapId]);
	    var helpTooltip = olUtil.getOverlayByName(mapId, actId + '_helper');
	    var helpTooltipElement = helpTooltip.get('element');
	    helpTooltip.setPosition(evt.coordinate);

	    if (drawer.getActive() === false) {
	        drawer.setActive(true);
	    }
	    var sketchFeature = iUtil.getSketchFeature(drawer);

	    if (!sketchFeature) {
	        return;
	    }

	    if (!sketchFeature.getStyle()) {
	        sketchFeature.setStyle(getLineStyle(params));
	    }

	    var geom = sketchFeature.getGeometry();
	    var output = formatArea(geom);
	    drawer.set('measureOutput', output);

	    helpTooltipElement.innerHTML = formatHelpTip(output);
	}

	function getLineStyle(param) {
	    if (param.fillColor) {
	    return new ol.style.Style({
	            fill: new ol.style.Fill({
	                color: param.fillColor
	            }),
	        stroke: new ol.style.Stroke({
	            color: param.strokeColor || '#0099ff',
	            width: param.strokeWidth || 3
	        })
	    });
	    } else {
	        return new ol.style.Style({
	            stroke: new ol.style.Stroke({
	                color: param.strokeColor || '#0099ff',
	                width: param.strokeWidth || 3
	            })
	        });
	    }
	}

	function HandleDrawEnd(evt, mapId, drawer, endCallback) {
	    var actId = drawer.get('actId');
	    alterHelpTooltip(mapId, actId);
	    addCloseButton(mapId, actId);
	    var pmKey = getMap(mapId).get('KEYS.MEASURE_AREA_PMOVE');
	    if (pmKey) {
	        getMap(mapId).unByKey(pmKey);
	    }
	    evt.feature.set('type', actId);
	    if (endCallback) {
	        endCallback(mapId, actId);
	    }
	    var output = drawer.get('measureOutput');
	    var specOut = 0 + ' ' + 'm<sup>2</sup>';
	    if (output === specOut) {
	        clearOverlay(mapId, actId);
	    }
	    setTimeout(function () {
	    	getMap(mapId).un('pointermove',pointerMoveHandler);
	        setMeasuring(mapId, false);
	        drawer.setActive(false);
	    }, 0);

	}

	function formatArea(polygon) {
	    var area;
	    var geom = polygon.clone().transform('EPSG:3857', 'EPSG:4326');
	    var coordinates = geom.getLinearRing(0).getCoordinates();
	    area = Math.abs(wgs84Sphere.geodesicArea(coordinates));
	    var output;
	    if (area > 1000000) {
	        output = (Math.round(area / 1000000 * 100) / 100) +
	            ' ' + 'km<sup>2</sup>';
	    }
	    else {
	        output = (Math.round(area * 100) / 100) +
	            ' ' + 'm<sup>2</sup>';
	    }
	    return output;
	}

	/**
	 * 格式化总长
	 * @param input
	 * @returns {string}
	 */
	function formatHelpTip(input) {
	    var output = I18n.prop('measureArea.message.total') + input;
	    output = output + '<br>' + I18n.prop('measure.message.helper');
	    return output;
	}

	/**
	 * 清空测量
	 * @param mapId
	 * @param actId
	 */
	function clearMeasure(mapId, actId) {
		var drawer = olUtil.getIntactByName(mapId, 'areaMeasure');
		getMap(mapId).un('pointermove',pointerMoveHandler);
		setMeasuring(mapId, false);
	    drawer.setActive(false);
	    clearFeature(mapId, actId);
	    clearOverlay(mapId, actId);
	}

	/**
	 * 清除上次画的线
	 * @param mapId
	 * @param actId
	 */
	function clearFeature(mapId, actId) {
	    var layer = olUtil.getLayer({
	        mapId: mapId,
	        layerId: 'measureArea'
	    });
	    if (layer) {
	        olUtil.delFeatureByType(layer.getSource(), actId);
	    }
	}

	/**
	 * 清空overlay
	 * @param mapId
	 * @param actId
	 */
	function clearOverlay(mapId, actId) {
	    var map = getMap(mapId);
	    var overlays = map.getOverlays().getArray().slice(0);
	    overlays.forEach(function (ov) {
	        var ovType = ov.get('type');
	        if (ovType && ovType === actId) {
	            map.removeOverlay(ov);
	        }
	    });
	    if (actPool[mapId]) {
	        var index = actPool[mapId].indexOf(actId);
	        if (index > -1) {
	            actPool[mapId].splice(index, 1);
	        }
	    }
	}

	function measureArea(params) {
	    if (params.isOpen) {
	        return _measureArea(params);
	    }
	}

	module.exports = {
	    measureArea: measureArea,
	    clearMeasure: clearMeasure
	};

/***/ },
/* 104 */
/*!***************************************!*\
  !*** ./src/gis/tools/measureAngle.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);

	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var math = __webpack_require__(/*! framework/algorithm */ 48);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var i18n = __webpack_require__(/*! utils/i18n */ 13);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);

	var tag = 0;
	/**
	 * tan转sin
	 * @returns {ol.layer.Vector}
	 */
	function tanToSin(tan, angle) {
	    var sin = Math.sqrt(Math.pow(tan, 2) / (1 + Math.pow(tan, 2)));
	    if (360 >= 360 - angle && 360 - angle >= 180) {
	        sin = -sin;
	    }
	    return sin
	}

	/**
	 * tan转cos
	 * @returns {ol.layer.Vector}
	 */
	function tanToCos(tan, angle) {
	    var cos = Math.sqrt(1 / (1 + Math.pow(tan, 2)));
	    if (270 >= 360 - angle && 360 - angle >= 90) {
	        cos = -cos;
	    }
	    return cos
	}

	/**
	 * 计算弧线上的点
	 * @returns {ol.layer.Vector}
	 */
	function measurePoints(point0, point1, radios, coods) {
	    var point00 = point0;
	    var point01 = point1;
	    var x1 = point00[0] - point01[0];
	    var y1 = point00[1] - point01[1];

	    var point01proj = ol.proj.toLonLat(point01);
	    var point1s = ol.proj.fromLonLat([180, point01proj[1]]);
	    var line1ForAngle = new ol.geom.LineString([point1s, point01, point00]);
	    var angleLine1 = formatAngle(line1ForAngle);
	    var tan1 = y1 / x1;
	    var sin1 = tanToSin(tan1, angleLine1);
	    var cos1 = tanToCos(tan1, angleLine1);
	    var line1Y = radios * sin1 * 0.25;
	    var line1X = radios * cos1 * 0.25;
	    coods.push([point01[0] + line1X, point01[1] + line1Y]);
	}

	/**
	 * 经纬度转弧度
	 * @returns {ol.layer.Vector}
	 */
	function degreeToRad(degree) {
	    var rad = Math.PI * degree / 180;
	    return rad;
	}

	/**
	 * 弧度转经纬度
	 * @returns {ol.layer.Vector}
	 */
	function radToDegree(rad) {
	    var degree = 180 * rad / Math.PI;
	    return degree;
	}

	/**
	 * 计算角度
	 * @returns {ol.layer.Vector}
	 */
	function formatAngle(line) {
	    var coordinates = line.getCoordinates();
	    var ii = coordinates.length - 1;
	    var output;
	    if (ii < 2) {
	        output = 0;
	    }
	    else {
	        var c1 = ol.proj.toLonLat(coordinates[0]);
	        var c2 = ol.proj.toLonLat(coordinates[1]);
	        var c3 = ol.proj.toLonLat(coordinates[2]);
	        var sin = degreeToRad(c1[1] - c2[1]) * degreeToRad(c3[0] - c2[0]) -
	            degreeToRad(c3[1] - c2[1]) * degreeToRad(c1[0] - c2[0]);
	        var cos = degreeToRad(c1[1] - c2[1]) * degreeToRad(c3[1] - c2[1]) +
	            degreeToRad(c1[0] - c2[0]) * degreeToRad(c3[0] - c2[0]);
	        var angleResult = Math.atan2(sin, cos) * (180 / Math.PI);
	        if (angleResult < 0) {
	            return 360 + angleResult
	        }
	        else {
	            return angleResult
	        }
	    }
	    return output;
	}

	/**
	 * 计算短边长度
	 * @param line
	 * @returns {*}
	 */
	function shortLineLength(line) {
	    var linePoints = line.getCoordinates();
	    var line1Points = linePoints.slice(0, 2);
	    var line2Points = linePoints.slice(1);
	    var line1 = new ol.geom.LineString(line1Points);
	    var line2 = new ol.geom.LineString(line2Points);
	    var line1Length = line1.getLength();
	    var line2Length = line2.getLength();
	    if (line1Length <= line2Length) {
	        return line1Length
	    }
	    else {
	        return line2Length
	    }
	}

	/**
	 * 添加关闭按钮
	 * @param tooltipCoord
	 * @returns {*}
	 */
	function addCloseButton(mapId, vectorLayer, tooltipCoord) {
	    var closeIconElement = document.createElement('div');
	    closeIconElement.className = 'measure-close';

	    var closeIcon = new ol.Overlay({
	        element: closeIconElement,
	        offset: [0, -7]
	    });
	    closeIconElement.id = tag;

	    closeIcon.tag = tag;
	    closeIcon.setPosition(tooltipCoord);
	    mapBox.getMapObj(mapId).addOverlay(closeIcon);
	    var tempTag = tag;
	    var measureClose = document.getElementById(tag);
	    measureClose.onclick = function() {
	        if (Number(this.id) === tempTag) {
	            clearMeasure(mapId, vectorLayer, tempTag);
	        }
	    }
	}

	function clearMeasure(mapId, vectorLayer, tempTag) {
	    clearPoint(vectorLayer, tempTag);
	    clearOverlay(mapId, tempTag);

	}

	function clearPoint(vectorLayer, tempTap) {
	    var features = vectorLayer.getSource().getFeatures();
	    for (var i = 0; i < features.length; i++) {
	        if (features[i].tag == tempTap) {
	            vectorLayer.getSource().removeFeature(features[i]);
	        }
	    }
	}

	function clearOverlay(mapId, tempTag) {
	    var overlays = mapBox.getMapObj(mapId).getOverlays().getArray().slice(0);
	    overlays.forEach(function(ov) {
	        if (ov.tag == tempTag || ov.get('name') === tempTag) {
	            mapBox.getMapObj(mapId).removeOverlay(ov)
	        }
	    });
	}
	function createHelpTooltip(mapObj, actId) {
	    var helpTooltipElement = document.createElement('div');
	    helpTooltipElement.innerHTML = i18n.prop('measure.message.startHelper');
	    helpTooltipElement.className = 'measure-tooltip';

	    var helpTooltip = new ol.Overlay({
	        element: helpTooltipElement,
	        offset: [5, -1],
	        positioning: 'center-left'
	    });
	    helpTooltip.set('type', actId);
	    helpTooltip.set('name', actId + '_helpTooltip');
	    mapObj.addOverlay(helpTooltip);
	    helpTooltipElement.parentNode.style.zIndex = olUtil.getPopupZIndex(mapObj.getTarget()) + 100;
	}
	function moveHelpTooltip(evt, _mapObj, actId) {
	    var geom = evt.target;
	    var mapId = _mapObj.getTarget();
	    var angleLine = evt.target;
	    var output = !isNaN(formatAngle(angleLine))&&formatAngle(angleLine).toFixed(2);
	    var tooltipCoord = geom.getLastCoordinate();
	    var helpTooltip = olUtil.getOverlayByName(mapId, actId + '_helpTooltip');
	    if (!!helpTooltip) {
	        helpTooltip.get('element').innerHTML = (function(input) {
	            var _output = i18n.prop('measure.angle.now') + input;
	            _output = _output + '<br>' + i18n.prop('measure.message.helper');
	            return _output;
	        }(output+'°'))
	        helpTooltip.setPosition(tooltipCoord);
	    }

	}
	function createActId(mapId) {
	    var str = 'measure_act_' + uid;
	    uid = uid + 1;
	    return str;
	}
	var uid = 1;
	/**
	 * Currently drawn feature.
	 * @type {ol.Feature}
	 */
	function measureAngle(mapId, color) {
	    var source = null, layer = null, draw = null, haveInteraction = null, interactionCache = null;
	    if (!color) {
	        color = '#0099ff';
	    }
	    var _mapObj = mapBox.getMapObj(mapId);
	    if (_mapObj.get('state.drawing')) {
	        return;
	    }
	    var arr = _mapObj.getInteractions();
	    var actId = createActId();
	    arr.forEach(function(interaction) {
	        if (interaction.get('measureAngle') == "have") {
	            haveInteraction = "have";
	            interactionCache = interaction;
	        }
	    });
	    if (haveInteraction === "have") {
	        interactionCache.setActive(true);
	        _mapObj.set('state.drawing', true);
	        _mapObj.set('state.measure.geoAngle', true);
	        return;
	    }
	    var features = new ol.Collection();
	    features.on('change:length', function(evt) {
	        var array = features.getArray();
	        array[array.length - 1].tag = tag;
	    });

	    var mapMain = mapBox.getMapObj(mapId);
	    source = new ol.source.Vector({wrapX: false});
	    layer = new ol.layer.Vector({
	        source: source,
	        style: new ol.style.Style({
	            fill: new ol.style.Fill({
	                color: 'rgba(255, 255, 255, 0.2)'
	            }),
	            stroke: new ol.style.Stroke({
	                color: color,//#ffcc33
	                width: 2
	            }),
	            image: new ol.style.Circle({
	                radius: 7,
	                fill: new ol.style.Fill({
	                    color: '#0099ff'//#ffcc33
	                })
	            })
	        })
	    });
	    _mapObj.set('state.drawing', true);
	    _mapObj.set('state.measure.geoAngle', true);
	    draw = new ol.interaction.Draw({
	        minPoints: 3,
	        source: source,
	        features: features,
	        type: 'LineString',
	        style: new ol.style.Style({
	            fill: new ol.style.Fill({
	                color: 'rgba(255, 255, 255, 0.2)'
	            }),
	            stroke: new ol.style.Stroke({
	                color: color,
	                width: 2
	            }),
	            image: new ol.style.Circle({
	                radius: 5,
	                stroke: new ol.style.Stroke({
	                    color: color
	                }),
	                fill: new ol.style.Fill({
	                    color: '#0099ff'
	                })
	            })
	        })
	    });
	    draw.set('measureAngle', 'have');
	    mapMain.addInteraction(draw);
	    mapMain.addLayer(layer);
	    createHelpTooltip(_mapObj, actId);
	    draw.on('drawstart', function(evt) {
	        var sketch = evt.feature;
	        _mapObj.set('measureDistance.drawLineSketch', sketch);
	        var sketchChangeHandler = sketch.getGeometry().on('change', function(evt) {
	            moveHelpTooltip(evt, _mapObj, actId);
	        });
	        _mapObj.set('measureDistance.sketchChange', sketchChangeHandler);
	    })
	    draw.on('drawend', function(evt) {
	        clearOverlay(mapId, actId + '_helpTooltip');
	        tag = tag + 1;
	        var sketch = evt.feature;
	        var geom = sketch.getGeometry();
	        var newCoors = geom.getCoordinates().slice(0, 3);
	        evt.feature.getGeometry().setCoordinates(newCoors);
	        var angle = formatAngle(geom);
	        addCloseButton(mapId, layer, evt.feature.getGeometry().getLastCoordinate());
	        //画弧线
	        var coor = geom.getCoordinates();

	        var point00 = coor[0];
	        var point01 = coor[1];
	        var point02 = coor[2];
	        var x1 = point00[0] - point01[0];
	        var y1 = point00[1] - point01[1];
	        var x2 = point02[0] - point01[0];
	        var y2 = point02[1] - point01[1];
	        var length1 = Math.sqrt(Math.pow(x1, 2) + Math.pow(y1, 2));
	        var length2 = Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2));
	        var radios;
	        if (length1 >= length2) {
	            radios = length2;
	        }
	        else {
	            radios = length1;
	        }
	        if (radios !== 0) {
	            var point01proj = ol.proj.toLonLat(point01);
	            var pointNorth = ol.proj.fromLonLat([point01proj[0], 85]);
	            var linePoints3857 = [];
	            measurePoints(point00, point01, radios, linePoints3857);
	            linePoints3857.push(point01);
	            measurePoints(point02, point01, radios, linePoints3857);

	            var line = new ol.geom.LineString(linePoints3857);
	            var lineForNorthAngle = new ol.geom.LineString([
	                pointNorth, point01, linePoints3857[2]
	            ]);
	            var angle1 = formatAngle(lineForNorthAngle);
	            var circleAngle = formatAngle(line);
	            var angleMu = angle1 - (circleAngle / 2);
	            var short = shortLineLength(line);
	            var radius = short * 6.5 / 7 / 100000;
	            var dateArr = math.createSector(point01proj[0], point01proj[1], radius, angleMu,
	                circleAngle);
	            var linePoints4326 = dateArr.slice(1, dateArr.length - 3);
	            var startPointX = ol.proj.fromLonLat(dateArr.slice(dateArr.length - 3, dateArr.length - 2)[0]);
	            var endPointX = ol.proj.fromLonLat(dateArr.slice(dateArr.length - 2, dateArr.length - 1)[0]);
	            var startPointY = point01;
	            var endPointY = point00;
	            var myLine1 = new ol.geom.LineString([startPointX, endPointX]);
	            var myLine2 = new ol.geom.LineString([startPointY, endPointY]);
	            var crossPoint1 = utils.getCrossPoint_(startPointX, endPointX, startPointY, endPointY, true);
	            var PointsArr = [];
	            PointsArr.push(linePoints3857[2]);
	            linePoints4326.forEach(function(coordinate) {
	                var newCoordinate = ol.proj.fromLonLat(coordinate);
	                PointsArr.push(newCoordinate);
	            });
	            PointsArr.push(crossPoint1);
	            var circle = new ol.geom.LineString(PointsArr);
	            var lineFeature = new ol.Feature({
	                geometry: circle
	            });
	            lineFeature.tag = tag;
	            lineFeature.setStyle(new ol.style.Style({
	                fill: new ol.style.Fill({
	                    color: 'rgba(255, 255, 255, 0.2)'
	                }),
	                stroke: new ol.style.Stroke({
	                    color: color,//#ffcc33
	                    width: 1
	                }),
	                text: new ol.style.Text({
	                    font: '12px Calibri,sans-serif',
	                    text: angle.toFixed(2) + '°',
	                    fill: new ol.style.Fill({
	                        color: 'black'//#000
	                    })
	                }),
	                image: new ol.style.Circle({
	                    radius: 7,
	                    fill: new ol.style.Fill({
	                        color: '#ffcc33'
	                    })
	                })
	            }));
	            source.addFeature(lineFeature);
	            sketch = null;
	        }
	        setTimeout(function() {
	            if (radios === 0) {
	                clearMeasure(mapId, layer, tag);
	            }
	            _mapObj.set('state.drawing', false);
	            _mapObj.set('state.measure.geoArea', false);
	            _mapObj.set('state.measure.geoAngle', false);
	            mapMain.removeInteraction(draw);
	        }, 100);

	    }, this);
	}

	module.exports = {
	    measureAngle: measureAngle
	};

/***/ },
/* 105 */
/*!***************************************!*\
  !*** ./src/gis/tools/drawGeometry.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var domUtil = __webpack_require__(/*! utils/domUtil */ 10);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var I18n = __webpack_require__(/*! utils/i18n */ 13);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);

	var d = domUtil, u = utils, i18n = I18n, uId = 1;
	var actPool = {};

	var DrawTypes = {
	    Point: 'Point',
	    LineString: 'LineString',
	    Polygon: 'Polygon',
	    Circle: 'Circle',
	    Square: 'Square',
	    Box: 'Box'
	};

	function isNull(obj) {
	    return obj === null;
	}

	function last(arr) {
	    if (!arr) {
	        return;
	    }
	    return arr[arr.length - 1];
	}

	function getMap(mapId) {
	    return mapBox.getMapObj(mapId);
	}

	function uniqueId(str) {
	    var strId = str + uId;
	    uId = uId + 1;
	    return strId;
	}

	/**
	 * 通过名字获取interaction
	 * @param mapId
	 * @param interName
	 */
	function getIntactByName(mapId, interName) {
	    var interactions = getMap(mapId).getInteractions().getArray();
	    return utils.find(interactions, function (item) {
	        return item.get('name') === interName;
	    });
	}

	/**
	 * 根据类型删除Feature
	 * @param source {object}   new ol.source
	 * @param type {String}
	 * */
	function delFeatureByType(source, type) {
	    if (!source) {
	        return;
	    }
	    source.getFeatures().forEach(function (feature) {
	        if (feature.get('type') === type) {
	            source.removeFeature(feature);
	        }
	    });
	}

	/**
	 * 通过layerId获取图层
	 * @param mapId
	 * @param layerId
	 * @returns {T|null|*|{}}
	 */
	function getLayerById(mapId, layerId) {
	    var layers = getMap(mapId).getLayers().getArray();
	    return utils.find(layers, function (layer) {
	        return layer.get('layerId') === layerId;
	    });
	}

	/**
	 * 新的画线操作
	 * @returns {*}
	 */
	function newActionId(mapId) {
	    var actId = uniqueId('drawGeo_act_');
	    if (!actPool[mapId]) {
	        actPool[mapId] = [];
	    }

	    actPool[mapId].push(actId);
	    return actId;
	}

	function getSketchCoords(drawer) {
	    var sketchCoords;
	    for (var x in drawer) {
	        if (!drawer.hasOwnProperty(x)) {
	            continue;
	        }
	        var item = drawer[x];
	        if (utils.isArray(item) && item.length > 0 && utils.isArray(item[0])) {
	            sketchCoords = item;
	        }
	    }
	    return sketchCoords;
	}

	function _drawGeometry(params) {
	    var mapId = params.mapId;
	    var type = params.type;
	    var olMap = getMap(mapId);
	    if (olMap.get('state.drawing')) {
	        return;
	    }
	    var drawer = null;

		setDoubleClickActive(mapId, false);
	    var actId = newActionId(mapId);
	    if (type === 'Polygon') {
	        drawer = getGeometryDrawer(mapId, type, actId, params.fillColor);
	    } else {
	        drawer = getGeometryDrawer(mapId, type, actId);
	    }

	    if (!drawer) {
	        return;
	    }
	    drawer.setActive(true);
	    var endKey = drawer.get('endKey');
	    if (endKey) {
	        drawer.unByKey(endKey);
	    }


	    endKey = drawer.on('drawend', function (evt) {
	        endHandler(params, actId, drawer, evt);
	        setDoubleClickActive(mapId, true);
	        fusiongis.Events.removeClickCallback(mapId, 'draw-geometry-click-event');
	    });
	    drawer.set('endKey', endKey);


	    if (params.clickCallback) {
	        fusiongis.Events.addClickCallback(mapId, 'draw-geometry-click-event', function (obj) {
	            var evt = obj.e;
	            var backData = {
	                coordinate: evt.coordinate,
	                evt: evt
	            };
	            params.clickCallback(backData);
	        }, 'tempGeometryLayer_' + mapId);
	    }

	}

	/**
	 * 结束处理函数
	 * @param params
	 * @param actId
	 * @param drawer
	 * @param evt
	 */
	function endHandler(params, actId, drawer, evt) {
	    var mapId = params.mapId;
	    var type = params.type;
	    var olMap = getMap(mapId);
	    evt.feature.set('type', actId);
	    evt.feature.set('id', actId);
	    if(!!!params.isStyle){
	    	evt.feature.setStyle(getStyleByParam(params));
	    }    
	    var coordinates = getSketchCoordinates(evt, drawer, type);
	    var _lastPoint = coordinates[1];
	    var _allPoint = coordinates[0];

	    if (params.showCloseIcon) {
	        var filterCoordinates = [];
	        if (!!_allPoint) {
	            for (var i = 0; i < _allPoint.length - 1; i++) {
	                filterCoordinates = _allPoint[i].concat(_allPoint[i + 1]);
	            }
	        }
	        var uniqueCoordinats = utils.unique(filterCoordinates);
	        if (uniqueCoordinats.length <= 2 && uniqueCoordinats.length > 0) {
	            addCloseButton(mapId, actId, undefined, type);

	        }
	        else {
	            addCloseButton(mapId, actId, _lastPoint, type);
	        }
	    }
	    drawer.setActive(false);

	    var clickKey = olMap.get('Keys.DrawGeometryClick');
	    if (clickKey) {
	        drawer.unByKey(clickKey);
	    }

	    if (!!params.endCallback) {
	        var coords = {};
	        var filterCoords = [];
	        if (params.type === DrawTypes.Circle) {
	            var geom = evt.feature.getGeometry();
	            coords = {
	                center: geom.getCenter(),
	                radius: geom.getRadius(),
	                lastCoordinate: geom.getLastCoordinate()
	            };
	        }
	        else if (params.type === DrawTypes.Polygon) {
	            var coordinate = evt.feature.getGeometry().getCoordinates()[0];
	            var tempCoordinates = coordinate.slice(1);
	            var flag = false;
	            if (tempCoordinates.length > 1) {
	                for (var i = 0; i < tempCoordinates.length - 1; i++) {
	                    if (tempCoordinates[i][0] !== tempCoordinates[i + 1][0] || tempCoordinates[i][1] !== tempCoordinates[+1][1]) {
	                        flag = true;
	                    }
	                }
	            }
	            setTimeout(function () {
	                if (!flag) {
	                    closeGeometryDraw(mapId, actId);
	                }
	            }, 500);
	            coords = olUtil.transform(coordinate, 3857, 4326);
	        }
	        else if (params.type === DrawTypes.Point) {
	            coords = evt.feature.getGeometry().getCoordinates();
	            coords = olUtil.transform(coords, 3857, 4326);
	            
	        }
	        else if (params.type === DrawTypes.LineString) {
	            coords = evt.feature.getGeometry().getCoordinates();
	            for (var i = 0; i < coords[0].length - 1; i++) {
	                filterCoords = coords[i].concat(coords[i + 1]);
	            }
	            coords = olUtil.transform(coords, 3857, 4326);
	        }
	        else {
	            coords = evt.feature.getGeometry().getCoordinates();
	        }
	        if(typeof params.endCallback === 'function') {
	        	params.endCallback({
	        		mapId: mapId,
	        		actId: actId,
	        		coordinates: coords
	        	});
	        }
	        
	        
	    }
		if(!!!params.isClear){
	        setTimeout(function(){
	            closeDrawAndClear(params, olMap, mapId, actId);
	        },500)

		}
	    
	    setTimeout(function () {
	        olMap.set('state.draw.' + params.type, false);
	    }, 1000);

	}

	function closeDrawAndClear(param, mapObj, mapId, actId) {
	    if (!param.showGeometry) {
	        clearFeature(mapId, actId);
	    }
	    mapObj.set('state.drawing', false);

	}

	function getStyleByParam(param) {
	    return new ol.style.Style({
	        fill: new ol.style.Fill({
	            color: param.fillColor || 'rgba(255, 255, 255, 0.2)'
	        }),
	        stroke: new ol.style.Stroke({
	            color: param.strokeColor || '#0099FF',
	            width: param.strokeWidth || 3
	        }),
	        image: new ol.style.Circle({
	            radius: param.imageRadius || 7,
	            fill: new ol.style.Fill({
	                color: param.imageFillColor || '#0099FF'
	            }),
	            stroke: new ol.style.Stroke({
	                color: param.imageStrokeColor || '#FFFFFF',
	                width: param.imageStrokeWidth || 1
	            })
	        })
	    });
	}

	function getSketchCoordinates(evt, drawer, drawType) {
	    var geom = evt.feature.getGeometry();
	    var sketchCoordinates = getSketchCoords(drawer);

	    if (drawType === DrawTypes.Point) {
	        var coordinate = geom.getCoordinates();
	        return [sketchCoordinates, coordinate];
	    }
	    if (drawType === DrawTypes.LineString) {
	        var coordinate = geom.getCoordinates();
	        return [sketchCoordinates, last(coordinate)];
	    }
	    if (drawType === DrawTypes.Polygon) {
	        var coordinate = geom.getCoordinates();
	        var _coordinate = coordinate[0];
	        return [sketchCoordinates, _coordinate[_coordinate.length - 2]];
	    }
	    if (drawType === DrawTypes.Circle) {
	        return [sketchCoordinates, last(sketchCoordinates)];
	    }
	    if (drawType === DrawTypes.Square) {
	        return [sketchCoordinates, last(sketchCoordinates)];
	    }
	    if (drawType === DrawTypes.Box) {
	        return [sketchCoordinates, last(sketchCoordinates)];
	    }

	}

	function setDoubleClickActive(mapId, active) {
	    var interactions = getMap(mapId).getInteractions().getArray();
	    interactions.forEach(function (item) {
	        if (item instanceof ol.interaction.DoubleClickZoom) {
	        	if (active) {
	        		setTimeout(function() {
	        			item.setActive(active);
	        		}, 500);
	        	}
	        	else {
	        		item.setActive(active);
	        	}
	        }
	    });
	}

	/**
	 * 添加关闭按钮
	 * @param mapId
	 * @param actId
	 * @param coordinates
	 */
	function addCloseButton(mapId, actId, coordinates, type) {
	    var closeIconElement = document.createElement('div');
	    closeIconElement.className = 'measure-close';
	    closeIconElement.mapId = mapId;
	    closeIconElement.actId = actId;
	    domUtil.on(closeIconElement, 'click', function () {
	        closeGeometryDraw(this.mapId, this.actId);
	        var identify = '';
	        if (type === 'Point') {
	            identify = 'tempPoint';
	        }
	        else if (type === 'LineString') {
	            identify = 'tempLine';
	        }
	        else if (type === 'Polygon') {
	            identify = 'tempPolygon';
	        }
	        var layer = hashMap.get(identify + '_' + mapId);
	        if (layer) {
	            var source = layer.getSource();
	            var hLayer = fusiongis.Highlight.getHLayer({
	                mapId: mapId,
	                layerId: layer.get('layer_id')
	            });
	            var _feature = source.getFeatureById(actId);
	            var hFeature = hLayer.getSource().getFeatures()[0];
	            if (!!_feature) {
	                source.removeFeature(_feature);
	            }
	            if (hFeature) {
	                hLayer.getSource().removeFeature(hFeature);
	            }
	        }
	    });

	    var closeIcon = new ol.Overlay({
	        element: closeIconElement,
	        offset: [15, 6],
	        positioning: 'bottom-center'
	    });
	    closeIcon.set('name', actId + '_close');
	    closeIcon.set('type', actId);
	    getMap(mapId).addOverlay(closeIcon);

	    closeIcon.setPosition(coordinates);
	}

	function getDrawLayer(mapId) {
	    var layer = hashMap.get('tempGeometryLayer_' + mapId);
	    if (!!!layer) {
	        layer = new ol.layer.Vector({
	            layerId: 'tempGeometryLayer',
	            type: 'tempGeometryLayer',
	            source: new ol.source.Vector({wrapX:false}),
	            style: new ol.style.Style({
	                fill: new ol.style.Fill({
	                    color: 'rgba(255, 255, 255, 0.2)'
	                }),
	                stroke: new ol.style.Stroke({
	                    color: '#0099FF',
	                    width: 3
	                }),
	                image: new ol.style.Circle({
	                    radius: 7,
	                    fill: new ol.style.Fill({
	                        color: '#0099FF'
	                    })
	                })
	            }),
	            opacity: 0
	        });
	        hashMap.put('tempGeometryLayer_' + mapId, layer);
	        getMap(mapId).addLayer(layer);
	    }
	    return layer;
	}

	function getGeometryDrawer(mapId, drawType, actId, fillStyle) {
	    var olMap = getMap(mapId);

	    var drawer = getIntactByName(mapId, 'geometryDrawer');
	    if (drawer) {
	        if (drawType === drawer.get('drawType')) {
	            drawer.set('actId', actId);
	            return drawer;
	        }
	        else {
	            olMap.removeInteraction(drawer);
	        }
	    }
	    var interType = drawType;

	    if (drawType !== 'None') {
	        var geometryFunction, maxPoints;

	        if (drawType === 'Square') {
	            interType = 'Circle';
	            geometryFunction = ol.interaction.Draw.createRegularPolygon(4);
	        }
	        else if (drawType === 'Box') {
	            interType = 'LineString';
	            maxPoints = 2;
	            geometryFunction = function (coordinates, geometry) {
	                if (!geometry) {
	                    geometry = new ol.geom.Polygon(null);
	                }
	                var start = coordinates[0];
	                var end = coordinates[1];
	                geometry.setCoordinates([
	                    [start, [start[0], end[1]], end, [end[0], start[1]], start]
	                ]);
	                return geometry;
	            };
	        }

	        drawer = new ol.interaction.Draw({
	            name: 'geometryDrawer',
	            actId: actId,
	            source: !!getDrawLayer(mapId) && getDrawLayer(mapId).getSource(),
	            type: (interType),
	            geometryFunction: geometryFunction,
	            maxPoints: maxPoints
	        });

	        if (drawType === 'Polygon') {
	            drawer = new ol.interaction.Draw({
	                name: 'geometryDrawer',
	                actId: actId,
	                source: !!getDrawLayer(mapId) && getDrawLayer(mapId).getSource(),
	                style: new ol.style.Style({
	                    fill: new ol.style.Fill({
	                        color: fillStyle === undefined ? 'transparent':fillStyle
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color: '#0099FF',
	                        width: 2
	                    }),
	                    image: new ol.style.Circle({
	                        radius: 5,
	                        stroke: new ol.style.Stroke({
	                            color: '#0099FF'
	                        }),
	                        fill: new ol.style.Fill({
	                            color: '#0099FF'
	                        })
	                    })
	                }),
	                type: (interType),
	                geometryFunction: geometryFunction,
	                maxPoints: maxPoints
	            });

	        }

	        drawer.set('name', 'geometryDrawer');
	        drawer.set('actId', actId);
	        drawer.set('drawType', drawType);
	        olMap.addInteraction(drawer);
	    }
	    return drawer;
	}

	function closeGeometryDraw(mapId, actId) {
	    clearFeature(mapId, actId);
	    clearOverlay(mapId, actId);
	}

	/**
	 * 根据mapId,actId清除featrue
	 * @param mapId
	 * @param actId
	 */
	function clearFeature(mapId, actId) {
	    var layer = getDrawLayer(mapId);
	    if (layer) {
	        delFeatureByType(layer.getSource(), actId);
	    }
	}

	/**
	 * 根据mapId清除features
	 * @param mapId
	 */
	function clearFeatures(mapId) {
	    var layer = getDrawLayer(mapId);
	    layer.getSource().clear();
	}

	/**
	 * 清空overlay
	 * @param mapId
	 * @param actId
	 */
	function clearOverlay(mapId, actId) {
	    var map = getMap(mapId);
	    var overlays = map.getOverlays().getArray().slice(0);
	    overlays.forEach(function (ov) {
	        var ovType = ov.get('type');
	        if (ovType && ovType === actId) {
	            map.removeOverlay(ov);
	        }
	    });
	    if (actPool[mapId]) {
	        var index = actPool[mapId].indexOf(actId);
	        if (index > -1) {
	            actPool[mapId].splice(index, 1);
	        }
	    }
	}

	/**
	 * 根据mapId清空overlays
	 * @param mapId
	 */
	function clearOverlays(mapId) {
	    var map = getMap(mapId);
	    var pool = actPool[mapId];
	    if (!pool && pool.length) {
	        return;
	    }
	    var overlays = map.getOverlays().getArray().slice(0);
	    overlays.forEach(function (ov) {
	        var ovType = ov.get('type');
	        if (ovType && pool.indexOf(ovType) > -1) {
	            map.removeOverlay(ov);
	        }
	    });
	    pool.splice(0, pool.length);
	}

	/**
	 * 根据mapId清空画的Geometry
	 * @param mapId
	 */
	function clearGeometryDraw(mapId) {
	    clearFeatures(mapId);
	    clearOverlays(mapId);
	}

	/**
	 * 关闭正在画的Geometry
	 * @param mapId
	 */
	function closeActiveDraw(mapId) {
	    var drawer = getIntactByName(mapId, 'geometryDrawer');
	    if (drawer && drawer.getActive()) {
	        drawer.setActive(false);
	        var actId = drawer.get('actId');
	        if (actId) {
	            closeGeometryDraw(mapId, actId);
	        }
	    }
	}

	function drawGeometry(params) {
	    var mapId = params.mapId;
	    var olMap = getMap(mapId);
	    if (!olMap) {
	        return;
	    }

	    if (params.isOpen) {
	        _drawGeometry(params);
	        olMap.set('state.drawing', true);
	        olMap.set('state.draw.' + params.type, true);
	    }
	    else {
	        closeActiveDraw(mapId);
	        olMap.set('state.drawing', false);
	        setTimeout(function() {
	        	olMap.set('state.draw.' + params.type, false);
	        }, 1100);
	    }
	}

	function isDrawing(params) {
	    var map = mapBox.getMapObj(params.mapId);
	    if (!map) {
	        return false;
	    }
	    var drawType = params.type || 'Point';
	    return map.get('state.draw.' + drawType);
	}

	module.exports = {
	    DrawTypes: DrawTypes,
	    drawGeometry: drawGeometry,
	    isDrawing: isDrawing,
	    clearGeometryDraw: clearGeometryDraw
	};

/***/ },
/* 106 */
/*!***************************************!*\
  !*** ./src/gis/tools/searchLocate.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);

	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var googleMap = __webpack_require__(/*! maps/googleMap */ 24);

	var _createXMLHttpRequest = function () {
	    var xmlHttpRequest;
	    if (window.XMLHttpRequest) {
	        xmlHttpRequest = new XMLHttpRequest();
	        if (xmlHttpRequest.overrideMimeType) {
	            xmlHttpRequest.overrideMimeType("text/xml");
	        }
	    }
	    else if (window.ActiveXObject) {
	        var activexName = ["MSXML2.XMLHTTP", "Microsoft.XMLHTTP"];
	        for (var i = 0; i < activexName.length; i++) {
	            try {
	                //取出一个控件名进行创建，如果创建成功就终止循环
	                //如果创建失败，回抛出异常，然后可以继续循环，继续尝试创建
	                xmlHttpRequest = new ActiveXObject(activexName[i]);
	                if (xmlHttpRequest) {
	                    break;
	                }
	            }
	            catch (e) {
	            }
	        }
	    }
	    return xmlHttpRequest;
	};

	var addMarker = function (paramObj) {
	    var layerId_ = 'search_result_inner_layer_id';
	    var _mapId = paramObj.mapId;
	    var _layerId = layerId_ + '_' + _mapId;
	    var _coordinate = paramObj.coordinate;
	    var _imgUrl = paramObj.imgUrl;
	    var _layer = null;

	    if (hashMap.containsKey(_layerId)) {
	        _layer = hashMap.get(_layerId);
	    }
	    else {
	        paramObj.layerId = layerId_;
	        baseLayer.createLayer(paramObj);
	        _layer = hashMap.get(_layerId);
	    }
	    var _glbSource = _layer.getSource();
	    var coordinate_ = ol.proj.fromLonLat(_coordinate);
	    var _point = new ol.geom.Point(coordinate_);
	    var _feature = new ol.Feature({
	        geometry: _point
	    });

	    var _style = new ol.style.Style({
	        image: new ol.style.Icon({
	            src: _imgUrl || constant.GisResourceURL + 'search/search-result-icon.png'
	        })
	    });
	    _feature.setStyle(_style);
	    _glbSource.clear();
	    _glbSource.addFeature(_feature)
	};

	var clearMarker = function (mapId) {
	    var layerObj = hashMap.get('search_result_inner_layer_id_' + mapId);
	    if (!!layerObj) {
	        layerObj.getSource().clear();
	    }
	};

	var osmSearch = function (paramObj) {
	    var xmlHttp = _createXMLHttpRequest();
	    var _protocol = 'http:';
	    if (location.protocol !== 'file:') {
	        _protocol = location.protocol;
	    }

	    // 不支持跨域访问，只能通过openstreetmap服务根据地址查找空间位置信息
	    var url = encodeURI(_protocol + '//nominatim.openstreetmap.org/search?q='
	        + paramObj.address + '&format=json&polygon=1&addressdetails=1&num=' + Math.random());
	    xmlHttp.open("GET", url, true);
	    xmlHttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded;");
	    xmlHttp.onreadystatechange = function () {
	        if (xmlHttp.readyState == 4) {
	            if (xmlHttp.status == 200) {
	                var _resultText = xmlHttp.responseText;
	                var _resultList = JSON.parse(_resultText);
	                var _params = [];
	                if (_resultList && _resultList.length > 0) {
	                    _resultList.forEach(function (result) {
	                        var _address = result.address;
	                        var bbox = result.boundingbox;
	                        _params.push({
	                            centerLonLat: [parseFloat(result.lon), parseFloat(result.lat)],
	                            displayName: result.display_name,
	                            type: result.type,
	                            placeId: result.place_id,
	                            city: _address.city,
	                            country: _address.country,
	                            countryCode: _address.country_code,
	                            postCode: _address.postcode,
	                            bbox: [
	                                parseFloat(bbox[2]), parseFloat(bbox[0]), parseFloat(bbox[3]),
	                                parseFloat(bbox[1])
	                            ]
	                        });
	                    });
	                }
	                else {
	                    _params.push({
	                        displayName: 'Sorry, we do not found the information you want'
	                    })
	                }

	                if (paramObj.callback && typeof paramObj.callback === 'function') {
	                    paramObj.callback(_params)
	                }

	            }
	            else {
	                console.log('search location failed');
	            }
	        }
	    };
	    xmlHttp.send();
	};

	var googleSearch = function (paramObj) {
	    //是否加载了谷歌map
	    if (!!paramObj && !!paramObj.key) {
	        googleMap.loadGoogleAPI(paramObj.key, paramObj.language, function (isTrue) {
	            if(isTrue){
	                var _geocoder = new google.maps.Geocoder();
	                _geocoder.geocode({'address': paramObj.address}, function (_resultList, status) {
	                    if (status == google.maps.GeocoderStatus.OK) {
	                        var _params = [];
	                        if (_resultList && _resultList.length > 0) {
	                            _resultList.forEach(function (result) {
	                                var _bbox = [];
	                                if (result.geometry.bounds) {
	                                    _bbox = [
	                                        result.geometry.bounds.b.b, result.geometry.bounds.f.f,
	                                        result.geometry.bounds.b.f, result.geometry.bounds.f.b
	                                    ]
	                                }
	                                _params.push({
	                                    centerLonLat: [
	                                        parseFloat(result.geometry.location.lng()),
	                                        parseFloat(result.geometry.location.lat())
	                                    ],
	                                    displayName: result.formatted_address,
	                                    bbox: _bbox
	                                });
	                            });
	                        }
	                        else {
	                            _params.push({
	                                displayName: 'Sorry, we do not found the information you want'
	                            })
	                        }

	                        if (paramObj.callback && typeof paramObj.callback === 'function') {
	                            paramObj.callback(_params)
	                        }
	                    }
	                    else {
	                        alert("Geocode was not successful for the following reason: " + status);
	                    }
	                });
	            }
	        });
	    }
	};

	var searchLocal = function (paramObj) {
	    if (paramObj.serviceVendor === constant.Search_Engine.OSM) {
	        osmSearch(paramObj);
	    }
	    else if (paramObj.serviceVendor === constant.Search_Engine.GOOGLE) {
	        googleSearch(paramObj);
	    }
	};
	module.exports = {
	    searchLocal: searchLocal,
	    addMarker: addMarker,
	    clearMarker: clearMarker
	};

/***/ },
/* 107 */
/*!***************************************!*\
  !*** ./src/gis/tools/searchObject.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	var ajax = __webpack_require__(/*! utils/ajax */ 14);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var OlUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var constant = __webpack_require__(/*! framework/constant */ 2);

	var seachFeature = function (type, data, callback) {
	    if (type === 1) {
	        ajax.postJSON({
				url: constant.GisRootUrl + "/spatialAnalysis/contain/geomContainGeoms",
				data: JSON.stringify({
					"containFcObject": data.containFcObject,
					"containedFcObjectList": data.containedFcObjectList
				}),
				success: function(responseText) {
					callback(responseText);
				},
				failure: function(responseText) {
					callback({
						msg: responseText
					});
				}
	        });
	    }
	    else if (type === 2) {
	        ajax.postJSON({
	            url: constant.GisRootUrl + "/spatialAnalysis/contain/fcosContainFcos",
	            data: JSON.stringify({
	                "containFcObjectId": data.containFcObjectId,
	                "containedFcObjectIdList": data.containedFcObjectIdList,
	                "featureClassNameContain": data.featureClassNameContain,
	                "featureClassNameContained": data.featureClassNameContained
	            }),
	            success: function (responseText) {
	                callback(responseText);
	            },
	            failure: function(responseText) {
					callback({
						msg: responseText
					});
	           }
	        })
	    }
	    else if (type === 3) {
	        ajax.postJSON({
	            url: constant.GisRootUrl + "/spatialAnalysis/contain/geomContainFcos",
	            data: JSON.stringify({
	                "containFcObject": data.containFcObject,
	                "containedFcObjectIdList": data.containedFcObjectIdList,
	                "featureClassNameContained": data.featureClassNameContained
	            }),
	            success: function (responseText) {
	                callback(responseText);
	            },
	            failure: function(responseText) {
					callback({
						msg: responseText
					});
	        	}
	        
	        });
	    }
	    else if (type === 4) {
	        fusiongis.OriginalAjax.postJSON({
	            url: fusiongis.Constant.GisRootUrl + "/spatialAnalysis/contain/fcosContainGeoms",
	            data: JSON.stringify({
	                    "containFcObjectId": data.containFcObjectId,
	                    "featureClassNameContain": data.featureClassNameContain,
	                    "containedFcObjectList": data.containedFcObjectList
	                }
	            ),
	            success: function (responseText) {
	                callback(responseText);
	            },
	            failure: function (responseText) {
	                callback({
	                    msg: responseText
	                });
	            }
	        })
	    }

	};

	function seachFeatures(param){
	    var mapObj = mapBox.getMapObj(param.mapId);
	    var type = param.type ? param.type : 'all';
	    var callback = param.callback;
	    var features = [];
	    var layer = OlUtil.getLayer({
	        mapId: param.mapId,
	        layerId: 'tempPolygon_'+param.mapId
	    });
	    if (!layer) {
	        fusiongis.Polygon.addLayer({
	            mapId: param.mapId,
	            layerId: 'tempPolygon'
	        })
	    }
	    fusiongis.Geometry.drawGeometry({
	        mapId: param.mapId,
	        type: fusiongis.Geometry.DrawTypes.Box,
	        isOpen: true,
	        showCloseIcon: false,
	        endCallback: function (res) {
	            console.log(res);
	            var _coordinates = [];
	            for (var j = 0; j < res.coordinates[0].length; j++) {
	                _coordinates.push(ol.proj.transform(res.coordinates[0][j], 'EPSG:3857', 'EPSG:4326'))
	            }
	            var _geoPolygon = new ol.geom.Polygon([res.coordinates[0]]);
	            if (_geoPolygon.getArea() > 0) {
	                var _extent = _geoPolygon.getExtent();
	                var layerList = mapObj.getLayers();
	                layerList.forEach(function(layer){
	                    var layerType = layer.get('businessType');
	                    if(layerType){
	                        var feature = [];
	                        if(type === 'all'){
	                            feature = layer.getSource().getFeaturesInExtent(_extent);
	                        }else if(type === layerType){
	                            feature = layer.getSource().getFeaturesInExtent(_extent);
	                        }
	                        features = features.concat(feature)
	                    }
	                })
	                if(callback && typeof callback==='function'){
	                    callback({
	                        extext:_extent,
	                        features:features
	                    })
	                }
	            }

	        }
	    })
	};

	function searchByImgToken(param){
	    var callback = param.callback;
	    var _drawType=fusiongis.Geometry.DrawTypes.Box;
	    var drawType = param.drawType === undefined ? _drawType: param.drawType;
	    fusiongis.Geometry.drawGeometry({
	        mapId: param.mapId,
	        type: drawType,
	        isOpen: true,
	        showCloseIcon: false,
	        endCallback: function (res) {
	            console.log(res);
	            var pointsData="";
	            if(drawType=='Box'){
	                var _pointsData=[];
	                res.coordinates[0].forEach(function(point){
	                    _pointsData.push(ol.proj.toLonLat(point));
	                });
	                pointsData=_pointsData.join("-");
	            }else{
	                pointsData=res.coordinates.join("-");
	            }
	            var pointsParam=pointsData.replace(/,/g," ");
	            var _pointsParam=pointsParam.replace(/-/g,",");
	            ajax.postJSON({
	                url:constant.GisRootUrl+"/mapRender/contains",
	                data: JSON.stringify({
	                    "polygon": "POLYGON(("+_pointsParam+"))",
	                    "imgToken": param.imgToken
	                }),
	                success: function (result) {
	                    var responseText = JSON.parse(result);
	                    var status = responseText.status;
	                    if (status.code === 1){
	                        callback(responseText);
	                    }
	                },
	                failure: function(result) {
						callback({
							msg: result
						});
	                }
	            })
	        }
	    })
	};

	function searchBackStage(param){
	    var callback = param.callback;
	    var _drawType=fusiongis.Geometry.DrawTypes.Box;
	    var drawType = param.drawType === undefined? _drawType: param.drawType;
	    fusiongis.Geometry.drawGeometry({
	        mapId: param.mapId,
	        type: drawType,
	        isOpen: true,
	        showCloseIcon: false,
	        endCallback: function (res) {
	            console.log(res);
	            var pointsData=[];
	            if(drawType=='Box'){
	                res.coordinates[0].forEach(function(point){
	                    pointsData.push(ol.proj.toLonLat(point));
	                });
	            }else{
	                pointsData=res.coordinates;
	            }
	            ajax.postJSON({
	                url: constant.GisRootUrl+"/spatialAnalysis/contain/geomContainFcos",
	                data: JSON.stringify({
	                    "containFcObject":{
	                        "cordinates":pointsData,
	                        "geometryId": "1",
	                        "geometryType":"POLYGON"
	                     },
	                     "containedFcObjectIdList": [],
	                     "featureClassNameContained":param.featureClassNameContained
	    }),
	                success: function (result) {
	                    var responseText = JSON.parse(result);
	                    var status = responseText.status;
	                    if (status.code === 1){
	                        callback(responseText);
	                    }
	                },
	                failure: function(result) {
						callback({
							msg: result
						});
	                }
	            })
	        }
	    })
	};
	module.exports = {
	    seachFeature: seachFeature,
	    seachFeatures:seachFeatures,
	    searchByImgToken:searchByImgToken,
	    searchBackStage:searchBackStage
	};

/***/ },
/* 108 */
/*!***************************************!*\
  !*** ./src/gis/tools/mapGraticule.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);

	/**
	 *
	 * @param param
	 * param = {
	 *      mapId: '',
	 *      cellWidth: 100 经纬线之间距离
	 * }
	 */
	var addGraticule = function (param) {
	    var _mapId = param.mapId;
	    var _mapObj = mapBox.getMapObj(_mapId);//根据地图id获取地图对象
	    var graticule = _mapObj.get('graticule');
	    if (!!!graticule) {
	        graticule = new ol.Graticule({
	            strokeStyle: new ol.style.Stroke({
	                color: '#3B78FD',
	                width: 2,
	                lineDash: [0.5, 4]
	            }),
	            targetSize: param.cellWidth || 100
	        });
	        _mapObj.set('graticule', graticule);//给地图设置属性
	    }
	    _mapObj.set('state', true);
	    graticule.setMap(_mapObj);//把辅助线加上

	};

	var removeGraticule = function (param) {
	    var _mapId = param.mapId;
	    var _mapObj = mapBox.getMapObj(_mapId);
	    var graticule = _mapObj.get('graticule');
	    if (!!graticule) {
	        _mapObj.set('state', false);
	        graticule.setMap(null);
	    }

	};

	function toggleGraticule(params) {
	    var _mapId = params.mapId;
	    var _mapObj = mapBox.getMapObj(_mapId);
	    var active = _mapObj.get('state');
	    if (active) {
	        removeGraticule(params);
	    }
	    else {
	        addGraticule(params);
	    }

	}

	module.exports = {
	    addGraticule: addGraticule,
	    removeGraticule: removeGraticule,
	    toggleGraticule: toggleGraticule
	};

/***/ },
/* 109 */
/*!*********************************!*\
  !*** ./src/gis/tools/select.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);

	function selectMode(param, callBack) {
	    var layerId = param.layerId;
	    var mapId = param.mapId;
	    var isOpen = param.isOpen;
	    var _mapObj = mapBox.getMapObj(mapId);
	    var source = new ol.source.Vector({wrapX: false});
	    var key = mapId + '_' + 'select';
	    var draw = hashMap.get(key);

	    var geometryFunction = function (coordinates, geometry) {
	        if (!geometry) {
	            geometry = new ol.geom.Polygon(null);
	        }
	        var start = coordinates[0];
	        var end = coordinates[1];
	        geometry.setCoordinates([
	            [start, [start[0], end[1]], end, [end[0], start[1]], start]
	        ]);
	        return geometry;
	    };

	    if (!!draw) {
	        draw.setActive(isOpen);
	        _mapObj.set('state.drawing', isOpen);
	        return;
	    }
	    else {
	        draw = new ol.interaction.Draw({
	            source: source,
	            type: 'LineString',
	            geometryFunction: geometryFunction,
	            maxPoints: 2,
	            style: new ol.style.Style({
	                fill: new ol.style.Fill({
	                    color: 'rgba(255, 255, 255, 0)'
	                }),
	                stroke: new ol.style.Stroke({
	                    color: 'rgba(255, 0, 0, 0.5)',
	                    width: 2
	                }),
	                image: new ol.style.Circle({
	                    radius: 5,
	                    stroke: new ol.style.Stroke({
	                        color: 'rgba(0, 0, 0, 0.7)'
	                    }),
	                    fill: new ol.style.Fill({
	                        color: 'rgba(255, 255, 255, 0.2)'
	                    })
	                })
	            })
	        });
	        hashMap.put(key, draw);
	    }

	    var setUpExtent = function (startPoint, endPoint) {
	        var minX = startPoint[0] <= endPoint[0] ? startPoint[0] : endPoint[0];
	        var maxX = startPoint[0] >= endPoint[0] ? startPoint[0] : endPoint[0];
	        var minY = startPoint[1] <= endPoint[1] ? startPoint[1] : endPoint[1];
	        var maxY = startPoint[1] >= endPoint[1] ? startPoint[1] : endPoint[1];
	        return [minX, minY, maxX, maxY];
	    };

	    function queryWithExtent(layerId, mapId, extent) {
	        var resultArr = [];
	        var _layerId = layerId + '_' + mapId;
	        var _layer = null;
	        if (hashMap.containsKey(_layerId)) {
	            _layer = hashMap.get(_layerId);
	        }
	        else {
	            return;
	        }
	        var _source = _layer.getSource();
	        var _features = _source.getFeatures();
	        _features.forEach(function (feature) {
	            var coors = feature.getGeometry().getCoordinates()[0];
	            var isContain = ol.extent.containsCoordinate(extent, coors[coors.length - 1]);
	            if (isContain) {
	                var cellId = feature.getId();
	                var centerPoint = coors[coors.length - 1];
	                var points = coors.slice(0, coors.length - 1);
	                var cell = {
	                    cellId: cellId,
	                    centerPoint: centerPoint,
	                    points: points
	                };
	                resultArr.push(cell);
	            }
	        });
	        return resultArr;
	    }

	    draw.on('drawend', function (evt) {
	        var geom = evt.feature.getGeometry();
	        var points = geom.getCoordinates()[0];
	        var start = points[0];
	        var end = points[2];
	        var extent = setUpExtent(start, end);
	        var selectedCell = queryWithExtent(layerId, mapId, extent);
	        if (!!callBack && typeof callBack === 'function') {
	            callBack(selectedCell);
	        }
	    }, this);
	    _mapObj.set('state.drawing', true);
	    _mapObj.addInteraction(draw);
	}
	module.exports = {
	    selectMode: selectMode
	};

/***/ },
/* 110 */
/*!***************************************!*\
  !*** ./src/gis/tools/migrationMap.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);

	var addMigrationMap = function (param) {
	    var _layerId = param.layerId;
	    var _mapId = param.mapId;
	    var _type = param.style.type ? param.style.type : 1;

	    fusiongis.LineAdd.addLineType(param);
	    param.numberOfPoints =500;
	    var bezierLineCoordinate =fusiongis.Curve.addCurve(param);

	    var firstFeaturePoint = new ol.Feature();
	    var firstFeature = new ol.Feature();
	    var secondFeature = new ol.Feature();
	    var lastFeature = new ol.Feature();
	    var lastFeature1 = new ol.Feature();
	    var lastFeature2 = new ol.Feature();
	    var firstPoint, firstLine, secondLine, lastLine, lastLine1, lastLine2 = null;
	    var i = 0;
	    var rotation = 0;
	    if (_type === 1) {
	        var PointStyle = new ol.style.Style({
	            image: new ol.style.Circle({
	                radius: param.style.width[0] ? param.style.width[0] : 4,
	                fill: new ol.style.Fill({
	                    color: param.style.color[0] ? param.style.color[0] : [255, 255, 255, 1]
	                })

	            })
	        });
	        var firstStyle = new ol.style.Style({
	            stroke: new ol.style.Stroke({
	                color: param.style.color[1] ? param.style.color[1] : [255, 255, 255, 0.9],
	                width: param.style.width[1] ? param.style.width[1] : 5
	            })
	        });
	        var secondStyle = new ol.style.Style({
	            stroke: new ol.style.Stroke({
	                color: param.style.color[2] ? param.style.color[2] : [255, 255, 255, 0.8],
	                width: param.style.width[2] ? param.style.width[2] : 4
	            })
	        });
	        var lastStyle = new ol.style.Style({
	            stroke: new ol.style.Stroke({
	                color: param.style.color[3] ? param.style.color[3] : [255, 255, 255, 0.7],
	                width: param.style.width[3] ? param.style.width[3] : 3
	            })
	        });
	        var lastStyle1 = new ol.style.Style({
	            stroke: new ol.style.Stroke({
	                color: param.style.color[4] ? param.style.color[4] : [255, 255, 255, 0.6],
	                width: param.style.width[4] ? param.style.width[4] : 2
	            })
	        });
	        var lastStyle2 = new ol.style.Style({
	            stroke: new ol.style.Stroke({
	                color: param.style.color[5] ? param.style.color[5] : [255, 255, 255, 0.5],
	                width: param.style.width[5] ? param.style.width[5] : 1
	            })
	        });

	        firstFeaturePoint.setStyle(PointStyle);
	        firstFeature.setStyle(firstStyle);
	        secondFeature.setStyle(secondStyle);
	        lastFeature.setStyle(lastStyle);
	        lastFeature1.setStyle(lastStyle1);
	        lastFeature2.setStyle(lastStyle2);
	        var _layer = hashMap.get(_layerId + '_' + _mapId);
	        _layer.getSource().addFeature(firstFeaturePoint);
	        _layer.getSource().addFeature(firstFeature);
	        _layer.getSource().addFeature(secondFeature);
	        _layer.getSource().addFeature(lastFeature);
	        _layer.getSource().addFeature(lastFeature1);
	        _layer.getSource().addFeature(lastFeature2);
	    }
	    else if (_type === 2) {
	        var _layer = hashMap.get(_layerId + '_' + _mapId);
	        _layer.getSource().addFeature(firstFeature);
	    }

	    setInterval(function () {
	        if (i < bezierLineCoordinate.length - 1) {
	            var nowPosition = bezierLineCoordinate[i];
	            var nextPosition = bezierLineCoordinate[i + 1];
	            var x = nextPosition[0] - nowPosition[0];
	            var y = nextPosition[1] - nowPosition[1];
	            var angle = Math.atan2(y, x);

	            if (angle >= 0) {
	                rotation = Math.PI * 2 - angle;
	            }
	            else {
	                rotation = -1 * angle;
	            }
	        }

	        if (_type === 1) {
	            if (i < 454) {
	                firstPoint = new ol.geom.Point(ol.proj.fromLonLat(bezierLineCoordinate[i + 45]));
	                firstLine = new ol.geom.LineString(bezierLineCoordinate.slice(i + 36, i + 45));
	                secondLine = new ol.geom.LineString(bezierLineCoordinate.slice(i + 27, i + 36));
	                lastLine = new ol.geom.LineString(bezierLineCoordinate.slice(i + 18, i + 27));
	                lastLine1 = new ol.geom.LineString(bezierLineCoordinate.slice(i + 9, i + 18));
	                lastLine2 = new ol.geom.LineString(bezierLineCoordinate.slice(i, i + 9));
	            }
	            else {
	                firstLine =
	                    new ol.geom.LineString(bezierLineCoordinate.slice(i + 45, bezierLineCoordinate.length - i - 45));
	                secondLine =
	                    new ol.geom.LineString(bezierLineCoordinate.slice(i + 36, bezierLineCoordinate.length - i - 36));
	                lastLine =
	                    new ol.geom.LineString(bezierLineCoordinate.slice(i + 27, bezierLineCoordinate.length - i - 27));
	                lastLine1 =
	                    new ol.geom.LineString(bezierLineCoordinate.slice(i + 18, bezierLineCoordinate.length - i - 18));
	                lastLine2 =
	                    new ol.geom.LineString(bezierLineCoordinate.slice(i + 9, bezierLineCoordinate.length - i - 9));

	            }

	            firstFeaturePoint.setGeometry(firstPoint);
	            lastFeature2.setGeometry(lastLine2);
	            lastFeature1.setGeometry(lastLine1);
	            lastFeature.setGeometry(lastLine);
	            secondFeature.setGeometry(secondLine);
	            firstFeature.setGeometry(firstLine);

	        }
	        else if (_type === 2) {
	            firstPoint = new ol.geom.Point(ol.proj.fromLonLat(bezierLineCoordinate[i]));
	            firstFeature.setGeometry(firstPoint);
	            firstFeature.setStyle(new ol.style.Style({
	                image: new ol.style.Icon({
	                    src: constant.GisResourceURL + 'plane.png',
	                    size: param.style.size,
	                    imgSize: param.style.imgSize,
	                    opacity: param.style.opacity,
	                    rotation: rotation
	                })
	            }));
	        }
	        else {
	            console.warn("no support!")
	        }

	        i = (i + 2) % bezierLineCoordinate.length;

	    }, param.time);

	};

	var removeMigrationMap = function (param) {

	    var _mapId = param.mapId;
	    var _layerId = param.layerId + '_' + param.mapId;
	    var _layer = null;

	    if (hashMap.containsKey(_layerId)) {
	        _layer = hashMap.get(_layerId);
	    }
	    else {
	        return;
	    }
	    var _mapObj = mapBox.getMapObj(_mapId);
	    _mapObj.removeLayer(_layer);
	    hashMap.remove(_layerId);
	    _layer = null;
	};
	module.exports = {
	    addMigrationMap: addMigrationMap,
	    removeMigrationMap: removeMigrationMap
	};

/***/ },
/* 111 */
/*!*******************************!*\
  !*** ./src/gis/tools/wave.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);

	var newCircleWithRadius = function (center, radius) {

	    var circle = new ol.geom.Circle(ol.proj.fromLonLat(center), radius);

	    return circle;
	};

	var newCircleStyle = function (color) {
	    var style = new ol.style.Style({
	        stroke: new ol.style.Stroke({
	            color: color,
	            width: 2
	        }),
	        fill: new ol.style.Fill({
	            color: 'rgba(255,255,255,0)'
	        })
	    });

	    return style;
	}

	var addPointOnLayer = function (param) {
	    var _layerId = param.layerId;
	    var _mapId = param.mapId;
	    var center = param.center;
	    var rgb = param.RGB;
	    var paramRadius = param.bubbleRadius;
	    var radius;

	    var red = rgb[0];
	    var green = rgb[1];
	    var blue = rgb[2];

	    var _mapObj = mapBox.getMapObj(_mapId);
	    var _view = _mapObj.getView();
	    radius = paramRadius * _view.getResolution();
	    var _layer = hashMap.get(_layerId + '_' + _mapId);
	    var _source = _layer.getSource();

	    var circleOne, circleTwo, circleThree;
	    var styleOne, styleTwo, styleThree;

	    var featureOne = new ol.Feature();
	    var featureOne1 = new ol.Feature();
	    var featureOne2 = new ol.Feature();
	    var featureOne3 = new ol.Feature();
	    var featureOne4 = new ol.Feature();

	    var featureOneArr = [featureOne, featureOne1, featureOne2, featureOne3, featureOne4];

	    var featureTwo = new ol.Feature();
	    var featureTwo1 = new ol.Feature();
	    var featureTwo2 = new ol.Feature();
	    var featureTwo3 = new ol.Feature();
	    var featureTwo4 = new ol.Feature();

	    var featureTwoArr = [featureTwo, featureTwo1, featureTwo2, featureTwo3, featureTwo4];

	    var featureThree = new ol.Feature();

	    circleOne = newCircleWithRadius(center, 0.1 * radius);
	    styleOne = newCircleStyle('rgba(255,255,255,0)');
	    circleTwo = newCircleWithRadius(center, 0.55 * radius);
	    styleTwo = newCircleStyle('rgba(255,255,255,0)');
	    circleThree = newCircleWithRadius(center, 0.85 * radius);
	    styleThree = newCircleStyle('rgba(255,255,255,0)');

	    featureOne.setGeometry(circleOne);
	    featureOne.setStyle(styleOne);

	    featureTwo.setGeometry(circleTwo);
	    featureTwo.setStyle(styleTwo);

	    featureThree.setGeometry(circleThree);
	    featureThree.setStyle(styleThree);

	    featureOneArr.forEach(function (feature) {
	        _source.addFeature(feature);
	    });

	    featureTwoArr.forEach(function (feature) {
	        _source.addFeature(feature);
	    });

	    _source.addFeature(featureThree);

	    var i = 1;
	    setInterval(function () {
	        radius = paramRadius * _view.getResolution();
	        var radius1 = (paramRadius - 2) * _view.getResolution();
	        var radius2 = (paramRadius - 4) * _view.getResolution();
	        var radius3 = (paramRadius - 6) * _view.getResolution();
	        var radius4 = (paramRadius - 8) * _view.getResolution();

	        var fullColorIndex = 1;
	        var circleOneStep = 0.15;
	        var circleTwoStep = 0.1;
	        var circleOneOriginRadiusIndex = 0.1;
	        var circleTwoAddIndex = 0.45;

	        var alphaOne = fullColorIndex - (i - 1) * circleOneStep;
	        var alphaTwo = fullColorIndex - (i - 1) * circleTwoStep - circleTwoAddIndex;
	        var alphaThree = 1 - (i - 1) * 0.05 - 0.75;
	        var radiusOneCoefficient = circleOneOriginRadiusIndex + circleOneStep * (i - 1);
	        var radiusTwoCoefficient = circleOneOriginRadiusIndex * i + circleTwoAddIndex;
	        var radiusThreeCoefficient = 0.05 * (i - 1) + 0.85;

	        circleOne = newCircleWithRadius(center, radiusOneCoefficient * radius);
	        var colorOne = "rgba(" + red + "," + green + "," + blue + "," + alphaOne + ")";
	        styleOne = newCircleStyle(colorOne);

	        var circleOne1 = newCircleWithRadius(center, radiusOneCoefficient * radius1);
	        var colorOne1 = "rgba(" + red + "," + green + "," + blue + "," + 0.8 * alphaOne + ")";
	        var styleOne1 = newCircleStyle(colorOne1);

	        var circleOne2 = newCircleWithRadius(center, radiusOneCoefficient * radius2);
	        var colorOne2 = "rgba(" + red + "," + green + "," + blue + "," + 0.6 * alphaOne + ")";
	        var styleOne2 = newCircleStyle(colorOne2);

	        var circleOne3 = newCircleWithRadius(center, radiusOneCoefficient * radius3);
	        var colorOne3 = "rgba(" + red + "," + green + "," + blue + "," + 0.4 * alphaOne + ")";
	        var styleOne3 = newCircleStyle(colorOne3);

	        var circleOne4 = newCircleWithRadius(center, radiusOneCoefficient * radius4);
	        var colorOne4 = "rgba(" + red + "," + green + "," + blue + "," + 0.2 * alphaOne + ")";
	        var styleOne4 = newCircleStyle(colorOne4);

	        featureOne1.setGeometry(circleOne1);
	        featureOne1.setStyle(styleOne1);

	        featureOne2.setGeometry(circleOne2);
	        featureOne2.setStyle(styleOne2);

	        featureOne3.setGeometry(circleOne3);
	        featureOne3.setStyle(styleOne3);

	        featureOne4.setGeometry(circleOne4);
	        featureOne4.setStyle(styleOne4);

	        circleTwo = newCircleWithRadius(center, radiusTwoCoefficient * radius);
	        var colorTwo = "rgba(" + red + "," + green + "," + blue + "," + alphaTwo + ")";
	        styleTwo = newCircleStyle(colorTwo);

	        var circleTwo1 = newCircleWithRadius(center, radiusTwoCoefficient * radius1);
	        var colorTwo1 = "rgba(" + red + "," + green + "," + blue + "," + 0.8 * alphaTwo + ")";
	        var styleTwo1 = newCircleStyle(colorTwo1);

	        var circleTwo2 = newCircleWithRadius(center, radiusTwoCoefficient * radius2);
	        var colorTwo2 = "rgba(" + red + "," + green + "," + blue + "," + 0.6 * alphaTwo + ")";
	        var styleTwo2 = newCircleStyle(colorTwo2);

	        var circleTwo3 = newCircleWithRadius(center, radiusTwoCoefficient * radius3);
	        var colorTwo3 = "rgba(" + red + "," + green + "," + blue + "," + 0.4 * alphaTwo + ")";
	        var styleTwo3 = newCircleStyle(colorTwo3);

	        var circleTwo4 = newCircleWithRadius(center, radiusTwoCoefficient * radius4);
	        var colorTwo4 = "rgba(" + red + "," + green + "," + blue + "," + 0.2 * alphaTwo + ")";
	        var styleTwo4 = newCircleStyle(colorTwo4);

	        featureTwo1.setGeometry(circleTwo1);
	        featureTwo1.setStyle(styleTwo1);

	        featureTwo2.setGeometry(circleTwo2);
	        featureTwo2.setStyle(styleTwo2);

	        featureTwo3.setGeometry(circleTwo3);
	        featureTwo3.setStyle(styleTwo3);

	        featureTwo4.setGeometry(circleTwo4);
	        featureTwo4.setStyle(styleTwo4);

	        circleThree = newCircleWithRadius(center, radiusThreeCoefficient * radius);
	        var colorThree = "rgba(" + red + "," + green + "," + blue + "," + alphaThree + ")";
	        styleThree = newCircleStyle(colorThree);

	        featureOne.setGeometry(circleOne);
	        featureOne.setStyle(styleOne);

	        featureTwo.setGeometry(circleTwo);
	        featureTwo.setStyle(styleTwo);

	        featureThree.setGeometry(circleThree);
	        featureThree.setStyle(styleThree);

	        i = (i + 1) % 5;
	        if (i === 0) {
	            i++;
	        }

	    }, 400);

	};

	var addBubbleMap = function (param) {
	    var newParam = param;
	    newParam.center = param.coordinates[param.coordinates.length - 1];
	    fusiongis.LineAdd.addLineType(param);
	    addPointOnLayer(newParam);
	};

	var removeBubbleMap = function (param) {

	    var _mapId = param.mapId;
	    var _layerId = param.layerId + '_' + param.mapId;
	    var _layer = null;

	    if (hashMap.containsKey(_layerId)) {
	        _layer = hashMap.get(_layerId);
	    }
	    else {
	        return;
	    }
	    var _mapObj = mapBox.getMapObj(_mapId);
	    _mapObj.removeLayer(_layer);
	    hashMap.remove(_layerId);
	    _layer = null;
	};

	module.exports = {
	    addBubbleMap: addBubbleMap,
	    removeBubbleMap: removeBubbleMap
	};

/***/ },
/* 112 */
/*!***************************************!*\
  !*** ./src/gis/tools/polygonQuery.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	var constant = __webpack_require__(/*! framework/constant */ 2);
	var $ = __webpack_require__(/*! utils/ajax */ 14);
	var util = __webpack_require__(/*! utils/util */ 1);

	var getPolygonFeatureInfo = function(paramObj, callbackfunc) {
	    var polLayerParam = {
	        mapId: paramObj.mapId,
	        layerId: paramObj.layerId
	    };
	    $.postJSON({
	        url: constant.PolygonQuery.GET_THIESSEN_POLYGONLAYER_INFO,
	        data: JSON.stringify({
	            featureClassName: paramObj.featureClassName,
	            columnName: paramObj.columnName,
	            operator: paramObj.operator,
	            value: paramObj.value
	        }),

	        success: function(_result) {
	            var result = JSON.parse(_result);
	            if (!!result) {
	                if (!!result.data && result.status.code === 1) {
	                    var _datas = result.data.fcObjectList;
	                    if (!!_datas) {
	                        _datas.forEach(function(val, index) {
	                            var coordinate = [];
	                            var pointString = util.htmlDecode(val.geometry);
	                            var point1 = pointString.substr(9);
	                            var point2 = point1.substr(0, point1.indexOf(')'));
	                            var split1String = point2.split(',');
	                            for (var i = 0; i < split1String.length; i++) {
	                                var _coordinate = split1String[i].split(' ');
	                                var _coorX = parseFloat(_coordinate[0]);
	                                var _coorY = parseFloat(_coordinate[1]);
	                                coordinate.push([_coorX, _coorY]);
	                            }
	                            val.coordinates = coordinate;
	                            val.id = val.fcObjectId;
	                        });

	                        polLayerParam.datas = _datas;
	                        if (paramObj.layerId !== undefined && paramObj.layerId !== '') {
	                            fusiongis.Polygon.addLayer(polLayerParam);
	                            fusiongis.Polygon.setLayerData(polLayerParam);
	                            fusiongis.Map.setMapCenter({
	                                mapId: paramObj.mapId,
	                                coordinate: polLayerParam.datas[0].coordinates[0]
	                            });
	                        }
	                        if (callbackfunc) {
	                            callbackfunc(_datas);
	                        }
	                    }
	                }
	            }
	        },
	        fail: function(result) {
	            console.log('get feature on thiessenPolygon layer fail:' + result);
	        }
	    });
	};
	module.exports = {
	    getPolygonFeatureInfo: getPolygonFeatureInfo
	};


/***/ },
/* 113 */
/*!********************************************!*\
  !*** ./src/gis/tools/polygonsInterSect.js ***!
  \********************************************/
/***/ function(module, exports) {

	function intersectsPolygonAndPolygon(polygon1LinearRings, polygon2LinearRings) {
	    // polygon1LinearRings : array[LinearRing,...]
	    var intersect = intersectsByLinearRings(polygon1LinearRings, polygon2LinearRings);
	    if (!intersect) {
	        // �������ǲ����ڶ������ڲ�
	        for (var i = 0;i<polygon2LinearRings.length;i++) {
	            var point = polygon2LinearRings[i];
	            intersect = containsPointByLinearRing(point, polygon1LinearRings);
	            if (intersect) {
	                break;
	            }
	        }
	    }
	    return intersect;
	}

	function intersectsByLinearRings(LinearRing1, LinearRings2) {
	    var intersect = false;
	    var segs1 = getSortedSegments(LinearRing1);
	    var segs2 = getSortedSegments(LinearRings2);

	    var seg1, seg1x1, seg1x2, seg1y1, seg1y2,
	        seg2, seg2y1, seg2y2;
	    // sweep right
	    outer: for (var i = 1;i<segs1.length; i++) {
	        seg1 = segs1[i-1];
	        seg1x1 = seg1.x1;
	        seg1x2 = seg1.x2;
	        seg1y1 = seg1.y1;
	        seg1y2 = seg1.y2;
	        inner: for (var j = 1;j<segs2.length;j++) {
	            seg2 = segs2[j-1];
	            if (seg2.x1 > seg1x2) {
	                // seg1 still left of seg2
	                break;
	            }
	            if (seg2.x2 < seg1x1) {
	                // seg2 still left of seg1
	                continue;
	            }
	            seg2y1 = seg2.y1;
	            seg2y2 = seg2.y2;
	            if (Math.min(seg2y1, seg2y2) > Math.max(seg1y1, seg1y2)) {
	                // seg2 above seg1
	                continue;
	            }
	            if (Math.max(seg2y1, seg2y2) < Math.min(seg1y1, seg1y2)) {
	                // seg2 below seg1
	                continue;
	            }
	            if (segmentsIntersect(seg1, seg2)) {
	                intersect = true;
	                break outer;
	            }
	        }
	    }
	    return intersect;
	}


	function getSortedSegments(points) {
	    var numSeg = points.length - 1;
	    var segments = new Array(numSeg), point1, point2;
	    for (var i = 1;i<points.length;i++) {
	        point1 = points[i-1];
	        point2 = points[i];
	        if (point1.x < point2.x) {
	            segments[i] = {
	                x1: point1.x,
	                y1: point1.y,
	                x2: point2.x,
	                y2: point2.y
	            };
	        } else {
	            segments[i] = {
	                x1: point2.x,
	                y1: point2.y,
	                x2: point1.x,
	                y2: point1.y
	            };
	        }
	    }
	    // more efficient to define this somewhere static
	    function byX1(seg1, seg2) {
	        return seg1.x1 - seg2.x1;
	    }
	    return segments.sort(byX1);
	}

	function segmentsIntersect(seg1, seg2, options) {
	    var point = options && options.point;
	    var tolerance = options && options.tolerance;
	    var intersection = false;
	    var x11_21 = seg1.x1 - seg2.x1;
	    var y11_21 = seg1.y1 - seg2.y1;
	    var x12_11 = seg1.x2 - seg1.x1;
	    var y12_11 = seg1.y2 - seg1.y1;
	    var y22_21 = seg2.y2 - seg2.y1;
	    var x22_21 = seg2.x2 - seg2.x1;
	    var d = (y22_21 * x12_11) - (x22_21 * y12_11);
	    var n1 = (x22_21 * y11_21) - (y22_21 * x11_21);
	    var n2 = (x12_11 * y11_21) - (y12_11 * x11_21);
	    if (d == 0) {
	        // parallel
	        if (n1 == 0 && n2 == 0) {
	            // coincident
	            intersection = true;
	        }
	    } else {
	        var along1 = n1 / d;
	        var along2 = n2 / d;
	        if (along1 >= 0 && along1 <= 1 && along2 >= 0 && along2 <= 1) {
	            // intersect
	            if (!point) {
	                intersection = true;
	            } else {
	                // calculate the intersection point
	                var x = seg1.x1 + (along1 * x12_11);
	                var y = seg1.y1 + (along1 * y12_11);
	                intersection = {'x': x, 'y': y};
	            }
	        }
	    }
	    if (tolerance) {
	        var dist;
	        if (intersection) {
	            if (point) {
	                var segs = [seg1, seg2];
	                var seg, x, y;
	                // check segment endpoints for proximity to intersection
	                // set intersection to first endpoint within the tolerance
	                outer: for (var i = 0; i < 2; ++i) {
	                    seg = segs[i];
	                    for (var j = 1; j < 3; ++j) {
	                        x = seg["x" + j];
	                        y = seg["y" + j];
	                        dist = Math.sqrt(
	                            Math.pow(x - intersection.x, 2) +
	                            Math.pow(y - intersection.y, 2)
	                        );
	                        if (dist < tolerance) {
	                            intersection.x = x;
	                            intersection.y = y;
	                            break outer;
	                        }
	                    }
	                }

	            }
	        } else {
	            // no calculated intersection, but segments could be within
	            // the tolerance of one another
	            var segs = [seg1, seg2];
	            var source, target, x, y, p, result;
	            // check segment endpoints for proximity to intersection
	            // set intersection to first endpoint within the tolerance
	            outer: for (var i = 0; i < 2; ++i) {
	                source = segs[i];
	                target = segs[(i + 1) % 2];
	                for (var j = 1; j < 3; ++j) {
	                    p = {x: source["x" + j], y: source["y" + j]};
	                    result = distanceToSegment(p, target);
	                    if (result.distance < tolerance) {
	                        if (point) {
	                            intersection = {'x': p.x, 'y': p.y};
	                        } else {
	                            intersection = true;
	                        }
	                        break outer;
	                    }
	                }
	            }
	        }
	    }
	    return intersection;
	};


	// LinearRing : array[pt]
	// point : {x:1,y:2}
	function containsPointByLinearRing(point, LinearRing) {

	    //limitSigDigs
	    function approx(num, sig) {
	        var fig = 0;
	        if (sig > 0) {
	            fig = parseFloat(num.toPrecision(sig));
	        }
	        return fig;
	    }

	    var digs = 14;
	    var px = approx(point.x, digs);
	    var py = approx(point.y, digs);

	    function getX(y, x1, y1, x2, y2) {
	        return (y - y2) * ((x2 - x1) / (y2 - y1)) + x2;
	    }

	    var numSeg = LinearRing.length - 1;
	    var start, end, x1, y1, x2, y2, cx, cy;
	    var crosses = 0;

	    for (var i = 0; i++;) {
	        start = LinearRing[i];
	        x1 = approx(start.x, digs);
	        y1 = approx(start.y, digs);
	        end = LinearRing[i + 1];
	        x2 = approx(end.x, digs);
	        y2 = approx(end.y, digs);

	        if (y1 == y2) {
	            // horizontal edge
	            if (py == y1) {
	                // point on horizontal line
	                if (x1 <= x2 && (px >= x1 && px <= x2) || // right or vert
	                    x1 >= x2 && (px <= x1 && px >= x2)) { // left or vert
	                    // point on edge
	                    crosses = -1;
	                    break;
	                }
	            }
	            // ignore other horizontal edges
	            continue;
	        }
	        cx = approx(getX(py, x1, y1, x2, y2), digs);
	        if (cx == px) {
	            // point on line
	            if (y1 < y2 && (py >= y1 && py <= y2) || // upward
	                y1 > y2 && (py <= y1 && py >= y2)) { // downward
	                // point on edge
	                crosses = -1;
	                break;
	            }
	        }
	        if (cx <= px) {
	            // no crossing to the right
	            continue;
	        }
	        if (x1 != x2 && (cx < Math.min(x1, x2) || cx > Math.max(x1, x2))) {
	            // no crossing
	            continue;
	        }
	        if (y1 < y2 && (py >= y1 && py < y2) || // upward
	            y1 > y2 && (py < y1 && py >= y2)) { // downward
	            ++crosses;
	        }
	    }

	    var contained = (crosses == -1) ?
	        // on edge
	        1 :
	        // even (out) or odd (in)
	        !!(crosses & 1);

	    return contained;
	}


	function distanceToSegment(point, segment) {
	    var result = distanceSquaredToSegment(point, segment);
	    result.distance = Math.sqrt(result.distance);
	    return result;
	};

	function distanceSquaredToSegment(point, segment) {
	    var x0 = point.x;
	    var y0 = point.y;
	    var x1 = segment.x1;
	    var y1 = segment.y1;
	    var x2 = segment.x2;
	    var y2 = segment.y2;
	    var dx = x2 - x1;
	    var dy = y2 - y1;
	    var along = ((dx * (x0 - x1)) + (dy * (y0 - y1))) /
	        (Math.pow(dx, 2) + Math.pow(dy, 2));
	    var x, y;
	    if (along <= 0.0) {
	        x = x1;
	        y = y1;
	    } else if (along >= 1.0) {
	        x = x2;
	        y = y2;
	    } else {
	        x = x1 + along * dx;
	        y = y1 + along * dy;
	    }
	    return {
	        distance: Math.pow(x - x0, 2) + Math.pow(y - y0, 2),
	        x: x, y: y,
	        along: along
	    };
	}

	module.exports = {
	    intersectsPolygonAndPolygon: intersectsPolygonAndPolygon
	};


/***/ },
/* 114 */
/*!************************************************!*\
  !*** ./src/gis/tools/showPolygonCenterIcon.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var showPolygonCenterIcon = function (paramObj) {
	    var polygonObject = paramObj.data;
	    if (!!polygonObject && polygonObject.length > 0) {
	        for (var i = 0; i < polygonObject.length; i++) {
	            var coordinates = polygonObject[i].coordinates;
	            var _paramData = [
	                {}
	            ];
	            var _geoPolygon = new ol.geom.Polygon([coordinates]);
	            var _centerPoint = ol.extent.getCenter(_geoPolygon.getExtent());
	            var polygonCenter = _centerPoint;
	            _paramData[0] = {
	                coordinate: polygonCenter,
	                id: i
	            };
	            fusiongis.Icon.addIcon({
	                layerId: paramObj.layerId,
	                mapId: paramObj.mapId,
	                datas: _paramData
	            });
	        }
	    }
	};
	module.exports = {
	    showPolygonCenterIcon: showPolygonCenterIcon
	};


/***/ },
/* 115 */
/*!**************************************************!*\
  !*** ./src/gis/layers/contributionPlotOnLine.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	var ol = __webpack_require__(/*! ol */ 4);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);

	//取消高亮
	function removeHighlight(paramObj) {
	    highlights.removeHighlight({
	        mapId: paramObj.mapId,
	        layerId: paramObj.layerId,
	        hTypes: ['click']
	    });
	}

	//高亮贡献小区
	function highlight(olLayer, hType, feature) {
	    var olMap = olLayer.get('map');
	    var mapId = olMap.getTarget();
	    var layerId = olLayer.get('layer_id');
	    var layerType = olLayer.get('businessType');
	    var hLayer = highlights.getHLayer({
	        mapId: mapId,
	        layerId: layerId
	    });
	    removeHighlight(hLayer);
	    if (hType === constant.HTYPE.CLICK) {
	        var of = feature;
	        if (!of) {
	            return;
	        }
	        var nFeature = of.clone();
	        nFeature.setStyle(new ol.style.Style({

	            fill: new ol.style.Fill({
	                color: 'red'
	            }),
	            stroke: new ol.style.Stroke({
	                color: 'rgba(255,215,0)',
	                width: 2
	            })
	        }));
	        nFeature.set('mapId', mapId);
	        nFeature.set('layerId', layerId);
	        nFeature.set('layerType', layerType);
	        nFeature.set('hType', hType);

	        hLayer.getSource().addFeature(nFeature);
	    }
	}

	module.exports = {
	    removeHighlight:removeHighlight,
	    highlight:highlight
	};


/***/ },
/* 116 */
/*!***********************************!*\
  !*** ./src/gis/layers/addLine.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var HashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var util = __webpack_require__(/*! utils/util */ 1);
	var events = __webpack_require__(/*! maps/event */ 11);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);
	var addLineType = function(paramObj) {
		var _layerId = paramObj.layerId;
	    //适配高德地图的火星坐标系
	    paramObj.coordinates =util.transformMultArray(util.extend([],paramObj.coordinates));

		if(paramObj.isBezier === 1) { //曲线
			fusiongis.Curve.addCurve(paramObj, function(coords,lineFeature) {
				if(paramObj.isArrow == 1) {
					//为连线添加箭头
					paramObj.controlCoordinate = coords;
					addArrow(paramObj,lineFeature);
				}
				//调用鼠标移入移出的函数
				if(paramObj.color) {
					mouseOnLeave(paramObj);
				}
			});
		} else { //直线
			fusiongis.LineStraight.addLine(paramObj, function(lineFeature) {
				if(paramObj.isArrow == 1) {
					addArrow(paramObj, lineFeature);
				}
				//调用鼠标移入移出的函数
				if(paramObj.color) {
					mouseOnLeave(paramObj);
				}
			});
		}

	};

	/**
	 * 获取直线对应百分比的点
	 * */
	var getCoordinatesByPercent = function(coordinates, arrowPosition) {
	    var lineLen = Math.sqrt(Math.pow((coordinates[0][0] - coordinates[1][0]), 2) +
	        Math.pow((coordinates[0][1] - coordinates[1][1]), 2));
	    var _x, _y;
	    if (coordinates[0][0] === coordinates[1][0]) {
	        _x = coordinates[0][0];
	        if (coordinates[0][1] < coordinates[1][1]) {
	            _y = lineLen * arrowPosition + coordinates[0][1];
	        } else {
	            _y = coordinates[0][1] - lineLen * arrowPosition
	        }
	    } else {
	        var k = (coordinates[0][1] - coordinates[1][1]) / (coordinates[0][0] - coordinates[1][0]);
	        var b = (coordinates[0][1] + coordinates[1][1] - k * (coordinates[0][0] + coordinates[1][0])) / 2;
	        var d = lineLen * arrowPosition;
	        var tmp = Math.pow((2 * k * (b - coordinates[0][1]) - 2 * coordinates[0][0]), 2) - 4 * (1 + k * k) *
	            (Math.pow(coordinates[0][0], 2) + Math.pow((b - coordinates[0][1]), 2) - d * d);
	        var _b = 2 * coordinates[0][0] - 2 * k * (b - coordinates[0][1]);
	        _x = (_b + Math.sqrt(tmp)) / (2 * (1 + k * k));
	        if (coordinates[0][0] < coordinates[1][0]) {
	            if (_x < coordinates[0][0]) {
	                _x = (_b - Math.sqrt(tmp)) / (2 * (1 + k * k));
	            }
	        } else {
	            if (_x > coordinates[0][0]) {
	                _x = (_b - Math.sqrt(tmp)) / (2 * (1 + k * k));
	            }
	        }
	        _y = k * _x + b;
	    }

	    return [_x, _y]
	}

	/**
	 * 获取曲线或直线对应坐标
	 * */
	var getLineMiddlePoint = function(coordinates, arrowPosition) {
	    var _middlePointCoordinate,
	        _coordinateX,
	        _coordinateY,
	        middleAndPrePointCoordinate = [],
	        prePointCoordinate = [],
	        index;
	    if (coordinates.length === 2) {
	        _coordinateX = getCoordinatesByPercent(coordinates, arrowPosition)[0];
	        _coordinateY = getCoordinatesByPercent(coordinates, arrowPosition)[1];
	        prePointCoordinate = ol.proj.toLonLat(coordinates[0]);
	    } else {
	        var len = coordinates.length;
	        if (arrowPosition === 0.5) {
	            if (len % 2 === 0) {
	                _coordinateX = (coordinates[len / 2 - 1][0] + coordinates[len / 2][0]) / 2;
	                _coordinateY = (coordinates[len / 2 - 1][1] + coordinates[len / 2][1]) / 2;
	                prePointCoordinate = ol.proj.toLonLat(coordinates[len / 2 - 1]);
	                index = len / 2 - 1;
	            } else {
	                _coordinateX = coordinates[(len - 1) / 2][0];
	                _coordinateY = coordinates[(len - 1) / 2][1];
	                prePointCoordinate = ol.proj.toLonLat(coordinates[((len - 1) / 2) - 1]);
	                index = ((len - 1) / 2) - 1;
	            }
	        } else {
	            var numOfCoordinates = Math.round(len * arrowPosition);
	            numOfCoordinates = numOfCoordinates === len ? numOfCoordinates - 1 : numOfCoordinates;
	            _coordinateX = coordinates[numOfCoordinates][0];
	            _coordinateY = coordinates[numOfCoordinates][1];
	            var numOfPrevPoint = numOfCoordinates === 0 ? 0 : numOfCoordinates - 1;
	            prePointCoordinate = ol.proj.toLonLat(coordinates[numOfPrevPoint]);
	            index = numOfPrevPoint;
	        }
	    }
	    _middlePointCoordinate = arrowPosition === 0 ? coordinates[0] : [_coordinateX, _coordinateY];
	    var _midPrePoint= arrowPosition === 0 ? [prePointCoordinate, ol.proj.toLonLat(coordinates[1])] :
	        [prePointCoordinate,ol.proj.toLonLat(_middlePointCoordinate)];
	    return {
	        middlePointCoordinate: _middlePointCoordinate,
	        middleAndPrePointCoordinate: _midPrePoint,//[prePointCoordinate,ol.proj.toLonLat(_middlePointCoordinate)],
	        index: index
	    };
	}

	/**
	 * 在连线的最后一个点绘制箭头
	 * */
	var addArrow = function(paramObj, lineFeature) {
		var __coordinateArr = [];
		var _coordinate = paramObj.coordinates;
		var _rotation = null;
		var _middlePointCoordinate;
		var _lastPoint = null;
		var _controlPoint, prevPoint; //曲线计算弧度值的两个控制点
		var _controlCoordinate = [],
			contorlPoint = [];
		for(var i = 0; i < _coordinate.length; i++) {
			__coordinateArr.push(ol.proj.fromLonLat(_coordinate[i]));
		}
		//连线的起点
		var _prevPoint = __coordinateArr[__coordinateArr.length - 2];

		if(!paramObj.isSetArrowPosition) {
			_lastPoint = __coordinateArr[__coordinateArr.length - 1];

		} else {
			var paramArrowPosition = paramObj.arrowPosition;
			var arrowPosition = typeof paramArrowPosition === 'undefined' ||
				paramArrowPosition > 1 || paramArrowPosition < 0 ?
				0.5 : paramArrowPosition;
			if(typeof paramObj.controlCoordinate === 'undefined') {
				_middlePointCoordinate = getLineMiddlePoint(__coordinateArr, arrowPosition);
			} else {
				paramObj.controlCoordinate.forEach(function(item) {
					_controlCoordinate.push(ol.proj.fromLonLat(item));
				})
				_middlePointCoordinate = getLineMiddlePoint(_controlCoordinate, arrowPosition);
				paramObj.controlCoordinate.forEach(function(item, index) {
					if(index <= _middlePointCoordinate.index) {
						contorlPoint.push(item);
					}
				})
			}

			_controlPoint = paramObj.isSetArrowPosition ? contorlPoint : paramObj.controlCoordinate;
			prevPoint = paramObj.isSetArrowPosition ? _middlePointCoordinate.middleAndPrePointCoordinate : paramObj.coordinates;

			_lastPoint = _middlePointCoordinate.middlePointCoordinate;

		}

		var arrowId = paramObj.lineGeoId + '_arrow';
		//弧度值
		if(paramObj.isBezier === 1) {
			if(!!paramObj.controlCoordinate) {
				_rotation = caculatBezierAzimuth(prevPoint, _controlPoint);
			}
		} else {
			var realLngLat = calculateLngLat(_prevPoint, _lastPoint, paramObj.mapId); //修改箭头位置往后移

			lineFeature.getGeometry().setCoordinates([_prevPoint, realLngLat]); //带箭头的连线需要缩短
			//计算直线的dy和dx
			var _vectorX = _lastPoint[0] - _prevPoint[0];
			var _vectorY = _lastPoint[1] - _prevPoint[1];

			_rotation = -Math.atan2(_vectorY, _vectorX) + Math.PI / 2;
		}

		var ftColl = null;
		
		var defaultHighLight = {
			labelFillColor: paramObj.fillColor,
			labelStrokeColor:paramObj.labelStrokeColor,
			strokeColor: 'black',
			strokeWidth: paramObj.strokeWidth || 1,
			arrowRadius:paramObj.arrowRadius || 8,
			rotation:_rotation,
			angle:0
		};

		if(paramObj.isBezier === 1) {
			ftColl = new ol.Feature({
				geometry: new ol.geom.Point(_middlePointCoordinate.middlePointCoordinate),
				select: paramObj.hightLight ? paramObj.hightLight : defaultHighLight
			});
		} else {
			ftColl = new ol.Feature({
				geometry: new ol.geom.Point(realLngLat),
				select: paramObj.hightLight ? paramObj.hightLight : defaultHighLight
			});

		}



		var _arrowStyle = new ol.style.Style({
			image: new ol.style.RegularShape({
				fill: new ol.style.Fill({
					color: paramObj.fillColor || '#208089'
				}),
				stroke: new ol.style.Stroke({
					color: paramObj.strokeColor || '#000',
					width: paramObj.strokeWidth || 1
				}),
				cursor: 'point',
				points: 3,
				radius: paramObj.arrowRadius || 8,
				rotation: _rotation,
				angle: 0
			})
		});
		

		ftColl.setId(arrowId);
		ftColl.setStyle(_arrowStyle);
		if(paramObj.isBezier !== 1) {
			ftColl.set('coordinates', realLngLat); //设置箭头的'coordinates'属性和值
		}

		//将箭头和连线关联在一起
		lineFeature.set('arrow', ftColl);

		var lineLayer = HashMap.get(paramObj.layerId + '_' + paramObj.mapId);
		if(!!lineLayer) {
			lineLayer.getSource().addFeatures([ftColl]);
		}
	};

	//修改箭头的位置
	function calculateLngLat(sourcePoint, targetPoint, mapId) {
	    var olMap = mapBox.getMapObj(mapId);
	    var startPixel = olMap.getPixelFromCoordinate(sourcePoint);
	    var endPixel = olMap.getPixelFromCoordinate(targetPoint);
	    var xStart = startPixel[0];
	    var yStart = startPixel[1];
	    var xEnd = endPixel[0];
	    var yEnd = endPixel[1];
	    var awayFromTop = 7;

	    var increaseX = (xEnd - xStart >= 0) ? -1 : 1;
	    var increaseY = (yEnd - yStart >= 0) ? -1 : 1;
	    var angle = Math.atan2(yEnd - yStart, xEnd - xStart);
	    var xCenter = xEnd + increaseX * awayFromTop * Math.abs(Math.cos(angle));
	    var yCenter = yEnd + increaseY * awayFromTop * Math.abs(Math.sin(angle));

	    return olMap.getCoordinateFromPixel([xCenter, yCenter]);
	}




	function setNewCoordinate(lineLayer, mapId) {
		if(!!!lineLayer) {
			return;
		}

		if(!!!lineLayer.getSource()) {
			return;
		}

		var hLineLayer = highlights.getHLayer({
			mapId: mapId,
			layerId: lineLayer.get('layer_id')
		});
		
		var highLineFeatures=null;
		
		if(hLineLayer){
			highLineFeatures =hLineLayer.getSource().getFeatures();
		}

		var lineFeatures = lineLayer.getSource().getFeatures();
		
		var setRightLonlat = function(lineFeature,arrowFeature) {
			var lineGeom = lineFeature.getGeometry(); 
			var arrowGeom = arrowFeature.getGeometry(); 
			var lineLngLat = lineFeature.get('coordinates'); //连线的坐标
			var realLngLat = calculateLngLat(lineLngLat[0], lineLngLat[1], mapId);

			lineGeom.setCoordinates([lineLngLat[0], realLngLat]);
			arrowGeom.setCoordinates(realLngLat);
		};
		
		
		!!lineFeatures && lineFeatures.forEach(function(featureItem) {
			var arrow = featureItem.get('arrow');
			//判断这个feature是否有箭头
			if(arrow) {
				setTimeout(function() {
					setRightLonlat(featureItem,arrow);
				}, 500);
			}
		});
		
		//处理高亮的连线和箭头
		!!highLineFeatures && highLineFeatures.forEach(function(highLineFea) {
			var highRowFea = highLineFea.get('arrow');
			if(highRowFea) {
				setTimeout(function() {
					setRightLonlat(highLineFea, highRowFea);
				}, 500);
			}
		});
		

	};


	/*计算曲线两点之间的方位角 points是控制点 */

	var caculatBezierAzimuth = function (coords, points) {
	    if (points.length > 0) {
	        var endCoords = coords[coords.length - 1];//最后一个控制点
	        var controlCoords = [];
	        var length = points.length;
	        if (points.length === 1) {//只有一个控制点
	            controlCoords = points[0];
	        }
	        else {//一个控制点以上
	            controlCoords = points[length - 1];
	        }
	        var _vectorX = endCoords[0] - controlCoords[0];
	        var _vectorY = endCoords[1] - controlCoords[1];
	        var _rotation = -Math.atan2(_vectorY, _vectorX) + Math.PI / 2;

	        return _rotation;
	    }
	};

	//线的鼠标移入移出事件
	var mouseOnLeave = function (paramObj) {
	    var _tempFeature = null;
	    var _newFeature = null;
	    fusiongis.BaseLayer.registerMouseEvent(paramObj, function (feature) {
	        if (!!feature) {//移入
	            if (feature.get('businessType') === 'STRAIGHTLINE') {
	                _tempFeature = feature.clone();
	                _newFeature = feature;
	                feature.setStyle(new ol.style.Style({
	                    stroke: new ol.style.Stroke({
	                        //鼠标移入feature的颜色设置为红色
	                        color: paramObj.color,
	                        width: paramObj.strokeWidth || 3
	                    })
	                }));
	                if (paramObj.mouseOverCallback && typeof paramObj.mouseOverCallback === 'function') {
	                    paramObj.mouseOverCallback(feature);
	                }
	            }
	        }
	        else {//移出
	            if (!!_tempFeature) {
	                var oldStyle = new ol.style.Style({
	                    stroke: new ol.style.Stroke({
	                        //鼠标移入feature的颜色设置为红色
	                        color: paramObj.strokeColor,
	                        width: paramObj.strokeWidth || 3
	                    })
	                });
	                _newFeature.setStyle(oldStyle);
	            }
	            if (paramObj.mouseLeaveCallback && typeof paramObj.mouseLeaveCallback === 'function') {
	                paramObj.mouseLeaveCallback();
	            }
	        }
	    });
	};

	//得到小区的中间点进行连线
	var getCellApex = function (featrue) {
	    var cellType = featrue.get('data').cellType;
	    var radius = featrue.get('data').radius;
	    var _rotation = featrue.get('data').azimuth;
	    var coordinate = [];
	    var geometry = featrue.getGeometry();
	    if (!!geometry) {
	        var _flatCoordinates = geometry.getCoordinates()[0];
	        var _coordinate = [];
	        if (cellType === 'triangle') {//三角形重新计算中心点
	            var resultCoords = [];
	            var length = _flatCoordinates.length;
	            for (var i = 0; i < length; i++) {
	                var flag = true;
	                for (var j = i; j < _flatCoordinates.length - 1; j++) {
	                    flag = false;
	                    if (_flatCoordinates[i] == _flatCoordinates[j + 1]) {
	                        break;
	                    }
	                }
	                if (flag) {
	                    resultCoords = _flatCoordinates[i];
	                }
	            }
	            var uniqueArray = util.unique(_flatCoordinates);
	            for (var i = 0, flag = true; i < uniqueArray.length; flag ? i++ : i) {
	                if (uniqueArray[i][0] === resultCoords[0] && uniqueArray[i][1] === resultCoords[1]) {
	                    uniqueArray.splice(i, 1);
	                    flag = false;
	                } else {
	                    flag = true;
	                }
	            }
	            if (uniqueArray.length === 2) {
	                var centerLon = (uniqueArray[0][0] + uniqueArray[1][0]) / 2;
	                var centerLat = (uniqueArray[0][1] + uniqueArray[1][1]) / 2;
	                _coordinate.push(centerLon, centerLat);
	            }
	        }
	        else if (cellType === 'arrow') {//取第6个和第7个点
	            _coordinate = _flatCoordinates[3];

	        } else {//扇形
	            var finalRadius = radius;
	            var _gcjCoord =util.gcjTransform(featrue.get('data').coordinate);
	            var _coords =ol.proj.fromLonLat(_gcjCoord);
	            var rotatedAngle = Math.PI / 2 - (_rotation) / 180 * Math.PI;
	            var x = _coords[0] + finalRadius * Math.cos(rotatedAngle);
	            var y = _coords[1] + finalRadius * Math.sin(rotatedAngle);
	            _coordinate.push(x, y);
	        }
	        coordinate = ol.proj.toLonLat(_coordinate);
	        //火星坐标到国策局坐标需要进行反偏移
	        var _deCoordinate =util.gcj_decTransform(coordinate);
	        return _deCoordinate;
	    }
	};

	/*显示连线的正东方向方位角*/
	var clickShowAzimuth = function (points) {
	    if (points.length === 2) {
	        var _prevPoint = ol.proj.fromLonLat(points[0]);
	        var _lastPoint = ol.proj.fromLonLat(points[1]);
	        var dx = _lastPoint[0] - _prevPoint[0];
	        var dy = _lastPoint[1] - _prevPoint[1];
	        var angle = Math.atan(dx / dy) * 180 / Math.PI;
	        if (angle === -90 || angle === 90) {
	            angle = angle * (-1);
	        }
	        if (dy > 0) {//逆时针
	            angle += 270;
	        }
	        else {
	            angle += 90;
	        }
	        if (angle > 360) {
	            angle -= 360;
	        }
	        if (angle === 0) {
	            angle = 360;
	        }
	        return angle;
	    }
	};


	/*显示连线的距离,连线以米为单位*/
	var showDistance = function (points) {
	    if (points) {
	        var length = 0;
	        var coordinates = points;
	        var coordinates1 = ol.proj.fromLonLat(points[0]);
	        var coordinates2 = ol.proj.fromLonLat(points[1]);
	        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
	            length += new ol.geom.LineString([coordinates1, coordinates2]).getLength();
	        }
	        var output;
	        output = (Math.round(length * 1000) / 1000) + ' ' + 'm';
	        return output;
	    }
	};

	function getLayerByLayerId(collection, layerId) {
	    var flag = false;
	    collection.forEach(function (layer) {
	        if (layer.get('layerId') && layer.get('layerId') === layerId) {
	            flag = true;
	        }
	    });
	    return flag
	}

	function addLineByGeomId(param) {
	    var mapId = param.mapId;
	    var mapObj = mapBox.getMapObj(mapId);
	    var targetLayerId = param.targetLayerId;
	    var targetGeoId = param.targetGeoId;
	    var sourceLayerId = param.sourceLayerId;
	    var sourceGeoId = param.sourceGeoId;
	    var _lineLayerId = param.layerId;
	    var lineGeoId = param.lineGeoId;
	    var targetLayer = HashMap.get(targetLayerId + '_' + mapId);
	    var sourceLayer = HashMap.get(sourceLayerId + '_' + mapId);
	    if (targetLayer && sourceLayer) {
	        var targetFeature = targetLayer.getSource().getFeatureById(targetGeoId);
	        var sourceFeature = sourceLayer.getSource().getFeatureById(sourceGeoId);
	        if (targetFeature && sourceFeature) {
	            var targetPoint = ol.proj.toLonLat(ol.extent.getCenter(targetFeature.getGeometry().getExtent()));
	            var sourcePoint = ol.proj.toLonLat(ol.extent.getCenter(sourceFeature.getGeometry().getExtent()));
	            param['coordinates'] = [targetPoint, sourcePoint];
	            addLineType(param);
	            mapObj.getLayers().on('change:length', function () {
	                if (getLayerByLayerId(this, targetLayerId + '_' + mapId) && getLayerByLayerId(this, sourceLayerId + '_' + mapId)) {
	                    //not delete
	                }
	                else {
	                    var lineLayer = HashMap.get(_lineLayerId + '_' + mapId);
	                    if (!!lineLayer) {
	                        var lineFeature = lineLayer.getSource().getFeatureById(lineGeoId);
	                        var arrowFeature = lineLayer.getSource().getFeatureById(lineGeoId + '_arrow');
	                        if (lineFeature) {
	                            lineLayer.getSource().removeFeature(lineFeature);
	                        }
	                        if (arrowFeature) {
	                            lineLayer.getSource().removeFeature(arrowFeature);
	                        }
	                    }
	                }
	            })
	        }
	        else {
	            console.warn("the feature is undefined")
	        }

	    }
	    else {
	        console.warn("the layer is undefined")
	    }

	}
	module.exports = {
	    addLineType: addLineType,
	    clickShowAzimuth: clickShowAzimuth,
	    showDistance: showDistance,
	    addLineByGeomId: addLineByGeomId,
	    getCellApex: getCellApex,
	    setNewCoordinate:setNewCoordinate
	};

/***/ },
/* 117 */
/*!*****************************************!*\
  !*** ./src/gis/layers/polygonBezier.js ***!
  \*****************************************/
/***/ function(module, exports) {

	//多边形曲线连线
	var addPolygonBezier = function (paramObj) {
	    if (paramObj.layerType === 'POLYGON') {
	        var arrayLength = paramObj.coordinates.length;
	        //是否传入的polygon是两个点
	        if (arrayLength === 2) {
	            var coordinates = [];
	            var cPointsX = (paramObj.coordinates[0][0] + paramObj.coordinates[arrayLength - 1][0]) / 2;
	            var cPointsY = (paramObj.coordinates[0][1] + paramObj.coordinates[arrayLength - 1][1]) / 2;
	            //得到中心点
	            if (paramObj.coordinates[0][0] === paramObj.coordinates[arrayLength - 1][0]) {
	                coordinates = [cPointsX + 1, cPointsY];
	            }
	            else {
	                coordinates = [cPointsX, cPointsY + 1];
	            }
	            //构造点数组
	            paramObj.coordinates.splice(1, 0, coordinates);
	            fusiongis.LineAdd.addLineType(paramObj);
	        }
	    }
	};
	module.exports = {
	    addPolygonBezier: addPolygonBezier
	};


/***/ },
/* 118 */
/*!********************************************!*\
  !*** ./src/gis/layers/unchangedPolygon.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);

	var addLayer = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId;
	    var _layer = null;
	    var isShow = paramObj.isShow != undefined ? paramObj.isShow : true;
	    var _label = paramObj.label ? paramObj.label : paramObj.layerId;

	    if (hashMap.containsKey(_layerId)) {
	        _layer = hashMap.get(_layerId);
	    }
	    else {
	        baseLayer.createLayer(paramObj);
	        _layer = hashMap.get(_layerId);
	    }
	    _layer.set('type', constant.CUSTOMTYPE.LAYERIMGTYPE);
	    _layer.set('businessType', 'unChangePolygon');
	    _layer.set('params.label', _label);
	    _layer.set('layerId', paramObj.layerId);
	    _layer.set('layer_id', paramObj.layerId);
	    _layer.set('isShow', isShow);
	    if (paramObj.zindex !== undefined) {
	        _layer.setZIndex(paramObj.zindex);
	    }
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	    }
	};

	var setLayerData = function (paramObj) {
	    var _layerId = paramObj.layerId + '_' + paramObj.mapId;
	    var _data = paramObj.datas;
	    var map = mapBox.getMapObj(paramObj.mapId);
	    var _layer = hashMap.get(_layerId);
	    _layer.set('datas',_data);
	    var _source = null;
	    if (_layer) {
	        _source = _layer.getSource();
	    }
	    if (utils.isValid(_data) || _data.length > 0) {
	        var _features = [];
	        _data.forEach(function (oneRecord) {
	            //�����ߵµ�ͼ��������ϵ
	            var _coor3857 = ol.proj.fromLonLat(utils.gcjTransform(oneRecord.coordinate));
	        	var _h = oneRecord.height != undefined ? oneRecord.height : 20;
	        	var _w = oneRecord.width != undefined ? oneRecord.width : 10;
	        	
	//          var pixel = map.getPixelFromCoordinate(_coor3857);
	//          var minX = pixel[0] - _w / 2;
	//          var maxX = pixel[0] + _w / 2;
	//          var minY = pixel[1] - _h / 2;
	//          var maxY = pixel[1] + _h / 2;
	//          var list =[];
	//          list.push(map.getCoordinateFromPixel([minX,minY]));
	//          list.push(map.getCoordinateFromPixel([maxX,minY]));
	//          list.push(map.getCoordinateFromPixel([maxX,maxY]));
	//          list.push(map.getCoordinateFromPixel([minX,maxY]));
	//          list.push(map.getCoordinateFromPixel([minX,minY]));

	            var minX = _coor3857[0] - _w / 2;
	            var maxX = _coor3857[0] + _w / 2;
	            var minY = _coor3857[1] - _h / 2;
	            var maxY = _coor3857[1] + _h / 2;
	            var list =[];
	            list.push([minX,minY]);
	            list.push([maxX,minY]);
	            list.push([maxX,maxY]);
				list.push([minX,maxY]);
				list.push([minX,minY]);
	            var _feature = new ol.Feature({
	                geometry: new ol.geom.Polygon([list]),
	                data: oneRecord,
	                businessType: 'unChangePolygon',
	                layer:_layer
	            });
	            _feature.setId(oneRecord.id);
	            var _style = new ol.style.Style({
	                fill: new ol.style.Fill({
	                    color: oneRecord.fillColor || 'rgba(255,255,0,0.1)'
	                }),
	                stroke: new ol.style.Stroke({
	                    color: oneRecord.strokeColor || '#76EEC6',
	                    width: oneRecord.strokeWidth || 2
	                })
	            });
	            _feature.setStyle(_style);
	            _feature.set('vectorType', 'unChangePolygon');
	            _features.push(_feature);

	        });
	        if (_source) {
	            _source.addFeatures(_features);
	        }
	    }
	};

	module.exports = {
	    addLayer: addLayer,
	    setLayerData: setLayerData
	};


/***/ },
/* 119 */
/*!*******************************************!*\
  !*** ./src/gis/utils/export/imageUtil.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	var utils = __webpack_require__(/*! utils/util */ 1);
	'use strict';
	/**
	 * 浏览器支持度标识
	 * @type {{canvas, imageData, dataURL, btoa}}
	 */
	var $support = function () {
	    var canvas = document.createElement('canvas'),
	        ctx = canvas.getContext('2d');
	    return {
	        canvas: !!ctx,
	        imageData: !!ctx.getImageData,
	        dataURL: !!canvas.toDataURL,
	        btoa: !!window.btoa
	    };
	}();

	/**
	 * 下载Mine
	 * @type {string}
	 */
	var downloadMime = 'image/octet-stream';

	/**
	 * 放大缩小canvas
	 * @param canvas
	 * @param width
	 * @param height
	 * @returns {Element}
	 */
	function scaleCanvas(canvas, width, height) {
	    var w = canvas.width,
	        h = canvas.height;
	    if (width === undefined) {
	        width = w;
	    }
	    if (height === undefined) {
	        height = h;
	    }

	    var retCanvas = document.createElement('canvas');
	    var retCtx = retCanvas.getContext('2d');
	    retCanvas.width = width;
	    retCanvas.height = height;
	    retCtx.drawImage(canvas, 0, 0, w, h, 0, 0, width, height);
	    return retCanvas;
	}

	/**
	 * 获取canvas图片的dataUrl
	 * @param canvas
	 * @param type
	 * @param width
	 * @param height
	 * @returns {string}
	 */
	function getDataURL(canvas, type, width, height) {
	    canvas = scaleCanvas(canvas, width, height);
	    return canvas.toDataURL(type);
	}

	/**
	 * 用指定的文件名保存图片
	 * @param strData
	 * @param fileName
	 */
	function saveFileWithName(strData, fileName) {
	    fileName = fileName ? fileName : 'download';
	    if (!utils.getBrowserType().msie) {
	        var saveLink = document.createElement('a');
	        saveLink.href = strData;
	        saveLink.download = fileName;

	        var evt = new MouseEvent('click', {
	            bubbles: true,
	            cancelable: false,
	            view: window,
	            detail: 0,
	            screenX: 0,
	            screenY: 0,
	            clientX: 0,
	            clientY: 0,
	            ctrlKey: false,
	            altKey: false,
	            shiftKey: false,
	            metaKey: false,
	            button: 0,
	            relatedTarget: null
	        });
	        saveLink.dispatchEvent(evt);
	    }
	    else {
	        var blobObject = dataURLtoBlob(strData);
	        window.navigator.msSaveBlob(blobObject, fileName);
	    }
	}

	/**
	 * 将dataUrl转为blob
	 * @param dataurl
	 * @returns {*}
	 */
	function dataURLtoBlob(dataurl) {
	    var arr = dataurl.split(',');
	    var mime = arr[0].match(/:(.*?);/)[1];
	    var bstr = atob(arr[1]);
	    var n = bstr.length;
	    var u8arr = new Uint8Array(n);
	    while (n--) {
	        u8arr[n] = bstr.charCodeAt(n);
	    }
	    return new Blob([u8arr], { type: mime });
	}

	/**
	 * 生成图片元素
	 * @param strData
	 * @returns {Element}
	 */
	function genImage(strData) {
	    var img = document.createElement('img');
	    img.src = strData;
	    return img;
	}

	/**
	 * 转换图片后缀为统一格式
	 * @param type
	 * @returns {string}
	 */
	function fixType(type) {
	    type = type.toLowerCase().replace(/jpg/i, 'jpeg');
	    var r = type.match(/png|jpeg|bmp|gif/)[0];
	    return 'image/' + r;
	}

	/**
	 * 将canvas保存为图片
	 * @param canvas
	 * @param width
	 * @param height
	 * @param type
	 * @param fileName
	 */
	function saveAsImage(canvas, width, height, type, fileName) {
	    if ($support.canvas && $support.dataURL) {
	        if (typeof canvas === 'string') {
	            canvas = document.getElementById(canvas);
	        }
	        if (type === undefined) {
	            type = 'png';
	        }
	        if (fileName.indexOf('.' + type) < 0) {
	            fileName = fileName + '.' + type;
	        }
	        type = fixType(type);

	        var strData = getDataURL(canvas, type, width, height);
	        saveFileWithName(strData.replace(type, downloadMime), fileName);
	    }
	}

	/**
	 * 将canvas转换为图片元素
	 * @param canvas
	 * @param width
	 * @param height
	 * @param type
	 * @returns {Element}
	 */
	function convertToImage(canvas, width, height, type) {
	    if ($support.canvas && $support.dataURL) {
	        if (typeof canvas === 'string') {
	            canvas = document.getElementById(canvas);
	        }
	        if (type === undefined) {
	            type = 'png';
	        }
	        type = fixType(type);

	        var strData = getDataURL(canvas, type, width, height);
	        return genImage(strData);
	    }
	}

	/**
	 * 根据元素id或元素来获取元素
	 * @param target
	 * @returns {*}
	 */
	function getTarget(target) {
	    if (typeof target === 'string') {
	        return document.getElementById(target);
	    }
	    else {
	        return target;
	    }
	}

	/**
	 * 处理谷歌地图样式
	 * @returns {String} 转换矩阵字符串
	 */
	function handleGMapStyle() {
	    var styleElement = document.querySelector('.gm-style>div:first-child>div');
	    if (!styleElement) {
	        return null;
	    }
	    var transform = styleElement.style.transform;
	    var comp = transform.split(','); //split up the transform matrix
	    var mapleft = parseFloat(comp[4]); //get left value
	    var maptop = parseFloat(comp[5]);  //get top value
	    var elements = document.querySelectorAll('.gm-style>div:first-child>div');
	    var ele_len = elements.length;
	    for (var x = 0; x < ele_len; x++) {
	        var e = elements[x];
	        e.style.transform = 'none';
	        e.style.left = mapleft;
	        e.style.top = maptop;
	    }
	    return transform;
	}

	/**
	 * 重置谷歌地图样式
	 * @param {String} transform 转换矩阵字符串
	 */
	function resetGMapStyle(transform) {
	    if (!transform) {
	        return;
	    }
	    var elements = document.querySelectorAll('.gm-style>div:first-child>div');
	    var ele_len = elements.length;
	    for (var x = 0; x < ele_len; x++) {
	        var e = elements[x];
	        e.style.transform = transform;
	        e.style.left = 0;
	        e.style.top = 0;
	    }
	}

	/**
	 * 将dom元素保存为图片
	 * @param target
	 * @param fileName
	 * @param endCallback
	 */
	function dom2image(target, fileName, endCallback) {
	    fileName = fileName.split('.');
	    var fileType = fileName[fileName.length - 1];
	    fileName = fileName[0];
	    target = getTarget(target);

	    var transform = handleGMapStyle();

	    html2canvas(target, {
	        useCORS: true,
	        onrendered: function (canvas) {
	            saveAsImage(canvas, canvas.width, canvas.height, fileType, fileName);
	            if (endCallback) {
	                endCallback(canvas);
	            }
	            resetGMapStyle(transform);
	        }
	    });
	}

	/**
	 * 将canvas保存为图片
	 * @param target
	 * @param fileName
	 */
	function canvas2image(target, fileName) {
	    fileName = fileName.split('.');
	    var fileType = fileName[fileName.length - 1];
	    fileName = fileName[0];

	    var canvas = getTarget(target);
	    saveAsImage(canvas, canvas.width, canvas.height, fileType, fileName);
	}

	/**
	 * 导出图片
	 * @param params 参数对晚
	 */
	function exportImage(params) {
	    var targetId;
	    if (typeof params.targetId === 'string') {
	        targetId = params.targetId;
	    }
	    else {
	        targetId = params.targetId.id;
	    }
	    if(params.mapId!==undefined){
	        targetId=params.mapId;
	    }
	    var overView = document.getElementById(targetId + '_overview');
	    if (!!overView && overView.style.opacity === '0') {
	        overView.style.display = 'none';
	    }
	    dom2image(params.targetId, params.fileName, params.endCallback);
	    if (!!overView && overView.style.opacity === '0') {
	        overView.style.display = 'block';
	    }

	}

	module.exports = {
	    exportImage: exportImage

	};

/***/ },
/* 120 */
/*!***********************************!*\
  !*** ./src/gis/utils/exportUI.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	var exportData = __webpack_require__(/*! utils/export/exportData */ 121);
	var exportImage = __webpack_require__(/*! utils/export/exportImage */ 123);

	module.exports = {
	    createExportDataUI: exportData.createExportDataUI,
	    createExportImageUI: exportImage.createExportImageUI
	};

/***/ },
/* 121 */
/*!********************************************!*\
  !*** ./src/gis/utils/export/exportData.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	var domUtil = __webpack_require__(/*! utils/domUtil */ 10);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var eventTool = __webpack_require__(/*! utils/eventTool */ 62);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var clientExport = __webpack_require__(/*! utils/export/clientExport */ 122);
	var i18n = __webpack_require__(/*! utils/i18n */ 13);

	function header_(box) {
	    var header = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            class: 'export_box_header',
	            style: 'width: 400px; height: 24px; line-height: 24px; text-indent: 8px; color: #388E8E;' +
	            'border-bottom-style: solid; border-bottom-color: #EBEBEB;border-bottom-width: 1px;'
	        },
	        text: i18n.prop('dataExport.title')
	    });
	    box.appendChild(header);

	    var closeBtn = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            title: i18n.prop('components.exportImage.closeExportBox'),
	            style: 'width: 16px; height: 16px;line-height: 16px;text-align: center; background: #388E8E; ' +
	            'color: white; position: absolute;top: 4px; right: 4px;cursor: pointer;text-indent: 0px;'
	        },
	        text: 'X'
	    });
	    eventTool.add(closeBtn, 'click', function () {
	        box.style.display = 'none';
	    });
	    header.appendChild(closeBtn);
	}

	function body_(paramObj, box) {
	    var fileTypes = [i18n.prop('dataExport.exportTypeSel'), 'KML', 'KMZ', 'Shape', 'GRD', 'TAB(Raster)', 'TAB(Vector)', 'KML(Raster)'];
	    var body = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            class: 'export_box_body',
	            style: 'margin-top: 25px; width: 100%; height: 261px;color: gray;'
	        }
	    });
	    box.appendChild(body);

	    var bodyTop = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            style: 'height: 20px; line-height: 20px; margin-bottom: 15px;'
	        }
	    });
	    body.appendChild(bodyTop);

	    var bodyBottom = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            style: 'height:225px;'
	        }
	    });
	    body.appendChild(bodyBottom);

	    var _exportFileTypeLabel = domUtil.createDom({
	        tagName: 'span',
	        attributes: {
	            style: 'display: block;float: left; text-indent: 18px;'
	        },
	        text: i18n.prop('components.exportImage.format')
	    });
	    bodyTop.appendChild(_exportFileTypeLabel);

	    var _selectNodeExportType = domUtil.createDom({
	        tagName: 'select',
	        attributes: {
	            name: 'export_file_type',
	            class: 'export_file_type',
	            style: 'padding: 0 5%; height: 20px; line-height: 20px; outline: none;' +
	            'margin-left: 10px;color: gray;'
	        }
	    });
	    fileTypes.forEach((function (fileType) {
	        var exportOption = domUtil.createDom({
	            tagName: 'option',
	            attributes: {
	                value: fileType
	            },
	            text: fileType
	        });
	        _selectNodeExportType.appendChild(exportOption);
	    }));
	    bodyTop.appendChild(_selectNodeExportType);

	    var exportLayers = domUtil.createDom({
	        tagName: 'span',
	        attributes: {
	            style: 'display:block;float:left;text-indent:18px;'
	        },
	        text: i18n.prop('components.exportImage.Layers')
	    });
	    bodyBottom.appendChild(exportLayers);
	    var layersTreeBox = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            style: 'height: 225px;width: 273px;outline:none;border:1px solid #EBEBEB;' +
	            'float:left;margin-left:10px;padding:5px;'
	        }
	    });
	    bodyBottom.appendChild(layersTreeBox);

	    var layersTreeUL = domUtil.createDom({
	        tagName: 'ul',
	        attributes: {
	            style: 'list-style: none'
	        }
	    });
	    var checkboxInLis = [];
	    var allLayerOneMap = layers.getLayers(paramObj.mapId);
	    if (!!allLayerOneMap) {
	        for (var i = 0; i < allLayerOneMap.length; i++) {
	            var businessLayer = allLayerOneMap[i];
	            if (!!businessLayer && !!businessLayer.get('businessType')) {

	                var layerName = !!!businessLayer.get('mineLayerName') ? businessLayer.get('params.label') : businessLayer.get('mineLayerName');
	                if (!!layerName) {
	                    if (layerName !== 'Temp Polygon' && layerName !== 'Temp Point' && layerName !== 'Temp Line') {
	                        if (!businessLayer.get('isVectorType')) {

	                            checkboxInLis.push(createOption_(layersTreeUL, layerName, businessLayer));
	                        }

	                    }
	                }
	            }
	        }
	    }

	    layersTreeBox.appendChild(layersTreeUL);
	    for (var i = 0; i < layersTreeUL.childNodes.length; i++) {
	        if (hashMap.get(layersTreeUL.childNodes[i].childNodes[1].innerText) === constant.BUSINESSTYPE.GRID.toLowerCase()) {
	            layersTreeUL.childNodes[i].style.display = "none";
	        }
	    }

	    filterLayerName_(paramObj);
	}

	function filterLayerName_(paramObj) {
	    var targetElement = hashMap.get(paramObj.mapId).getTargetElement();
	    var exportBoxBody = targetElement.querySelector('.export_box_body');
	    if (!!exportBoxBody && exportBoxBody.querySelector('select').value === i18n.prop('dataExport.exportTypeSel')) {
	        exportBoxBody.querySelector('ul').style.display = 'none'
	    }
	    else {
	        exportBoxBody.querySelector('ul').style.display = 'block'
	    }
	}

	function foot_(paramObj, box) {
	    var targetElement = hashMap.get(paramObj.mapId).getTargetElement();
	    var exportFileType = targetElement.querySelector('.export_file_type');

	    var foot = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            class: 'export_box_foot',
	            style: 'margin: 30px auto; width: 210px; height: 30px; line-height: 30px;'
	        }
	    });
	    box.appendChild(foot);

	    var okBtn = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            type: 'submit',
	            style: 'float: left; width: 100px; height: 100%;line-height: 30px; text-align: center;' +
	            ' background: #9ACD32;cursor: pointer; margin-right: 10px;font-weight: bold; color: white;'
	        },
	        text: i18n.prop('components.exportImage.OK')
	    });
	    foot.appendChild(okBtn);
	    // when button click, begin to process window data export or download.
	    eventTool.add(okBtn, 'click', function () {
	        var layerNameNode = targetElement.querySelectorAll('.export_layer_checkbox_in_li');

	        var exportLayerNames = (function (layerNameNode) {
	            var names = [];
	            for (var i = 0; i < layerNameNode.length; i++) {
	                if (layerNameNode[i].checked) {
	                    layerNameNode[i].value && names.push(layerNameNode[i].value);
	                }
	            }
	            return names;
	        }(layerNameNode));

	        if (exportLayerNames && exportLayerNames.length > 0) {
	            clientExport.exportFileToClient(paramObj.mapId, exportFileType.value, exportLayerNames);
	        }

	        box.style.display = 'none';
	    });

	    //根据导出类型，控制导出列表中显示的图层名称
	    _filterLayerName(exportFileType, targetElement);

	    var cancelBtn = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            style: 'float: left; width: 100px; height: 100%;line-height: 30px; text-align: center;' +
	            ' background: #D4D4D4;cursor: pointer; font-weight: bold; color: white;'
	        },
	        text: i18n.prop('components.exportImage.Cancel')
	    });
	    foot.appendChild(cancelBtn);
	    eventTool.add(cancelBtn, 'click', function () {
	        box.style.display = 'none';
	    });
	}

	/**
	 * 根据导出类型，控制导出列表中显示的图层名称
	 * @param exportFileType {document} select tag
	 * @param targetElement
	 * @private
	 */
	function _filterLayerName(exportFileType, targetElement) {
	    eventTool.add(exportFileType, 'change', function () {
	        var layerNameNodes = targetElement.querySelectorAll('.export_layer_checkbox_in_li');
	        if (!!layerNameNodes) {
	            for (var i = 0; i < layerNameNodes.length; i++) {
	                var layerNameNode = layerNameNodes[i];
	                layerNameNode.parentNode.style.display = "none";
	                var layerType = layerNameNode.value.substring(0, layerNameNode.value.indexOf('('));
	                var exportType = exportFileType.value;

	                if (exportType === 'GRC' || exportType === 'GRD' || exportType === 'TAB(Raster)' || exportType === 'KML(Raster)') {
	                    if (layerType === constant.BUSINESSTYPE.GRID.toLowerCase()) {
	                        layerNameNode.parentNode.style.display = "block";
	                    }
	                }
	                else if (exportType === 'Shape' || exportType === 'KML'
	                    || exportType === 'KMZ' || exportType === 'TAB(Vector)') {

	                    if (layerType !== constant.BUSINESSTYPE.GRID.toLowerCase()) {
	                        layerNameNode.parentNode.style.display = "block";
	                    }
	                }
	            }
	        }

	        filterLayerName_({
	            mapId: targetElement.id
	        });
	    });
	}

	var createExportDataUI = function (paramObj) {
	    var targetElement = hashMap.get(paramObj.mapId).getTargetElement();
	    var _exportWin = targetElement.querySelector('.export_kml_kmz_shape_grd_window');
	    if (!!_exportWin) {
	        targetElement.removeChild(_exportWin);
	    }
	    var exportWindow = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            class: 'export_box export_kml_kmz_shape_grd_window',
	            style: 'width: 400px; height: 390px;border:1px solid #EBEBEB; background: white; ' +
	            'position: absolute; margin-left: -200px; margin-top: -185px; z-index: 1;top: 50%; left: 50%;'
	        }
	    });
	    targetElement.appendChild(exportWindow);

	    header_(exportWindow);
	    body_(paramObj, exportWindow);
	    foot_(paramObj, exportWindow);
	};

	/**
	 * 构建图层名称
	 * @param mapId
	 * @param layersTreeUL
	 * @param isCheckAll
	 * @param text
	 * @returns {*}
	 * @private
	 */
	function createOption_(layersTreeUL, text, businessLayer) {
	    if (!!businessLayer.get('isCluster') ||
	        !!businessLayer.get('isVectorType') ||
	        !!businessLayer.get('isImgType')) {
	        return;
	    }
	    var layersTreeLI = domUtil.createDom({
	        tagName: 'li'
	    });
	    var layersTreeLi_checkbox = domUtil.createDom({
	        tagName: 'input',
	        attributes: {
	            type: 'radio',
	            name: 'exportLayerName',
	            value: text,
	            class: 'export_layer_checkbox_in_li'
	        }
	    });
	    layersTreeLI.appendChild(layersTreeLi_checkbox);
	    layersTreeUL.appendChild(layersTreeLI);

	    var layersTreeLi_label = domUtil.createDom({
	        tagName: 'label',
	        attributes: {
	            style: 'position:relative;top:-4px;'
	        },
	        text: text
	    });
	    layersTreeLI.appendChild(layersTreeLi_label);

	    return layersTreeLi_checkbox;
	}

	module.exports = {
	    createExportDataUI: createExportDataUI
	};

/***/ },
/* 122 */
/*!**********************************************!*\
  !*** ./src/gis/utils/export/clientExport.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	var domUtil = __webpack_require__(/*! utils/domUtil */ 10);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);

	var SHAPE_URL = constant.GisRootUrl + '/vectorManager/data/export?FCName=';
	var GRC_GRD_URL = constant.GisRootUrl + '/gridManager/data/export?cacheKey=';

	function _getImageToken(mapId, _layerName) {
	    var layersInHashMap = layers.getLayers(mapId);
	    var imgToken = null;
	    layersInHashMap.forEach(function (layerObj) {
	        if (!!layerObj) {
	            if (!!layerObj.get('mineLayerName')) {
	                var layerName = layerObj.get('mineLayerName');
	                if (layerName === _layerName[0]) {
	                    imgToken = layerObj.get('mineLayerImgToken');
	                    return imgToken;
	                }
	            }
	            else if (!!layerObj.get('params.label')) {
	                var layerName = layerObj.get('params.label');
	                if (layerName === _layerName[0]) {
	                    imgToken = layerObj.get('imgToken');
	                    return imgToken;
	                }
	            }
	        }
	    });

	    return imgToken;
	}

	/**
	 *
	 * @param mapId
	 * @param exportType
	 * @param layerName
	 * @returns {boolean}
	 */
	function exportFileToClient(mapId, exportType, layerName) {
	    var imgToken = _getImageToken(mapId, layerName);

	    if (!!!imgToken) {
	        console.warn('%c vector layer not support data export', 'color:red');
	        return false;
	    }

	    var ActionURL = null;
	    if (exportType === 'KML' || exportType === 'KMZ' || exportType === 'Shape' || exportType === 'TAB(Vector)') {
	    	var fcName = imgToken != undefined ? imgToken.slice(0, imgToken.indexOf(':')) : undefined;
	        ActionURL = SHAPE_URL +fcName;
	    }
	    else if (exportType === 'GRD' || exportType === 'GRC' || exportType === 'TAB(Raster)' || exportType === 'KML(Raster)') {
	        ActionURL = GRC_GRD_URL+imgToken;
	    }

	    var mapObj = hashMap.get(mapId);
	    if (!!!mapObj) {
	        return false;
	    }
	    var extent = mapBox.getExtent(mapId);
	    var targetElement = mapObj.getTargetElement();
	    if (exportType.indexOf('TAB') !== -1) {
	        exportType = 'TAB';
	    }

	    if (exportType.indexOf('KML') !== -1) {
	        exportType = 'KML';
	    }
	    var exportParam = {
	        extent: extent,
	        imgToken: imgToken,
	        Format: exportType.toLowerCase()
	    };

	    var _formClass = 'kml_kmz_shape_grd_grc_form_id';
	    var oldForm = targetElement.querySelector('.' + _formClass);
	    if (!!oldForm) {
	        targetElement.removeChild(oldForm);
	    }

	    var form = domUtil.createDom({
	        tagName: 'form',
	        attributes: {
	            style: 'display: none',
	            action: ActionURL,
	            method: 'post',
	            class: _formClass
	        }
	    });
	    targetElement.appendChild(form);

	    var input = domUtil.createDom({
	        tagName: 'input',
	        attributes: {
	            type: 'hidden',
	            name: 'export',
	            value: JSON.stringify(exportParam)
	        }
	    });
	    form.appendChild(input);
	    form.submit();
	}

	module.exports = {
	    exportFileToClient: exportFileToClient
	};

/***/ },
/* 123 */
/*!*********************************************!*\
  !*** ./src/gis/utils/export/exportImage.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	var imageUtil = __webpack_require__(/*! utils/export/imageUtil */ 119);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var domUtil = __webpack_require__(/*! utils/domUtil */ 10);
	var i18n = __webpack_require__(/*! utils/i18n */ 13);

	var createExportImageUI = function (param) {
	    var _mapId = param.mapId;
	    var _rootDom = mapBox.getMapObj(_mapId).getTargetElement();

	    var createDom = function (param) {
	        var element = document.createElement(param.labelName);
	        !!param.id && element.setAttribute('id', param.id);
	        !!param.class && element.setAttribute('class', param.class);
	        !!param.title && element.setAttribute('title', param.title);
	        !!param.style && element.setAttribute('style', param.style);
	        !!param.value && element.setAttribute('value', param.value);
	        if (!!param.text) {
	            element.innerHTML = param.text;
	        }

	        return element;
	    };

	    var windowDiv = createDom({
	        labelName: 'div',
	        class: 'export-image-window',
	        style: 'width: 400px; height: 140px; position: absolute; top: 50%; left: 50%;' +
	            ' margin-left: -200px; margin-top: -70px; border:1px solid #EBEBEB; background: white;'
	    });
	    _rootDom.appendChild(windowDiv);

	    var _header = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            class: 'export_image_header',
	            style: 'width: 400px; height: 24px; line-height: 24px; text-indent: 8px; color: #388E8E;' +
	                ' border-bottom-style: solid; border-bottom-color: #EBEBEB;border-bottom-width: 1px;'
	        },
	        text: fusiongis.I18n.prop('imageExport.title')
	    });
	    windowDiv.appendChild(_header);

	    var _closeDiv = createDom({
	        labelName: 'div',
	        class: 'export-image-title',
	        style: 'width: 16px; height: 16px;line-height: 16px;text-align: center; background: #388E8E; ' +
	            'color: white; position: absolute;top: 4px; right: 4px;cursor: pointer;text-indent: 0px;',
	        text: 'X'
	    });
	    _header.appendChild(_closeDiv);
	    _closeDiv.onclick = function () {
	        _rootDom.removeChild(windowDiv);
	    };

	    var _select = createDom({
	        labelName: 'select',
	        class: 'export-image-select',
	        style: 'position: absolute;top: 50px;left: 50%;width: 138px;margin-left: -69px;cursor: pointer;'
	    });

	    var imageExtension = [fusiongis.I18n.prop('imageExport.exportTypeSel'), 'PNG', 'GIF', 'JPG'];
	    imageExtension.forEach(function (imageExtension) {
	        var _option = createDom({
	            labelName: 'option',
	            class: 'export-image-select',
	            style: '',
	            value: imageExtension === fusiongis.I18n.prop('imageExport.exportTypeSel') ? 'png' : imageExtension,
	            text: imageExtension
	        });

	        _select.appendChild(_option);
	    });
	    windowDiv.appendChild(_select);

	    var okBtn = createDom({
	        labelName: 'div',
	        style: 'width: 100px; height: 30px;line-height: 30px;position: absolute;bottom: 10px;left: 95px;' +
	            'background-color:#9ACD32;font-weight:bold;color:white;text-align:center;cursor: pointer;',
	        text: i18n.prop('components.exportImage.OK')
	    });
	    windowDiv.appendChild(okBtn);
	    okBtn.onclick = function () {
	        windowDiv.style.display = 'none';
	        var imgType = this.parentNode.querySelector('.export-image-select').value;
	        imageUtil.exportImage({
	            targetId: _mapId,
	            fileName: "map." + imgType
	        });
	        _rootDom.removeChild(windowDiv);
	    };

	    var cancelBtn = createDom({
	        labelName: 'div',
	        style: 'width: 100px; height: 30px;line-height: 30px;position: absolute;bottom: 10px;left: 205px;' +
	            'background-color:#D4D4D4;font-weight:bold;color:white;text-align:center;cursor: pointer;',
	        text: i18n.prop('components.exportImage.Cancel')
	    });
	    windowDiv.appendChild(cancelBtn);
	    cancelBtn.onclick = function () {
	        _rootDom.removeChild(windowDiv);
	    };
	};

	module.exports = {
	    createExportImageUI: createExportImageUI
	};

/***/ },
/* 124 */
/*!**********************************************!*\
  !*** ./src/gis/tools/dragZoomInteraction.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 *
	 *@file 鼠标框选进行地图放大操作。
	 *
	 *
	 */

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);

	var zoomInterAction = null;

	/**
	 *
	 * @param paramObj
	 * paramObj = {
	 *     mapId: 'mapId',
	 *     isActive: true or false
	 * }
	 */
	var dragZoomInteraction = function (paramObj) {
	    if (!!!zoomInterAction) {
	        zoomInterAction = new ol.interaction.DragZoom({
	            condition: ol.events.condition.always
	        });
	        mapBox.getMapObj(paramObj.mapId).addInteraction(zoomInterAction);
	    }

	    if (paramObj.isActive) {
	        zoomInterAction.setActive(true);
	    }
	    else {
	        zoomInterAction.setActive(false);
	    }
	};

	module.exports = {
	    dragZoomInteraction: dragZoomInteraction
	};

/***/ },
/* 125 */
/*!*****************************************!*\
  !*** ./src/gis/tools/gps-navigation.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	/*******************************************************
	 @file 轨迹播放，带方向箭头
	 1、每隔几个点显示箭头，由用户自定义；
	 ********************************************************/
	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var algorithm = __webpack_require__(/*! framework/algorithm */ 48);
	var Map = __webpack_require__(/*! maps/map */ 8);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var util = __webpack_require__(/*! utils/util */ 1);
	var I18n = __webpack_require__(/*! utils/i18n */ 13);
	var popList = [];
	var mapRadius = 6378137;
	/**
	 *
	 * @param paramObj
	 * paramObj = {
	 *
	 *
	 * }
	 * @returns {*}
	 */
	var addLayer = function (paramObj) {
	    var _mapId = paramObj.mapId;
	    var _lineLayerId = paramObj.layerId + '_line_' + _mapId;
	    var _arrowLayerId = paramObj.layerId + '_arrow_' + _mapId;
	    var _lineLayer =null;
	    var _arrowLine = null;
	    if (!hashMap.containsKey(_lineLayerId) && !hashMap.containsKey(_arrowLayerId)) {
	        _lineLayer = new ol.layer.Vector({
	            source: new ol.source.Vector({
	                wrapX: false
	            })
	        });
	        _arrowLine = new ol.layer.Vector({
	            source: new ol.source.Vector({
	                wrapX: false
	            })
	        });

	        _lineLayer.set('mapId', _mapId);
	        _lineLayer.set('layerId', paramObj.layerId);
	        _lineLayer.set('popList',[]);
	        hashMap.put(_lineLayerId, _lineLayer);
	        mapBox.getMapObj(_mapId).addLayer(_lineLayer);
	        _arrowLine.set('mapId', _mapId);
	        _arrowLine.set('layerId', paramObj.layerId);
	        hashMap.put(_arrowLayerId, _arrowLine);
	        mapBox.getMapObj(_mapId).addLayer(_arrowLine);
	    }
	};


	var setLayerData = function (paramObj) {
	    var _lineLayerId = paramObj.layerId + '_line_' +paramObj.mapId;
	    var _arrowLayerId = paramObj.layerId + '_arrow_' + paramObj.mapId;
	    var _lineLayer = hashMap.get(_lineLayerId);
	    var _arrowLayer = hashMap.get(_arrowLayerId);
	    var _data = paramObj.data;
	    var _showBreakPoint = paramObj.showBreakPoint !== undefined ? paramObj.showBreakPoint : true;
	    var _showStraightIcon = paramObj.showStraightIcon !== undefined ? paramObj.showStraightIcon : false;
	    var _breakPointInterval = paramObj.breakPointInterval || 3;
	    var _straightInterval = paramObj.straightInterval || 1000;
	    var _breakPointStyle = paramObj.breakPointStyle || {};
	    var _straightStyle = paramObj.straightStyle || {};
	    var _lineStyle = paramObj.lineStyle || {};
	    var showMeasure = paramObj.showMeasure !== undefined ? paramObj.showMeasure : false;
	    var isClear = paramObj.isClear !== undefined ? paramObj.isClear : false;
	    var mapObj = Map.getMapObj(paramObj.mapId);
	    var sourceProj = mapObj.getView().getProjection();
	    var wgs84Sphere = new ol.Sphere(mapRadius);
	    var _features = [];
	    var _trackFeatures = [];
	    var _trackPoints = [];
	    if(_data && _data.length>1){
	        for(var i=0;i<_data.length;i++){
	            var _coordinate = ol.proj.fromLonLat(_data[i].coordinate);
	            _trackPoints.push(_coordinate);
	            if(i <_data.length -1){
	                var _nextCoordinate = ol.proj.fromLonLat(_data[i+1].coordinate);

	                var _vectorX = _nextCoordinate[0] - _coordinate[0];
	                var _vectorY = _nextCoordinate[1] - _coordinate[1];
	                var _azimuth = Math.atan(_vectorX/_vectorY) * 180 / Math.PI;
	                if(_azimuth === -90 || _azimuth === 90){
	                    _azimuth = _azimuth * (-1);
	                }
	                if (_vectorY> 0) {
	                    _azimuth += 360;
	                }
	                else {
	                    _azimuth += 180;
	                }
	                if (_azimuth > 360) {
	                    _azimuth -= 360;
	                }
	                var lineLength = new ol.geom.LineString([_coordinate,_nextCoordinate]).getLength();
	                var arrowNum = parseInt(lineLength/_straightInterval);
	                for(var n = 0;n < arrowNum;n++){
	                    var rotatedAngle = Math.PI / 2 - _azimuth/ 180 * Math.PI;
	                    var _pointX = _coordinate[0] + (n+1) *_straightInterval * Math.cos(rotatedAngle);
	                    var _pointY = _coordinate[1] + (n+1) *_straightInterval * Math.sin(rotatedAngle);
	                    if(_showStraightIcon){
	                        var straightArrowHeight = _straightStyle.height || 500;
	                        var straightList = algorithm.createArrow(_pointX,_pointY,straightArrowHeight,_azimuth,60);
	                        var _straight = new ol.geom.LinearRing(straightList);
	                        var _polygon = new ol.geom.Polygon([_straight.getCoordinates()]);
	                        var straightfeature = new ol.Feature({
	                            geometry: _polygon,
	                            data: _data[i]
	                        });
	                        var _Pstyle = new ol.style.Style({
	                            fill: new ol.style.Fill({
	                                color: _straightStyle.fillColor || 'blue'
	                            }),
	                            stroke: new ol.style.Stroke({
	                                color: _straightStyle.strokeColor || 'blue',
	                                width: _straightStyle.width || 1
	                            })
	                        });
	                        straightfeature.setStyle(_Pstyle);
	                        _features.push(straightfeature);
	                    }
	                }
	                var breakPointHeight = _breakPointStyle.height || 500;
	                var _dataList = algorithm.createArrow(_coordinate[0],_coordinate[1],breakPointHeight,_azimuth,60);
	                var _linearRing = new ol.geom.LinearRing(_dataList);
	                var _polygon = new ol.geom.Polygon([_linearRing.getCoordinates()]);
	                var _feature = new ol.Feature({
	                    geometry: _polygon,
	                    data: _data[i]
	                });

	                var _Pstyle = new ol.style.Style({
	                    fill: new ol.style.Fill({
	                        color: _breakPointStyle.fillColor || 'blue'
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color: _breakPointStyle.strokeColor || 'blue',
	                        width: _breakPointStyle.width || 1
	                    })
	                });
	                _feature.setStyle(_Pstyle);
	                if (i % _breakPointInterval === 0 && i <= _data.length - 2) {
	                    if(_showBreakPoint){
	                        _features.push(_feature);
	                    }
	                }
	            }

	        }
	        var _trackFeature = new ol.Feature({
	            geometry: new ol.geom.LineString(_trackPoints)
	        });
	        var _Pstyle = new ol.style.Style({
	            stroke: new ol.style.Stroke({
	                color: _lineStyle.strokeColor || 'white',
	                width: _lineStyle.width || 2
	            })
	        });
	        _trackFeature.setStyle(_Pstyle);
	        _trackFeatures.push(_trackFeature);
	    }
	    var popList = _lineLayer.get('popList');
	        if (popList && popList.length > 0) {
	            for (var i = 0; i < popList.length; i++) {
	                mapObj.removeOverlay(popList[i]);
	            }
	            _lineLayer.set('popList',[]);
	        }
	        var allMeasure = 0;
	        if (showMeasure) {
	            for (var i = 0; i < _trackPoints.length - 1; i++) {
	                var c1 = ol.proj.transform(_trackPoints[i], sourceProj, 'EPSG:4326');
	                var c2 = ol.proj.transform(_trackPoints[i + 1], sourceProj, 'EPSG:4326');
	                var _distence = wgs84Sphere.haversineDistance(c1, c2);
	                allMeasure += _distence;
	                var distence;
	                if (_distence > 100) {
	                    distence = (Math.round(_distence / 1000 * 100) / 100) + "km";
	                }
	                else {
	                    distence = (Math.round(_distence * 100) / 100) + "m";
	                }
	                var measureTooltipElement = document.createElement('div');
	                measureTooltipElement.className = 'measure-tooltip mile';
	                if (i === _trackPoints.length - 2) {
	                    var allDistence;
	                    if (allMeasure > 100) {
	                        allDistence = (Math.round(allMeasure / 1000 * 100) / 100) + "km";
	                    }
	                    else {
	                        allDistence = (Math.round(allMeasure * 100) / 100) + "m";
	                    }
	                    measureTooltipElement.innerHTML = distence + ";" + I18n.prop('measure.message.total') + allDistence;
	                }
	                else {
	                    measureTooltipElement.innerHTML = distence;
	                }
	                measureTooltipElement.style.zIndex = olUtil.getPopupZIndex(mapObj.getTarget());
	                var measureTooltip = new ol.Overlay({
	                    element: measureTooltipElement,
	                    offset: [-5, -1],
	                    positioning: 'top-center'
	                });
	                measureTooltip.setPosition(_trackPoints[i + 1]);
	                mapObj.addOverlay(measureTooltip);
	                popList.push(measureTooltip);
	            }
	        }
	    if (isClear) {
	        !!_lineLayer && _lineLayer.getSource().clear();
	        !!_arrowLayer && _arrowLayer.getSource().clear();
	        if (popList.length > 0) {
	            for (var i = 0; i < popList.length; i++) {
	                mapObj.removeOverlay(popList[i]);
	            }
	        }
	        popList = [];
	    }

	    !!_lineLayer && _lineLayer.getSource().addFeatures(_trackFeatures);
	    !!_arrowLayer && _arrowLayer.getSource().addFeatures(_features);
	};

	module.exports = {
	    addLayer: addLayer,
	    setLayerData: setLayerData
	};

/***/ },
/* 126 */
/*!******************************************!*\
  !*** ./src/gis/layers/renderGeometry.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	/*
	 *@file renderGeometry.js
	 *@describe 根据用户传入的数据进行矢量点、线、面的绘制。
	 *   本文件中的功能只支持矢量绘制，暂不做服务处理
	 *
	 */

	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);

	/**
	 *
	 * @param param
	 */
	var circle = function (param) {
	    var _callback = param.callback;
	    var _mapId = param.mapId;
	    var _layerId = param.layerId;
	    var _dataList = param.dataList;
	    var _layerIdentify = _layerId + constant.Joiner.UNDERLINE + _mapId;
	    var _olMap = hashMap.get(_mapId);
	    var _layer = null;

	    if (!!!hashMap.containsKey(_layerIdentify)) {
	        _layer = new ol.layer.Vector({
	            source: new ol.source.Vector({
	                wrapX: false
	            })
	        });

	        hashMap.put(_layerIdentify, _layer);
	        _olMap.addLayer(_layer);
	    }
	    else {
	        _layer = hashMap.get(_layerIdentify);
	    }
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	    }

	    (function () {
	        var select = new ol.interaction.Select({
	            layers: [_layer],
	            wrapX: false
	        });
	        _olMap.addInteraction(select);

	        var translate = new ol.interaction.Translate({
	            features: select.getFeatures()
	        });
	        _olMap.addInteraction(translate);

	        translate.on('translateend', function (evt) {
	            var feature = evt.features.getArray()[0];
	            var _extent = ol.proj.transformExtent(feature.getGeometry().getExtent(),
	                constant.PROJ.EPSG_3857, constant.PROJ.EPSG_4326);
	            _extent[0] = fomLon(_extent[0]);
	            _extent[2] = fomLon(_extent[2]);

	            if (!!_callback && typeof _callback === 'function') {
	                if(Math.abs(_extent[1])< 90 && Math.abs(_extent[3])< 90){
	                    _callback({
	                        extent: _extent
	                    });
	                }else{
	                    console.warn('the circle out of range');
	                }
	            }
	        });

	        var modify = new ol.interaction.Modify({
	            features: select.getFeatures()
	        });
	        _olMap.addInteraction(modify);

	        var circleKvoKey = false;
	        var uniqueEventKey = null;
	        modify.on('modifystart', function (evt) {
	            var selectFeatures = evt.features;
	            if (selectFeatures && selectFeatures.getArray().length > 0) {
	                var feature = selectFeatures.getArray()[0];
	                if (circleKvoKey == false) {
	                    var extent = feature.getGeometry().getExtent();
	                    var center = ol.extent.getCenter(extent);
	                    center = gcjTransform3857(center);
	                    uniqueEventKey = _olMap.on('pointermove', function (evt) {
	                        var position = gcjTransform3857(evt.coordinate);
	                        var geomLineString = new ol.geom.LineString([center, position]);
	                        var radius = geomLineString.getLength();
	                        var geomCircle = new ol.geom.Circle(center, radius);
	                        var polygon = new ol.geom.Polygon.fromCircle(geomCircle, 1000);
	                        feature.setGeometry(polygon);
	                    });
	                    circleKvoKey = true;
	                }
	                else {
	                    _olMap.unByKey(uniqueEventKey);
	                    circleKvoKey = false;
	                    uniqueEventKey = null;
	                    if (!!_callback && typeof _callback === 'function') {
	                        var _extent = ol.proj.transformExtent(feature.getGeometry().getExtent(),
	                            constant.PROJ.EPSG_3857, constant.PROJ.EPSG_4326);
	                        _extent[0] = fomLon(_extent[0]);
	                        _extent[2] = fomLon(_extent[2]);
	                        if(Math.abs(_extent[1])< 90 && Math.abs(_extent[3])< 90){
	                            _callback({
	                                extent: _extent
	                            });
	                        }else{
	                            console.warn('the circle out of range');
	                        }
	                    }
	                }
	            }
	        });
	    }());

	    //render geometry
	    (function () {
	        !!_dataList && _dataList.forEach(function (data) {
	            if (data.radius > 0) {
	                var _lon = data.coordinate[0];
	                var _lat = data.coordinate[1];
	                if (_lon > 180 || _lon < -180) {
	                    console.warn("lon must between -180 at 180");
	                    return
	                }
	                if (_lat >= 90 || _lat <= -90) {
	                    console.warn("lat must between -90 at 90");
	                    return
	                }
	                var extens = extentEarth(_lon,_lat,data.radius);
	                if(!extens){
	                    console.warn('the circle out of range');
	                    return
	                }
	            }
	            else {
	                console.warn('radius must be greater than 0');
	                return
	            }

	            //适配高德地图火星坐标系
	            var cacheCircle = new ol.geom.Circle(ol.proj.fromLonLat(utils.gcjTransform(data.coordinate)), data.radius);
	            var _feature = new ol.Feature({
	                geometry: new ol.geom.Polygon.fromCircle(cacheCircle, 1000)
	            });
	            _feature.setId(data.id);
	            _layer.getSource().addFeature(_feature);

	            _feature.setStyle(function () {
	                return new ol.style.Style({
	                    fill: new ol.style.Fill({
	                        color: 'rgba(33, 150, 243, .6)'
	                    }),
	                    stroke: new ol.style.Stroke({
	                        color: '#ff0',
	                        width: 1
	                    })
	                });
	            });

	            if (!!_callback && typeof _callback === 'function') {
	                var _extent = ol.proj.transformExtent(_feature.getGeometry().getExtent(),
	                    constant.PROJ.EPSG_3857, constant.PROJ.EPSG_4326);
	                _extent[0] = fomLon(_extent[0]);
	                _extent[2] = fomLon(_extent[2]);
	                if(Math.abs(_extent[1])< 90 && Math.abs(_extent[3])< 90){
	                    _callback({
	                        extent: _extent
	                    });
	                }else{
	                    console.warn('the circle out of range');
	                }

	            }
	        })
	    }());
	};
	function fomLon(lon) {
	    var _lon = lon;
	    var mapNumber = 0;
	    if (lon < -180) {
	        mapNumber = Math.abs(parseInt((lon + 180) / 360)) + 1;
	        _lon = _lon + mapNumber * 360;
	    }
	    else if (lon > 180) {
	        mapNumber = Math.abs(parseInt((lon - 180) / 360)) + 1;
	        _lon = _lon - mapNumber * 360;
	    }

	    return _lon;
	}

	function extentEarth(lon,lat,radius){
	    var flag =true;
	    var _rad = 1113190*(90-Math.abs(lat));
	    if(radius>_rad){
	        flag =false;
	    }
	    return flag
	}
	var removeGeometry = function (param, isClear) {
	    var _layerIdentify = param.layerId + constant.Joiner.UNDERLINE + param.mapId;
	    var _layer = hashMap.get(_layerIdentify);
	    if (!!_layer && _layer instanceof ol.layer.Vector) {
	        var _featureList = _layer.getSource().getFeatures();

	        if (!!arguments[1] && arguments[1] === true) {
	            _layer.getSource().clear();
	        }
	        else {
	            _featureList.forEach(function (feature) {
	                if (feature.getId() === param.featureId) {
	                    _layer.getSource().removeFeature(feature);
	                }
	            });
	        }
	    }
	};

	module.exports = {
	    circle: circle,
	    removeGeometry: removeGeometry
	};

/***/ },
/* 127 */
/*!**************************************!*\
  !*** ./src/gis/tools/customQuery.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	var constant = __webpack_require__(/*! framework/constant */ 2);
	var $ = __webpack_require__(/*! utils/ajax */ 14);

	/**
	 * 根据图层名称查询图层上所有元素
	 * @param param
	 *  {
	 *      loadAll: {boolean}
	 *      nameFilter: {string}
	 *      criteria: {string}
	 *      start: {number},
	 *      limit: {number}
	 *  }
	 *
	 *  return
	 *  {
	 *      datas:[
	 *              {
	 *                  id: '8',
	 *                  isLeaf: true,
	 *                  name: 'commercial',
	 *                  data: {
	 *                      gid: 8,
	 *                      osm_id: '123456',
	 *                      projcode: 4326,
	 *                      points: [
	 *                          [108.94, 34.25],
	 *                          [108.95, 36.24],
	 *                          [1112, 36]
	 *                      ],
	 *                      type: 'commercial'
	 *                  },
	 *                  pid: null
	 *              },
	 *              ...
	 *       ],
	 *       State: {
	 *          resultCode: 0,
	 *          resultMessage: 'succuss'
	 *       }
	 *  }
	 *
	 */
	var getFeatureInfo = function (param) {
	    $.postJSON({
	        url: constant.CustomQuery.GET_FEATURE_INFO,
	        data: JSON.stringify(param.requestParam),
	        success: function (_result) {
	            var result = JSON.parse(_result);
	            if (!!result && result.State.resultCode === 0) {
	                var _datas = result.datas;
	                if (!!_datas) {
	                    if (!!param.callback && typeof param.callback === 'function') {
	                        param.callback(_datas);
	                    }
	                }
	            }
	        },
	        failure: function (result) {
	            console.log('get feature on custom layer fail:' + result);
	        }
	    });
	};

	/**
	 *
	 * 获取自定义图层列表。
	 * @param callback
	 *
	 * return [
	 *          {
	 *            isShowLabel: 是否显示标注，始终未false,代表 不显示标注
	 *            layers:WMS可访问的图层
	 *            layerName:自定义图层的名称
	 *            fieldName:待查询的字段名称
	 *            mapName:后台WMS服务的实例名称
	 *          }
	 *      ]
	 */
	var getLayerInfo = function (callback) {
	    $.postJSON({
	        url: constant.CustomQuery.GET_LAYER_INFO,
	        data: null,
	        success: function (_result) {
	            var result = JSON.parse(_result);
	            if (!!result && result.State.resultCode === 0) {
	                var _datas = result.datas;

	                if (!!_datas) {
	                    if (!!callback && typeof callback === 'function') {
	                        callback(_datas);
	                    }
	                }
	            }
	        },
	        failure: function (result) {
	            console.log('get custom layers fail:' + result);
	        }
	    });
	};

	/**
	 * 通用点线面图层列表
	 * @param callback
	 */
	var commonLayerInfo = function (callback) {
	    $.get({
	        url: constant.CustomQuery.GET_COMMON_LAYER_INFO,
	        data: null,
	        success: function (_result) {
	            var result = JSON.parse(_result);
	            if (!!result && result.status.code === 1) {

	                if (!!result.data) {
	                    if (!!callback && typeof callback === 'function') {
	                        callback(result.data);
	                    }
	                }
	            }
	        },
	        failure: function (result) {
	            console.log('get common layers fail:' + result);
	        }
	    });
	};

	/**
	 * 获取通用点线面、公参、polygon图层你上的元素
	 * @param callback
	 */
	var getFeatureInCommonLayer = function (param) {
	    var callback = param.callback;
	    $.postJSON({
	        url: constant.CustomQuery.GET_FEATURE_IN_COMMON_LAYER,
	        data: JSON.stringify(param.requestParam),
	        success: function (_result) {
	            var result = JSON.parse(_result);
	            if (!!result && result.status.code === 1) {
	                var _data = result.data;

	                if (!!_data) {
	                    if (!!callback && typeof callback === 'function') {
	                        callback(_data);
	                    }
	                }
	            }
	        },
	        failure: function (result) {
	            console.log('get common layers fail:' + result);
	        }
	    });
	};

	module.exports = {
	    getLayerInfo: getLayerInfo,
	    getFeatureInfo: getFeatureInfo,
	    getCommonLayerInfo: commonLayerInfo,
	    getFeatureInCommonLayer: getFeatureInCommonLayer
	};

/***/ },
/* 128 */
/*!****************************************!*\
  !*** ./src/gis/framework/transform.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var constant = __webpack_require__(/*! framework/constant */ 2);

	function transform(paramObj) {
	    var _coordinate = paramObj.coordinate;
	    var _sourceProj = paramObj.sourceProj;
	    var _targetProj = paramObj.targetProj;

	    if (_coordinate.length === 4) {
	        return ol.proj.transformExtent(_coordinate, _sourceProj, _targetProj);
	    }
	    else if (_coordinate.length === 2) {
	        return ol.proj.transform(_coordinate, _sourceProj, _targetProj);
	    }
	    else {
	        return ol.proj.transform(_coordinate, _sourceProj, _targetProj);
	    }

	}

	function mapMaxExtent() {
	    return transform({
	        coordinate: [-180, -87, 180, 87],
	        sourceProj: constant.PROJ.EPSG_4326,
	        targetProj: constant.PROJ.EPSG_3857
	    });
	}

	module.exports = {
	    Transform: {
	        transform: transform
	    },
	    Extent: {
	        mapMaxExtent: mapMaxExtent
	    },
	    transform: transform

	};

/***/ },
/* 129 */
/*!***********************************!*\
  !*** ./src/gis/utils/searchUI.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	var domUtil = __webpack_require__(/*! utils/domUtil */ 10);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var $ = __webpack_require__(/*! utils/ajax */ 14);
	var util = __webpack_require__(/*! utils/util */ 1);
	var I18n = __webpack_require__(/*! utils/i18n */ 13);
	var createSearchUI = function (param) {
	    var mapId = param.mapId;
	    var targetElement = hashMap.get(mapId).getTargetElement();
	    var searchContainer = null;
	    //container
	    (function () {
	        searchContainer = targetElement.querySelector('.search');
	        var _positionRight = 80;
	        var _export = targetElement.querySelector('.export-image')
	            && targetElement.querySelector('.export-image').style.display;
	        var _mapType = targetElement.querySelector('.map-mode')
	            && targetElement.querySelector('.map-mode').style.display;
	        if (_export === 'block' || _mapType === 'block') {
	            _positionRight = 110;
	        }

	        if (_export === 'block' && _mapType === 'block') {
	            _positionRight = 140;
	        }

	        var _createContainer = function () {
	            searchContainer = domUtil.createDom({
	                tagName: 'div',
	                attributes: {
	                    id: mapId + '_search',
	                    class: 'search',
	                    style: 'right: ' + _positionRight + 'px'
	                }
	            });
	            targetElement.appendChild(searchContainer);
	        };

	        if (!!searchContainer) {
	            targetElement.removeChild(searchContainer);
	        }
	        _createContainer();
	        setTimeout(function () {
	            util.dragBox([mapId + '_search'], [mapId]);
	        });

	    }());

	    //header
	    (function () {
	        var _searchHead = domUtil.createDom({
	            tagName: 'div',
	            attributes: {
	                class: 'header'
	            },
	            text: I18n.prop('search.title')
	        });
	        searchContainer.appendChild(_searchHead);

	        //close button
	        var _closeBtn = domUtil.createDom({
	            tagName: 'div',
	            attributes: {
	                class: 'close-btn'
	            },
	            text: 'X'
	        });
	        _searchHead.appendChild(_closeBtn);
	        _closeBtn.onclick = function () {
	            targetElement.removeChild(searchContainer);
	        };
	    }());

	    //body
	    var _searchBody = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            class: 'body'
	        }
	    });
	    searchContainer.appendChild(_searchBody);

	    //tab
	    _createSwitchPanel(_searchBody);

	    //在线
	    (function () {
	        var _onlineContent = domUtil.createDom({
	            tagName: 'div',
	            attributes: {
	                class: 'content-online content'
	            }
	        });
	        _searchBody.appendChild(_onlineContent);

	        var _onlineContentHead = domUtil.createDom({
	            tagName: 'div',
	            attributes: {
	                class: 'header'
	            }
	        });
	        _onlineContent.appendChild(_onlineContentHead);

	        var _searchInput = domUtil.createDom({
	            tagName: 'input',
	            attributes: {
	                type: 'search'
	            }
	        });
	        _onlineContentHead.appendChild(_searchInput);
	        var _searchBtn = domUtil.createDom({
	            tagName: 'div',
	            attributes: {
	                class: 'searchBtn'
	            },
	            title: I18n.prop('search.click.search')
	        });
	        _onlineContentHead.appendChild(_searchBtn);

	        //搜索结果显示的列表
	        var searchResultContainer = domUtil.createDom({
	            tagName: 'div',
	            attributes: {
	                class: 'body'
	            }
	        });
	        _onlineContent.appendChild(searchResultContainer);

	        _searchBtn.onclick = function () {
	            searchResultContainer.innerHTML = '';
	            var searchEngine = (function () {
	                var _searchEngine = undefined;
	                var _mapObj = hashMap.get(mapId);
	                var _layers = _mapObj.getLayers();
	                var _baseLayer = _layers.item(0);
	                if (!!_baseLayer && !!_baseLayer.get('mapType')) {
	                    _searchEngine = _baseLayer.get('mapType');
	                }
	                return _searchEngine;
	            }());
	            var googleDiv = document.getElementById('$$customMap_' + mapId);
	            if (googleDiv) {
	                searchEngine = 'GOOGLE';
	            }
	            if (!!!searchEngine) {
	                searchResultContainer.innerHTML = I18n.prop('search.current.map.not.support');
	            }
	            else {
	                onlineSearch(mapId, searchContainer, searchResultContainer, searchEngine,
	                    _searchInput, param.imgUrl);
	            }
	        };
	    }());

	    //tab 切换，控制在线、离线显示隐藏
	    toggleMenu(_searchBody, searchContainer, function (_offlineContent) {
	        _offlineContent.innerHTML = '';
	        createLayerNameSelect(_offlineContent);
	        createLayerValueInput(mapId, searchContainer, _offlineContent);
	    });

	};

	/**
	 * 离线搜索页面，由后台查询图层
	 * @param _offlineContent
	 */
	function createLayerNameSelect(_offlineContent) {
	    var _createLayerOption = function (resultObjects) {
	        var layerNameSelect = _offlineContent.querySelector('.layer-name').querySelector('select');
	        resultObjects.forEach(function (object) {
	            layerNameSelect.appendChild((function () {
	                var _displayText = object.layerName;
	                return domUtil.createDom({
	                    tagName: 'option',
	                    attributes: {
	                        value: _displayText,
	                        title: _displayText
	                    },
	                    text: !!_displayText && _displayText.substring(0, 30)
	                })
	            }()));
	        });
	    };

	    var resultObjects = [];

	    //场景一：自定义图层
	    /*fusiongis.CustomQuery.getLayerInfo(function (objs) {
	        _createLayerOption(objs);
	    });*/
	    //场景二：通用点线面,调用宇博的服务接口返回
	    fusiongis.CustomQuery.getCommonLayerInfo(function (objs) {
	        var tempObjs = [];
	        !!objs && objs.forEach(function (obj) {
	            tempObjs.push({
	                layerName: obj.name
	            });
	        });
	        _createLayerOption(tempObjs);
	    });

	    //场景三 cellsite、Polygon
	    (function () {
	        resultObjects = resultObjects.concat([
	            {
	                layerName: 'layer_name_empty_'
	            },
	            {
	                layerName: 'layer_name_site_'
	            },
	            {
	                layerName: 'layer_name_cell_'
	            },
	            {
	                layerName: 'layer_name_polygon_'
	            }
	        ]);
	    }());

	    var _layerNameDiv = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            class: 'layer-name'
	        }
	    });
	    _offlineContent.appendChild(_layerNameDiv);
	    _layerNameDiv.appendChild((function () {
	        return domUtil.createDom({
	            tagName: 'span',
	            text: I18n.prop('search.layerName') + '：'
	        });
	    }()));

	    _layerNameDiv.appendChild((function () {
	        var _layerNameSelect = domUtil.createDom({
	            tagName: 'select',
	            attributes: {
	                name: 'layerName'
	            }
	        });

	        resultObjects.forEach(function (object) {
	            _layerNameSelect.appendChild((function () {
	                var _displayText = object.layerName;
	                if (_displayText === 'layer_name_site_') {
	                    _displayText = I18n.prop('search.site');
	                }
	                else if (_displayText === 'layer_name_cell_') {
	                    _displayText = I18n.prop('search.cell');
	                }
	                else if (_displayText === 'layer_name_polygon_') {
	                    _displayText = I18n.prop('search.systemPolygon');
	                }
	                else if (_displayText === 'layer_name_empty_') {
	                    _displayText = '--' + I18n.prop('search.choose') + '--';
	                }
	                return domUtil.createDom({
	                    tagName: 'option',
	                    attributes: {
	                        value: object.layerName
	                    },
	                    text: _displayText
	                })
	            }()));
	        });

	        return _layerNameSelect;
	    }()));

	    var select = _layerNameDiv.querySelector('select');
	    if (!!select) {
	        select.onchange = function () {
	            createLayerAttrSelect(_offlineContent, this.value);
	        }
	    }
	}

	/**
	 * 离线搜索页面，由后台查询,当前图层的所有属性
	 * @param _offlineContent
	 */
	function createLayerAttrSelect(_offlineContent, layerName) {
	    var _layerAttrDiv = _offlineContent.querySelector('.layer-attr');
	    var _layerValueDiv = _offlineContent.querySelector('.layer-val');
	    if (!!!_layerAttrDiv) {
	        _layerAttrDiv = domUtil.createDom({
	            tagName: 'div',
	            attributes: {
	                class: 'layer-attr'
	            }
	        });
	        _offlineContent.insertBefore(_layerAttrDiv, _layerValueDiv);
	    }
	    _layerAttrDiv.innerHTML = '';

	    _layerAttrDiv.appendChild((function () {
	        return domUtil.createDom({
	            tagName: 'span',
	            text: I18n.prop('search.propertyName') + '：'
	        });
	    }()));

	    (function () {
	        var _layerAttrSelect = domUtil.createDom({
	            tagName: 'select',
	            attributes: {
	                name: 'layerAttr'
	            }
	        });
	        _layerAttrDiv.appendChild(_layerAttrSelect);

	        var _createSelect = function (attributes) {
	            attributes.forEach(function (value, index) {
	                var optionNode = domUtil.createDom({
	                    tagName: 'option',
	                    attributes: {
	                        value: value
	                    },
	                    text: value
	                });
	                _layerAttrSelect.appendChild(optionNode);
	            });
	        };

	        if (layerName === 'layer_name_site_'
	            || layerName === 'layer_name_cell_'
	            || layerName === 'layer_name_polygon_') {

	            //通用点线面
	            _createSelect(['id', 'name']);
	        }
	        else {
	            //todo
	            //1、宇博的服务
	            $.postJSON({
	                url: constant.CustomQuery.GET_ATTR_IN_COMMON_LAYER,//'/spatialdata/v1/queryFieldsInfo'
	                data: JSON.stringify({
	                    featureClassName: layerName
	                }),
	                success: function (_result) {
	                    var result = JSON.parse(_result);
	                    if (!!result && result.status.code === 1) {
	                        var _data = result.data;
	                        if (!!_data) {
	                            var columnNames = [];
	                            _data.forEach(function (data) {
	                                columnNames.push(data.columnName);
	                            });

	                            _createSelect(columnNames);
	                        }
	                    }
	                },
	                failure: function (result) {
	                    console.warn('get attribute in layer failed: ' + result);
	                }
	            });

	            //2、调用顺朝的服务
	            /*$.postJSON({
	                url: constant.CustomQuery.GET_ATTR_INFO,///customMap.do
	                data: JSON.stringify({
	                    services: [
	                        {
	                            name: "getCustomLayersInfo",//参数固定
	                            param: {}
	                        }
	                    ]
	                }),
	                success: function (_result) {
	                    var result = JSON.parse(_result);
	                    if (!!result && result.status.code === 1) {
	                        var _data = result.data;
	                        if (!!_data && !!_data.layers) {
	                            var attributes = [];
	                            _data.layers.forEach(function (dataObject) {
	                                if (!!dataObject && layerName === dataObject.layerName) {
	                                    if (!!dataObject.defualtField) {
	                                        attributes.push(dataObject.defualtField);
	                                    }
	                                }
	                            });

	                            _createSelect(attributes);
	                        }
	                    }
	                },
	                failure: function (result) {
	                    console.warn('get attribute in layer failed: ' + result);
	                }
	            });*/
	        }

	    }());
	}

	/**
	 *  @param mapId
	 * @param searchContainer
	 * @param _offlineContent
	 */
	function createLayerValueInput(mapId, searchContainer, _offlineContent) {
	    var _layerValueDiv = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            class: 'layer-val'
	        }
	    });
	    _offlineContent.appendChild(_layerValueDiv);
	    _layerValueDiv.appendChild((function () {
	        return domUtil.createDom({
	            tagName: 'span',
	            text: I18n.prop('search.propertyValue') + '：'
	        });
	    }()));
	    var filterNameNode = domUtil.createDom({
	        tagName: 'input',
	        attributes: {
	            type: 'search'
	        }
	    });
	    _layerValueDiv.appendChild(filterNameNode);
	    _layerValueDiv.appendChild((function () {
	        var searchBtn = domUtil.createDom({
	            tagName: 'div',
	            attributes: {
	                class: 'searchBtn'
	            }
	        });

	        searchBtn.onclick = function () {
	            if (!!!filterNameNode.value) {
	                console.warn('Search box does not contain a null value!!!');
	                return false;
	            }
	            var layerName = _offlineContent.querySelector('.layer-name').querySelector('select').value;
	            var layerAttr = _offlineContent.querySelector('.layer-attr').querySelector('select').value;
	            var featureList = searchContainer.querySelector('.featureList');

	            if (!!featureList) {
	                searchContainer.removeChild(featureList);
	            }

	            var _featureList = domUtil.createDom({
	                tagName: 'div',
	                attributes: {
	                    class: 'featureList'
	                }
	            });
	            searchContainer.appendChild(_featureList);
	            var _head = domUtil.createDom({
	                tagName: 'div',
	                attributes: {
	                    class: 'head'
	                },
	                text: I18n.prop('search.elementList')
	            });
	            _featureList.appendChild(_head);

	            var _closeBtn = domUtil.createDom({
	                tagName: 'div',
	                attributes: {
	                    class: 'close'
	                },
	                text: 'X'
	            });
	            _head.appendChild(_closeBtn);
	            _closeBtn.onclick = function () {
	                searchContainer.removeChild(_featureList);
	            };

	            var _content = domUtil.createDom({
	                tagName: 'div',
	                attributes: {
	                    class: 'content'
	                }
	            });
	            _featureList.appendChild(_content);

	            //谢顺朝自定义搜索结果
	            /*fusiongis.CustomQuery.getFeatureInfo({
	                requestParam: {
	                    loadAll: true,
	                    nameFilter: filterNameNode.value,
	                    criteria: layerName,
	                    start: 0,
	                    limit: 50
	                },
	                callback: function (datas) {

	                    !!datas && datas.forEach(function (oneData) {
	                        var _id = oneData.data.gid;
	                        var _name = oneData.name;

	                        var _displayText = '';
	                        if (!!_name && !!_id) {
	                            _displayText = _name + ' ' + _id;
	                        }
	                        else if (!!_name && !!!_id) {
	                            _displayText = _name;
	                        }
	                        else if (!!!_name && !!_id) {
	                            _displayText = _id;
	                        }
	                        var _coordinate = oneData.data.points.toString();

	                        var _oneRecord = domUtil.createDom({
	                            tagName: 'div',
	                            attributes: {
	                                id: _id,
	                                coordinate: _coordinate,
	                                title: _displayText
	                            },
	                            text: _displayText
	                        });
	                        _content.appendChild(_oneRecord);
	                        _clickSearchResultEvent(mapId, _oneRecord);
	                    });
	                }
	            });*/

	            //场景二通用点线面、公参、polygon,雨博
	            fusiongis.CustomQuery.getFeatureInCommonLayer({
	                requestParam: {
	                    featureClassName: layerName,
	                    columnName: layerAttr,
	                    value: [filterNameNode.value],
	                    operator: 'like'
	                },
	                callback: function (data) {
	                    if (!!data && !!data.fcObjectList) {
	                        var _fcObjectList = data.fcObjectList;
	                        _fcObjectList.forEach(function (fcObject) {
	                            if (!!!fcObject) {
	                                return false;
	                            }
	                            //gid
	                            var _id = fcObject.fcObjectId || fcObject.attributeList.SECTOREQMKEY || fcObject.attributeList.gid
	                                || fcObject.attributeList.POLYGONID
	                                || fcObject.attributeList.SITEKEY
	                                || fcObject.attributeList.BTSNAME;
	                            var _name = fcObject.attributeList && fcObject.attributeList.name
	                                || fcObject.attributeList.CELLNAME
	                                || fcObject.attributeList.POLYGONNAME
	                                || fcObject.attributeList.NOdEBNAME
	                                || fcObject.attributeList.ENODEBNAME
	                                || fcObject.attributeList.BTSNAME;

	                            var _displayText = '';
	                            if (!!_name && !!_id) {
	                                _displayText = _name + ' ' + _id;
	                            }
	                            else if (!!_name && !!!_id) {
	                                _displayText = _name;
	                            }
	                            else if (!!!_name && !!_id) {
	                                _displayText = _id;
	                            }

	                            var _geometry = util.htmlDecode(fcObject.geometry);
	                            var _geomAttr = (function () {
	                                var _wktFeature = util.getWKTFromText(_geometry);
	                                var coordinateList = _wktFeature.coordinates;
	                                var geomType = _wktFeature.geoType;
	                                return {
	                                    coordinate: coordinateList,
	                                    geomType: geomType
	                                };
	                            }());

	                            var _oneRecord = domUtil.createDom({
	                                tagName: 'div',
	                                attributes: {
	                                    id: _id,
	                                    coordinate: _geomAttr.coordinate,
	                                    geomType: _geomAttr.geomType,
	                                    title: _displayText
	                                },
	                                text: _displayText
	                            });
	                            _content.appendChild(_oneRecord);
	                            _clickSearchResultEvent(mapId, _oneRecord);
	                        });
	                    }
	                }
	            })
	        };

	        return searchBtn;
	    }()));
	}

	/**
	 *
	 * @param mapId
	 * @param eventTarget
	 * @private
	 */
	function _clickSearchResultEvent(mapId, eventTarget) {
	    if (!!eventTarget) {
	        eventTarget.onclick = function (e) {
	            e.stopPropagation();
	            var _strCoordinate = eventTarget.getAttributeNode('coordinate').value;
	            var _geomType = eventTarget.getAttributeNode("geomtype").value;
	            if (!!!_strCoordinate) {
	                return false;
	            }
	            var _x = 0;
	            var _y = 0;
	            if (_strCoordinate.indexOf('[[') !== -1 && _strCoordinate.indexOf(']]') !== -1) {
	                var _tempStrCoordinate = _strCoordinate.substring(2, _strCoordinate.length - 2);
	                if (_tempStrCoordinate.indexOf('],[')) {
	                    var _tempArrayCoordinate = _tempStrCoordinate.split('],[');
	                    var _coordinates = _tempArrayCoordinate[0].split(',');
	                    _x = parseFloat(_coordinates[0]);
	                    _y = parseFloat(_coordinates[1]);
	                }
	                else {
	                    var _coordinates = _tempStrCoordinate.split(',');
	                    _x = parseFloat(_coordinates[0]);
	                    _y = parseFloat(_coordinates[1]);
	                }

	                if (!!_x && !!_y) {
	                    fusiongis.Map.setMapCenter({
	                        mapId: mapId,
	                        coordinate: [_x, _y],
	                        zoom: (!!_geomType && _geomType === 'Point') ? 17 : undefined
	                    });
	                }
	            }
	            else {
	                if (_strCoordinate.indexOf(',') != -1) {
	                    var _coordinates = _strCoordinate.split(',');
	                    var _x = parseFloat(_coordinates[0]);
	                    var _y = parseFloat(_coordinates[1]);
	                    if (!!_x && !!_y) {
	                        fusiongis.Map.setMapCenter({
	                            mapId: mapId,
	                            coordinate: [_x, _y],
	                            zoom: (!!_geomType && _geomType === 'Point') ? 17 : undefined
	                        });
	                    }
	                }
	            }

	        }
	    }
	}

	/**
	 *
	 * @param _searchBody
	 * @param searchContainer
	 * @param loadDataAndMakeOffLine {function}
	 */
	function toggleMenu(_searchBody, searchContainer, loadDataAndMakeOffLine) {
	    var tabItems = searchContainer.querySelectorAll('.tab-item');

	    var toggleShow = function (show, hide) {
	        if (!!searchContainer.querySelector(show)) {
	            searchContainer.querySelector(show).style.display = 'block';
	        }

	        if (!!searchContainer.querySelector(hide)) {
	            searchContainer.querySelector(hide).style.display = 'none';
	        }
	    };

	    for (var i = 0; i < tabItems.length; i++) {
	        var tabItem = tabItems[i];

	        tabItem.onclick = function () {
	            var tabItemClassList = this.classList;
	            if (tabItemClassList[0] === 'tab-online') {
	                toggleShow('.content-online', '.content-offline');
	            }
	            else if (tabItemClassList[0] === 'tab-offline') {
	                var _offlineContent = _searchBody.querySelector('.content-offline');
	                if (!!!_offlineContent) {
	                    _offlineContent = domUtil.createDom({
	                        tagName: 'div',
	                        attributes: {
	                            class: 'content-offline content'
	                        }
	                    });
	                    _searchBody.appendChild(_offlineContent);
	                }

	                loadDataAndMakeOffLine(_offlineContent);

	                toggleShow('.content-offline', '.content-online');
	            }
	        };
	    }
	}

	function onlineSearch(mapId, searchContainer, searchResultContainer, searchEngine, _searchInput, imgUrl) {
	    fusiongis.Search.searchLocal({
	        serviceVendor: searchEngine,
	        address: _searchInput.value,
	        key: window.sessionStorage ? sessionStorage.getItem("key") : Cookie.read("key"),
	        callback: function (results) {
	            !!results && results.forEach(function (result) {
	                var _centerLonLat = result.centerLonLat;
	                var _displayName = result.displayName;
	                var _extent = result.bbox;

	                var _oneRecord = domUtil.createDom({
	                    tagName: 'div',
	                    attributes: {
	                        title: _displayName
	                    },
	                    text: _displayName.substring(0, 25) + '...'
	                });

	                searchResultContainer.appendChild(_oneRecord);

	                _oneRecord.onclick = function () {
	                    //Set the map center
	                    if (_extent.length) {
	                        fusiongis.Map.setExtent({
	                            mapId: mapId,
	                            extent: _extent
	                        });
	                    }
	                    else {
	                        fusiongis.Map.setMapCenter({
	                            coordinate: _centerLonLat,
	                            zoom: 10,
	                            mapId: mapId
	                        });
	                    }
	                    // add marker on map
	                    fusiongis.Search.clearMarker(mapId);
	                    fusiongis.Search.addMarker({
	                        mapId: mapId,
	                        coordinate: _centerLonLat,
	                        imgUrl: imgUrl || fusiongis.Constant.GisResourceURL + 'search/search-result-icon.png'
	                    });

	                    searchContainer.style.display = 'none';
	                };
	            });
	        }
	    });
	}

	/**
	 * 界面->切换按钮
	 * @param _searchBody
	 * @private
	 */
	function _createSwitchPanel(_searchBody) {
	    _searchBody.appendChild((function () {
	        var _tab = domUtil.createDom({
	            tagName: 'div',
	            attributes: {
	                class: 'tab'
	            }
	        });

	        _tab.appendChild((function () {
	            return domUtil.createDom({
	                tagName: 'div',
	                attributes: {
	                    class: 'tab-online tab-item',
	                    style:'cursor: pointer;'
	                },
	                text: I18n.prop('search.online')
	            });
	        }()));

	        _tab.appendChild((function () {
	            return domUtil.createDom({
	                tagName: 'div',
	                attributes: {
	                    class: 'border'
	                }
	            });
	        }()));

	        _tab.appendChild((function () {
	            return domUtil.createDom({
	                tagName: 'div',
	                attributes: {
	                    class: 'tab-offline tab-item',
	                    style:'cursor: pointer;'
	                },
	                text: I18n.prop('search.offline')
	            });
	        }()));

	        return _tab;
	    }()));
	}

	module.exports = {
	    createSearchUI: createSearchUI
	};

/***/ },
/* 130 */
/*!**************************************************!*\
  !*** ./src/gis/businessLayers/serviceHeatMap.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var createLayer = function (paramObj) {
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId;
	    var _layerIdentify = _layerId + '_' + _mapId;
	    var _mapObj = mapBox.getMapObj(_mapId);
	    var _zoom = _mapObj.getView().getZoom();
	    var _label = !!!paramObj.label?paramObj.layerId:paramObj.label;
	    var _layer = null;

	    if (!!!hashMap.get(_layerIdentify)) {
	        _layer = new ol.layer.Image({
	            opacity: paramObj.opacity || 0.7
	        });

	        _layer.set('layerId', _layerId);
	        _layer.set('mapId', _mapId);
	        _layer.set('businessType', constant.BUSINESSTYPE.HEAT_MAP);
	        _layer.set('isVectorType',false);
	        _layer.set('params.label', _label);
	        _mapObj.addLayer(_layer);
	        hashMap.put(_layerIdentify, _layer);
	    }
	    else {
	        _layer = hashMap.get(_layerIdentify);
	    }
	    if (paramObj.minShowLevel != undefined) {
	        _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	    }

	    if (paramObj.maxShowLevel != undefined) {
	        _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	    }

	    return _layer;
	};

	var loadImage = function (_mapId) {
	    var url = 'https://127.0.0.1:11251/fusiongis';
	    url = url + '/heatmap.do';
	    var _mapObj = mapBox.getMapObj(_mapId);
	    var extent = mapBox.getExtent(_mapId);
	    var minPoint = [extent[0], extent[1]];
	    var maxPoint = [extent[2], extent[3]];
	    var min = ol.proj.toLonLat(minPoint);
	    var max = ol.proj.toLonLat(maxPoint);

	    var size = _mapObj.getSize();
	    url = url + '?' + 'SERVICE=WMS&VERSION=1.1.1&REQUEST=GetMap&FORMAT=image%2Fpng&TRANSPARENT=true&'
	        + 'minx=' + min[0] + '&miny=' + min[1] + '&maxx=' + max[0] + '&maxy=' + max[1]
	        + '&width=' + size[0] + '&height=' + size[1]
	        + '&featureClassName=m49ed41dd3c2b4b6ab03baed853e7a2fc_places';
	    return url;
	};

	var addServiceHeatMap = function (paramObj) {
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId;
	    var _layerIdentify = _layerId + '_' + _mapId;
	    var _layer = hashMap.get(_layerIdentify);
	    var _mapObj = mapBox.getMapObj(_mapId);
	    var _source = null;
	    var url = loadImage(_mapId);

	    _source = new ol.source.ImageStatic({
	        projection: 'EPSG:3857',
	        url: url,
	        imageExtent: mapBox.getExtent(_mapId)
	    });
	    !!_layer && _layer.setSource(_source);

	    _mapObj.on('moveend', function () {
	        var url = loadImage(_mapId);

	        _source = new ol.source.ImageStatic({
	            projection: 'EPSG:3857',
	            url: url,
	            imageExtent: mapBox.getExtent(_mapId)
	        });
	        !!_layer && _layer.setSource(_source);
	    });

	    var view = _mapObj.getView();
	    view.on('change:resolution', function () {
	        var url = loadImage(_mapId);

	        _source = new ol.source.ImageStatic({
	            projection: 'EPSG:3857',
	            url: url,
	            imageExtent: mapBox.getExtent(_mapId)
	        });
	        !!_layer && _layer.setSource(_source);
	    })

	};
	module.exports = {
	    createLayer: createLayer,
	    addLayer: createLayer,
	    addServiceHeatMap: addServiceHeatMap,
	    setLayerData: addServiceHeatMap
	};

/***/ },
/* 131 */
/*!*****************************************!*\
  !*** ./src/gis/transformation/union.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 取并集
	 */
	var ol = __webpack_require__(/*! ol */ 4);

	var _makeupFeature = function (coordinates) {
	    if (!!!coordinates) {
	        return false;
	    }
	    else {
	        if (coordinates[0].length > 0) {
	            if (coordinates[0][0][0] !== coordinates[0][coordinates[0].length - 1][0]
	                && coordinates[0][0][1] !== coordinates[0][coordinates[0].length - 1][1]) {
	                coordinates[0].push(coordinates[0][0]);
	            }
	        }
	    }
	    var feature = {
	        "type": "Feature",
	        "properties": {
	            "fill": "#00f"
	        },
	        "geometry": {
	            "type": "Polygon",
	            "coordinates": coordinates
	        }
	    };

	    return feature;
	};
	/**
	 * 合并多边形
	 */
	var getUnionPolygonCoordinates = function (polygon1, polygon2) {
	    var _polygon1 = _makeupFeature(polygon1);
	    var _polygon2 = _makeupFeature(polygon2);
	    var unionPolygon = turf.union(_polygon1, _polygon2);

	    if (!!unionPolygon && unionPolygon.geometry) {
	        var _geometry = unionPolygon.geometry;
	        return {
	            type: _geometry.type,
	            coordinates: (function () {
	                if (_geometry.type === 'Polygon') {
	                    return _geometry.coordinates[0];
	                }
	                else if (_geometry.type === 'MultiPolygon') {
	                    return _geometry.coordinates;
	                }
	            }())
	        };
	    }
	    else {
	        return {};
	    }
	};

	module.exports = {
	    getUnionPolygonCoordinates: getUnionPolygonCoordinates
	};

/***/ },
/* 132 */
/*!*********************************************!*\
  !*** ./src/gis/transformation/intersect.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 取交集
	 */


	var ol = __webpack_require__(/*! ol */ 4);

	var _makeupFeature = function (coordinates) {
	    if (!!!coordinates) {
	        return false;
	    }
	    else {
	        if (coordinates[0].length > 0) {
	            if (coordinates[0][0][0] !== coordinates[0][coordinates[0].length - 1][0]
	                && coordinates[0][0][1] !== coordinates[0][coordinates[0].length - 1][1]) {
	                coordinates[0].push(coordinates[0][0]);
	            }
	        }
	    }
	    var feature = {
	        "type": "Feature",
	        "properties": {
	            "fill": "#00f"
	        },
	        "geometry": {
	            "type": "Polygon",
	            "coordinates": coordinates
	        }
	    };

	    return feature;
	};
	/**
	 * 多边形取交
	 */
	var getIntersectPolyCoordinates = function (polygon1, polygon2) {
	    var _polygon1 = _makeupFeature(polygon1);
	    var _polygon2 = _makeupFeature(polygon2);
	    var _intersectPolygonFeature = turf.intersect(_polygon1, _polygon2);

	    if (!!_intersectPolygonFeature && !!_intersectPolygonFeature.geometry) {
	        var _geometry = _intersectPolygonFeature.geometry;
	        return {
	            type: _geometry.type,
	            coordinates: (function () {
	                if (_geometry.type === 'Point') {
	                    return _geometry.coordinates
	                }
	                else if (_geometry.type === 'Polygon') {
	                    return _geometry.coordinates[0];
	                }
	            }())
	        };
	    }
	    else {
	        return {};
	    }
	};

	module.exports = {
	    getIntersectPolyCoordinates: getIntersectPolyCoordinates
	};

/***/ },
/* 133 */
/*!**********************************************!*\
  !*** ./src/gis/transformation/difference.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 取差异
	 */


	var ol = __webpack_require__(/*! ol */ 4);

	var _makeupFeature = function (coordinates) {
	    if (!!!coordinates) {
	        return false;
	    }
	    else {
	        if (coordinates[0].length > 0) {
	            if (coordinates[0][0][0] !== coordinates[0][coordinates[0].length - 1][0]
	                && coordinates[0][0][1] !== coordinates[0][coordinates[0].length - 1][1]) {
	                coordinates[0].push(coordinates[0][0]);
	            }
	        }
	    }
	    var feature = {
	        "type": "Feature",
	        "properties": {
	            "fill": "#00f"
	        },
	        "geometry": {
	            "type": "Polygon",
	            "coordinates": coordinates
	        }
	    };

	    return feature;
	};
	/**
	 * 多边形取差异
	 */
	var getDiffPolyCoordinates = function (polygon1, polygon2) {
	    var _polygon1 = _makeupFeature(polygon1);
	    var _polygon2 = _makeupFeature(polygon2);
	    var _differencePolygonFeature = turf.difference(_polygon1, _polygon2);

	    if (!!_differencePolygonFeature && !!_differencePolygonFeature.geometry) {
	        var _geometry = _differencePolygonFeature.geometry;
	        return {
	            type: _geometry.type,
	            coordinates: _geometry.coordinates
	        };
	    }
	    else {
	        return {};
	    }
	};

	module.exports = {
	    getDiffPolyCoordinates: getDiffPolyCoordinates
	};

/***/ },
/* 134 */
/*!****************************************!*\
  !*** ./src/gis/tools/secondaryMesh.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);

	/**
	 *
	 * @param param
	 * param = {
	 *      mapId: ''
	 * }
	 */

	var addGrid =function(param) {
	    var _mapId =  param.mapId;
	    var _distance = 1000000;
	    if (param.distance != undefined) {
	        var distance_ = parseInt(param.distance);
	        if (distance_ >= 500) {
	            _distance = distance_;
	        }
	        else {
	            console.warn('the distance must greater than or equal to 500!!!');
	        }
	    }
	    var _lineColor = param.lineColor ? param.lineColor : [0,100,250,0.6];
	    var _lineWidth = param.lineWidth ? param.lineWidth : 1.5;
	    var _lineDash= param.lineDash ? param.lineDash : [2,5];
	    var _mapObj = mapBox.getMapObj(_mapId);//根据地图id获取地图对象
	    var source = new ol.source.Vector({wrapX:false});
	    //定义矢量图层
	    var layer = new ol.layer.Vector({
	        id: 'myLayer',
	        source: source
	    });
	    layer.set('id','myLayer');
	    _mapObj.addLayer(layer);
	    var x_half=ol.proj.fromLonLat([180,0])[0];
	    var y_half=ol.proj.fromLonLat([0,85])[1];
	    var x_distance=2 * x_half;
	    var y_distance=2 * y_half;
	    var x_lineCounts=Math.round(y_distance/_distance);
	    var y_lineCounts=Math.round(x_distance/_distance);
	    var lineStyle=new ol.style.Style({
	        stroke:new ol.style.Stroke({
	            width:_lineWidth,
	            color:_lineColor,
	            lineDash:_lineDash
	        })
	    });
	    var features = [];
	    //划横线
	    var lineFeature = {};
	    for (var i = 0; i <= x_lineCounts; i++) {
	        lineFeature = new ol.Feature();
	        lineFeature.setGeometry(new ol.geom.LineString([
	            [-x_half, -y_half + _distance * i],
	            [x_half, -y_half + _distance * i]
	        ]));
	        lineFeature.setStyle(lineStyle);
	        features.push(lineFeature);
	    }
	    //划竖线
	    for (var i = 0; i <= y_lineCounts; i++) {
	        lineFeature = new ol.Feature();
	        lineFeature.setGeometry(new ol.geom.LineString([
	            [-x_half + _distance * i, y_half],
	            [-x_half + _distance * i, -y_half]
	        ]));
	        lineFeature.setStyle(lineStyle);
	        features.push(lineFeature);
	    }
	    layer.getSource().addFeatures(features);
	    _mapObj.set('state', true);
	};

	var removeGrid = function (param) {
	    var _mapId = param.mapId;
	    var _mapObj = mapBox.getMapObj(_mapId);
	    var layerCollection = _mapObj.getLayers();
	    layerCollection.forEach(function(e){
	        if(e.get('id')== "myLayer"){
	            _mapObj.removeLayer(e);
	            _mapObj.set('state', false);
	        }
	    })
	}

	function toggleGrid(param) {
	    var _mapId = param.mapId;
	    var _mapObj = mapBox.getMapObj(_mapId);
	    var active = _mapObj.get('state');
	    if (active) {
	        removeGrid(param);
	    }
	    else {
	        addGrid(param);
	    }

	}

	module.exports = {
	    addGrid: addGrid,
	    removeGrid: removeGrid,
	    toggleGrid: toggleGrid
	};

/***/ },
/* 135 */
/*!****************************************!*\
  !*** ./src/gis/tools/intersectSelf.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);

	/**
	 *
	 * @param param
	 * param = {
	 *      mapId: ''
	 *      points:[]
	 * }
	 */
	var judgeConnection=function(param){
	    var _mapId =  param.mapId;
	    var _points = param.points
	    var source=new ol.source.Vector({wrapX:false});
	    var layer=new ol.layer.Vector({
	        source:source
	    });
	    var featrues=[];
	    var polyFeature=new ol.Feature();
	    var len=_points.length;
	    //将经纬度坐标转化为“EPSG:3826”坐标
	    for(var i=0;i<len;i++){
	        _points[i]=ol.proj.fromLonLat(_points[i]);
	    }
	    var _polygon=new ol.geom.Polygon([_points]);
	    var polyStyle=new ol.style.Style({
	        stroke: new ol.style.Stroke({
	            width: 1.5,
	            color: [255,255,0,1.0]
	        }),
	        fill: new ol.style.Fill({
	            color: [0,255,0,0.7]
	        })
	    });
	    polyFeature.setGeometry(_polygon);
	    polyFeature.setStyle(polyStyle);
	    featrues.push(polyFeature);
	    source.addFeatures(featrues);
	    var _mapObj = mapBox.getMapObj(_mapId);//根据地图id获取地图对象
	    _mapObj.addLayer(layer);
	    if((len>=4) && (_points[0][0] === _points[len-1][0]) && (_points[0][1] === _points[len-1][1])){
	        for(var i=1;i<len-2;i++){
	            for(var j=i+1;j<len-1;j++){
	                if((_points[i][0] === _points[j][0]) && (_points[i][1] === _points[j][1])){
	                    console.log('该多边形自相交');
	                    return;
	                }
	            }
	            if(i==len-3){
	                console.log('该多边形不自相交');
	            }
	        }
	    }
	}

	module.exports = {
	    judgeConnection: judgeConnection
	};

/***/ },
/* 136 */
/*!******************************************!*\
  !*** ./src/gis/utils/analysisGeoJson.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	/**
	 * 将GeoJson数据解析成包含各个feature对象的数组
	 */

	 function getDataByGeoJson(geojsonObj){
	    var features=new ol.format.GeoJSON().readFeatures(geojsonObj);
	    var name,type,coordinates,id,featureObj;
	    var featureGather=[];
	    for(var i=0;i<features.length;i++){
	        id=features[i].getId();
	        name=features[i].getProperties().name;
	        type=features[i].getGeometry().getType();
	        coordinates=features[i].getGeometry().getCoordinates();
	        featureObj={
	            id:id,
	            name:name,
	            type:type,
	            coordinates:coordinates[0]
	        }
	        featureGather.push(featureObj);
	    }
	    return featureGather;
	}
	module.exports={
	    getDataByGeoJson:getDataByGeoJson
	}

/***/ },
/* 137 */
/*!******************************************!*\
  !*** ./src/gis/transformation/buffer.js ***!
  \******************************************/
/***/ function(module, exports) {

	

/***/ },
/* 138 */
/*!*******************************!*\
  !*** ./src/gis/tools/drag.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var app = {};


	/**
	 * @constructor
	 * @extends {ol.interaction.Pointer}
	 */
	app.Drag = function(param) {
	    this.handleDownEvent = param.handleDownEvent;
	    this.handleDragEvent = param.handleDragEvent;
	    this.handleMoveEvent = param.handleMoveEvent;
	    this.handleUpEvent = param.handleUpEvent;
	    this.cursor_ = param.cursor || 'pointer';
	    this.type = param.type;
	    this.featureId = param.featureId;
	    this.isDragBox=false;
	    this.feature_a=null;
	    this.mapObj = mapBox.getMapObj(param.mapId);
	    ol.interaction.Pointer.call(this, {
	        handleDownEvent: app.Drag.prototype.handleDownEvent,
	        handleDragEvent: app.Drag.prototype.handleDragEvent,
	        handleMoveEvent: app.Drag.prototype.handleMoveEvent,
	        handleUpEvent: app.Drag.prototype.handleUpEvent
	    });

	    /**
	     * @type {ol.Pixel}
	     * @private
	     */
	    this.coordinate_ = null;
	    /**
	     * @type {ol.Feature}
	     * @private
	     */
	    this.feature_ = null;

	    /**
	     * @type {string|undefined}
	     * @private
	     */
	    this.previousCursor_ = undefined;

	};
	ol.inherits(app.Drag, ol.interaction.Pointer);


	/**
	 * @param {ol.MapBrowserEvent} evt Map browser event.
	 * @return {boolean} `true` to start the drag sequence.
	 */
	app.Drag.prototype.handleDownEvent = function(evt) {
	    var map = evt.map;
	    this.isDragBox=false;
	    this.feature_a=null;
	    var feature = map.forEachFeatureAtPixel(evt.pixel, function(feature) {
	        return feature;
	    });
	    this.mapObj.forEachFeatureAtPixel(evt.pixel, function (feature) {
	        if(!!feature&&feature.getId()===this.featureId){
	            this.isDragBox=true;
	            this.feature_a=feature;
	        }
	    }.bind(this))
	    if (feature) {
	        this.coordinate_ = evt.coordinate;
	        this.feature_ = feature;
	    }
	    if(this.feature_.getId().indexOf('upDown')!==-1&&!!this.isDragBox&&!!this.feature_a){
	        this.feature_ = this.feature_a;
	    }
	    if(this.handleDownEvent && typeof this.handleDownEvent === 'function'){
	    	if (feature == undefined) {
	    		this.handleDownEvent({});
	    	}
	    	else {
	    		this.handleDownEvent({
	    		    evt:evt,
	    		    feature:feature,
	    		    data: feature.get('data'),
	    		    extent: ol.proj.transformExtent(feature.getGeometry().getExtent(), 'EPSG:3857', 'EPSG:4326')
	    		});
	    	}
	    }
	    return !!feature;

	};


	/**
	 * @param {ol.MapBrowserEvent} evt Map browser event.
	 */
	app.Drag.prototype.handleDragEvent = function(evt) {
		var map = evt.map;
	    var feature = map.forEachFeatureAtPixel(evt.pixel, function(feature) {
	        return feature;
	    });
	    if(this.featureId){
	        if(this.feature_.getId() === this.featureId){
	            var deltaX = evt.coordinate[0] - this.coordinate_[0];
	            var deltaY = evt.coordinate[1] - this.coordinate_[1];

	            var geometry = /** @type {ol.geom.SimpleGeometry} */
	                (this.feature_.getGeometry());
	            geometry.translate(deltaX, deltaY);
	            this.coordinate_[0] = evt.coordinate[0];
	            this.coordinate_[1] = evt.coordinate[1];
	            var layer = this.feature_.get('layer');
	            var id = this.feature_.getId();
	            if(layer){
	                var data = layer.get('datas');
	                if(data && data.length>0){
	                    for(var i= 0,len=data.length;i<len;i++){
	                        if(id === data[i].id){
	                            data[i].coordinate = ol.proj.toLonLat(evt.coordinate);
	                            break;
	                        }
	                    }
	                }
	            }
	            if(this.handleDragEvent && typeof this.handleDragEvent === 'function'){
	            	if (feature == undefined) {
	            		this.handleDragEvent({});	
	            	}
	            	else {
	            		this.handleDragEvent({
	            		    evt:evt,
	            		    feature:this.feature_,
	            		    data: this.feature_.get('data'),
	            		    extent: ol.proj.transformExtent(feature.getGeometry().getExtent(), 'EPSG:3857', 'EPSG:4326')
	            		});
	            	}
	            }
	        } else {
	            return false;
	        }
	    } else {
	        var deltaX = evt.coordinate[0] - this.coordinate_[0];
	        var deltaY = evt.coordinate[1] - this.coordinate_[1];

	        var geometry = /** @type {ol.geom.SimpleGeometry} */
	            (this.feature_.getGeometry());
	        geometry.translate(deltaX, deltaY);
	        var layer = this.feature_.get('layer');
	        var id = this.feature_.getId();
	        if(layer){
	            var data = layer.get('datas');
	            if(data && data.length>0){
	                for(var i= 0,len=data.length;i<len;i++){
	                    if(id === data[i].id){
	                        data[i].coordinate = ol.proj.toLonLat(evt.coordinate);
	                        break;
	                    }
	                }
	            }
	        }
	        this.coordinate_[0] = evt.coordinate[0];
	        this.coordinate_[1] = evt.coordinate[1];

	        if(this.handleDragEvent && typeof this.handleDragEvent === 'function'){
	            if (feature == undefined) {
	            		this.handleDragEvent({});	
	        	}
	        	else {
	        		this.handleDragEvent({
	        		    evt:evt,
	        		    feature:this.feature_,
	        		    data: this.feature_.get('data'),
	        		    extent: ol.proj.transformExtent(feature.getGeometry().getExtent(), 'EPSG:3857', 'EPSG:4326')
	        		});
	        	}
	        }
	    }

	};


	/**
	 * @param {ol.MapBrowserEvent} evt Event.
	 */
	app.Drag.prototype.handleMoveEvent = function(evt) {
	    if (this.cursor_) {
	        var map = evt.map;
	        var feature = map.forEachFeatureAtPixel(evt.pixel, function(feature) {
	            return feature;
	        });
	        var element = evt.map.getTargetElement();
	        if (feature) {
	            if (element.style.cursor != this.cursor_) {
	                this.previousCursor_ = element.style.cursor;
	                element.style.cursor = this.cursor_;
	            }
	        } else if (this.previousCursor_ !== undefined) {
	            element.style.cursor = this.previousCursor_;
	            this.previousCursor_ = undefined;
	        }
	        if(this.handleMoveEvent && typeof this.handleMoveEvent === 'function'){
	            this.handleMoveEvent({
	                evt:evt,
	                feature:feature,
	                data: feature.get('data'),
	                extent: ol.proj.transformExtent(feature.getGeometry().getExtent(), 'EPSG:3857', 'EPSG:4326')
	            })
	        }
	    }
	};

	/**
	 * @return {boolean} `false` to stop the drag sequence.
	 */
	app.Drag.prototype.handleUpEvent = function(evt) {
	    this.coordinate_ = null;
	    this.feature_ = null;
	    if(this.handleMoveEvent && typeof this.handleMoveEvent === 'function'){
	        this.handleMoveEvent(evt)
	    }
	    return false;

	};

	function addDrag(param){
	    var map = mapBox.getMapObj(param.mapId);
	    this.drag = new app.Drag(param);
	    map.addInteraction(this.drag);
	}

	function removeDrag(mapId){
	    var map = mapBox.getMapObj(mapId);
	    map.removeInteraction(this.drag);
	}
	module.exports = {
	    addDrag: addDrag,
	    removeDrag: removeDrag
	};

/***/ },
/* 139 */
/*!********************************************!*\
  !*** ./src/gis/businessLayers/xyzLayer.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var olUtil = __webpack_require__(/*! utils/olUtil */ 16);
	var event = __webpack_require__(/*! maps/event */ 11);

	function addLayer(paramObj) {
	    var _layerIdentify = paramObj.layerId + '_' + paramObj.mapId;
	    var _mapObj = mapBox.getMapObj(paramObj.mapId);
	    var _label = paramObj.label ? paramObj.label : paramObj.layerId;

	    if (!hashMap.containsKey(_layerIdentify)) {
	        var _layer = new ol.layer.Tile({
	            source: new ol.source.XYZ({
	                wrapX: false
	            })
	        });

	        _layer.set('map', _mapObj);
	        _layer.set('layerId', _layerIdentify);
	        _layer.set('layer_id', paramObj.layerId);
	        _layer.set('params.label', _label); //ͼ�����
	        _layer.set('legendName', paramObj.legendName);//ͼ�����
	        _layer.set('businessType', constant.BUSINESSTYPE.GRID);
	        var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.GRID;
	        _layer.setZIndex(_ZIndex);
	        if (paramObj.minShowLevel != undefined) {
	            _layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
	        }

	        if (paramObj.maxShowLevel != undefined) {
	            _layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
	        }

	        hashMap.put(_layerIdentify, _layer);
	        _mapObj.addLayer(_layer);
	    }
	}


	function setLayerData(paramObj) {
	    var _layerIdentify = paramObj.layerId + '_' + paramObj.mapId;
	    var _layer = hashMap.get(_layerIdentify);

	    if (!!_layer) {
	        _layer.set('legendName', paramObj.legendName);
	        _layer.getSource().setUrl(paramObj.url);
	        _layer.set('paramObj',paramObj);
	    }
	}

	module.exports = {
	    addLayer: addLayer,
	    setLayerData: setLayerData
	};

/***/ },
/* 140 */
/*!**************************************!*\
  !*** ./src/gis/framework/preLoad.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	var ajax = __webpack_require__(/*! utils/ajax */ 14);
	module.exports = {
	    setHeader: (function(){
	        ajax.setHeader();
	    }())
	};

/***/ },
/* 141 */
/*!*************************************!*\
  !*** ./src/gis/layers/trackPlay.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);


	/**
	 * 单轨迹播放器
	 * @param paramObj
	 * @constructor
	 */
	function SinglePlayer(paramObj) {
	    this.source = paramObj.source;
	    this.trackId = paramObj.uniqueIdentify;
	    this.mapId = paramObj.mapId;
	    this.layerId = paramObj.layerId;
	    this.coordinates = paramObj.coordinates;
	    this.style = paramObj.style;
	    this.showLine = paramObj.showLine;
	    this.isKeepTrack = paramObj.isKeepTrack;
	    this.cycling = paramObj.cycling;
	    this.speedRate = paramObj.speedRate || 1;
	    this.callback = paramObj.callback;

	    this._position = -1;
	    this._finalPosition = this.coordinates.length - 1;
	    this._playing = false;
	    this._finished = false;
	    this._lineFeature = null;
	    this._arrowFeature = null;
	    this._pointFeatures = [];
	    this._dotHandler = null;

	    this._addLine();
	    this._addPoints();
	}

	SinglePlayer.$new = function (paramObj) {
	    return new this(paramObj);
	};

	SinglePlayer.prototype._addLine = function _addLine() {
	    var source = this.source;
	    var style = this.style;
	    //适配高德地图的火星坐标系
	    var _coordinates = utils.transformMultArray(this.coordinates);
	    var coordinates = _coordinates.map(function (item) {
	        return ol.proj.fromLonLat(item.slice(0, 2));
	    });

	    /**
	     * 线条feature
	     * @type {ol.Feature}
	     */
	    this._lineFeature = new ol.Feature({
	        geometry: new ol.geom.LineString(coordinates),
	        businessType: constant.BUSINESSTYPE.TRACK_SHOW_LINE
	    });

	    if (style && style.lineStrokeColor) {
	        this._lineFeature.setStyle(new ol.style.Style({
	            stroke: new ol.style.Stroke({
	                color: style.lineStrokeColor,
	                width: style.lineStrokeWidth ? style.lineStrokeWidth : 3
	            })
	        }));
	    }
	    //获取线上最后两点画箭头
	    var last2Point = coordinates.slice(-2);
	    var dx = last2Point[1][0] - last2Point[0][0];
	    var dy = last2Point[1][1] - last2Point[0][1];
	    var rotation = -Math.atan2(dy, dx) + Math.PI / 2;
	    var arrowStyle = new ol.style.Style({
	        image: new ol.style.RegularShape({
	            fill: new ol.style.Fill({
	                color: style ? style.lineStrokeColor : 'blue'
	            }),
	            stroke: new ol.style.Stroke({
	                color: style ? style.lineStrokeColor : 'blue',
	                width: 1
	            }),
	            points: 3,
	            radius: 10,
	            rotation: rotation,
	            angle: 0
	        })
	    });

	    /**
	     * 箭头Feature
	     * @type {ol.Feature}
	     */
	    this._arrowFeature = new ol.Feature({
	        geometry: new ol.geom.Point(last2Point[1]),
	        businessType: constant.BUSINESSTYPE.TRACK_SHOW_LINE
	    });
	    this._arrowFeature.setStyle(arrowStyle);


	    if (!this.showLine) {
	        this._lineFeature.setGeometryName('invisible');
	        this._arrowFeature.setGeometryName('invisible');
	    }

	    source.addFeature(this._lineFeature);
	    source.addFeature(this._arrowFeature);
	};

	SinglePlayer.prototype._addPoints = function _addPoints() {
	    var trackThis = this;
	    var style = trackThis.style;
	    var pointStyle;
	    if (style) {
	        ///如果轨迹有自己默认的样式，就使用默认样式
	        pointStyle = new ol.style.Style({
	            image: new ol.style.Circle({
	                fill: new ol.style.Fill({
	                    color: style.fillColor ? style.fillColor : '#319FD3'
	                }),
	                radius: style.radius ? style.radius : 5,
	                stroke: new ol.style.Stroke({
	                    color: style.strokeColor ? style.strokeColor : '#ff0',
	                    width: style.strokeWidth ? style.strokeWidth : 1
	                })
	            })
	        });
	    }
	    else {
	        ///如果轨迹没有默认样式，就使用统一的样式
	        pointStyle = new ol.style.Style({
	            image: new ol.style.Circle({
	                fill: new ol.style.Fill({
	                    color: '#319FD3'
	                }),
	                radius: 5,
	                stroke: new ol.style.Stroke({
	                    color: '#ff0',
	                    width: 1
	                })
	            })
	        });
	    }

	    trackThis.coordinates.forEach(function (coordinate, index) {
	        var _point = new ol.geom.Point(ol.proj.fromLonLat(coordinate.slice(0, 2)));
	        var feature = new ol.Feature({
	            geometry: _point,
	            businessType: constant.BUSINESSTYPE.TRACK_SHOW
	        });
	        feature.setStyle(pointStyle);
	        feature.setId('trackPoint_' + index);
	        feature.setGeometryName('invisible');
	        trackThis._pointFeatures.push(feature);
	    });

	    trackThis.source.addFeatures(trackThis._pointFeatures);
	};

	SinglePlayer.prototype.continue = function () {
	    if (this._position === -1) {
	        this.playAtPosition(0);
	    } else {
	        this.playAtPosition(this._position);
	    }
	};

	SinglePlayer.prototype.playAtPosition = function playAtPosition(position) {
	    if (position === null || !isFinite(position) ||
	        position < 0 && position > this._finalPosition) {
	        return;
	    }

	    if (this._position === this._finalPosition && !this.cycling) {
	        this._playing = false;
	        this._finished = true;
	        return;
	    }

	    if (this._playing) {
	        clearTimeout(this._dotHandler);
	    }

	    this._playing = true;
	    this._finished = false;


	    var flowId = 'track_' + new Date().getTime().toString(16);

	    this._dot(flowId, position);

	};

	SinglePlayer.prototype.previous = function previous() {
	    var position = this._position;
	    if (position > 0) {
	        position = position - 1;
	    } else {
	        if (this.cycling) {
	            position = this._finalPosition;
	        } else {
	            position = 0;
	        }
	    }

	    if (this._playing) {
	        this.playAtPosition(position);
	    } else {
	        this.setPosition(position);
	    }
	};

	SinglePlayer.prototype.next = function next() {
	    var position = this._position;
	    if (position < this._finalPosition) {
	        position = position + 1;
	    } else {
	        if (this.cycling) {
	            position = 0;
	        } else {
	            position = this._finalPosition;
	        }
	    }

	    if (this.isPlaying()) {
	        this.playAtPosition(position);
	    } else {
	        this.setPosition(position);
	    }
	};

	SinglePlayer.prototype._dot = function dot(flowId, position) {
	    //如果是通过setTimeout执行，将当前指针向后移。如果是立即执行，指针不跳。
	    if (position >= 0) {
	        this.setPosition(position);
	    } else {
	        if (this.cycling && this._position === this._finalPosition) {
	            this.setPosition(0);
	        } else {
	            this.setPosition(this._position + 1);
	        }

	    }

	    if (this._position === this._finalPosition) {
	        if (!this.cycling) {
	            this.setPosition(this._position + 1);
	            this._playing = false;
	            this._finished = true;
	            if (this.callback) {
	                this.callback({
	                    data: this.coordinates[this._position],
	                    position: this.position
	                });
	            }
	            return;
	        }
	    } else {
	        if (this.callback) {
	            this.callback({
	                data: this.coordinates[this._position],
	                position: this._position
	            });
	        }
	    }


	    if (this.callback) {
	        this.callback({
	            data: this.coordinates[this._position],
	            position: this._position
	        });
	    }

	    this._dotHandler = setTimeout(this._dot.bind(this), this._getInterval(), flowId);
	};

	SinglePlayer.prototype._getInterval = function () {
	    var interval = 500 / this.speedRate;
	    var record = this.coordinates[this._position];
	    if (record.length > 2) {
	        interval = record[2] / this.speedRate;
	    }
	    return interval;
	};

	SinglePlayer.prototype.setPosition = function setPosition(position) {
	    if (position === null || !isFinite(position) || this._position === position ||
	        position < 0 && position > this._finalPosition) {
	        return;
	    }
	    this._position = position;

	    if (this.isKeepTrack) {
	        this._pointFeatures.forEach(function (feature, index) {
	            var geoName = feature.getGeometryName();
	            if (index <= position) {
	                if (geoName !== 'geometry') {
	                    feature.setGeometryName('geometry');
	                }
	            } else {
	                if (geoName !== 'invisible') {
	                    feature.setGeometryName('invisible');
	                }
	            }
	        });
	    } else {
	        this._pointFeatures.forEach(function (feature, index) {
	            var geoName = feature.getGeometryName();
	            if (index === position) {
	                if (geoName !== 'geometry') {
	                    feature.setGeometryName('geometry');
	                }
	            } else {
	                if (geoName !== 'invisible') {
	                    feature.setGeometryName('invisible');
	                }
	            }
	        });
	    }
	};

	SinglePlayer.prototype.getPosition = function getPosition() {
	    return this._position;
	};

	SinglePlayer.prototype.isPlaying = function isPlaying() {
	    return this._playing;
	};

	SinglePlayer.prototype.isFinished = function isfinished() {
	    return this._finished;
	};

	SinglePlayer.prototype.pause = function () {
	    if (this._playing) {
	        this._playing = false;
	        clearTimeout(this._dotHandler);
	    }
	};

	SinglePlayer.prototype.destroy = function () {
	    if (this._dotHandler) {
	        clearTimeout(this._dotHandler);
	    }

	    this.source = null;
	    this.trackId = null;
	    this.mapId = null;
	    this.layerId = null;
	    this.coordinates = null;
	    this.style = null;
	    this.showLine = null;
	    this.isKeepTrack = null;
	    this.cycling = null;
	    this.speedRate = null;
	    this.callback = null;

	    this._position = null;
	    this._finalPosition = null;
	    this._playing = null;
	    this._finished = null;
	    this._lineFeature = null;
	    this._arrowFeature = null;
	    this._pointFeatures = null;
	    this._dotHandler = null;
	};


	/**
	 * 多轨播放器，由多个单轨播放器组成
	 * @param paramObj
	 * @constructor
	 */
	function TrackPlayer(paramObj) {
	    var TrackThis = this;
	    this._playing = false;
	    this.playerUnit = [];
	    var _coordinates;
	    paramObj.datas.forEach(function (data) {
	        //适配高德地图火星坐标系
	        _coordinates = utils.transformMultArray(data.coordinates);
	        var player = SinglePlayer.$new({
	            source: paramObj.source,
	            uniqueIdentify: data.uniqueIdentify,
	            mapId: paramObj.mapId,
	            layerId: paramObj.layerId,
	            coordinates: _coordinates,
	            style: data.style,
	            showLine: paramObj.showLine,
	            isKeepTrack: paramObj.isKeepTrack,
	            cycling: paramObj.cycling,
	            speedRate: paramObj.speedRate,
	            callback: paramObj.callback
	        });
	        TrackThis.playerUnit.push(player);
	    });
	}

	TrackPlayer.$new = function (paramObj) {
	    return new this(paramObj);
	};

	TrackPlayer.prototype.getPlayer = function (trackId) {
	    return this.playerUnit.find(function (player) {
	        return player.trackId === trackId;
	    });
	};

	TrackPlayer.prototype.each = function (callback) {
	    this.playerUnit.forEach(callback.bind(this));
	};

	TrackPlayer.prototype.start = function (position) {
	    this.each(function (player) {
	        if (utils.isValid(position)) {
	            player.playAtPosition(position);
	        } else {
	            player.continue();
	        }
	    });
	};

	TrackPlayer.prototype.previous = function () {
	    this.each(function (player) {
	        player.previous();
	    });
	};

	TrackPlayer.prototype.next = function () {
	    this.each(function (player) {
	        player.next();
	    });
	};

	TrackPlayer.prototype.pause = function () {
	    this.each(function (player) {
	        player.pause();
	    });
	};

	TrackPlayer.prototype.position = function (trackId, position) {
	    var player = this.getPlayer(trackId);
	    if (player) {
	        if (utils.isValid(position)) {
	            //适配高德地图火星坐标系
	            var rePosition = utils.gcjTransform(position);
	            player.setPosition(rePosition);
	        } else {
	            return player.getPosition();
	        }
	    }
	};

	TrackPlayer.prototype.destroy = function () {
	    this.each(function (player) {
	        player.destroy();
	    });
	    this.playerUnit.splice(0);
	};


	//播放器储存集合
	var trackMap = {};


	function addTrackShow(paramObj) {
	    var _mapId = paramObj.mapId;
	    var _layerId = paramObj.layerId + '_' + _mapId;
	    var _layer = null;

	    if (hashMap.containsKey(_layerId)) {
	        _layer = hashMap.get(_layerId);
	    }
	    else {
	        baseLayer.createLayer(paramObj);
	        _layer = hashMap.get(_layerId);
	    }
	    if (paramObj.zindex !== undefined) {
	        _layer.setZIndex(paramObj.zindex);
	    }
	    paramObj.source = _layer.getSource();

	    var trackPlayer = trackMap[_mapId];
	    if (!trackPlayer) {
	        trackMap[_mapId] = TrackPlayer.$new(paramObj);
	    } else if (trackPlayer.length) {
	        trackPlayer.destroy();
	    }
	}

	module.exports = {
	    addTrackShow: addTrackShow,
	    pause: function (mapId) {
	        var trackPlayer = trackMap[mapId];
	        if (trackPlayer) {
	            trackPlayer.pause();
	        }
	    },
	    start: function (mapId, position) {
	        var trackPlayer = trackMap[mapId];
	        if (trackPlayer) {
	            trackPlayer.start(position);
	        }
	    },
	    position: function (mapId, trackId, position) {
	        var trackPlayer = trackMap[mapId];
	        if (trackPlayer) {
	            return trackPlayer.position(trackId, position);
	        }
	    },
	    isPlaying: function (mapId, trackId) {
	        var trackPlayer = trackMap[mapId];
	        if (!trackPlayer) {
	            return;
	        }
	        var singlePlayer = trackPlayer.getPlayer(trackId);
	        if (singlePlayer) {
	            return singlePlayer.isPlaying();
	        }
	    },
	    pre: function (mapId) {
	        var trackPlayer = trackMap[mapId];
	        if (trackPlayer) {
	            trackPlayer.previous();
	        }
	    },
	    next: function (mapId) {
	        var trackPlayer = trackMap[mapId];
	        if (trackPlayer) {
	            trackPlayer.next();
	        }
	    },
	    destroy: function (mapId) {
	        var trackPlayer = trackMap[mapId];
	        if (trackPlayer) {
	            trackPlayer.destroy();
	        }
	        delete trackMap[mapId];
	    }
	};

/***/ },
/* 142 */
/*!***************************************!*\
  !*** ./src/gis/layers/trackPlayer.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);


	var _LASTTRACK = 'lastTrack';

	var IntervalType = {
	    fixed: 0,
	    real: 1
	};



	function TrackPlayer(mapId, layerName) {
	    var trackLayer = baseLayer.getLayer({
	        mapId:mapId,
	        layerId:layerName
	    });
	    if (!trackLayer) {
	        return;
	    }
	    this.mapId = mapId;
	    this.layerName = layerName;//轨迹播放图层名
	    this.layer = trackLayer;// 轨迹播放图层
	    this.intervalType = IntervalType.fixed;
	    this.process = -1;//进度，即播放到哪个点了
	    this.finalProcess = -1;//最终播放进度
	    this.stepTime = 500;//ms 间隔时间
	    this.isPlaying = false;
	    this.speed = 1;// //播放速度，1代表正常速度，2表示2倍速，4表示4倍速，0.5表示0.5倍速；目前只支持这4种速度
	    this.playCallback = function () {};//播放到某个点时的回调事件
	    /*
	     * 数据
	     * data [{object}]
	     * eg:[{
	     *	"time" : 1413477302592,
	     *	"lat" : 29.531063,
	     *	"lon" : 106.553803,
	     *	"netType" : "UMTS",
	     *	'color' : "#aad500" ,
	     * }]
	     * */
	    this.data = [];
	}

	TrackPlayer.prototype.setData = function (data) {
	    if (!data || !(data instanceof Array) || !data.length) {
	        return false;
	    }
	    this.data = data;
	    this.finalProcess = data.length - 1;

	    var source = this.layer.getSource();
	    source.getFeatures().forEach(function(feature,item){
	        feature.setGeometryName('invisible');
	    })

	};

	TrackPlayer.prototype.getItem = function (process) {
	    if (!this.data || !this.data.length) {
	        return;
	    }
	    if (!Number.isFinite(process)) {
	        return;
	    }
	    process = Number(process);
	    if (process < 0 || process > this.finalProcess) {
	        return;
	    }
	    return this.data[process];
	};

	TrackPlayer.prototype.setIntervalType = function (mode) {
	    if (Number.isFinite(mode) && [0, 1].indexOf(Number(mode)) > -1) {
	        this.intervalType = mode;
	    }
	};

	TrackPlayer.prototype.setPlayCallback = function (callback) {
	    if (callback) {
	        this.playCallback = callback;
	    }
	};

	TrackPlayer.prototype.setProcess = function (process,skipCurrent) {
	    if (!Number.isFinite(process)) {
	        return false;
	    }
	    process = Number(process);
	    if (process < 0 || process > this.finalProcess) {
	        return false;
	    }
	    this._setProcess(process);
	    if(!skipCurrent) {
	        this.playCallback.call(null, {
	            mapId: this.mapId,
	            layerName: this.layerName,
	            data: this.data[this.process],
	            realDeltaTime:this.deltaTime,
	            realTime:this.lastTime,
	            process: this.process,
	            intervalType: this.intervalType,
	            stepTime: this.stepTime,
	            speed: this.speed
	        });
	    }

	};

	TrackPlayer.prototype._setProcess = function (process) {
	    if (!Number.isFinite(process)) {
	        return;
	    }
	    process = Number(process);
	    if (process < 0 || process > this.finalProcess) {
	        return;
	    }

	    if(this.process === process) {
	        return;
	    }

	    this.process = process;
	    var curTime = new Date();
	    if(this.lastTime) {
	        this.deltaTime = curTime.getTime() - this.lastTime;
	    }else{
	        this.deltaTime = 0;
	    }

	    this.lastTime = curTime;
	    this.focus();

	    var source = this.layer.getSource();
	    var features = source.getFeatures();
	    features.forEach(function(feature){
	        var count = Number(feature.getId().split('_')[1]);
	        var geoName = feature.getGeometryName();
	        if (count <= process) {
	            if (geoName !== 'geometry') {
	                feature.setGeometryName('geometry');
	            }
	        } else {
	            if (geoName !== 'invisible') {
	                feature.setGeometryName('invisible');
	            }
	        }
	    })
	};

	TrackPlayer.prototype.focus = function () {
	    var process = this.getProcess();
	    var item = this.getItem(process);
	    if (Number(item.lon) < -180 || Number(item.lon) > 180 ||
	        Number(item.lat) < -85 || Number(item.lat) > 85) {
	        return;
	    }
	    var coordinate = ol.proj.fromLonLat([item.lon, item.lat]);
	    var extent = mapBox.getExtent(this.mapId);
	    if (process === 0 || !ol.extent.containsCoordinate(extent, coordinate)) {
	        mapBox.getMapObj(this.mapId).getView().setCenter(coordinate);
	    }

	};

	TrackPlayer.prototype.getProcess = function () {
	    return this.process;
	};

	TrackPlayer.prototype.setSpeed = function (speed) {
	    if (!Number.isFinite(speed) || speed <= 0) {
	        return;
	    }
	    this.speed = Number(speed);
	};

	TrackPlayer.prototype.setStepTime = function (stepTime) {
	    if (!Number.isFinite(stepTime)) {
	        return;
	    }
	    this.stepTime = stepTime;
	};

	TrackPlayer.prototype.playAt = function (process, skipCurrent) {
	    var self = this, stepTime;
	    if (!Number.isFinite(process)) {
	        return false;
	    }
	    process = Number(process);
	    if (process < 0 || process > this.finalProcess) {
	        return false;
	    }
	    if(this.process === process && this.flow) {
	        return;
	    }

	    if (this.callbackHander) {
	        clearTimeout(this.callbackHander);
	    }

	    this.setProcess(process,skipCurrent);

	    if (process === this.finalProcess) {
	        return;
	    }

	    //flowsheet代表播放一次的流程信息
	    this.flow = {
	        id: _uuidGenerator,
	        process:process,
	        timeStamp:new Date().getTime()
	    };

	    if (this.intervalType === IntervalType.fixed) {

	        stepTime = this.stepTime / this.speed;
	        this.isPlaying = true;
	        this.callbackHander = setTimeout(fixedCallback, stepTime, this.flow);
	        this.flow.stepHandler = this.callbackHander;

	    } else if (this.intervalType === IntervalType.real) {

	        var currentTime = this.getItem(process).time;
	        var nextTime = this.getItem(process + 1).time;
	        stepTime = (nextTime - currentTime) / this.speed;
	        this.isPlaying = true;
	        this.callbackHander = setTimeout(realCallback, stepTime, this.flow);
	        this.flow.stepHandler = this.callbackHander;
	    }

	    function fixedCallback(flow) {
	        if(self.isPlaying === false) {
	            return;
	        }
	        if(self.flow.id !== flow.id){
	            return;
	        }

	        var process = self.getProcess() + 1;

	        if (process === self.finalProcess) {
	            self.callbackHander = 0;
	            flow.process = process;
	            self.setProcess(process);
	            self.isPlaying = false;
	            self.flow = null;
	            return
	        }

	        flow.process = process;
	        self.setProcess(process);

	        if(self.isPlaying && self.process === flow.process) {
	            var stepTime = self.stepTime / self.speed;
	            self.callbackHander = setTimeout(fixedCallback, stepTime,flow);
	            self.flow.stepHandler = self.callbackHander;
	        }
	    }

	    function realCallback(flow) {
	        if(self.isPlaying === false) {
	            return;
	        }

	        if(self.flow.id !== flow.id){
	            return;
	        }

	        var process = self.getProcess() + 1;

	        if (process === self.finalProcess) {
	            self.callbackHander = 0;
	            flow.process = process;
	            self.setProcess(process);
	            self.isPlaying = false;
	            self.flow = null;
	            return
	        }

	        flow.process = process;
	        self.setProcess(process);

	        if(self.isPlaying && self.process === flow.process) {
	            var currentTime = self.getItem(process).time;
	            var nextTime = self.getItem(process + 1).time;
	            var stepTime = (nextTime - currentTime) / self.speed;
	            self.callbackHander = setTimeout(realCallback, stepTime,flow);
	            self.flow.stepHandler = self.callbackHander;
	        }
	    }
	};

	TrackPlayer.prototype.pause = function () {
	    if (this.callbackHander) {
	        clearInterval(this.callbackHander);
	        this.flow = null;
	    }
	    this.isPlaying = false;
	};

	TrackPlayer.prototype.destroy = function () {
	    if(this.callbackHander) {
	        clearInterval(this.callbackHander);
	    }
	    if(this.layer && this.layer.getSource()) {
	        this.layer.getSource().clear();
	    }
	    this.mapId = null;
	    this.layerName = null;
	    this.layer = null;
	    this.intervalType = 0;
	    this.process = -1;
	    this.finalProcess = -1;
	    this.stepTime = 500;
	    this.isPlaying = false;
	    this.speed = 1;
	    this.data = null;
	};

	/**
	 * 生成唯一的UUID
	 * @returns {string}
	 * @private
	 */
	function _uuidGenerator(){
	    return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
	}


	function instanceTrack (mapId, layerName) {
	    var olMap = mapBox.getMapObj(mapId);
	    if(!olMap) {
	        return;
	    }
	    var lastTrack = olMap.get(_LASTTRACK);
	    if(lastTrack) {
	        lastTrack.destroy();
	    }
	    var trackPlayer = new TrackPlayer(mapId, layerName);
	    olMap.set(_LASTTRACK,trackPlayer);

	    return {
	        //设置轨迹播放数据
	        setAllData: function (data) {
	            trackPlayer.setData(data);
	        },
	        //设置轨迹播放点播放时间差
	        setTimeInterval: function (timeInterval) {
	            trackPlayer.setStepTime(timeInterval);
	        },
	        //设计播放速度
	        setSpeed: function (speed) {
	            trackPlayer.setSpeed(speed);
	        },
	        //开始播放
	        startInterval: function (mode, callback) {
	            trackPlayer.setIntervalType(mode);
	            trackPlayer.setPlayCallback(callback);
	            if(trackPlayer.process === -1){
	                trackPlayer.process = 0;
	            }
	            trackPlayer.playAt(trackPlayer.process);
	        },
	        //重新开始播放
	        resumeInterval: function () {
	            var process = trackPlayer.getProcess();
	            trackPlayer.playAt(process,true);
	        },
	        //暂停播放
	        pauseInterval: function () {
	            trackPlayer.pause();
	        },
	        //停止播放
	        stopInterval: function () {
	            trackPlayer._setProcess(trackPlayer.finalProcess);
	            trackPlayer.pause();
	        },
	        //获取是否播放完成状态
	        getIsPlayFinished: function () {
	            var process = trackPlayer.getProcess();
	            var finalProgress = trackPlayer.finalProcess;

	            return trackPlayer.isPlaying === false && process >= finalProgress;
	        },
	        //设置播放进度
	        setIntervalProcess: function (process,skipCurrent) {
	            if(trackPlayer.isPlaying) {
	                trackPlayer.playAt(process,skipCurrent);
	            }else{
	                trackPlayer.setProcess(process,skipCurrent);
	            }
	        },
	        //获取播放进度
	        getIntervalProcess: function () {
	            return trackPlayer.getProcess();
	        }
	    };
	}

	module.exports = {
	    instanceTrack:instanceTrack
	};


/***/ },
/* 143 */
/*!********************************************!*\
  !*** ./src/gis/businessLayers/roadMain.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var constant = __webpack_require__(/*! framework/constant */ 2);

	//图层名称列表
	var interLayer = 'interLayer', highlightLayer = 'highlightLayer', editMarkerLayer = 'editMarkerLayer',
	    pixPointsLayer = 'pixPointsLayer', route = 'route';

	//地图上Interaction的Id
	var polylineInter = 'polylineInter', polygonInter = 'polygonInter', snapInter = 'snapInter',
	    editInter = 'editInter', markerInter = 'markerInter';

	//注册地图事件数据
	var drawendEvent = {}, singleClickEvent = {}, dblClickEvent = {},dblclickFlag = false;

	//其它
	var roadLayers = {}, GisToken = {}, roadUrl = '/roadTestServlet',
	    redStyle = { color: '#FF0000', width: 3 }, blueStyle = { color: '#0000FF', width: 2 };
	var preClickPoint = [],//道路编辑时存储上次点击对应道路上的点
	    endClickFlag = false, startClickFlag = false, currentClick, clickFea, vertexes;
	/**
	 * c初始化道路，创建基础图层以及Interaction
	 * @param mapId
	 */
	function initRoadMgt(mapId) {
	    var layersArray = [highlightLayer, interLayer, editMarkerLayer, route, pixPointsLayer];

	    baseLayer.removeLayer({
	        mapId: mapId,
	        layerIds: layersArray
	    });

	    var interIds = [polylineInter, polygonInter, editInter, snapInter, markerInter];
	    _removeInteraction(mapId, interIds);

	    //添加道路高亮图层以及polygon或者polyline的操作图层
	    var initLayers = [highlightLayer, interLayer];
	    for (var i = 0; i < initLayers.length; i++) {
	        baseLayer.createLayer({
	            mapId: mapId,
	            layerId: initLayers[i]
	        });
	    }

	    var interLayerObj = baseLayer.getLayer({ mapId: mapId, layerId: interLayer });
	    interLayerObj.setZIndex(constant.Z_INDEX.ROADMAIN_1);
	    baseLayer.getLayer({mapId:mapId,layerId:highlightLayer}).setZIndex(constant.Z_INDEX.ROADMAIN_2);
	    interLayerObj.setStyle(new ol.style.Style({
	        stroke: new ol.style.Stroke({
	            color: [19, 129, 255, 255],
	            width: 2
	        }),
	        fill: new ol.style.Fill({
	            color: [255, 255, 255, 0]
	        })
	    })
	    );
	}

	/**
	 * 注册图层点击事件
	 * @param mapId
	 */
	function _registerMapEvent(mapId) {
	    var _mapObj = mapBox.getMapObj(mapId);
	    _mapObj.on('singleclick', function (evt) {
	        dblclickFlag = false;
	        var inters = [polygonInter,polylineInter,snapInter,editInter,markerInter];
	        var flag = false;
	        for(var i=0;i<inters.length;i++){
	            if(_getInteraction(mapId,inters[i])&&_getInteraction(mapId,inters[i]).getActive()){
	                flag = true;
	            }
	        }
	        if(!flag){
	            singleClickEvent.sel(evt,mapId);
	        }
	    });
	    _mapObj.on('dblclick', function (evt) {
	        dblclickFlag = true;
	        for (var o in dblClickEvent) {
	            dblClickEvent[o](evt);
	        }
	    });
	}

	/**
	 * 打开选路模式
	 * @param type 选路方式(值包含 polygon/polyline)
	 * @param callback 选完路后的回调函数
	 */
	function chooseRoads(mapId, type, callback) {
	    var polygonInterObj = _getInteraction(mapId, polygonInter);
	    var polylineInterObj = _getInteraction(mapId, polylineInter);
	    if ((polygonInterObj && polygonInterObj.getActive()) || (
	        polylineInterObj && polylineInterObj.getActive())) {
	        this.chooseRoadCancel(mapId, type);
	        return;
	    }

	    _removeFeaturesById(mapId, interLayer, [], true);
	    if (type === 'polygon') {
	        _drawPolygon(mapId, callback);
	    } else {
	        _drawPolyline(mapId, callback);
	    }
	}

	/**
	 * 设置道路图层信息
	 * @param mapId
	 * @param roadLayers
	 */
	function initRoadParams(mapId, params) {


	    _registerMapEvent(mapId);

	    if (params.GisTokenName) {
	        GisToken.name = params.GisTokenName;
	        GisToken.value = params.GISTokenValue;

	    }
	}

	function setRoadLayers(mapId, layers) {
	    if (layers) {
	        roadLayers[mapId] = layers;
	    } else {
	        roadLayers[mapId] = [];
	    }
	}

	/**
	 * Polygon选路
	 * @param mapId
	 * @param callback
	 * @private
	 */
	function _drawPolygon(mapId, callback) {
	    function polygonDrawEnd(e) {
	        _showLoading('polygon', true);
	        var pointsArr = e.feature.getGeometry().getCoordinates()[0];
	        setTimeout(function () {
	            var interLayerObj = baseLayer.getLayer({
	                mapId: mapId,
	                layerId: interLayer
	            });
	            interLayerObj.getSource().clear();
	        }, 20)

	        var queryParam = {};
	        queryParam.business = 'getRoadByPolygon';
	        var points = _.map(pointsArr, function (item) {
	            return _transformEPSG(item, 3857);
	        });
	        queryParam.data = {
	            roadLayer: roadLayers[mapId],
	            points: [points]
	        };
	        if (points.length > 201) {
	            callback({ polygonPoints: points });
	            setTimeout(function () {
	                polygonInter.setActive(false);
	            }, 10);
	            _removeFeaturesById(mapId, interLayer, [], true);
	            _showLoading('polygon', false);
	            return;
	        }

	        _crossDomainRequest(roadUrl, queryParam,
	            function (result) {
	                _showLoading('polygon', false);
	                polygonInter.setActive(false);
	                _removeFeaturesById(mapId, interLayer, [], true);
	                try {
	                    var tempRes = JSON.parse(result);
	                    if (_.isEmpty(tempRes) || tempRes.message) {
	                        throw new Error('polygon select road mode' +
	                            ' response is error');
	                    }
	                } catch (err) {
	                    return;
	                }
	                result = JSON.parse(result);
	                callback(result.geometries);
	            }
	        );
	        setTimeout(function () {
	            polygonInter.setActive(false);
	        }, 10);

	        _removeFeaturesById(mapId, interLayer, [], true);
	    }
	    var interLayerObj = baseLayer.getLayer({
	        mapId: mapId,
	        layerId: interLayer
	    });
	    var polygonInter = new ol.interaction.Draw({
	        source: interLayerObj.getSource(),
	        type: ('Polygon'),
	        style: new ol.style.Style({
	            stroke: new ol.style.Stroke({
	                width: 2,
	                color: '#42A8CF'
	            }),
	            fill: new ol.style.Fill({
	                color: 'rgba(255, 255, 255, 0.5)'
	            }),
	            image: new ol.style.Circle({
	                radius: 5,
	                stroke: new ol.style.Stroke({
	                    color: 'rgba(255, 255, 255, 0.7)'
	                }),
	                fill: new ol.style.Fill({
	                    color: '#42A8CF'
	                })
	            })
	        })
	    });

	    polygonInter.set('id', 'polygonInter');
	    var _mapObj = mapBox.getMapObj(mapId);
	    _mapObj.addInteraction(polygonInter);
	    polygonInter.setActive(true);
	    polygonInter.on('drawend', polygonDrawEnd);
	}

	/**
	 * polyline选路
	 * @param mapId
	 * @param callback
	 * @private
	 */
	function _drawPolyline(mapId, callback) {
	    var _mapObj = mapBox.getMapObj(mapId);
	    //初始化部分参数信息
	    var queryParam = null;
	    var requestNum = 1;
	    //上次点击获取的道路数据
	    var preRoadObj = {};
	    //polyline选中的道路数据
	    var selectRoadByLine = [];

	    var highLightLayerObj = baseLayer.getLayer({
	        mapId: mapId,
	        layerId: highlightLayer
	    });
	    var lineDblClick = function (e) {
	        var dbClickGeo = _transformEPSG(e.coordinate, 3857);
	        _removeFeaturesById(mapId, interLayer, [], true);
	        setTimeout(function () {
	            lineInter.setActive(false);
	            _removeInteraction(mapId, [polylineInter]);
	            preLineInterCoord = [];
	        }, 10);
	        if (requestNum === 1) {
	            return;
	        }
	        var dbQueryParam = {
	            business: 'roadSimulation',
	            data: {
	                action: 'execute',
	                data: [{
	                    routeId: -1,
	                    layerId: "" + -1 + "",
	                    geometry: { x: dbClickGeo[0], y: dbClickGeo[1] }
	                }],
	                roadLayer: roadLayers[mapId]
	            }
	        };
	        dbQueryParam.data.data.push({
	            routeId: preRoadObj.routeId,
	            layerId: "" + preRoadObj.layerId + "",
	            geometry: preRoadObj.geometry
	        });
	        _showLoading('polyline', true, mapId);

	        setTimeout(function () {
	            var interLayerObj = baseLayer.getLayer({
	                mapId: mapId,
	                layerId: interLayer
	            });
	            interLayerObj.getSource().clear();
	        }, 20)

	        _crossDomainRequest(roadUrl, dbQueryParam,
	            function (result) {
	                _showLoading('polyline', false, mapId);
	                try {
	                    var tempRes = JSON.parse(result);
	                    if (_.isEmpty(tempRes) || tempRes.message) {
	                        throw new Error(' the dbclick response of polyline select road mode is error');
	                    }
	                } catch (err) {
	                    var roadData = _groupTheSameRoad(selectRoadByLine);
	                    callback(roadData);
	                    return;
	                }
	                result = JSON.parse(result);
	                var dealRes = _dealResult(result, dbClickGeo, requestNum, preRoadObj);

	                // 发送请求，判断返回的第一个点和最后一个点是不是在一条道路上
	                if (requestNum > 2) {
	                    var overRoadData = [], totalPoints = [];
	                    //从之前返回的道路数据中获取和最后一个点获取的道路Id相同的道路点信息
	                    var last = _.last(dealRes.selectRoads);
	                    var hasFlag = false;
	                    _.each(dealRes.selectRoads.slice(0, -1), function (pre) {
	                        var prePoint = _.first(pre.paths[0]);
	                        var lastPoint = _.last(last.paths[0]);
	                        hasFlag = pre.routeId === last.routeId;
	                        if (hasFlag) {
	                            var last4326 = prePoint.slice(0, -1);
	                            var pre4326 = lastPoint.slice(0, -1);
	                            totalPoints.push(pre4326.concat(prePoint[2]),
	                                last4326.concat(lastPoint[2]));
	                        }
	                    }
	                    );
	                    overRoadData.push({
	                        routeId: last.routeId,
	                        layerId: last.layerId,
	                        points: totalPoints
	                    });
	                    selectRoadByLine = selectRoadByLine.concat(dealRes.selectRoads);
	                    var roadData = _groupTheSameRoad(selectRoadByLine);

	                    callback(roadData);
	                }
	            }
	        );
	    };

	    dblClickEvent.lineDblClick = lineDblClick;
	    //存储Line Interaction的数据，通过数据长度变化判断是否发生点击事件
	    var preLineInterCoord = [];

	    var lineInter = new ol.interaction.Draw({
	        source: baseLayer.getLayer({
	            mapId: mapId,
	            layerId: interLayer
	        }).getSource(),
	        type: ('LineString'),
	        geometryFunction: function (coords, geom) {
	            if (preLineInterCoord.length < coords.length) {
	                preLineInterCoord = JSON.parse(JSON.stringify(coords));
	                var singleClickPoint = _transformEPSG(coords[coords.length - 1], 3857);
	                queryParam = {
	                    business: 'roadSimulation',
	                    data: {
	                        action: 'start',
	                        roadLayer: roadLayers[mapId],
	                        data: []
	                    }
	                };
	                if (requestNum === 1) {
	                    queryParam.data.data.push(
	                        { routeId: -1, layerId: "" + -1 + "", geometry: { x: singleClickPoint[0], y: singleClickPoint[1] } }
	                    );
	                } else {
	                    queryParam.data.action = 'execute';
	                    var existRoadParam = {
	                        routeId: preRoadObj.routeId,
	                        layerId: "" + preRoadObj.layerId + "",
	                        geometry: preRoadObj.geometry
	                    };


	                    var newRoadParam = {
	                        routeId: -1,
	                        layerId: "" + -1 + "",
	                        geometry: { x: singleClickPoint[0], y: singleClickPoint[1] }
	                    };
	                    if (requestNum === 2) {
	                        existRoadParam.start = true;
	                    }
	                    queryParam.data.data.push(existRoadParam);
	                    queryParam.data.data.push(newRoadParam);
	                }

	                _crossDomainRequest(roadUrl, queryParam,
	                    function (result) {
	                        _showLoading('polyline', false, mapId);
	                        try {
	                            //对后台返回值校验  包含(null,)
	                            result = JSON.parse(result);
	                            if (_.isEmpty(result) || result.message) {
	                                throw new Error('polyline response error');
	                            }
	                        } catch (err) {
	                            result = {
	                                message: (!result || _.isEmpty(result)) ? '10000002' : result.message
	                            };
	                            callback({ error: result.message });
	                        }

	                        //对返回geom的处理
	                        if (!geom) {
	                            geom = new ol.geom.LineString(null);
	                        }
	                        if (!result || result.message) {
	                            coords.pop();
	                        } else {
	                            var selectData = _dealResult(result, singleClickPoint, requestNum, preRoadObj);
	                            preRoadObj = selectData.preRoadObj;
	                            if (selectData.selectRoads.length !== 0) {
	                                selectRoadByLine.concat(selectData.selectRoads);
	                            }

	                            requestNum++;
	                            //对第一次请求返回的点数据和之后返回的点数据分开处理
	                            var vertexes = [];
	                            if (requestNum === 2) {
	                                vertexes = [
	                                    [result.point.x, result.point.y]
	                                ];
	                                if (vertexes.length === 1) {
	                                    vertexes.push(
	                                        [vertexes[0][0] + 0.000001,
	                                        vertexes[0][1] + 0.0000001]
	                                    )
	                                }
	                                _drawLineFeature(highLightLayerObj, null, vertexes, blueStyle);
	                            } else {
	                                _.each(result.geometries, function (geometry) {
	                                    _drawLineFeature(highLightLayerObj, null, geometry.paths[0], blueStyle);
	                                });
	                            }
	                        }
	                        preLineInterCoord = JSON.parse(JSON.stringify(coords));
	                    }
	                );
	            }

	            if (!geom) {
	                geom = new ol.geom.LineString(null);
	            }
	            geom.setCoordinates(coords);
	            return geom;
	        }
	    });
	    lineInter.set('id', polylineInter);
	    _mapObj.addInteraction(lineInter);
	    lineInter.setActive(true);
	}

	/**
	 * 道路编辑
	 * @param vertexes 要编辑道路的拐点
	 * @param callback 回调事件，将编辑后的道路长度和顶点信息传给业务
	 * @param routeId 要编辑道路的id
	 */
	function editRoads(mapId, vertexes, callback) {

	    startClickFlag = false,endClickFlag = false,currentClick = null;
	    _removeFeaturesById(mapId, interLayer, [], true);
	    _createSnapPoint(mapId, vertexes.paths);
	    var sidepoint = [vertexes.paths[0],vertexes.paths[vertexes.paths.length-1]];
	    //适配高德地图火星坐标系
	    sidepoint = utils.transformMultArray(sidepoint);
	    _createSidePoint(mapId,sidepoint);
	    //SnapInter结束后的回调函数,区分是单击还是双击事件
	    var snapEndFun = function(evt){
	        setTimeout(function(){
	            if(dblclickFlag&&_getInteraction(mapId,editInter)&&_getInteraction(mapId,editInter).getActive()){
	                _editDbClickFun(evt,vertexes,callback);
	            }else if(!dblclickFlag){
	                _editSingleClickFun(evt,vertexes);
	            }
	        },260);
	    };

	    var editInterObj = _createDrawInter(mapId, editInter, 'Point',snapEndFun);
	    editInterObj.setActive(false);
	    _createSnapInter(mapId);
	    var snapInterObj = _getInteraction(mapId, snapInter);
	    snapInterObj.setActive(false);
	    _createMarkerClickInter(mapId,sidepoint);
	}

	/**
	 * 取消道路编辑(其中会删除Interaction、清楚图层数据、解绑地图注册事件)
	 */
	function editCancel(mapId) {
	    var _mapObj = mapBox.getMapObj(mapId);
	    if (!_mapObj) {
	        return;
	    }
	    var inters = [markerInter, editInter, snapInter];
	    _removeInteraction(mapId, inters);

	    _removeFeaturesById(mapId, interLayer, [], true);
	    _removeFeaturesById(mapId, pixPointsLayer, [], true);

	    baseLayer.removeLayer({
	        mapId: mapId,
	        layerIds: [editMarkerLayer]
	    });

	    //取消编辑后打开个默认的Interaction设置true
	    _.each(_mapObj.getInteractions().getArray(), function (inter) {
	        if (typeof inter === ol.interaction.DoubleClickZoom) {
	            setTimeout(function () {
	                inter.setActive(true);
	            }, 100);
	        }
	    });
	}

	/**
	 * 取消道路状态
	 * @param type 选路方式
	 */
	function chooseRoadCancel(mapId, type) {
	    //当polygon或者polyline模式处于打开状态时删掉已画的道路
	    if (type === 'polygon') {
	        _removeInteraction(mapId, ['polygonInter']);
	    } else {

	        // singleClickEvent = {};
	        delete dblClickEvent.lineDblClick;
	        var lineInter = _getInteraction(mapId, polylineInter);
	        if (lineInter && lineInter.getActive()) {
	            _removeFeaturesById(mapId, highlightLayer, [undefined]);
	            _removeInteraction(mapId, [polylineInter]);
	        }
	    }
	    _removeFeaturesById(mapId, interLayer, [], true);
	    _showLoading('polyline', false, mapId);
	}

	/***
	 * 删除地图上的画的道路线(包括红线和蓝线)
	 */
	function removeRoadDataOnMap(mapId) {
	    _removeFeaturesById(mapId, highlightLayer, [], true);
	}

	/***
	 * 删除地图上添加的图层 如高亮图层
	 * @param layerName
	 */
	function removeRoadInRoadMgt(mapId) {
	    var layerIds = [interLayer, highlightLayer, pixPointsLayer];
	    baseLayer.removeLayer({
	        mapId: mapId,
	        layerIds: layerIds
	    })
	}

	/**
	 * 地图道路数据关联
	 * @param callback  业务回调，将获取到的信息(即roadId传给业务)
	 */
	function selRoadOnMap(mapId, callback) {
	    var selFunction = function (e,mapId) {
	        var lineInter = _getInteraction(mapId, polylineInter);
	        var polygonInter = _getInteraction(mapId, 'polygonInter');
	        if (lineInter && lineInter.getActive() || polygonInter && polygonInter.getActive()) {
	            return;
	        }
	        var selPoint = _transformEPSG(e.coordinate, 3857);
	        var requestParam = {};
	        requestParam.business = 'query';
	        requestParam.data = {
	            action: 'queryRouteId',
	            roadLayer: roadLayers[mapId],
	            data: [{
	                geometry: { x: selPoint[0], y: selPoint[1] }
	            }]
	        };
	        _crossDomainRequest(roadUrl, requestParam,
	            function (result) {
	                try {
	                    var parseRes = JSON.parse(result);
	                    if(parseRes&&parseRes.layerId){
	                        callback(parseRes);
	                    }
	                } catch (err) {
	                    console.log('selRoadOnMap no response!', 'warn');
	                }
	            }
	        );
	    };
	    singleClickEvent.sel = selFunction;
	}

	/**
	 * 获取离线地图的边界范围
	 * @param url 离线地图的url路径
	 * @param callback 回调
	 */
	function setWMSExtent(url, callback) {

	    _crossDomainRequest(url, {},
	        function (res) {
	            if (res !== null && res !== '') {
	                var resultJSON = JSON.parse(res);
	                var extentObj = resultJSON.fullExtent;
	                var min = _transformEPSG(
	                    [extentObj.xmin, extentObj.ymin], 3857);
	                var max = _transformEPSG(
	                    [extentObj.xmax, extentObj.ymax], 3857);
	                callback([min[0], min[1], max[0], max[1]]);
	            }
	        }
	    )
	}

	/**
	 * 根据道路IdList删除对应的道路feature数据
	 * @param idList 道路ids  如果传入为空时则清楚全部
	 */
	function removeFeatureDataByIdList(mapId, idList) {
	    if (idList && idList.length !== 0) {
	        _removeFeaturesById(mapId, highlightLayer, idList);
	    } else {
	        _removeFeaturesById(mapId, highlightLayer, [], true);
	    }
	}

	/**
	 * 根据连线
	 * @param mapId
	 * @param lineParam
	 * @param routeColor
	 */
	function drawRouteLine(mapId, lineParam, routeColor) {
	    var layerObj = baseLayer.getLayer({
	        mapId: mapId,
	        layerId: highlightLayer
	    });
	    _removeFeaturesById(mapId, highlightLayer, [lineParam.id]);

	    _drawLineFeature(layerObj, lineParam.id,
	        lineParam.vertexes, routeColor);
	}

	/**
	 * 修改道路的颜色
	 * @param lineId
	 * @param style
	 */
	function changeLineStyle(mapId, lineId, style) {
	    var layerObj = baseLayer.getLayer({ mapId: mapId, layerId: highlightLayer });
	    var highLightFea = layerObj.getSource().getFeatureById(lineId);
	    if (highLightFea) {
	        highLightFea.setStyle(new ol.style.Style({
	            stroke: new ol.style.Stroke(style)
	        }))
	    }
	}

	/**
	 * 编辑道路单击事件
	 * @param clickE
	 * @private
	 */
	function _editSingleClickFun(evt,vertexes) {
	    var _mapObj = evt.target.getMap();
	    var mapId = _mapObj.getTarget();

	    _removeFeaturesById(mapId, interLayer, ['clickFeature']);
	    //单击时所在的地理位置(4326)
	    var firstCoord = evt.feature.getGeometry().getFirstCoordinate();
	    var snapClickPix = _mapObj.getPixelFromCoordinate(firstCoord);
	    var clickPoint = _transformEPSG(firstCoord, 3857);

	    //保存上次在道路上单击的点
	    preClickPoint = clickPoint;
	    evt.feature.setId('clickFeature');
	    var interLayerObj = baseLayer.getLayer({
	        mapId: mapId,
	        layerId: interLayer
	    });
	    interLayerObj.getSource().addFeature(evt.feature);
	    _getInteraction(mapId,editInter).setActive(false);
	    _getInteraction(mapId,snapInter).setActive(false);
	    _mapObj.forEachFeatureAtPixel(snapClickPix, function (feature) {
	        var privateId = feature.get('roadNum');
	        //根据所点击道路所在的像素点的roadNum对道路点数据做处理
	        if (privateId || privateId === 0) {

	            _removeFeaturesById(mapId, interLayer, ['spareFeature']);
	            if (currentClick === 'start') {
	                endClickFlag = false;
	            } else if (currentClick === 'end') {
	                startClickFlag = false;
	            }
	            //存储单击后的高亮道路feature
	            clickFea = feature;
	            //计算点击后剩余道路的点集，同时将这些点集生成蓝色线
	            var closePoint = _transformEPSG(
	                feature.getGeometry().getFirstCoordinate(), 3857);
	            var valueAndSpare = _calSparePoint(vertexes.paths,
	                closePoint, startClickFlag);
	            var spareArr =
	                startClickFlag ? valueAndSpare[1].concat([clickPoint]) :
	                    [clickPoint].concat(valueAndSpare[1]);
	            var spareFeature =
	                new ol.Feature(
	                    new ol.geom.MultiLineString([
	                        _.map(spareArr, function (item) {
	                            return _transformEPSG(item, 4326)
	                        })
	                    ])
	                );
	            spareFeature.setId('spareFeature');
	            spareFeature.setStyle(new ol.style.Style({
	                stroke: new ol.style.Stroke(blueStyle)
	            }));
	            interLayerObj.getSource().addFeature(spareFeature);
	        }
	    })
	}

	/**
	 * 编辑道路双击事件
	 * @param mapId
	 * @param evt
	 * @private
	 */
	function _editDbClickFun(evt,vertexes,callback) {
	    var _mapObj = evt.target.getMap();
	    var mapId = _mapObj.getTarget();

	    var clickCoord = evt.feature.getGeometry().getCoordinates();
	    var dbClickPix = _mapObj.getPixelFromCoordinate(clickCoord);
	    var clickPoint = _transformEPSG(clickCoord,3857);
	    //处理编辑状态下地图双击放大的问题 start
	    _.each(_mapObj.getInteractions().getArray(), function (inter) {
	        if (typeof inter === ol.interaction.DoubleClickZoom) {
	            inter.setActive(false);
	        }
	    });

	    //双击点的地理位置
	    var interIds = [editInter, markerInter, snapInter];
	    _removeInteraction(mapId, interIds);
	    _mapObj.forEachFeatureAtPixel(dbClickPix, function (feature) {
	        var privateId = feature.get('roadNum');
	        if (privateId || privateId === 0) {
	            var valueVertexes = [];
	            if (startClickFlag && !endClickFlag) {
	                //编辑时只点击左侧的点
	                var clickFeaTerminal = _transformEPSG(
	                    feature.getGeometry().getFirstCoordinate(), 3857);
	                valueVertexes = [clickPoint].concat(
	                    _calSparePoint(vertexes.paths,
	                        clickFeaTerminal, true)[0]);
	            } else if (!startClickFlag && endClickFlag) {
	                //编辑时只点击右侧的点
	                var clickFeaTerminal = _transformEPSG(
	                    feature.getGeometry().getFirstCoordinate(), 3857);
	                valueVertexes = (_calSparePoint(vertexes.paths,
	                    clickFeaTerminal, false)[0]).concat([clickPoint]);
	            } else if (startClickFlag && endClickFlag) {
	                //编辑时两侧的点都点击，判读其点击所在feature的roadNum大小做不同情况的处理
	                var singleClickFeaId = clickFea.get('roadNum');
	                if (singleClickFeaId === privateId) {

	                    valueVertexes = [clickPoint].concat([preClickPoint]);

	                } else if (singleClickFeaId !== privateId &&
	                    singleClickFeaId > privateId) {
	                    var tempArr = [clickPoint].concat(_calSparePoint(
	                        vertexes.paths, _transformEPSG(
	                            feature.getGeometry().getFirstCoordinate(),
	                            3857), true)[0]);
	                    valueVertexes = _calSparePoint(tempArr,
	                        _transformEPSG(
	                            clickFea.getGeometry().
	                                getFirstCoordinate(), 3857),
	                        false)[0].concat([preClickPoint]);
	                } else if (singleClickFeaId !== privateId &&
	                    singleClickFeaId < privateId) {
	                    var tempArr = _calSparePoint(
	                        vertexes.paths, _transformEPSG(feature.getGeometry().
	                            getFirstCoordinate(), 3857),
	                        false)[0].concat([clickPoint]);
	                    valueVertexes = [preClickPoint].concat(
	                        _calSparePoint(tempArr,
	                            _transformEPSG(
	                                clickFea.getGeometry().getFirstCoordinate(), 3857), true)[0]
	                    );

	                }
	            }
	            _removeFeaturesById(mapId, highlightLayer, [vertexes.routeId]);

	            var length = parseInt(_calVertexesLength(valueVertexes));

	            if (!valueVertexes[0][2] && valueVertexes[0][2] !== 0) {
	                valueVertexes[1][2] = valueVertexes[1][2] ? valueVertexes[1][2] : 0;
	                valueVertexes[0][2] = valueVertexes[1][2] -
	                    _calDistanceByPoint(valueVertexes[0], valueVertexes[1]);
	            }
	            if (!valueVertexes[valueVertexes.length - 1][2]) {
	                valueVertexes[valueVertexes.length - 1][2] = valueVertexes[valueVertexes.length - 2][2] -
	                    _calDistanceByPoint(
	                        valueVertexes[valueVertexes.length - 1],
	                        valueVertexes[valueVertexes.length - 2]
	                    );
	            }
	            callback({ paths: valueVertexes, length: length });
	        }
	    });
	    editCancel(mapId);
	}

	/**
	 * 生成道路端点以及点击Interaction
	 * @param mapId
	 * @param points
	 * @private
	 */
	function _createSidePoint(mapId, points) {
	    var markerStyle = new ol.style.Style({
	        image: new ol.style.Circle({
	            radius: 5,
	            fill: new ol.style.Fill({
	                color: '#FF0000'
	            })
	        })
	    }
	    );

	    baseLayer.removeLayer({
	        mapId: mapId,
	        layerIds: [editMarkerLayer]
	    });
	    baseLayer.createLayer({
	        mapId: mapId,
	        layerId: editMarkerLayer
	    });
	    var markerLayer = baseLayer.getLayer({
	        mapId: mapId,
	        layerId: editMarkerLayer
	    });

	    var firstPoint = _transformEPSG(points[0], 4326);
	    var lastPoint = _transformEPSG(points[1], 4326);
	    var markerStartFea = new ol.Feature(new ol.geom.Point(firstPoint));
	    markerStartFea.setId('marker_start');
	    markerStartFea.setStyle(markerStyle);
	    var markerEndFea = new ol.Feature(new ol.geom.Point(lastPoint));
	    markerEndFea.setId('marker_end');
	    markerEndFea.setStyle(markerStyle);
	    markerLayer.getSource().addFeatures([markerStartFea, markerEndFea]);
	}

	/**
	 * 生成点击Interaction
	 * @param mapId
	 * @private
	 */
	function _createMarkerClickInter(mapId,sidePoint) {
	    var _mapObj = mapBox.getMapObj(mapId);
	    var markerLayerObj = baseLayer.getLayer({
	        mapId: mapId,
	        layerId: editMarkerLayer
	    });

	    var markerClickInter = new ol.interaction.Select({
	        layers: [markerLayerObj]
	    });
	    markerClickInter.set('id', 'markerInter');
	    _mapObj.addInteraction(markerClickInter);

	    var editInterObj = _getInteraction(mapId, editInter);
	    var snapInterObj = _getInteraction(mapId, snapInter);
	    markerClickInter.on('select', function (evt) {
	        if(evt.selected.length ===0){
	            return;
	        }
	        //由于ol3的点点击事件无法准确获取点击到的矢量点，所以通过
	        // 计算点击点与最近的编辑点的距离是否小于编辑点的直径达获取点击的是那个编辑点的目的
	        var mouseClickPix = evt.mapBrowserEvent.pixel;
	        var firstPix = _mapObj.getPixelFromCoordinate(_transformEPSG(sidePoint[0],4326));
	        var lastPix = _mapObj.getPixelFromCoordinate(_transformEPSG(sidePoint[1],4326));
	        var minFirstLength = Math.sqrt(Math.pow((mouseClickPix[0] - firstPix[0]), 2) +
	            Math.pow((mouseClickPix[1] - firstPix[1]), 2));
	        var minLastLength = Math.sqrt(Math.pow((mouseClickPix[0] - lastPix[0]), 2) +
	            Math.pow((mouseClickPix[1] - lastPix[1]), 2));
	        if (minFirstLength > 10 && minLastLength > 10) {
	            return;
	        }

	        if (minFirstLength <= 10 && !editInterObj.getActive()) {
	            editInterObj.setActive(true);
	            snapInterObj.setActive(true);
	            startClickFlag = true;
	            currentClick = 'start';
	        } else if (minLastLength <= 10 && !editInterObj.getActive()) {
	            editInterObj.setActive(true);
	            snapInterObj.setActive(true);
	            endClickFlag = true;
	            currentClick = 'end';
	        }
	    });
	}

	/**
	 * 根据类型生成操作Inter
	 * @param mapId
	 * @param interId
	 * @param type
	 * @returns {ol.interaction.Draw}
	 * @private
	 */
	function _createDrawInter(mapId, interId, type,clickFun) {
	    var _mapObj = mapBox.getMapObj(mapId);
	    var interLayerObj = baseLayer.getLayer({
	        mapId: mapId,
	        layerId: interLayer
	    });
	    var interObj = new ol.interaction.Draw({
	        source: interLayerObj.getSource(),
	        type: (type)
	    });
	    interObj.on('drawend',clickFun);
	    interObj.set('id', interId);
	    _mapObj.addInteraction(interObj);
	    return interObj;
	}

	/**
	 * 生成依附Interaction
	 * @param mapId
	 * @private
	 */
	function _createSnapInter(mapId) {
	    var _mapObj = mapBox.getMapObj(mapId);
	    var interLayerObj = baseLayer.getLayer({
	        mapId: mapId,
	        layerId: interLayer
	    });
	    var pixLayer = baseLayer.getLayer({
	        mapId: mapId,
	        layerId: pixPointsLayer
	    })
	    var interObj = new ol.interaction.Snap({
	        features: new ol.Collection(pixLayer.getSource().getFeatures()),
	        pixelTolerance: 100000,
	        source: interLayerObj.getSource()
	    });
	    interObj.set('id', 'snapInter');
	    _mapObj.addInteraction(interObj);
	}

	/**
	 * 根据线计算像素点以及生成线
	 * @param mapId
	 * @param sourceCoord
	 * @returns {Array}
	 * @private
	 */
	function _createSnapPoint(mapId, sourceCoord) {
	    var pixPoint = _calPixPoint(mapId, sourceCoord);
	    var pixPointFeaArr = [];
	    _.each(pixPoint, function (item, key) {
	        //适配高德地图火星坐标系
	        var _coordinate = utils.transformMultArray(item);
	        var pixPointFea = new ol.Feature(new ol.geom.MultiPoint(_coordinate));
	        pixPointFea.set('roadNum', key);
	        pixPointFea.setStyle(new ol.style.Style({
	            image: new ol.style.Circle({
	                radius: 0.5,
	                fill: new ol.style.Fill({
	                    color: [0, 255, 0, 1]
	                })
	            })
	        }
	        ));
	        pixPointFeaArr.push(pixPointFea);
	    });
	    var pixPointLayerObj = baseLayer.getLayer({
	        mapId: mapId,
	        layerId: pixPointsLayer
	    });
	    if (pixPointLayerObj) {
	        pixPointLayerObj.getSource().clear();
	        pixPointLayerObj.getSource().addFeatures(pixPointFeaArr);
	    } else {
	        baseLayer.createLayer({
	            mapId: mapId,
	            layerId: pixPointsLayer
	        });
	        pixPointLayerObj = baseLayer.getLayer({
	            mapId: mapId,
	            layerId: pixPointsLayer
	        });
	        pixPointLayerObj.getSource().addFeatures(pixPointFeaArr);
	        pixPointLayerObj.setZIndex(constant.Z_INDEX.ROADMAIN_3);
	    }
	    return pixPoint;
	}

	/**
	 * 获取Interaction
	 * @param mapId
	 * @param interId
	 * @returns {T}
	 * @private
	 */
	function _getInteraction(mapId, interId) {
	    var _mapObj = mapBox.getMapObj(mapId);
	    var inters = _mapObj.getInteractions().getArray();
	    var interObj = null;
	    for (var i = 0; i < inters.length; i++) {
	        if (inters[i].get('id') === interId) {
	            interObj = inters[i];
	            break;
	        }
	    }
	    return interObj;
	}

	/**
	 * 删除Interaction
	 * @param mapId
	 * @param interId
	 * @private
	 */
	function _removeInteraction(mapId, interIds) {
	    var _mapObj = mapBox.getMapObj(mapId);
	    for (var i = 0; i < interIds.length; i++) {
	        var interaction = _getInteraction(mapId, interIds[i]);
	        _mapObj.removeInteraction(interaction);
	    }
	}

	/***
	 * 对单个点的坐标系进行转换
	 * @param point 点
	 * @param formGeoType 当前点的坐标系
	 * @returns {ol.Coordinate} 转换后的点
	 */
	function _transformEPSG(point, formGeoType) {
	    //要转换成的坐标系
	    var toGeoType = (formGeoType === 3857 ? 4326 : 3857);
	    return ol.proj.transform([point[0], point[1]], 'EPSG:' + formGeoType, 'EPSG:' + toGeoType);
	}

	/**
	 * 根据Id删除Feature
	 * @param mapId
	 * @param layerId
	 * @param featureIds
	 * @param clearFlag:是否全部清除feature
	 */
	function _removeFeaturesById(mapId, layerId, featureIds, clearFlag) {
	    var layerObj = baseLayer.getLayer({
	        mapId: mapId,
	        layerId: layerId
	    });
	    if (!layerObj) {
	        return;
	    }
	    var source = layerObj.getSource();
	    if (!clearFlag) {
	        if (source) {
	            source.forEachFeature(function (feature) {
	                featureIds.forEach(function (id) {
	                    if (id === feature.getId()) {
	                        source.removeFeature(feature);
	                    }
	                })
	            })
	        }
	    } else {
	        if (source) {
	            source.clear();
	        }
	    }
	}

	/***
	 * showLoading进度条或者将地图窗口的树表样式修改为等待
	 * @param type 选路模式(polygon/polyline)
	 * @param flag true:显示，false：不显示
	 * @param mapId 地图窗口Id
	 */
	function _showLoading(type, flag, mapId) {
	    function addMaskOnMap() {
	        var mapDom = $('#' + mapId);
	        var width = mapDom.width();
	        var height = mapDom.height();
	        var maskStr = '<div style="width:' + width + 'px;height:' + height +
	            'px;position:fixed;z-index:1000" id="roadMask"></div>';
	        mapDom.before(maskStr);
	    }

	    function removeMask() {
	        $('#roadMask').remove();
	    }

	    if (type === 'polygon') {
	        if (flag) {
	            $('#geoLoading').removeClass('hide').addClass('show');
	        } else {

	            $('#geoLoading').removeClass('show').addClass('hide');
	        }
	    } else {
	        var mapDomObj = $('#' + mapId);
	        var mapStyle = mapDomObj.attr('style') || '';
	        if (mapStyle.indexOf('cursor') >= 0) {
	            mapStyle = flag ? mapStyle.replace('default', 'wait') :
	                mapStyle.replace('wait', 'default');
	            if (flag) {
	                addMaskOnMap();
	            } else {
	                removeMask();
	            }
	        } else {
	            flag ? mapStyle += 'cursor:wait' : mapStyle += 'cursor:default';
	            if (flag) {
	                addMaskOnMap();
	            } else {
	                removeMask();
	            }
	        }
	        mapDomObj.attr('style', mapStyle);
	    }
	}

	/**
	 * 将每条道路当做一个feature画路
	 * @param layerObj 画路的目标图层
	 * @param roadId 道路Id
	 * @param vertexes  道路轨点信息
	 * @param style   feature的颜色
	 */
	function _drawLineFeature(layerObj, roadId, vertexes, style) {
	    var vertexes3857 = _.map(vertexes, function (item) {
	        //适配高德地图火星坐标系
	        item = utils.gcjTransform(item);
	        return ol.proj.transform(
	            [item[0], item[1]], 'EPSG:4326', 'EPSG:3857');
	    });
	    var roadFeature = new ol.Feature({ geometry: new ol.geom.MultiLineString([vertexes3857]) });
	    if (roadId) {
	        roadFeature.setId(roadId);
	    }
	    roadFeature.setStyle(new ol.style.Style({
	        stroke: new ol.style.Stroke(style)
	    }));
	    layerObj.getSource().addFeature(roadFeature);
	}

	/**
	 * 计算像素点
	 * @param map 地图对象
	 * @param pointArr 多个点数据(如：[[x,y],[x,y]]),点坐标系为4326
	 * @returns {Array}  返回点数据 坐标系为3857
	 * @describe 该算法的主要逻辑是将传入的4326点转换为普通的像素点后，计算每两个点构成的直线方程式计算
	 *            再以起点为起始值，横轴或者纵轴每次增加一像素来计算点数据
	 */
	function _calPixPoint(map, pointArr) {
	    var _mapObj = mapBox.getMapObj(map);
	    var resolution = 1;//横轴或者纵轴增加的步长
	    var pixPointArr = [];
	    var x = function (y, point1, point2) {
	        var x1 = point1[0], y1 = point1[1];
	        var x2 = point2[0], y2 = point2[1];
	        return (x1 - x2) * y / (y1 - y2) + (x2 * y1 - x1 * y2) / (y1 - y2);
	    };
	    var y = function (x, point1, point2) {
	        var x1 = point1[0], y1 = point1[1];
	        var x2 = point2[0], y2 = point2[1];
	        return (y1 - y2) * x / (x1 - x2) + (x1 * y2 - x2 * y1) / (x1 - x2);
	    };
	    for (var i = 0; i < pointArr.length - 1; i++) {
	        var p = _mapObj.getPixelFromCoordinate(ol.proj.transform(pointArr[i],
	            'EPSG:4326', 'EPSG:3857')),
	            pNext = _mapObj.getPixelFromCoordinate(ol.proj.transform(pointArr[i + 1],
	                'EPSG:4326', 'EPSG:3857'));
	        var increaseFlag = Math.abs(p[0] - pNext[0]) > Math.abs(p[1] - pNext[1]);
	        pixPointArr[i] = [];
	        if (increaseFlag) {
	            var xResFlag = p[0] > pNext[0] ? false : true;
	            if (xResFlag) {
	                for (var lon = p[0]; lon <= pNext[0]; lon = lon + resolution) {
	                    pixPointArr[i].push(_mapObj.getCoordinateFromPixel([lon,
	                        y(lon, p, pNext)]));
	                }
	            } else {
	                for (var lon = p[0]; lon >= pNext[0]; lon = lon - resolution) {
	                    pixPointArr[i].push(_mapObj.getCoordinateFromPixel([lon,
	                        y(lon, p, pNext)]));
	                }
	            }
	        } else {
	            var yResFlag = p[1] > pNext[1] ? false : true;
	            if (yResFlag) {
	                for (var lat = p[1]; lat <= pNext[1]; lat = lat + resolution) {
	                    pixPointArr[i].push(_mapObj.getCoordinateFromPixel([x(lat, p, pNext),
	                        lat]));
	                }
	            } else {
	                for (var lat = p[1]; lat >= pNext[1]; lat = lat - resolution) {
	                    pixPointArr[i].push(_mapObj.getCoordinateFromPixel([x(lat, p, pNext),
	                        lat]));
	                }
	            }
	        }
	    }
	    return pixPointArr;
	}

	/**
	 * 将一个数组根据传入的点分为两个数组返回
	 * @param pointArr 被拆分的数组
	 * @param point 要拆分的点
	 * @param flag 数组的顺序，用来区分被拆分的数组那部分有用,true为前部分为剩余，false为后面部分剩余
	 * @returns {*[]}，第一部分有用数组，第二部分为剩余数组
	 */
	function _calSparePoint(pointArr, point, flag) {
	    var index = 0;
	    for (var i = 0; i < pointArr.length; i++) {
	        if (Math.abs(point[0] - pointArr[i][0]) < 0.0001 &&
	            Math.abs(point[1] - pointArr[i][1]) < 0.00001) {
	            index = i;
	            break;
	        }
	    }
	    tempArr1 = pointArr.slice(0, index + 1);
	    tempArr2 = pointArr.slice(index + 1, pointArr.length);
	    return [flag ? tempArr2 : tempArr1, flag ? tempArr1 : tempArr2];
	}

	/**
	 * 比较三个点之间长度
	 * @param publicPoint 公共的点
	 * @param pointOne
	 * @param pointTwo
	 * @returns {*} 当第一个点距离公共点较近返回true
	 */
	function _comparePointsLength(publicPoint, pointOne, pointTwo) {
	    var lengthOne = new ol.geom.LineString(
	        [ol.proj.transform(publicPoint, 'EPSG:4326', 'EPSG:3857'),
	        ol.proj.transform([pointOne[0], pointOne[1]], 'EPSG:4326', 'EPSG:3857')]).
	        getLength();
	    var lengthTwo = new ol.geom.LineString([
	        ol.proj.transform(publicPoint, 'EPSG:4326', 'EPSG:3857'),
	        ol.proj.transform([pointTwo[0], pointTwo[1]], 'EPSG:4326', 'EPSG:3857')]).
	        getLength();
	    return lengthOne > lengthTwo ? pointTwo : pointOne;
	}

	/***
	 * 处理polyline选路时单击返回的值
	 * @param result 请求的返回值
	 */
	function _dealResult(result, coordinates, requestNum, preRoadObj) {
	    var preRoad = JSON.parse(JSON.stringify(preRoadObj));
	    var roadsObj = [];
	    if (result && !result.message) {
	        if (requestNum === 1) {
	            result = {
	                geometries: [{
	                    paths: [[[result.point.x, result.point.y, result.point.m]]],
	                    routeId: result.routeId,
	                    layerId: result.layerId,
	                    length: 0
	                }]
	            };
	        } else {
	            _.each(result.geometries, function (geometry) {
	                roadsObj.push(geometry);
	            });
	        }
	        //标识后台返回到了的数据，和道路断点距离所点的点最近的一个点
	        var lastGeometry, nearerPoint;

	        if (result.geometries.length !== 1) {
	            if (result.geometries[0].routeId === preRoad.routeId) {
	                lastGeometry = _.last(result.geometries);
	            } else {
	                lastGeometry = _.first(result.geometries);
	            }
	            nearerPoint = _comparePointsLength(
	                coordinates, _.first(lastGeometry.paths[0]),
	                _.last(lastGeometry.paths[0])
	            );
	        } else {
	            lastGeometry = _.first(result.geometries);
	            if (_.isEmpty(preRoad)) {
	                nearerPoint = _comparePointsLength(
	                    coordinates, _.first(lastGeometry.paths[0]),
	                    _.last(lastGeometry.paths[0])
	                );
	            } else {
	                if (preRoad.geometry.x ===
	                    _.last(lastGeometry.paths[0])[0] ||
	                    preRoad.geometry.y ===
	                    _.last(lastGeometry.paths[0])[1]) {
	                    nearerPoint = _.first(lastGeometry.paths[0]);
	                } else {
	                    nearerPoint = _.last(lastGeometry.paths[0]);
	                }
	            }
	        }

	        preRoad = {
	            routeId: lastGeometry.routeId,
	            layerId: lastGeometry.layerId,
	            geometry: {
	                x: nearerPoint[0],
	                y: nearerPoint[1],
	                m: parseInt(nearerPoint[2])
	            }
	        };
	        return {
	            selectRoads: roadsObj,
	            preRoadObj: preRoad
	        }
	    }
	}

	/**
	 * 将polyline模式获取的道路数据道路数据按道路Id整合
	 * @param roadData 道路数据
	 * @theSameFlag  道路起点和终点是否相同的标识
	 * @returns {Array} 整合后的道路数据
	 */
	function _groupTheSameRoad(roadData) {
	    var sourceData = _.groupBy(roadData, function (data) {
	        return data.routeId
	    });
	    var uniqData = _.map(sourceData, function (o) {
	        for (var i = 1; i < o.length; i++) {
	            o[0].paths[0] = o[0].paths[0].concat(o[i].paths[0]);
	        }

	        o[0].paths[0] = _.sortBy(o[0].paths[0], function (mile) {
	            return mile[2];
	        });
	        o[0].paths[0] = _.uniq(o[0].paths[0], function (item) {
	            return item[2]
	        });
	        var pathLength = o[0].paths[0].length;
	        o[0].length = parseInt(o[0].paths[0][pathLength - 1][2] - o[0].paths[0][0][2]);
	        return o[0];
	    });
	    return uniqData
	}

	/**
	 * 根据传入的点列表  在去重后计算各点之间的总和
	 * @param vertexs
	 * @returns {number}
	 */
	function _calVertexesLength(vertexs) {
	    var length = 0;
	    vertexs = _.uniq(vertexs);
	    for (var i = 0; i < vertexs.length; i++) {
	        if (i <= vertexs.length - 2) {
	            length += new ol.Sphere(6378137).haversineDistance([vertexs[i][0], vertexs[i][1]],
	                [vertexs[i + 1][0], vertexs[i + 1][1]]);
	        }
	    }
	    return length
	}

	/**
	 * 根据两个点计算点之间的举例
	 */
	function _calDistanceByPoint(point1, point2) {
	    var firstPoint = [point1[0], point1[1]];
	    var lastPoint = [point2[0], point2[1]];
	    var length = new ol.Sphere(6378137).haversineDistance(firstPoint, lastPoint);
	    return length;
	}

	/**
	 * 发送请求
	 * @param path
	 * @param data
	 * @param success
	 * @param failure
	 * @private
	 */
	function _crossDomainRequest(path, data, success, failure) {

	    if (GisToken === {}) {
	        console.error('no domain setting. Please execute crossDomainHandshake first.');
	        return;
	    }

	    function htmlDecode(text) {
	        var temp = document.createElement('div');
	        temp.innerHTML = text;
	        var output = temp.innerText || temp.textContent;
	        temp = null;
	        return output;
	    }
	    var xml_http;

	    path = '/CosmosGISMaster' + path;

	    xml_http = new XMLHttpRequest();
	    xml_http.open("POST", path, true);
	    xml_http.setRequestHeader(GisToken.name, GisToken.value);
	    xml_http.send(JSON.stringify(data));
	    xml_http.onreadystatechange = function () {
	        if (xml_http.readyState === 4 && xml_http.status === 200) {
	            success(htmlDecode(xml_http.responseText));
	        } else {
	            if (xml_http.readyState === 4) {
	                console.error(path + ' response error');
	            }
	        }
	    }
	}

	module.exports = {
	    initRoadMgt: initRoadMgt,
	    chooseRoads: chooseRoads,
	    editRoads: editRoads,
	    setRoadLayers: setRoadLayers,
	    editCancel: editCancel,
	    changeLineStyle: changeLineStyle,
	    drawRouteLine: drawRouteLine,
	    initRoadParams: initRoadParams,
	    chooseRoadCancel: chooseRoadCancel,
	    removeRoadDataOnMap: removeRoadDataOnMap,
	    removeRoadInRoadMgt: removeRoadInRoadMgt,
	    selRoadOnMap: selRoadOnMap,
	    setWMSExtent: setWMSExtent,
	    removeFeatureDataByIdList: removeFeatureDataByIdList
	};


/***/ },
/* 144 */
/*!***************************************!*\
  !*** ./src/gis/layers/iconCluster.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);

	var map = new Map();
	var imgPath = constant.GisResourceURL + 'marker/';

	var addLayer = function(paramObj) {
		var _layerIdentify = paramObj.layerId + '_' + paramObj.mapId;
		var _clusterStyle = paramObj.clusterStyle || {};
		var fontColor = _clusterStyle.fontColor || '#ffffff';
		var distance = _clusterStyle.distance || 50;
		if(paramObj.isClusterVariableSize === undefined) {
			paramObj.isClusterVariableSize = false;
		}

		paramObj.distance = distance;
		var _clusterStyleFunc = function(feature, resolution) {
			var _imgUrl = null;
			var _features = feature.get('features');
			var iconData = _features[0].get('data');
			var _size = _features.length;
			if(!!iconData && iconData.imageName) {
				_imgUrl = imgPath + iconData.imageName;
			} else {
				_imgUrl = constant.GisResourceURL + 'marker/ne_default.png';
			}

			var _rotation = 0;
			if(!!!iconData.rotation) {
				_rotation = 0;
			} else {
				_rotation = iconData.rotation;
			}
			if(_size > 1) {
				return [
					new ol.style.Style({
						image: new ol.style.Icon({
							src: constant.GisResourceURL + 'marker/ne_default.png',
							rotation: _rotation,
							opacity: iconData.opacity || 1,
							anchor: iconData.anchor != undefined ? iconData.anchor : [0, 0]
						}),
						text: new ol.style.Text({
							scale: 1.5,
							text: _size.toString(),
							fill: new ol.style.Fill({
								color: fontColor
							}),
							stroke: new ol.style.Stroke({
								width: 3,
								color: 'black'
							})
						})
					})
				];
			} else {
				return [
					new ol.style.Style({
						image: new ol.style.Icon({
							src: _imgUrl,
							rotation: _rotation,
							opacity: iconData.opacity || 1,
							anchor: iconData.anchor != undefined ? iconData.anchor : [0, 0]
						}),
						text: new ol.style.Text({
							text: (iconData.label != undefined ? iconData.label : '') + ''
						})
					})
				];
			}
		};

		var _layer = null;
		if(hashMap.containsKey(_layerIdentify)) {
			_layer = hashMap.get(_layerIdentify);
		} else {
			baseLayer.createLayer(paramObj);
			_layer = hashMap.get(_layerIdentify);
		}
		var _ZIndex = paramObj.zindex !== undefined ? paramObj.zindex : constant.Z_INDEX.MARKER;
		_layer.setZIndex(_ZIndex);
		_layer.setStyle(_clusterStyleFunc);
		_layer.set('businessType', 'ICON_CLUSTER');
		_layer.set('isImgType',true);
		_layer.set('params.label', paramObj.label ? paramObj.label : paramObj.layerId);
		_layer.set('state.showLabel', !!paramObj.showLabel);
		_layer.set('layerId', _layerIdentify);
		_layer.set('layer_id', paramObj.layerId);
		_layer.set('legendName', paramObj.legendName);
		if (paramObj.minShowLevel != undefined) {
			_layer.set('minShowLevel', parseInt(paramObj.minShowLevel));
		}

		if (paramObj.maxShowLevel != undefined) {
			_layer.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
		}
	};

	var setLayerData = function(paramObj) {
		var _layerIdentify = paramObj.layerId + '_' + paramObj.mapId;
		var _data = paramObj.datas;
		var _layer = hashMap.get(_layerIdentify);
		var _source = null;
		var isCluster = paramObj.isCluster === undefined ? true : paramObj.isCluster;
		if(_layer) {
			_layer.set('legendName', paramObj.legendName);
			if(paramObj.label) {
				_layer.set('params.label', paramObj.label);
			}
			_source = isCluster === true ? _layer.getSource().getSource() : _layer.getSource();
		}

		if(!!paramObj.imgPath) {
			imgPath = paramObj.imgPath;
		}

		if(!!_data) {
			var _features = [];
			_data.forEach(function(iconData) {
				var _imgUrl = null;
				var _selectImgUrl = null;
				var _coordinate = iconData.coordinate;

				var coordinate_ = ol.proj.fromLonLat(utils.gcjTransform(_coordinate));
				var _point = new ol.geom.Point(coordinate_);
				var _feature = new ol.Feature({
					geometry: _point,
					businessType: constant.BUSINESSTYPE.ICON,
					data: iconData
				});
				if(iconData.imageName) {
					_imgUrl = imgPath + iconData.imageName;
				} else {
					_imgUrl = constant.GisResourceURL + 'marker/ne_default.png';
				}

				var _rotation = 0;
				if(!!!iconData.rotation) {
					_rotation = 0;
				} else {
					_rotation = iconData.rotation;
				}
				_feature.set('vectorType', 'ICON_CLUSTER');
				_feature.setId(iconData.id);
				_feature.set('layer',_layer);
				_feature.set('data', iconData);
				_features.push(_feature);
			});
			_source.addFeatures(_features);
			_layer.set('legendName', paramObj.legendName);
		}
	};

	module.exports = {
		addLayer: addLayer,
		setLayerData: setLayerData
	};

/***/ },
/* 145 */
/*!************************************!*\
  !*** ./src/gis/layers/wmsLayer.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	/*创建wms图层*/
	var wmsLayer = function(paramObj) {
		var _layerId = paramObj.layerId + '_' + paramObj.mapId;
		var _tileLayers = null;
		var _mapObj = mapBox.getMapObj(paramObj.mapId);

		if(paramObj.singleTitle) {
			_tileLayers = new ol.layer.Image({
				source: new ol.source.ImageWMS({
					ratio: paramObj.ratio,
					url: paramObj.url,
					params: paramObj.params
				})
			});
			_tileLayers.set('type', constant.CUSTOMTYPE.LAYERIMGTYPE);
			_tileLayers.set('businessType', constant.CUSTOMTYPE.LAYERIMGTYPE);
		} else {
			_tileLayers = new ol.layer.Tile({
				source: new ol.source.TileWMS({
					url: paramObj.url,
					params: paramObj.params,
					wrapX:false
				})
			});
			_tileLayers.set('type', constant.CUSTOMTYPE.LAYERTILETYPE);
			_tileLayers.set('businessType', constant.CUSTOMTYPE.LAYERTILETYPE);

		}

		_tileLayers.set('layerId', _layerId);
		_tileLayers.set('layer_id', paramObj.layerId);
		if(paramObj.zindex!==undefined){
			_tileLayers.setZIndex(paramObj.zindex);
		}
		if (paramObj.minShowLevel != undefined) {
			_tileLayers.set('minShowLevel', parseInt(paramObj.minShowLevel));
		}

		if (paramObj.maxShowLevel != undefined) {
			_tileLayers.set('maxShowLevel', parseInt(paramObj.maxShowLevel));    
		}

		hashMap.put(_layerId, _tileLayers);
		_mapObj.addLayer(_tileLayers);
		return _tileLayers;
	};

	module.exports = {
		createWmsLayer: wmsLayer
	};

/***/ },
/* 146 */
/*!****************************************!*\
  !*** ./src/gis/layers/servicelayer.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var baseLayer = __webpack_require__(/*! layers/baseLayer */ 6);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);

	var _indentifyURL = {}, domain = '/CosmosGISMaster';
	/**
	 * 添加图层
	 * @param mapId
	 * @param param
	 */
	function addLayer(mapId, param) {
	    var mapObj = mapBox.getMapObj(mapId);
	    var _layerId = param.layerId + '_' + param.mapId;
	    var layerObj = new ol.layer.Image({
	        layerName: param.layerId,
	        defaultVisibleLevel: param.defaultVisibleLevel,
	        source: new ol.source.ImageWMS({wrapX: false})
	    });
	    layerObj.set('layerId', _layerId);
	    layerObj.set('layer_id',param.layerId);
	    layerObj.set('businessType', 'SERVICELAYER');
	    layerObj.set('serviceLayerType', param.layerType);
	    if (param.zindex !== undefined) {
	        layerObj.setZIndex(param.zindex);
	    }
	    mapObj.addLayer(layerObj);
	    hashMap.put(_layerId, layerObj);
	}

	/**
	 * 设置数据
	 * @param mapId
	 * @param layerId
	 * @param param
	 */
	function setData(mapId, layerId, param) {
	    var sourceParam = {
	        FORMAT: 'png',
	        VERSION: '1.1.1',
	        F: 'image',
	        BBOXSR: 3857,
	        IMAGESR: 3857
	    };
	    for (var o in param) {
	        if (o !== 'url'&&o !== 'roadtype') {
	            sourceParam[o] = param[o];
	        }
	    };
	    var layerObj = baseLayer.getLayer({
	        mapId: mapId,
	        layerId: layerId
	    });
	    var source = new ol.source.ImageWMS({
	        url: param.url,
	        params: sourceParam,
	        wrapX: false
	    });
	    layerObj.set('layerData', param);
	    layerObj.setSource(source);
	}

	/**
	 * 注册图层事件
	 * @param mapId
	 * @param layerId
	 * @param callback
	 */
	function registerEvent(mapId, layerId, callback, url) {
	    _indentifyURL[layerId] = url;
	    var param = {
	        mapId: mapId,
	        layerId: layerId,
	        callbackfunc: getServiceLayerInfo
	    };
	    baseLayer.registerClick(param);
	}

	/**
	 * 处理问题区域的数据，供点击返回值使用
	 * @param {*} mapId
	 * @param {*} layerId
	 * @param {*} lonLat
	 * @param {*} data
	 */
	function _clickWorstarea(mapObj, _layer, e, callback) {
	    var layerId = _layer.get('layerName'),
	        lonLat = ol.proj.transform(e.coordinate, 'EPSG:3857', 'EPSG:4326'),
	        mapId = mapObj.getTarget();
	    var geometry = JSON.stringify({x: e.coordinate[0], y: e.coordinate[1]});
	    var mapExtent = mapObj.getView().calculateExtent(mapObj.getSize()).join(',');
	    var params = {
	        geometry: geometry,
	        tolerance: 1,
	        mapExtent: mapExtent,
	        imgToken: _layer.get('layerData').imgToken
	    };
	    _crossDomainRequest(_indentifyURL[layerId], params, 'GET', function(res) {
	        res = JSON.parse(res);
	        if (res && res.results && res.results.length > 0) {
	            var resData = [];
	            res.results.forEach(function(ele) {
	                var coordinate3857 = ol.proj.fromLonLat([
	                    Number(ele.attributes.CENTERPOINTLON),
	                    Number(ele.attributes.CENTERPOINTLAT)
	                ]);
	                ele.attributes.CENTERPOINTLON = coordinate3857[0];
	                ele.attributes.CENTERPOINTLAT = coordinate3857[1];
	                var backJson = {
	                    layerId: layerId,
	                    mapId:mapId,
	                    geoId: ele.attributes.WORSTAREAID,
	                    layerType: 'WORSTAREA',
	                    lonLat: lonLat,
	                    pixLonLat:lonLat,
	                    featureName:ele.attributes&&ele.attributes.WORSTAREANAME,
	                    dataType: 'LTE',
	                    label: '',
	                    jsonData: ele.geometry,
	                    orignData: ele.attributes
	                };
	                resData.push(backJson);
	            });
	            callback(resData);
	        }else{
	            callback([{layerId: layerId}]);
	        }

	    }, function() {
	        callback([{
	            layerId: layerId
	        }]);
	    });
	}

	/**
	 * 处理高铁返回的数据，供点击使用
	 * @param {*} mapId
	 * @param {*} layerId
	 * @param {*} lonLat
	 * @param {*} data
	 */
	function _clickRailway(mapObj, _layer, e, callback) {
	    var mapId = mapObj.getTarget(), layerId = _layer.get('layerName');
	    var clickCoordinate = ol.proj.transform(e.coordinate, 'EPSG:3857', 'EPSG:4326');
	    var geometry = {
	        x: clickCoordinate[0],
	        y: clickCoordinate[1]
	    };
	    var mapExtent = mapObj.getView().calculateExtent(mapObj.getSize()).join(',');
	    var layerData = _layer.get('layerData');
	    var params = {
	        subject: {
	            param: {},
	            formatter: {
	                date: 'yyyy-MM-dd'
	            }
	        },
	        services: [{
	            name: 'railwayInfo',
	            param: {
	                roadtype: layerData.roadtype,
	                imgToken: layerData.imgToken,
	                geometry: geometry
	            }
	        }]
	    };
	    var backJson = {layerId: layerId};
	    _crossDomainRequest(_indentifyURL[layerId], params, 'POST', function(res) {
	        res = JSON.parse(res);
	        if (res && res.data && res.data.railwayInfo && res.data.railwayInfo.geometries) {
	            var points = [];
	            res.data.railwayInfo.geometries.forEach(function(ele,index){
	                points[index] = [];
	                ele.paths[0].forEach(function(p){
	                    points[index].push([p[0],p[1]]);
	                });
	            });
	            backJson = [{
	                layerId: layerId,
	                mapId:mapId,
	                layerType: _layer.get('serviceLayerType'),
	                geoId:res.data.railwayInfo.geometries[0].layerId,
	                lonLat:clickCoordinate,
	                pixLonLat:clickCoordinate,
	                jsonData: points,
	                originData: res.data.railwayInfo.properties,
	                featureName: 'Railway'
	            }];
	            callback(backJson);
	        } else {
	            callback([backJson]);
	        }
	    },
	        function() {
	            _base.log('grid clickFun error!');
	            callback([backJson]);
	        }
	    );
	}
	/**
	 * 点击地图的时候获取服务图层的信息
	 * @param {*} mapObj  地图OL对象
	 * @param {*} _layer  图层OL对象
	 * @param {*} e       点击事件对象
	 * @param {*} callback 回调函数
	 */
	function getServiceLayerInfo(mapObj, _layer, e, callback) {

	    if (_layer.get('serviceLayerType') === 'RAILWAY') {
	        _clickRailway(mapObj, _layer, e, callback);
	    } else if (_layer.get('serviceLayerType') === 'WORSTAREA') {
	        _clickWorstarea(mapObj, _layer, e, callback);
	    }
	}

	/**
	 * 发送请求
	 * @param path
	 * @param data
	 * @param success
	 * @param failure
	 * @private
	 */
	function _crossDomainRequest(path, data, type, success, failure) {

	    if ($g.cosMosGisMasterCsrfHeader === '') {
	        console.error('no domain setting. Please execute crossDomainHandshake first.');
	        return;
	    }

	    function htmlDecode(text) {
	        var temp = document.createElement('div');
	        temp.innerHTML = text;
	        var output = temp.innerText || temp.textContent;
	        temp = null;
	        return output;
	    }
	    var xml_http;

	    path = domain + path;

	    xml_http = new XMLHttpRequest();

	    if (type === 'POST') {
	        xml_http.open(type, path, true);
	        xml_http.setRequestHeader($g.cosMosGisMasterCsrfHeader, $g.cosMosGisMasterCsrfToken);
	        xml_http.send(JSON.stringify(data));
	    } else {
	        var param = _getParameterString(data);
	        xml_http.open(type, path + param, true);
	        xml_http.setRequestHeader($g.cosMosGisMasterCsrfHeader, $g.cosMosGisMasterCsrfToken);
	        xml_http.send('');
	    }
	    xml_http.onreadystatechange = function() {
	        if (xml_http.readyState === 4 && xml_http.status === 200) {
	            success(htmlDecode(xml_http.responseText));
	        } else {
	            if (xml_http.readyState === 4) {
	                console.error(path + ' response error');
	            }
	        }
	    };
	}

	function _getParameterString(params) {
	    var paramsArray = [];
	    for (var key in params) {
	        var value = params[key];
	        if ((value !== null) && (typeof value !== 'function')) {
	            var encodedValue;
	            if (typeof value === 'object' && value.constructor === Array) {
	                /* value is an array; encode items and separate with "," */
	                var encodedItemArray = [];
	                var item;
	                for (var itemIndex = 0, len = value.length; itemIndex < len; itemIndex++) {
	                    item = value[itemIndex];
	                    encodedItemArray.push(encodeURIComponent(
	                        (item === null || item === undefined) ? '' : item)
	                    );
	                }
	                encodedValue = encodedItemArray.join(',');
	            }
	            else {
	                /* value is a string; simply encode */
	                encodedValue = encodeURIComponent(value);
	            }
	            paramsArray.push(encodeURIComponent(key) + '=' + encodedValue);
	        }
	    }

	    return paramsArray.join('&');
	}
	/**
	 * 高亮问题区域
	 * @param {*} mapId
	 * @param {*} layerId
	 * @param {*} params
	 */
	function _highlightWorstArea(mapId, layerId, params) {
	    _queryWorstArea(params, function(backJson) {
	        var highLayer = highlights.getHLayer({mapId: mapId, layerId: layerId});
	        var hiFeature = new ol.Feature({
	            geometry: new ol.geom.Polygon(backJson.rings)
	        });
	        hiFeature.setStyle(new ol.style.Style({
	            fill: new ol.style.Fill({
	                color: [0, 0, 0, 0]
	            }),
	            stroke: new ol.style.Stroke({
	                width: 2,
	                color: [0, 0, 0, 1]
	            })
	        }));
	        hiFeature.setId('serviceLayer_' + layerId);
	        highLayer.getSource().addFeature(hiFeature);
	    });
	}
	/**
	 * 高亮高铁线路
	 * @param {*} mapId
	 * @param {*} layerId
	 * @param {*} params
	 */
	function _highlightTHSR(mapId, layerId, params) {
	    var width = params.width||3,color = params.strokeColor||'rgba(255,255,255,0.9)';
	    var style = new ol.style.Style({
	        stroke:new ol.style.Stroke({
	            color:color,
	            width:width
	        })
	    });
	    var highLayer = highlights.getHLayer({mapId: mapId, layerId: layerId});
	    var highFea = highLayer.getSource().getFeatureById('serviceLayer_'+layerId);
	    if(highFea){
	        highLayer.getSource().removeFeature(highFea);
	    }
	    _queryRailway(params, function(backData) {
	        if (backData !== null) {

	            var hiFeature = new ol.Feature({
	                geometry: new ol.geom.MultiLineString(backData.jsonData).transform('EPSG:4326',
	                    'EPSG:3857'),
	                mapId: mapId,
	                layerName: layerId
	            });
	            hiFeature.setStyle(style);
	            hiFeature.setId('serviceLayer_' + layerId);
	            highLayer.getSource().addFeature(hiFeature);
	        }
	    })
	}

	/**
	 * 查询问题区域数据(常说的query接口)
	 * @param {*} mapId
	 * @param {*} layerId
	 * @param {*} ids
	 * @param {*} callback
	 */
	function _queryWorstArea(params, callback) {
	    var action;
	    if (params.dataType === 'UMTS') {
	        action = '/worstArea/_img_get/services/DisCoverGeo/UWorstArea/MapServer' +
	            '/0/query?where=WORSTAREAID in (' + params.featureId + ')&date=' + params.date;
	    } else if (params.dataType === 'LTE') {
	        action = '/worstArea/_img_get/services/DisCoverGeo/LWorstArea/MapServer' +
	            '/0/query?where=WORSTAREAID in (' + params.featureId + ')&date=' + params.date;
	    } else {
	        action = '/worstArea/_img_get/services/DisCoverGeo/GWorstArea/MapServer' +
	            '/0/query?where=WORSTAREAID in (' + params.featureId + ')&date=' + params.date;
	    }
	    _crossDomainRequest(action, {}, 'GET',
	        function(rs) {
	            var JsonRs = JSON.parse(rs);
	            if (rs === '{}' || JsonRs.error || (JsonRs.data&&JsonRs.data.features.length === 0)) {
	                callback(null);
	            } else {
	                var backJson = JsonRs.data.features[0].geometry;
	                callback(backJson);
	            }
	        });
	}

	/**
	 * 查询高铁信息(常用的query请求)
	 * @param {*} parms
	 * @param {*} callback
	 */
	function _queryRailway(params, callback) {
	    var action = '/railwayMgr.do?';
	    var param = {
	        subject: {
	            param: {},
	            formatter: {
	                date: 'yyyy-MM-dd'
	            }
	        },
	        services: [{
	            name: 'railwayByDimension',
	            param: params.featureIds
	        }]
	    };
	    _crossDomainRequest(action, param, 'POST', function(rs) {
	        var JsonRs = JSON.parse(rs);
	        if (!(JsonRs && JsonRs.data && JsonRs.data.railwayByDimension.geometries)) {
	            callback(null);
	        } else {
	            var points = [];
	            JsonRs.data.railwayByDimension.geometries.forEach(function(o, index) {
	                points[index] = [];
	                o.paths[0].forEach(function(p) {
	                    points[index].push([p[0], p[1]]);
	                });
	            });
	            var backJson = {
	                layerName: params.layerName,
	                layerType: params.layerType,
	                label: params.label,
	                jsonData: points,
	                originData: JsonRs,
	                persistHighLightFlag: params.persistHighLightFlag
	            };
	            callback(backJson);
	        }
	    },
	        function(e) {
	            _base.log(e);
	        });
	}

	/**
	 *  高亮元素
	 * @param {*地图Id} mapId
	 * @param {*图层id} layerId
	 * @param {*} params
	 */
	function highlight(mapId, layerId, params) {
	    var layerType = baseLayer.getLayer({
	        mapId: mapId,
	        layerId: layerId
	    }).get('serviceLayerType');
	    if (layerType === 'WORSTAREA') {
	        _highlightWorstArea(mapId, layerId, params);
	    } else if (layerType === 'RAILWAY') {
	        _highlightTHSR(mapId, layerId, params);
	    }
	}

	/**
	 * 去除高亮效果
	 * @param {*} mapId
	 * @param {*} layerId
	 */
	function removeHighlight(mapId, layerId) {
	    var highLayer = highlights.getHLayer({mapId: mapId, layerId: layerId});
	    var highFea = highLayer.getSource().getFeatureById('serviceLayer_' + layerId);
	    if (highLayer && highLayer.getSource() && highFea) {
	        highLayer.getSource().removeFeature(highFea);
	    }
	}

	module.exports = {
	    addLayer: addLayer,
	    setData: setData,
	    registerEvent: registerEvent,
	    highlight: highlight,
	    removeHighlight: removeHighlight,
	    getServiceLayerInfo: getServiceLayerInfo
	};


/***/ },
/* 147 */
/*!******************************************!*\
  !*** ./src/gis/utils/filterFeatureUI.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	var domUtil = __webpack_require__(/*! utils/domUtil */ 10);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var hashMap = __webpack_require__(/*! framework/hashmap */ 5);
	var eventTool = __webpack_require__(/*! utils/eventTool */ 62);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var i18n = __webpack_require__(/*! utils/i18n */ 13);


	var _filterFeatureWinTitle = i18n.prop('filterFeature.wind.head.title');
	var _closeWinBtnTitle = i18n.prop('filterFeature.wind.close.title');
	var _layerId = i18n.prop('filterFeature.body.layerId');
	var _layerOpt = i18n.prop('featureFilter.layerTypeSel');

	function header_(_filterFeatureWind) {
	    var header = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            class: 'filter_feature_head_class',
	            style: 'width: 400px; height: 24px; line-height: 24px; text-indent: 8px; color: #388E8E;' +
	            'border-bottom-style: solid; border-bottom-color: #EBEBEB;border-bottom-width: 1px;'
	        },
	        text: _filterFeatureWinTitle
	    });
	    _filterFeatureWind.appendChild(header);

	    var closeBtn = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            title: _closeWinBtnTitle,
	            style: 'width: 16px; height: 16px;line-height: 16px;text-align: center; background: #388E8E; ' +
	            'color: white; position: absolute;top: 4px; right: 4px;cursor: pointer;text-indent: 0px;'
	        },
	        text: 'X'
	    });
	    eventTool.add(closeBtn, 'click', function () {
	        _filterFeatureWind.style.display = 'none';
	    });
	    header.appendChild(closeBtn);
	}

	function body_(paramObj, _filterFeatureWind) {
	    var _mapObj = hashMap.get(paramObj.mapId);
	    var _businessLayes = (function () {
	        var layers = [];
	        var _olLayers = _mapObj.getLayers().getArray();
	        for (var i = 0; i < _olLayers.length; i++) {
	            if (_olLayers[i].get('businessType') != undefined) {
	                if (_olLayers[i].get('isCluster') || _olLayers[i].get('businessType') === 'ICON') {
	                    continue;
	                }
	                if (_olLayers[i].get('params.label') != undefined) {
	                    layers.push(_olLayers[i].get('params.label') + '|' + _olLayers[i].get('layer_id'));
	                }
	                else {
	                    layers.push(_olLayers[i].get('layer_id') + '|' + _olLayers[i].get('layer_id'));
	                }
	            }
	        }
	        return layers;
	    }());
	    var _divSelect = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            class: 'layerlist'
	        }
	    });

	    var _selectNodeExportType = domUtil.createDom({
	        tagName: 'select',
	        attributes: {
	            name: 'filter_layer_id',
	            class: 'filter_layer_id'
	        }
	    });
	    var _blankOption = domUtil.createDom({
	        tagName: 'option',
	        attributes: {
	            value: 'blank_layerid',
	            selected: true
	        },
	        text: _layerOpt
	    });
	    _selectNodeExportType.appendChild(_blankOption);
	    _businessLayes.forEach((function (attr) {
	        var layerId = attr.split('|')[1];
	        var layer = layers.getLayer({
	            layerId: layerId,
	            mapId: paramObj.mapId
	        });
	        if (layer != undefined) {
	            if (layer.get('businessType') == constant.BUSINESSTYPE.GRID) {
	                return;
	            }
	        }
	        var layerName = attr.split('|')[0];
	        var exportOption = domUtil.createDom({
	            tagName: 'option',
	            attributes: {
	                value: layerName,
	                title: layerName,
	                id: layerId
	            },
	            text: layerName && layerName.length > 30 ? layerName.substring(0, 30) + '...' : layerName
	        });
	        _selectNodeExportType.appendChild(exportOption);
	    }));
	    _divSelect.appendChild(_selectNodeExportType);


	    var _divDrawBbt = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            class: 'drawPolygon'
	        }
	    });

	    _filterFeatureWind.appendChild(_divSelect);
	    _filterFeatureWind.appendChild(_divDrawBbt);

	    var filterLayerIdNode = _mapObj.getTargetElement().querySelector('.filter_layer_id');
	    eventTool.add(filterLayerIdNode, 'change', function () {
	        var _selectLayerId = filterLayerIdNode.selectedOptions[0].id;
	        hashMap.put('layerId_by_polygon_filter', _selectLayerId);
	    });

	    eventTool.add(_divDrawBbt, 'click', function () {
	        var params = {
	            mapId: paramObj.mapId,
	            type: 'Polygon',
	            isOpen: true,
	            fillColor: 'rgba(0, 191, 255, 0.76)',
	            endCallback: function (res) {
	                var _mapId = paramObj.mapId;
	                var _layerId = hashMap.get('layerId_by_polygon_filter');
	                var _imgToken = (function () {
	                    var layer = hashMap.get(_layerId + '_' + paramObj.mapId);
	                    if (layer && layer.get('imagToken')) {
	                        return layer.get('imgToken');
	                    }
	                    else {
	                        return undefined;
	                    }
	                }());
	                var _coordinates = res.coordinates;
	                if (paramObj.callback != undefined && typeof paramObj.callback == 'function') {
	                    paramObj.callback({
	                        mapId: _mapId,
	                        layerId: _layerId,
	                        imgToken: _imgToken,
	                        coordinates: _coordinates
	                    });
	                }

	                hashMap.put('layerId_by_polygon_filter', undefined);
	            }
	        }

	        if (hashMap.get('layerId_by_polygon_filter') != undefined) {
	            console.warn('please select the layer');
	            fusiongis.Geometry.drawGeometry(params);
	        }

	        _filterFeatureWind.style.display = 'none';
	    });
	}


	var _filterFeatureUI = function (paramObj) {
	    hashMap.put('layerId_by_polygon_filter', undefined);
	    var targetElement = hashMap.get(paramObj.mapId).getTargetElement();
	    var _win = targetElement.querySelector('.filter_feature_by_polygon_window');
	    if (!!_win) {
	        targetElement.removeChild(_win);
	    }
	    var _filterFeatureWind = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            class: 'filter_feature_by_polygon_window'
	        }
	    });
	    targetElement.appendChild(_filterFeatureWind);

	    header_(_filterFeatureWind);
	    body_(paramObj, _filterFeatureWind);
	};


	module.exports = {
	    filterFeatureUI: _filterFeatureUI
	};

/***/ },
/* 148 */
/*!****************************************************!*\
  !*** ./src/gis/tools/layerFilteringHighlighted.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var ajax = __webpack_require__(/*! utils/ajax */ 14);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var layers = __webpack_require__(/*! layers/layers */ 41);
	var utils = __webpack_require__(/*! utils/util */ 1);
	var constant = __webpack_require__(/*! framework/constant */ 2);
	var highlights = __webpack_require__(/*! layers/highlight */ 43);

	var ol = __webpack_require__(/*! ol */ 4);

	function layerHighlight(param) {
		var layerId = param.layerId;
		var mapId = param.mapId;
		var polygonCoords = param.coordinates;
		var layerCategory = null;

		var layer = layers.getLayer({
			mapId: mapId,
			layerId: layerId
		});
		if(!!layer) {
			var imgToken = layer.get('imgToken') ? layer.get('imgToken') : layer.get('params.imgToken');
			if(!layer.getVisible()){//图层被隐藏
				return;
			}
			if(imgToken) { //服务图层
				layerCategory = 1;
				getServiceData(imgToken, polygonCoords, function(responseText) {
					// 得到过滤的框选范围内的图层feature的id并且进行高亮
					var serviceLayerType = layer.get('businessType');
					var resultData = responseText.data;
					var params = {
						mapId: mapId,
						layerId: layerId,
						resultData: resultData,
						layerType: serviceLayerType,
						layerCategory: layerCategory,
						layer: layer
					};
					highLightFilterFeatures(params);
				});

			} else { //矢量图层
				layerCategory = 0;
				var vectorLayerType = layer.get('businessType');
				var vectorParams = {
					layer: layer,
					polygonCoords: polygonCoords,
					layerType: vectorLayerType
				};
				getVectorLayerData(vectorParams, function(datas) {
					var params = {
						mapId: mapId,
						layerId: layerId,
						resultData: datas,
						layerType: vectorLayerType,
						layerCategory: layerCategory,
						layer: layer
					};
					highLightFilterFeatures(params);
				});
			}

		}

	}

	function getServiceData(imgToken, coords, callBack) {
		var callback = callBack;
		//调用转换WKT格式的接口将点集转换为
		var pointsParam = utils.translateVertexToWKT([coords]);
		ajax.postJSON({
			url: constant.GisRootUrl + "/mapRender/contains",
			data: JSON.stringify({
				"polygon": pointsParam,
				"imgToken": imgToken
			}),
			success: function(result) {
				var responseText = JSON.parse(result);
				var status = responseText.status;
				if(status.code === 1) {
					callback(responseText);
				}
			},
			failure: function(result) {
				callback({
					msg: result
				});
			}
		})

	}
	/*取框选的多边形范围内的feature*/
	function getVectorLayerData(vectorParams, callBack) {
		var vectorLayer = vectorParams.layer;
		var vectorFeatures = vectorLayer.getSource().getFeatures();
		var callBack = callBack;
		var coordinates = [];
		var layerType =vectorParams.layerType;
		var polygonCoords = vectorParams.polygonCoords;
		var tempPolygonCoords = [];

		if(polygonCoords.length > 0) {
			for(var j = 0; j < polygonCoords.length; j++) { //4326转换为3857格式
				var singleCoord = ol.proj.fromLonLat(polygonCoords[j]);
				tempPolygonCoords.push(singleCoord);
			}
		}
		if(vectorFeatures.length > 0) {
			for(var i = 0; i < vectorFeatures.length; i++) {
				var geom = vectorFeatures[i].getGeometry(); //得到每个feature的geometry;
				var coord = null;
				if(layerType == constant.BUSINESSTYPE.VECTOR_CELL) {
					if(vectorFeatures[i].get('data')) {
						var cellData = vectorFeatures[i].get('data');
						var cellAngle = cellData.angle;
						if(cellAngle === 360) { //是geometry集合
							var geometries = geom.getGeometries();
							for(var j = 0; j < geometries.length; j++) {
								var _geom = geometries[j];
								if(j === geometries.length - 1) {
									if(_geom) {
										coord = _geom.getCoordinates();
									}
								}
							}

						} else {
							coord = geom.getCoordinates();
						}
					}

				} else {
					coord = geom.getCoordinates();
				}

				var geoId = vectorFeatures[i].getId() ? vectorFeatures[i].getId() : vectorFeatures[i].get('id');
				coordinates.push({
					id: geoId,
					geometry: coord
				});
			}

			//调用从polygon中过滤point的方法
			var filterDatas = vectorLayerFilterPoints(tempPolygonCoords, coordinates, vectorParams.layerType);
			callBack(filterDatas);

		}

	}
	//高亮多个过滤之后的features包括矢量的和服务的
	function highLightFilterFeatures(params) {
		var features = null;
		var olLayer = params.layer;

		var layerHighLightParams = {
			mapId: params.mapId,
			layerId: params.layerId,
			layerType: params.layerType,
			layerCategory: params.layerCategory,
			olLayer: olLayer
		};

		features = params.resultData.map(function(data) {
			var pointData = null;
			if(params.layerType == constant.BUSINESSTYPE.CELL) {
				var _polygons = null;
				if($.isArray(data.geometry)) {
					_polygons = data.geometry;
				} else {
					_polygons = JSON.parse(data.geometry);
				}
				pointData = _polygons;
			} else if(params.layerType == constant.BUSINESSTYPE.GRID) {
				var points = data.geometry;
				var lonConstant = 50,
					tempMaxLon, tempMinLon, _points = [];
				tempMinLon = data.centerPoint[0] - lonConstant / 2;
				tempMaxLon = data.centerPoint[0] + lonConstant / 2;
				_points.push([tempMinLon, points[1]]);
				_points.push([tempMaxLon, points[1]]);
				_points.push([tempMaxLon, points[3]]);
				_points.push([tempMinLon, points[3]]);
				pointData = _points;

			} else {
				pointData = data;
			}

			layerHighLightParams.data = pointData;
			return _pointHighLight(layerHighLightParams);
		});

		//得到高亮图层的对象
		var layerObj = highlights.getHLayer({
			mapId: params.mapId,
			layerId: params.layerId
		});
		//添加设置了样式的features
		layerObj.getSource().addFeatures(features);

	}

	/*
	 * geometrys:[] 代表每个图层地图上的所有feature的geometry
	 */
	function vectorLayerFilterPoints(extentCoords, geometrys, layerType) {
		var filterFeaturesArray = [];
		var coordinate = [];

		if(geometrys.length > 0) {
			for(var i = 0; i < geometrys.length; i++) {
				var count = 0;
				var polygonCoords = geometrys[i].geometry; //每个feature的geometry
				var id = geometrys[i].id;

				if(layerType == constant.BUSINESSTYPE.POLYGON ||
				    layerType == constant.BUSINESSTYPE.VECTOR_CELL) {
					coordinate = polygonCoords[0];
				} else {
					coordinate = polygonCoords;
				}

				if(layerType == constant.BUSINESSTYPE.POINT) { //还需要加其他图层类型判断
					var pt = turf.point(coordinate);
					var poly = turf.polygon([extentCoords]);
					var isInside = turf.inside(pt, poly);
					if(isInside) { //点在polygon里面为true
						filterFeaturesArray.push({
							id: id,
							geometry: coordinate
						});
					}
				} else {
					for(var j = 0; j < coordinate.length; j++) {
						var singlePoint = coordinate[j];
						var pt = turf.point(singlePoint);
						/*turf.polygon传入的是二维数组,联调的时候注意*/
						var poly = turf.polygon([extentCoords]);
						var isInside = turf.inside(pt, poly);
						if(isInside) { //点在polygon里面为true
							count++;
						}
					}

					if(count === coordinate.length) { //polygon的所有点都在这个范围内的话,向filterCoords中塞数组
						filterFeaturesArray.push({
							id: id,
							geometry: coordinate
						});
					}
				}

			}
			return filterFeaturesArray;
		}
	}

	function vectorFeatureHihLight(params) {
		var olLayer = params.olLayer;
		if(!!olLayer) {
			var geoId = params.data.id;
			var _feature = olLayer.getSource().getFeatureById(geoId);
			if(_feature) {
				var _tempFeature = _feature.clone();
				_tempFeature.setStyle(params.style);
				return _tempFeature;
			}
		}
	}

	function _pointHighLight(params) {
		var feature = null,
			points = null;
		var _style = null;
		var _commonStyle = new ol.style.Style({
			stroke: new ol.style.Stroke({
				width: 2,
				color: 'black'
			})
		});
		var circleOrSiteStyle = new ol.style.Style({
			image: new ol.style.Circle({
				stroke: new ol.style.Stroke({
					width: 2,
					color: 'black'
				}),
				radius: 5
			})
		});
		
		var layerType = params.layerType;

		if(layerType == constant.BUSINESSTYPE.GRID) {
			points = params.data;
		} else {
			points = params.data.geometry;
		}
		var geometry = null;

		switch(layerType) {
			case constant.BUSINESSTYPE.SERVICEPOINT:
				geometry = new ol.geom.Point(points[0]);
				_style = circleOrSiteStyle;
				break;
			case constant.BUSINESSTYPE.SERVICELINE:
				geometry = new ol.geom.LineString(points);
				_style = _commonStyle;
				break;
			case constant.BUSINESSTYPE.SERVICEPOLYGON:
				geometry = new ol.geom.Polygon([points]);
				_style = _commonStyle;
				break;
			case constant.BUSINESSTYPE.POINT:
				_style = circleOrSiteStyle;
				break;
			case constant.BUSINESSTYPE.LINE:
				_style = _commonStyle;
				break;
			case constant.BUSINESSTYPE.STRAIGHTLINE:
				_style = _commonStyle;
				break;
			case constant.BUSINESSTYPE.POLYGON:
				_style = _commonStyle;
				break;
			case constant.BUSINESSTYPE.CELL: //服务小区
				geometry = new ol.geom.Polygon([points]);
				_style = _commonStyle;
				break;
			case constant.BUSINESSTYPE.VECTOR_CELL: //矢量小区
				_style = _commonStyle;
				break;
			case constant.BUSINESSTYPE.SITE: //服务的基站
				geometry = new ol.geom.Point(points);
				_style = circleOrSiteStyle;
				break;
			case constant.BUSINESSTYPE.GRID:
				geometry = new ol.geom.Polygon([points]);
				_style = _commonStyle;
				break;
			default:
		}

		if(params.layerCategory === 0) {
			var highLightParams = {
				data: params.data,
				olLayer: params.olLayer,
				style: _style
			};
			feature = vectorFeatureHihLight(highLightParams);

		} else {
			feature = new ol.Feature({
				geometry: geometry,
				mapId: params.mapId,
				layerId: params.layerId,
				layerType: params.layerType
			});

			feature.setStyle(_style);
		}
		return feature;
	}

	module.exports = {
		layerFilterHighlight: layerHighlight
	};

/***/ },
/* 149 */
/*!***************************************!*\
  !*** ./src/gis/layers/circleLabel.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	var ol = __webpack_require__(/*! ol */ 4);
	var domUtil = __webpack_require__(/*! utils/domUtil */ 10);
	var mapBox = __webpack_require__(/*! maps/mapBox */ 7);
	var util = __webpack_require__(/*! utils/util */ 1);

	var _overLayers = [];
	var _type = 'popup_as_circle_label';

	var _addCircleLabel = function (options) {
		if (options.position == undefined) {
			return;
		}

		var _mapId = options.mapId;
		var _mapObj = mapBox.getMapObj(_mapId);
	    var _content = options.content;
	    var _position = ol.proj.fromLonLat(options.position);
	    var _labelId = options.labelId;
	    
	    var popupContainer = domUtil.createDom({
	        tagName: 'div',
	        attributes: {
	            'class': 'circle-label-container'
	        }
	    });

	    var popupContent = domUtil.createDom({
	        tagName: 'div'
	    });

	    if (!!_content) {
	        if (typeof _content === 'string') {
	            popupContent.innerHTML = _content;
	        }
	        else if (typeof _content === 'object') {
	            popupContent.appendChild(_content);
	        }
	    }

	    popupContainer.appendChild(popupContent);
	    document.body.appendChild(popupContainer);
	    var overLay = new ol.Overlay({
	        element: popupContainer,
	        position: _position
	    });
	    overLay.set('mapId', _mapId);
	    overLay.set('type', _type);
		overLay.set('id', _labelId);
		overLay.setMap(_mapObj);
	    _overLayers.push(overLay);

	    return overLay;
	};

	var _removeCircleLabel = function (mapId, overlayerId) {
		var _mapObj = mapBox.getMapObj(mapId);
	    if (_overLayers && _overLayers.length > 0) {
	    	for (var i = 0; i < _overLayers.length; i++) {
	    		var overlay = _overLayers[i];
	    		if (overlay != undefined &&  overlay.mapId === mapId) {
	            	if (overlay.get('type') == _type) {
	            		if (overlayerId != undefined) {
	            			if (overlay.get('id') == overlayerId) {
	            				_mapObj.removeOverlay(overlay);
	            				break
	            			}
	            		}
	            		else {
	            			_mapObj.removeOverlay(overlay);
	            		}
	            		_overLayers.splice(index, 1);
	            	}
	            }
	    	}
	    }
	};


	module.exports = {
	    addCircleLabel: _addCircleLabel,
	    removeCircleLabel: _removeCircleLabel
	};


/***/ }
/******/ ]);